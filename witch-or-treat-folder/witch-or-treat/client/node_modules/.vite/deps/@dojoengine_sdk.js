import {
  ToriiClient
} from "./chunk-3KXKU4GZ.js";
import {
  CairoCustomEnum,
  CairoOption,
  CairoOptionVariant,
  addAddressPadding,
  shortString_exports
} from "./chunk-NGYOB2GY.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/.pnpm/neverthrow@8.2.0/node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config2 = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config2.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject2);
    };
  }
  function verb(n, f2) {
    if (g[n]) {
      i[n] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n, v2, a, b2]) > 1 || resume2(n, v2);
        });
      };
      if (f2) i[n] = f2(i[n]);
    }
  }
  function resume2(n, v2) {
    try {
      step3(g[n](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step3(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q2[0][2], r);
  }
  function fulfill(value6) {
    resume2("next", value6);
  }
  function reject2(value6) {
    resume2("throw", value6);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume2(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f2) {
    i[n] = o[n] ? function(v2) {
      return (p = !p) ? { value: __await(o[n](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject2) {
        v2 = o[n](v2), settle(resolve, reject2, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject2, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject2);
  }
}
var ResultAsync = class _ResultAsync {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise3) {
    const newPromise = promise3.then((value6) => new Ok(value6));
    return new _ResultAsync(newPromise);
  }
  static fromPromise(promise3, errorFn) {
    const newPromise = promise3.then((value6) => new Ok(value6)).catch((e) => new Err(errorFn(e)));
    return new _ResultAsync(newPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromThrowable(fn, errorFn) {
    return (...args2) => {
      return new _ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
        try {
          return new Ok(yield fn(...args2));
        } catch (error2) {
          return new Err(errorFn ? errorFn(error2) : error2);
        }
      }))());
    };
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f2(res.value));
    })));
  }
  andThrough(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newRes = yield f2(res.value);
      if (newRes.isErr()) {
        return new Err(newRes.error);
      }
      return new Ok(res.value);
    })));
  }
  andTee(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      try {
        yield f2(res.value);
      } catch (e) {
      }
      return new Ok(res.value);
    })));
  }
  orTee(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      try {
        yield f2(res.error);
      } catch (e) {
      }
      return new Err(res.error);
    })));
  }
  mapErr(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f2(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return new _ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f2(res.value);
      return newValue instanceof _ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f2(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t) {
    return this._promise.then((res) => res.unwrapOr(t));
  }
  /**
   * @deprecated will be removed in 9.0.0.
   *
   * You can use `safeTry` without this method.
   * @example
   * ```typescript
   * safeTry(async function* () {
   *   const okValue = yield* yourResult
   * })
   * ```
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a() {
      const result = yield __await(this._promise);
      if (result.isErr()) {
        yield yield __await(errAsync(result.error));
      }
      return yield __await(result.value);
    });
  }
};
function errAsync(err2) {
  return new ResultAsync(Promise.resolve(new Err(err2)));
}
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var fromAsyncThrowable = ResultAsync.fromThrowable;
var combineResultList = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr()) {
      acc = err(result.error);
      break;
    } else {
      acc.map((list) => list.push(result.value));
    }
  }
  return acc;
};
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr() && acc.isErr()) {
      acc.error.push(result.error);
    } else if (result.isErr() && acc.isOk()) {
      acc = err([result.error]);
    } else if (result.isOk() && acc.isOk()) {
      acc.value.push(result.value);
    }
  }
  return acc;
};
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args2) => {
      try {
        const result = fn(...args2);
        return ok(result);
      } catch (e) {
        return err(errorFn ? errorFn(e) : e);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine18(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine18;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
function ok(value6) {
  return new Ok(value6);
}
function err(err2) {
  return new Err(err2);
}
var Ok = class {
  constructor(value6) {
    this.value = value6;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f2) {
    return ok(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThrough(f2) {
    return f2(this.value).map((_value) => this.value);
  }
  andTee(f2) {
    try {
      f2(this.value);
    } catch (e) {
    }
    return ok(this.value);
  }
  orTee(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  asyncAndThrough(f2) {
    return f2(this.value).map(() => this.value);
  }
  asyncMap(f2) {
    return ResultAsync.fromSafePromise(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value6 = this.value;
    return function* () {
      return value6;
    }();
  }
  _unsafeUnwrap(_2) {
    return this.value;
  }
  _unsafeUnwrapErr(config2) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config2);
  }
  // eslint-disable-next-line @typescript-eslint/no-this-alias, require-yield
  *[Symbol.iterator]() {
    return this.value;
  }
};
var Err = class {
  constructor(error2) {
    this.error = error2;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f2) {
    return err(f2(this.error));
  }
  andThrough(_f) {
    return err(this.error);
  }
  andTee(_f) {
    return err(this.error);
  }
  orTee(f2) {
    try {
      f2(this.error);
    } catch (e) {
    }
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return f2(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  asyncAndThrough(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v2) {
    return v2;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error2 = this.error;
    return function* () {
      yield err(error2);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config2) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config2);
  }
  _unsafeUnwrapErr(_2) {
    return this.error;
  }
  *[Symbol.iterator]() {
    const self = this;
    yield self;
    return self;
  }
};
var fromThrowable = Result.fromThrowable;

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
function typeofJsonValue(value6) {
  let t = typeof value6;
  if (t == "object") {
    if (Array.isArray(value6))
      return "array";
    if (value6 === null)
      return "null";
  }
  return t;
}
function isJsonObject(value6) {
  return value6 !== null && typeof value6 == "object" && !Array.isArray(value6);
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b2, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b2 = decTable[base64Str.charCodeAt(i)];
    if (b2 === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b2;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b2 & 48) >> 4;
        p = b2;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b2 & 60) >> 2;
        p = b2;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b2;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base642 = "", groupPos = 0, b2, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b2 = bytes[i];
    switch (groupPos) {
      case 0:
        base642 += encTable[b2 >> 2];
        p = (b2 & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base642 += encTable[p | b2 >> 4];
        p = (b2 & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base642 += encTable[p | b2 >> 6];
        base642 += encTable[b2 & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base642 += encTable[p];
    base642 += "=";
    if (groupPos == 1)
      base642 += "=";
  }
  return base642;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is3(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is3(message)) {
      let all11 = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all11.filter((uf) => uf.no == fieldNo) : all11;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is3 = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
function mergeBinaryOptions(a, b2) {
  return Object.assign(Object.assign({}, a), b2);
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift2 = 0; shift2 < 28; shift2 += 7) {
    let b2 = this.buf[this.pos++];
    lowBits |= (b2 & 127) << shift2;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift2 = 3; shift2 <= 31; shift2 += 7) {
    let b2 = this.buf[this.pos++];
    highBits |= (b2 & 127) << shift2;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift2 = lo >>> i;
    const hasNext = !(shift2 >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift2 = hi >>> i;
    const hasNext = !(shift2 >>> 7 == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end6) {
    const digit1e6 = Number(dec.slice(begin, end6));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial3 = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial3.length) + partial3;
    }
    return partial3;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value6, bytes) {
  if (value6 >= 0) {
    while (value6 > 127) {
      bytes.push(value6 & 127 | 128);
      value6 = value6 >>> 7;
    }
    bytes.push(value6);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value6 & 127 | 128);
      value6 = value6 >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b2 = this.buf[this.pos++];
  let result = b2 & 127;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 7;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 14;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 21;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 15) << 28;
  for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
    b2 = this.buf[this.pos++];
  if ((b2 & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok2 = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok2 ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value6) {
    if (BI)
      switch (typeof value6) {
        case "string":
          if (value6 == "0")
            return this.ZERO;
          if (value6 == "")
            throw new Error("string is no integer");
          value6 = BI.C(value6);
        case "number":
          if (value6 === 0)
            return this.ZERO;
          value6 = BI.C(value6);
        case "bigint":
          if (!value6)
            return this.ZERO;
          if (value6 < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value6 > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value6, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value6) {
        case "string":
          if (value6 == "0")
            return this.ZERO;
          value6 = value6.trim();
          if (!RE_DECIMAL_STR.test(value6))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value6);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi);
        case "number":
          if (value6 == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value6))
            throw new Error("number is no integer");
          if (value6 < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value6, value6 / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value6);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value6) {
    if (BI)
      switch (typeof value6) {
        case "string":
          if (value6 == "0")
            return this.ZERO;
          if (value6 == "")
            throw new Error("string is no integer");
          value6 = BI.C(value6);
        case "number":
          if (value6 === 0)
            return this.ZERO;
          value6 = BI.C(value6);
        case "bigint":
          if (!value6)
            return this.ZERO;
          if (value6 < BI.MIN)
            throw new Error("signed long too small");
          if (value6 > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value6, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value6) {
        case "string":
          if (value6 == "0")
            return this.ZERO;
          value6 = value6.trim();
          if (!RE_DECIMAL_STR.test(value6))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value6);
          if (minus) {
            if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value6 == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value6))
            throw new Error("number is no integer");
          return value6 > 0 ? new _PbLong(value6, value6 / TWO_PWR_32_DBL2) : new _PbLong(-value6, -value6 / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value6);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi += 1;
    return new _PbLong(lo, hi);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder3) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder3 !== null && textDecoder3 !== void 0 ? textDecoder3 : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag3 = this.uint32(), fieldNo = tag3 >>> 3, wireType = tag3 & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start5 = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start5, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return new PbLong(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start5 = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start5, start5 + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function assertNever(value6, msg) {
  throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value6);
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk4 = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk4.byteLength);
    return this.raw(chunk4);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type2) {
    return this.uint32((fieldNo << 3 | type2) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk4) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk4);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value6) {
    assertUInt32(value6);
    while (value6 > 127) {
      this.buf.push(value6 & 127 | 128);
      value6 = value6 >>> 7;
    }
    this.buf.push(value6);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value6) {
    assertInt32(value6);
    varint32write(value6, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value6) {
    this.buf.push(value6 ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value6) {
    this.uint32(value6.byteLength);
    return this.raw(value6);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value6) {
    let chunk4 = this.textEncoder.encode(value6);
    this.uint32(chunk4.byteLength);
    return this.raw(chunk4);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value6) {
    assertFloat32(value6);
    let chunk4 = new Uint8Array(4);
    new DataView(chunk4.buffer).setFloat32(0, value6, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value6) {
    let chunk4 = new Uint8Array(8);
    new DataView(chunk4.buffer).setFloat64(0, value6, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value6) {
    assertUInt32(value6);
    let chunk4 = new Uint8Array(4);
    new DataView(chunk4.buffer).setUint32(0, value6, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value6) {
    assertInt32(value6);
    let chunk4 = new Uint8Array(4);
    new DataView(chunk4.buffer).setInt32(0, value6, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value6) {
    assertInt32(value6);
    value6 = (value6 << 1 ^ value6 >> 31) >>> 0;
    varint32write(value6, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value6) {
    let chunk4 = new Uint8Array(8);
    let view = new DataView(chunk4.buffer);
    let long = PbLong.from(value6);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value6) {
    let chunk4 = new Uint8Array(8);
    let view = new DataView(chunk4.buffer);
    let long = PbULong.from(value6);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk4);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value6) {
    let long = PbLong.from(value6);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value6) {
    let long = PbLong.from(value6), sign3 = long.hi >> 31, lo = long.lo << 1 ^ sign3, hi = (long.hi << 1 | long.lo >>> 31) ^ sign3;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value6) {
    let long = PbULong.from(value6);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}
function mergeJsonOptions(a, b2) {
  var _a, _b;
  let c = Object.assign(Object.assign({}, a), b2);
  c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b2 === null || b2 === void 0 ? void 0 : b2.typeRegistry) !== null && _b !== void 0 ? _b : []];
  return c;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
function lowerCamelCase(snakeCase3) {
  let capNext = false;
  const sb = [];
  for (let i = 0; i < snakeCase3.length; i++) {
    let next5 = snakeCase3.charAt(i);
    if (next5 == "_") {
      capNext = true;
    } else if (/\d/.test(next5)) {
      sb.push(next5);
      capNext = true;
    } else if (capNext) {
      sb.push(next5.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb.push(next5.toLowerCase());
    } else {
      sb.push(next5);
    }
  }
  return sb.join("");
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a, _b, _c, _d;
  field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
function isOneofGroup(any2) {
  if (typeof any2 != "object" || any2 === null || !any2.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any2.oneofKind) {
    case "string":
      if (any2[any2.oneofKind] === void 0)
        return false;
      return Object.keys(any2).length == 2;
    case "undefined":
      return Object.keys(any2).length == 1;
    default:
      return false;
  }
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info2) {
    var _a;
    this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys10 = Object.keys(message), data = this.data;
    if (keys10.length < data.req.length || data.req.some((n) => !keys10.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys10.some((k2) => !data.known.includes(k2)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name of data.oneofs) {
      const group4 = message[name];
      if (!isOneofGroup(group4))
        return false;
      if (group4.oneofKind === void 0)
        continue;
      const field = this.fields.find((f2) => f2.localName === group4.oneofKind);
      if (!field)
        return false;
      if (!this.field(group4[group4.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated3 = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated3)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated3)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated3)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type2, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type2.isAssignable(arg, depth);
    }
    return type2.is(arg, depth);
  }
  messages(arg, type2, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type2.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type2.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type2, longType) {
    let argType = typeof arg;
    switch (type2) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type2, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type2, longType))
          return false;
    }
    return true;
  }
  mapKeys(map40, type2, depth) {
    let keys10 = Object.keys(map40);
    switch (type2) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys10.slice(0, depth).map((k2) => parseInt(k2)), type2, depth);
      case ScalarType.BOOL:
        return this.scalars(keys10.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type2, depth);
      default:
        return this.scalars(keys10, type2, depth, LongType.STRING);
    }
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
function reflectionLongConvert(long, type2) {
  switch (type2) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info2) {
    this.info = info2;
  }
  prepare() {
    var _a;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue2) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue2);
      if (what == "number" || what == "boolean")
        what = jsonValue2.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue2] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue2 === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue2 === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue2), field.name, jsonValue2);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue2)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue2 === null)
          continue;
        this.assert(Array.isArray(jsonValue2), field.name, jsonValue2);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue2) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue2);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue2 === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue2, options, target[localName]);
            break;
          case "enum":
            if (jsonValue2 === null)
              continue;
            let val = this.enum(field.T(), jsonValue2, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue2 === null)
              continue;
            target[localName] = this.scalar(jsonValue2, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type2, json3, fieldName, ignoreUnknownFields) {
    if (type2[0] == "google.protobuf.NullValue")
      assert(json3 === null || json3 === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type2[0]} only accepts null.`);
    if (json3 === null)
      return 0;
    switch (typeof json3) {
      case "number":
        assert(Number.isInteger(json3), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json3}.`);
        return json3;
      case "string":
        let localEnumName = json3;
        if (type2[2] && json3.substring(0, type2[2].length) === type2[2])
          localEnumName = json3.substring(type2[2].length);
        let enumNumber = type2[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type2[0]} has no value for "${json3}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json3}".`);
  }
  scalar(json3, type2, longType, fieldName) {
    let e;
    try {
      switch (type2) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json3 === null)
            return 0;
          if (json3 === "NaN")
            return Number.NaN;
          if (json3 === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json3 === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json3 === "") {
            e = "empty string";
            break;
          }
          if (typeof json3 == "string" && json3.trim().length !== json3.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json3 != "string" && typeof json3 != "number") {
            break;
          }
          let float2 = Number(json3);
          if (Number.isNaN(float2)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float2)) {
            e = "too large or small";
            break;
          }
          if (type2 == ScalarType.FLOAT)
            assertFloat32(float2);
          return float2;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json3 === null)
            return 0;
          let int32;
          if (typeof json3 == "number")
            int32 = json3;
          else if (json3 === "")
            e = "empty string";
          else if (typeof json3 == "string") {
            if (json3.trim().length !== json3.length)
              e = "extra whitespace";
            else
              int32 = Number(json3);
          }
          if (int32 === void 0)
            break;
          if (type2 == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json3 === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json3 != "number" && typeof json3 != "string")
            break;
          return reflectionLongConvert(PbLong.from(json3), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json3 === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json3 != "number" && typeof json3 != "string")
            break;
          return reflectionLongConvert(PbULong.from(json3), longType);
        // bool:
        case ScalarType.BOOL:
          if (json3 === null)
            return false;
          if (typeof json3 !== "boolean")
            break;
          return json3;
        // string:
        case ScalarType.STRING:
          if (json3 === null)
            return "";
          if (typeof json3 !== "string") {
            e = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json3);
          } catch (e2) {
            e2 = "invalid UTF8";
            break;
          }
          return json3;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
          if (json3 === null || json3 === "")
            return new Uint8Array(0);
          if (typeof json3 !== "string")
            break;
          return base64decode(json3);
      }
    } catch (error2) {
      e = error2.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json3);
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var ReflectionJsonWriter = class {
  constructor(info2) {
    var _a;
    this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json3 = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue3 = this.field(field, source[field.localName], options);
        if (jsonValue3 !== void 0)
          json3[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue3;
        continue;
      }
      const group4 = source[field.oneof];
      if (group4.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue2 = this.field(field, group4[field.localName], opt);
      assert(jsonValue2 !== void 0);
      json3[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
    }
    return json3;
  }
  field(field, value6, options) {
    let jsonValue2 = void 0;
    if (field.kind == "map") {
      assert(typeof value6 == "object" && value6 !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value6)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value6)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value6)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue2 = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value6));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value6.length; i++) {
            const val = this.scalar(field.T, value6[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value6.length; i++) {
            assert(value6[i] === void 0 || typeof value6[i] == "number");
            const val = this.enum(enumInfo, value6[i], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value6.length; i++) {
            const val = this.message(messageType, value6[i], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue2 = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue2 = this.scalar(field.T, value6, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue2 = this.enum(field.T(), value6, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue2 = this.message(field.T(), value6, field.name, options);
          break;
      }
    }
    return jsonValue2;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type2, value6, fieldName, optional2, emitDefaultValues, enumAsInteger) {
    if (type2[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional2 ? void 0 : null;
    if (value6 === void 0) {
      assert(optional2);
      return void 0;
    }
    if (value6 === 0 && !emitDefaultValues && !optional2)
      return void 0;
    assert(typeof value6 == "number");
    assert(Number.isInteger(value6));
    if (enumAsInteger || !type2[1].hasOwnProperty(value6))
      return value6;
    if (type2[2])
      return type2[2] + type2[1][value6];
    return type2[1][value6];
  }
  message(type2, value6, fieldName, options) {
    if (value6 === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type2.internalJsonWrite(value6, options);
  }
  scalar(type2, value6, fieldName, optional2, emitDefaultValues) {
    if (value6 === void 0) {
      assert(optional2);
      return void 0;
    }
    const ed = emitDefaultValues || optional2;
    switch (type2) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value6 === 0)
          return ed ? 0 : void 0;
        assertInt32(value6);
        return value6;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value6 === 0)
          return ed ? 0 : void 0;
        assertUInt32(value6);
        return value6;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
        assertFloat32(value6);
      case ScalarType.DOUBLE:
        if (value6 === 0)
          return ed ? 0 : void 0;
        assert(typeof value6 == "number");
        if (Number.isNaN(value6))
          return "NaN";
        if (value6 === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value6 === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value6;
      // string:
      case ScalarType.STRING:
        if (value6 === "")
          return ed ? "" : void 0;
        assert(typeof value6 == "string");
        return value6;
      // bool:
      case ScalarType.BOOL:
        if (value6 === false)
          return ed ? false : void 0;
        assert(typeof value6 == "boolean");
        return value6;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value6 == "number" || typeof value6 == "string" || typeof value6 == "bigint");
        let ulong = PbULong.from(value6);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value6 == "number" || typeof value6 == "string" || typeof value6 == "bigint");
        let long = PbLong.from(value6);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value6 instanceof Uint8Array);
        if (!value6.byteLength)
          return ed ? "" : void 0;
        return base64encode(value6);
    }
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
function reflectionScalarDefault(type2, longType = LongType.STRING) {
  switch (type2) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info2) {
    this.info = info2;
  }
  prepare() {
    var _a;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length4) {
    this.prepare();
    const end6 = length4 === void 0 ? reader.len : reader.pos + length4;
    while (reader.pos < end6) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u = options.readUnknownField;
        if (u == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated3 = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L2 = field.kind == "scalar" ? field.L : void 0;
          if (repeated3) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T2 != ScalarType.STRING && T2 != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T2, L2));
            } else
              arr.push(this.scalar(reader, T2, L2));
          } else
            target[localName] = this.scalar(reader, T2, L2);
          break;
        case "message":
          if (repeated3) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length4 = reader.uint32();
    let end6 = reader.pos + length4;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type2, longType) {
    switch (type2) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var ReflectionBinaryWriter = class {
  constructor(info2) {
    this.info = info2;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a, b2) => a.no - b2.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value6, emitDefault, repeated3 = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group4 = message[field.oneof];
        if (group4.oneofKind !== localName)
          continue;
        value6 = group4[localName];
        emitDefault = true;
      } else {
        value6 = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated3) {
            assert(Array.isArray(value6));
            if (repeated3 == RepeatType.PACKED)
              this.packed(writer, T2, field.no, value6);
            else
              for (const item of value6)
                this.scalar(writer, T2, field.no, item, true);
          } else if (value6 === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T2, field.no, value6, emitDefault || field.opt);
          break;
        case "message":
          if (repeated3) {
            assert(Array.isArray(value6));
            for (const item of value6)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value6);
          }
          break;
        case "map":
          assert(typeof value6 == "object" && value6 !== null);
          for (const [key, val] of Object.entries(value6))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value6) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value6, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value6, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value6);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value6) {
    if (value6 === void 0)
      return;
    handler.internalBinaryWrite(value6, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type2, fieldNo, value6, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type2, value6);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value6);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type2, fieldNo, value6) {
    if (!value6.length)
      return;
    assert(type2 !== ScalarType.BYTES && type2 !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type2);
    for (let i = 0; i < value6.length; i++)
      writer[method](value6[i]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type2, value6) {
    let t = WireType.Varint;
    let m2;
    let i = value6 === void 0;
    let d = value6 === 0;
    switch (type2) {
      case ScalarType.INT32:
        m2 = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value6.length;
        t = WireType.LengthDelimited;
        m2 = "string";
        break;
      case ScalarType.BOOL:
        d = value6 === false;
        m2 = "bool";
        break;
      case ScalarType.UINT32:
        m2 = "uint32";
        break;
      case ScalarType.DOUBLE:
        t = WireType.Bit64;
        m2 = "double";
        break;
      case ScalarType.FLOAT:
        t = WireType.Bit32;
        m2 = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value6).isZero();
        m2 = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value6).isZero();
        m2 = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value6).isZero();
        t = WireType.Bit64;
        m2 = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value6.byteLength;
        t = WireType.LengthDelimited;
        m2 = "bytes";
        break;
      case ScalarType.FIXED32:
        t = WireType.Bit32;
        m2 = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t = WireType.Bit32;
        m2 = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value6).isZero();
        t = WireType.Bit64;
        m2 = "sfixed64";
        break;
      case ScalarType.SINT32:
        m2 = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value6).isZero();
        m2 = "sint64";
        break;
    }
    return [t, m2, i || d];
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
function reflectionCreate(type2) {
  const msg = type2.messagePrototype ? Object.create(type2.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type2 });
  for (let field of type2.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
function reflectionMergePartial(info2, target, source) {
  let fieldValue, input = source, output;
  for (let field of info2.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group4 = input[field.oneof];
      if ((group4 === null || group4 === void 0 ? void 0 : group4.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group4[name];
      output = target[field.oneof];
      output.oneofKind = group4.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = fieldValue[i];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T2 = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = T2.create(fieldValue[i]);
        else if (output[name] === void 0)
          output[name] = T2.create(fieldValue);
        else
          T2.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T3 = field.V.T();
            for (let k2 of Object.keys(fieldValue))
              output[name][k2] = T3.create(fieldValue[k2]);
            break;
        }
        break;
    }
  }
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
function reflectionEquals(info2, a, b2) {
  if (a === b2)
    return true;
  if (!a || !b2)
    return false;
  for (let field of info2.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
    let val_b = field.oneof ? b2[field.oneof][localName] : b2[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T2 = field.T();
        if (!(field.repeat ? repeatedMsgEq(T2, val_a, val_b) : T2.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type2, a, b2) {
  if (a === b2)
    return true;
  if (type2 !== ScalarType.BYTES)
    return false;
  let ba = a;
  let bb = b2;
  if (ba.length !== bb.length)
    return false;
  for (let i = 0; i < ba.length; i++)
    if (ba[i] != bb[i])
      return false;
  return true;
}
function repeatedPrimitiveEq(type2, a, b2) {
  if (a.length !== b2.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!primitiveEq(type2, a[i], b2[i]))
      return false;
  return true;
}
function repeatedMsgEq(type2, a, b2) {
  if (a.length !== b2.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!type2.equals(a[i], b2[i]))
      return false;
  return true;
}

// node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
var MessageType = class {
  constructor(name, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    messageTypeDescriptor.value = this;
    this.messagePrototype = Object.create(null, baseDescriptors);
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value6) {
    let message = reflectionCreate(this);
    if (value6 !== void 0) {
      reflectionMergePartial(this, message, value6);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy5 = this.create();
    reflectionMergePartial(this, copy5, message);
    return copy5;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a, b2) {
    return reflectionEquals(this, a, b2);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json3, options) {
    return this.internalJsonRead(json3, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json3, options) {
    let value6 = JSON.parse(json3);
    return this.fromJson(value6, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a;
    let value6 = this.toJson(message, options);
    return JSON.stringify(value6, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json3, options, target) {
    if (json3 !== null && typeof json3 == "object" && !Array.isArray(json3)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json3, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json3)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length4, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length4);
    return message;
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js
function normalizeMethodInfo(method, service3) {
  var _a, _b, _c;
  let m2 = method;
  m2.service = service3;
  m2.localName = (_a = m2.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m2.name);
  m2.serverStreaming = !!m2.serverStreaming;
  m2.clientStreaming = !!m2.clientStreaming;
  m2.options = (_b = m2.options) !== null && _b !== void 0 ? _b : {};
  m2.idempotency = (_c = m2.idempotency) !== null && _c !== void 0 ? _c : void 0;
  return m2;
}

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js
var ServiceType = class {
  constructor(typeName, methods, options) {
    this.typeName = typeName;
    this.methods = methods.map((i) => normalizeMethodInfo(i, this));
    this.options = options !== null && options !== void 0 ? options : {};
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js
var RpcError = class extends Error {
  constructor(message, code = "UNKNOWN", meta) {
    super(message);
    this.name = "RpcError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.meta = meta !== null && meta !== void 0 ? meta : {};
  }
  toString() {
    const l2 = [this.name + ": " + this.message];
    if (this.code) {
      l2.push("");
      l2.push("Code: " + this.code);
    }
    if (this.serviceName && this.methodName) {
      l2.push("Method: " + this.serviceName + "/" + this.methodName);
    }
    let m2 = Object.entries(this.meta);
    if (m2.length) {
      l2.push("");
      l2.push("Meta:");
      for (let [k2, v2] of m2) {
        l2.push(`  ${k2}: ${v2}`);
      }
    }
    return l2.join("\n");
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js
function mergeRpcOptions(defaults, options) {
  if (!options)
    return defaults;
  let o = {};
  copy(defaults, o);
  copy(options, o);
  for (let key of Object.keys(options)) {
    let val = options[key];
    switch (key) {
      case "jsonOptions":
        o.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
        break;
      case "binaryOptions":
        o.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
        break;
      case "meta":
        o.meta = {};
        copy(defaults.meta, o.meta);
        copy(options.meta, o.meta);
        break;
      case "interceptors":
        o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
        break;
    }
  }
  return o;
}
function copy(a, into2) {
  if (!a)
    return;
  let c = into2;
  for (let [k2, v2] of Object.entries(a)) {
    if (v2 instanceof Date)
      c[k2] = new Date(v2.getTime());
    else if (Array.isArray(v2))
      c[k2] = v2.concat();
    else
      c[k2] = v2;
  }
}

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js
var DeferredState;
(function(DeferredState2) {
  DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
  DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
  DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
})(DeferredState || (DeferredState = {}));
var Deferred = class {
  /**
   * @param preventUnhandledRejectionWarning - prevents the warning
   * "Unhandled Promise rejection" by adding a noop rejection handler.
   * Working with calls returned from the runtime-rpc package in an
   * async function usually means awaiting one call property after
   * the other. This means that the "status" is not being awaited when
   * an earlier await for the "headers" is rejected. This causes the
   * "unhandled promise reject" warning. A more correct behaviour for
   * calls might be to become aware whether at least one of the
   * promises is handled and swallow the rejection warning for the
   * others.
   */
  constructor(preventUnhandledRejectionWarning = true) {
    this._state = DeferredState.PENDING;
    this._promise = new Promise((resolve, reject2) => {
      this._resolve = resolve;
      this._reject = reject2;
    });
    if (preventUnhandledRejectionWarning) {
      this._promise.catch((_2) => {
      });
    }
  }
  /**
   * Get the current state of the promise.
   */
  get state() {
    return this._state;
  }
  /**
   * Get the deferred promise.
   */
  get promise() {
    return this._promise;
  }
  /**
   * Resolve the promise. Throws if the promise is already resolved or rejected.
   */
  resolve(value6) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
    this._resolve(value6);
    this._state = DeferredState.RESOLVED;
  }
  /**
   * Reject the promise. Throws if the promise is already resolved or rejected.
   */
  reject(reason) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
    this._reject(reason);
    this._state = DeferredState.REJECTED;
  }
  /**
   * Resolve the promise. Ignore if not pending.
   */
  resolvePending(val) {
    if (this._state === DeferredState.PENDING)
      this.resolve(val);
  }
  /**
   * Reject the promise. Ignore if not pending.
   */
  rejectPending(reason) {
    if (this._state === DeferredState.PENDING)
      this.reject(reason);
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js
var RpcOutputStreamController = class {
  constructor() {
    this._lis = {
      nxt: [],
      msg: [],
      err: [],
      cmp: []
    };
    this._closed = false;
    this._itState = { q: [] };
  }
  // --- RpcOutputStream callback API
  onNext(callback) {
    return this.addLis(callback, this._lis.nxt);
  }
  onMessage(callback) {
    return this.addLis(callback, this._lis.msg);
  }
  onError(callback) {
    return this.addLis(callback, this._lis.err);
  }
  onComplete(callback) {
    return this.addLis(callback, this._lis.cmp);
  }
  addLis(callback, list) {
    list.push(callback);
    return () => {
      let i = list.indexOf(callback);
      if (i >= 0)
        list.splice(i, 1);
    };
  }
  // remove all listeners
  clearLis() {
    for (let l2 of Object.values(this._lis))
      l2.splice(0, l2.length);
  }
  // --- Controller API
  /**
   * Is this stream already closed by a completion or error?
   */
  get closed() {
    return this._closed !== false;
  }
  /**
   * Emit message, close with error, or close successfully, but only one
   * at a time.
   * Can be used to wrap a stream by using the other stream's `onNext`.
   */
  notifyNext(message, error2, complete4) {
    assert((message ? 1 : 0) + (error2 ? 1 : 0) + (complete4 ? 1 : 0) <= 1, "only one emission at a time");
    if (message)
      this.notifyMessage(message);
    if (error2)
      this.notifyError(error2);
    if (complete4)
      this.notifyComplete();
  }
  /**
   * Emits a new message. Throws if stream is closed.
   *
   * Triggers onNext and onMessage callbacks.
   */
  notifyMessage(message) {
    assert(!this.closed, "stream is closed");
    this.pushIt({ value: message, done: false });
    this._lis.msg.forEach((l2) => l2(message));
    this._lis.nxt.forEach((l2) => l2(message, void 0, false));
  }
  /**
   * Closes the stream with an error. Throws if stream is closed.
   *
   * Triggers onNext and onError callbacks.
   */
  notifyError(error2) {
    assert(!this.closed, "stream is closed");
    this._closed = error2;
    this.pushIt(error2);
    this._lis.err.forEach((l2) => l2(error2));
    this._lis.nxt.forEach((l2) => l2(void 0, error2, false));
    this.clearLis();
  }
  /**
   * Closes the stream successfully. Throws if stream is closed.
   *
   * Triggers onNext and onComplete callbacks.
   */
  notifyComplete() {
    assert(!this.closed, "stream is closed");
    this._closed = true;
    this.pushIt({ value: null, done: true });
    this._lis.cmp.forEach((l2) => l2());
    this._lis.nxt.forEach((l2) => l2(void 0, void 0, true));
    this.clearLis();
  }
  /**
   * Creates an async iterator (that can be used with `for await {...}`)
   * to consume the stream.
   *
   * Some things to note:
   * - If an error occurs, the `for await` will throw it.
   * - If an error occurred before the `for await` was started, `for await`
   *   will re-throw it.
   * - If the stream is already complete, the `for await` will be empty.
   * - If your `for await` consumes slower than the stream produces,
   *   for example because you are relaying messages in a slow operation,
   *   messages are queued.
   */
  [Symbol.asyncIterator]() {
    if (this._closed === true)
      this.pushIt({ value: null, done: true });
    else if (this._closed !== false)
      this.pushIt(this._closed);
    return {
      next: () => {
        let state = this._itState;
        assert(state, "bad state");
        assert(!state.p, "iterator contract broken");
        let first4 = state.q.shift();
        if (first4)
          return "value" in first4 ? Promise.resolve(first4) : Promise.reject(first4);
        state.p = new Deferred();
        return state.p.promise;
      }
    };
  }
  // "push" a new iterator result.
  // this either resolves a pending promise, or enqueues the result.
  pushIt(result) {
    let state = this._itState;
    if (state.p) {
      const p = state.p;
      assert(p.state == DeferredState.PENDING, "iterator contract broken");
      "value" in result ? p.resolve(result) : p.reject(result);
      delete state.p;
    } else {
      state.q.push(result);
    }
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UnaryCall = class {
  constructor(method, requestHeaders, request2, headers, response, status2, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.status = status2;
    this.trailers = trailers;
  }
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value6) => onfulfilled ? Promise.resolve(onfulfilled(value6)) : value6, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter2(this, void 0, void 0, function* () {
      let [headers, response, status2, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        response,
        status: status2,
        trailers
      };
    });
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ServerStreamingCall = class {
  constructor(method, requestHeaders, request2, headers, response, status2, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request2;
    this.headers = headers;
    this.responses = response;
    this.status = status2;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value6) => onfulfilled ? Promise.resolve(onfulfilled(value6)) : value6, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter3(this, void 0, void 0, function* () {
      let [headers, status2, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        status: status2,
        trailers
      };
    });
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientStreamingCall = class {
  constructor(method, requestHeaders, request2, headers, response, status2, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request2;
    this.headers = headers;
    this.response = response;
    this.status = status2;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value6) => onfulfilled ? Promise.resolve(onfulfilled(value6)) : value6, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter4(this, void 0, void 0, function* () {
      let [headers, response, status2, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        response,
        status: status2,
        trailers
      };
    });
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DuplexStreamingCall = class {
  constructor(method, requestHeaders, request2, headers, response, status2, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request2;
    this.headers = headers;
    this.responses = response;
    this.status = status2;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value6) => onfulfilled ? Promise.resolve(onfulfilled(value6)) : value6, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter5(this, void 0, void 0, function* () {
      let [headers, status2, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        status: status2,
        trailers
      };
    });
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/test-transport.js
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TestTransport = class _TestTransport {
  /**
   * Initialize with mock data. Omitted fields have default value.
   */
  constructor(data) {
    this.suppressUncaughtRejections = true;
    this.headerDelay = 10;
    this.responseDelay = 50;
    this.betweenResponseDelay = 10;
    this.afterResponseDelay = 10;
    this.data = data !== null && data !== void 0 ? data : {};
  }
  /**
   * Sent message(s) during the last operation.
   */
  get sentMessages() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.sent;
    } else if (typeof this.lastInput == "object") {
      return [this.lastInput.single];
    }
    return [];
  }
  /**
   * Sending message(s) completed?
   */
  get sendComplete() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.completed;
    } else if (typeof this.lastInput == "object") {
      return true;
    }
    return false;
  }
  // Creates a promise for response headers from the mock data.
  promiseHeaders() {
    var _a;
    const headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : _TestTransport.defaultHeaders;
    return headers instanceof RpcError ? Promise.reject(headers) : Promise.resolve(headers);
  }
  // Creates a promise for a single, valid, message from the mock data.
  promiseSingleResponse(method) {
    if (this.data.response instanceof RpcError) {
      return Promise.reject(this.data.response);
    }
    let r;
    if (Array.isArray(this.data.response)) {
      assert(this.data.response.length > 0);
      r = this.data.response[0];
    } else if (this.data.response !== void 0) {
      r = this.data.response;
    } else {
      r = method.O.create();
    }
    assert(method.O.is(r));
    return Promise.resolve(r);
  }
  /**
   * Pushes response messages from the mock data to the output stream.
   * If an error response, status or trailers are mocked, the stream is
   * closed with the respective error.
   * Otherwise, stream is completed successfully.
   *
   * The returned promise resolves when the stream is closed. It should
   * not reject. If it does, code is broken.
   */
  streamResponses(method, stream2, abort) {
    return __awaiter6(this, void 0, void 0, function* () {
      const messages = [];
      if (this.data.response === void 0) {
        messages.push(method.O.create());
      } else if (Array.isArray(this.data.response)) {
        for (let msg of this.data.response) {
          assert(method.O.is(msg));
          messages.push(msg);
        }
      } else if (!(this.data.response instanceof RpcError)) {
        assert(method.O.is(this.data.response));
        messages.push(this.data.response);
      }
      try {
        yield delay(this.responseDelay, abort)(void 0);
      } catch (error2) {
        stream2.notifyError(error2);
        return;
      }
      if (this.data.response instanceof RpcError) {
        stream2.notifyError(this.data.response);
        return;
      }
      for (let msg of messages) {
        stream2.notifyMessage(msg);
        try {
          yield delay(this.betweenResponseDelay, abort)(void 0);
        } catch (error2) {
          stream2.notifyError(error2);
          return;
        }
      }
      if (this.data.status instanceof RpcError) {
        stream2.notifyError(this.data.status);
        return;
      }
      if (this.data.trailers instanceof RpcError) {
        stream2.notifyError(this.data.trailers);
        return;
      }
      stream2.notifyComplete();
    });
  }
  // Creates a promise for response status from the mock data.
  promiseStatus() {
    var _a;
    const status2 = (_a = this.data.status) !== null && _a !== void 0 ? _a : _TestTransport.defaultStatus;
    return status2 instanceof RpcError ? Promise.reject(status2) : Promise.resolve(status2);
  }
  // Creates a promise for response trailers from the mock data.
  promiseTrailers() {
    var _a;
    const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : _TestTransport.defaultTrailers;
    return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
  }
  maybeSuppressUncaught(...promise3) {
    if (this.suppressUncaughtRejections) {
      for (let p of promise3) {
        p.catch(() => {
        });
      }
    }
  }
  mergeOptions(options) {
    return mergeRpcOptions({}, options);
  }
  unary(method, input, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
    }).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  serverStreaming(method, input, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
  }
  clientStreaming(method, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
    }).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  duplex(method, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
  }
};
TestTransport.defaultHeaders = {
  responseHeader: "test"
};
TestTransport.defaultStatus = {
  code: "OK",
  detail: "all good"
};
TestTransport.defaultTrailers = {
  responseTrailer: "test"
};
function delay(ms, abort) {
  return (v2) => new Promise((resolve, reject2) => {
    if (abort === null || abort === void 0 ? void 0 : abort.aborted) {
      reject2(new RpcError("user cancel", "CANCELLED"));
    } else {
      const id2 = setTimeout(() => resolve(v2), ms);
      if (abort) {
        abort.addEventListener("abort", (ev) => {
          clearTimeout(id2);
          reject2(new RpcError("user cancel", "CANCELLED"));
        });
      }
    }
  });
}
var TestInputStream = class {
  constructor(data, abort) {
    this._completed = false;
    this._sent = [];
    this.data = data;
    this.abort = abort;
  }
  get sent() {
    return this._sent;
  }
  get completed() {
    return this._completed;
  }
  send(message) {
    if (this.data.inputMessage instanceof RpcError) {
      return Promise.reject(this.data.inputMessage);
    }
    const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
    return Promise.resolve(void 0).then(() => {
      this._sent.push(message);
    }).then(delay(delayMs, this.abort));
  }
  complete() {
    if (this.data.inputComplete instanceof RpcError) {
      return Promise.reject(this.data.inputComplete);
    }
    const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
    return Promise.resolve(void 0).then(() => {
      this._completed = true;
    }).then(delay(delayMs, this.abort));
  }
};

// node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js
function stackIntercept(kind, transport, method, options, input) {
  var _a, _b, _c, _d;
  if (kind == "unary") {
    let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
    for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
      const next5 = tail;
      tail = (mtd, inp, opt) => curr.interceptUnary(next5, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "serverStreaming") {
    let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
    for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
      const next5 = tail;
      tail = (mtd, inp, opt) => curr.interceptServerStreaming(next5, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "clientStreaming") {
    let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
    for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
      const next5 = tail;
      tail = (mtd, opt) => curr.interceptClientStreaming(next5, mtd, opt);
    }
    return tail(method, options);
  }
  if (kind == "duplex") {
    let tail = (mtd, opt) => transport.duplex(mtd, opt);
    for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
      const next5 = tail;
      tail = (mtd, opt) => curr.interceptDuplex(next5, mtd, opt);
    }
    return tail(method, options);
  }
  assertNever(kind);
}

// node_modules/.pnpm/@protobuf-ts+grpcweb-transport@2.11.1/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/goog-grpc-status-code.js
var GrpcStatusCode;
(function(GrpcStatusCode2) {
  GrpcStatusCode2[GrpcStatusCode2["OK"] = 0] = "OK";
  GrpcStatusCode2[GrpcStatusCode2["CANCELLED"] = 1] = "CANCELLED";
  GrpcStatusCode2[GrpcStatusCode2["UNKNOWN"] = 2] = "UNKNOWN";
  GrpcStatusCode2[GrpcStatusCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
  GrpcStatusCode2[GrpcStatusCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
  GrpcStatusCode2[GrpcStatusCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
  GrpcStatusCode2[GrpcStatusCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
  GrpcStatusCode2[GrpcStatusCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
  GrpcStatusCode2[GrpcStatusCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  GrpcStatusCode2[GrpcStatusCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
  GrpcStatusCode2[GrpcStatusCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
  GrpcStatusCode2[GrpcStatusCode2["ABORTED"] = 10] = "ABORTED";
  GrpcStatusCode2[GrpcStatusCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
  GrpcStatusCode2[GrpcStatusCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
  GrpcStatusCode2[GrpcStatusCode2["INTERNAL"] = 13] = "INTERNAL";
  GrpcStatusCode2[GrpcStatusCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
  GrpcStatusCode2[GrpcStatusCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
})(GrpcStatusCode || (GrpcStatusCode = {}));

// node_modules/.pnpm/@protobuf-ts+grpcweb-transport@2.11.1/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-format.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value6) {
    return value6 instanceof P2 ? value6 : new P2(function(resolve) {
      resolve(value6);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value6) {
      try {
        step3(generator.next(value6));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value6) {
      try {
        step3(generator["throw"](value6));
      } catch (e) {
        reject2(e);
      }
    }
    function step3(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createGrpcWebRequestHeader(headers, format7, timeout4, meta, userAgent) {
  if (meta) {
    for (let [k2, v2] of Object.entries(meta)) {
      if (typeof v2 == "string")
        headers.append(k2, v2);
      else
        for (let i of v2)
          headers.append(k2, i);
    }
  }
  headers.set("Content-Type", format7 === "text" ? "application/grpc-web-text" : "application/grpc-web+proto");
  if (format7 == "text") {
    headers.set("Accept", "application/grpc-web-text");
  }
  headers.set("X-Grpc-Web", "1");
  if (userAgent)
    headers.set("X-User-Agent", userAgent);
  if (typeof timeout4 === "number") {
    if (timeout4 <= 0) {
      throw new RpcError(`timeout ${timeout4} ms exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
    }
    headers.set("grpc-timeout", `${timeout4}m`);
  } else if (timeout4) {
    const deadline = timeout4.getTime();
    const now3 = Date.now();
    if (deadline <= now3) {
      throw new RpcError(`deadline ${timeout4} exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
    }
    headers.set("grpc-timeout", `${deadline - now3}m`);
  }
  return headers;
}
function createGrpcWebRequestBody(message, format7) {
  let body = new Uint8Array(5 + message.length);
  body[0] = GrpcWebFrame.DATA;
  for (let msgLen = message.length, i = 4; i > 0; i--) {
    body[i] = msgLen % 256;
    msgLen >>>= 8;
  }
  body.set(message, 5);
  return format7 === "binary" ? body : base64encode(body);
}
function readGrpcWebResponseHeader(headersOrFetchResponse, httpStatus, httpStatusText) {
  if (arguments.length === 1) {
    let fetchResponse = headersOrFetchResponse;
    let responseType;
    try {
      responseType = fetchResponse.type;
    } catch (_a) {
    }
    switch (responseType) {
      case "error":
      case "opaque":
      case "opaqueredirect":
        throw new RpcError(`fetch response type ${fetchResponse.type}`, GrpcStatusCode[GrpcStatusCode.UNKNOWN]);
    }
    return readGrpcWebResponseHeader(fetchHeadersToHttp(fetchResponse.headers), fetchResponse.status, fetchResponse.statusText);
  }
  let headers = headersOrFetchResponse, httpOk = httpStatus >= 200 && httpStatus < 300, responseMeta = parseMetadata(headers), [statusCode, statusDetail] = parseStatus(headers);
  if ((statusCode === void 0 || statusCode === GrpcStatusCode.OK) && !httpOk) {
    statusCode = httpStatusToGrpc(httpStatus);
    statusDetail = httpStatusText;
  }
  return [statusCode, statusDetail, responseMeta];
}
function readGrpcWebResponseTrailer(data) {
  let headers = parseTrailer(data), [code, detail] = parseStatus(headers), meta = parseMetadata(headers);
  return [code !== null && code !== void 0 ? code : GrpcStatusCode.OK, detail, meta];
}
var GrpcWebFrame;
(function(GrpcWebFrame2) {
  GrpcWebFrame2[GrpcWebFrame2["DATA"] = 0] = "DATA";
  GrpcWebFrame2[GrpcWebFrame2["TRAILER"] = 128] = "TRAILER";
})(GrpcWebFrame || (GrpcWebFrame = {}));
function readGrpcWebResponseBody(stream2, contentType, onFrame) {
  return __awaiter7(this, void 0, void 0, function* () {
    let streamReader, base64queue = "", byteQueue = new Uint8Array(0), format7 = parseFormat(contentType);
    if (isReadableStream(stream2)) {
      let whatWgReadableStream = stream2.getReader();
      streamReader = {
        next: () => whatWgReadableStream.read()
      };
    } else {
      streamReader = stream2[Symbol.asyncIterator]();
    }
    while (true) {
      let result = yield streamReader.next();
      if (result.value !== void 0) {
        if (format7 === "text") {
          for (let i = 0; i < result.value.length; i++)
            base64queue += String.fromCharCode(result.value[i]);
          let safeLen = base64queue.length - base64queue.length % 4;
          if (safeLen === 0)
            continue;
          byteQueue = concatBytes(byteQueue, base64decode(base64queue.substring(0, safeLen)));
          base64queue = base64queue.substring(safeLen);
        } else {
          byteQueue = concatBytes(byteQueue, result.value);
        }
        while (byteQueue.length >= 5 && byteQueue[0] === GrpcWebFrame.DATA) {
          let msgLen = 0;
          for (let i = 1; i < 5; i++)
            msgLen = (msgLen << 8) + byteQueue[i];
          if (byteQueue.length - 5 >= msgLen) {
            onFrame(GrpcWebFrame.DATA, byteQueue.subarray(5, 5 + msgLen));
            byteQueue = byteQueue.subarray(5 + msgLen);
          } else
            break;
        }
      }
      if (result.done) {
        if (byteQueue.length === 0)
          break;
        if (byteQueue[0] !== GrpcWebFrame.TRAILER || byteQueue.length < 5)
          throw new RpcError("premature EOF", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
        onFrame(GrpcWebFrame.TRAILER, byteQueue.subarray(5));
        break;
      }
    }
  });
}
var isReadableStream = (s) => {
  return typeof s.getReader == "function";
};
function concatBytes(a, b2) {
  let n = new Uint8Array(a.length + b2.length);
  n.set(a);
  n.set(b2, a.length);
  return n;
}
function parseFormat(contentType) {
  switch (contentType) {
    case "application/grpc-web-text":
    case "application/grpc-web-text+proto":
      return "text";
    case "application/grpc-web":
    case "application/grpc-web+proto":
      return "binary";
    case void 0:
    case null:
      throw new RpcError("missing response content type", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
    default:
      throw new RpcError("unexpected response content type: " + contentType, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
  }
}
function parseStatus(headers) {
  let code, message;
  let m2 = headers["grpc-message"];
  if (m2 !== void 0) {
    if (Array.isArray(m2))
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web message"];
    message = m2;
  }
  let s = headers["grpc-status"];
  if (s !== void 0) {
    if (Array.isArray(s))
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
    code = parseInt(s, 10);
    if (GrpcStatusCode[code] === void 0)
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
  }
  return [code, message];
}
function parseMetadata(headers) {
  let meta = {};
  for (let [k2, v2] of Object.entries(headers))
    switch (k2) {
      case "grpc-message":
      case "grpc-status":
      case "content-type":
        break;
      default:
        meta[k2] = v2;
    }
  return meta;
}
function parseTrailer(trailerData) {
  let headers = {};
  for (let chunk4 of String.fromCharCode.apply(String, trailerData).trim().split("\r\n")) {
    if (chunk4 == "")
      continue;
    let [key, ...val] = chunk4.split(":");
    const value6 = val.join(":").trim();
    key = key.trim();
    let e = headers[key];
    if (typeof e == "string")
      headers[key] = [e, value6];
    else if (Array.isArray(e))
      e.push(value6);
    else
      headers[key] = value6;
  }
  return headers;
}
function fetchHeadersToHttp(fetchHeaders) {
  let headers = {};
  fetchHeaders.forEach((value6, key) => {
    let e = headers[key];
    if (typeof e == "string")
      headers[key] = [e, value6];
    else if (Array.isArray(e))
      e.push(value6);
    else
      headers[key] = value6;
  });
  return headers;
}
function httpStatusToGrpc(httpStatus) {
  switch (httpStatus) {
    case 200:
      return GrpcStatusCode.OK;
    case 400:
      return GrpcStatusCode.INVALID_ARGUMENT;
    case 401:
      return GrpcStatusCode.UNAUTHENTICATED;
    case 403:
      return GrpcStatusCode.PERMISSION_DENIED;
    case 404:
      return GrpcStatusCode.NOT_FOUND;
    case 409:
      return GrpcStatusCode.ABORTED;
    case 412:
      return GrpcStatusCode.FAILED_PRECONDITION;
    case 429:
      return GrpcStatusCode.RESOURCE_EXHAUSTED;
    case 499:
      return GrpcStatusCode.CANCELLED;
    case 500:
      return GrpcStatusCode.UNKNOWN;
    case 501:
      return GrpcStatusCode.UNIMPLEMENTED;
    case 503:
      return GrpcStatusCode.UNAVAILABLE;
    case 504:
      return GrpcStatusCode.DEADLINE_EXCEEDED;
    default:
      return GrpcStatusCode.UNKNOWN;
  }
}

// node_modules/.pnpm/@protobuf-ts+grpcweb-transport@2.11.1/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-transport.js
var GrpcWebFetchTransport = class {
  constructor(defaultOptions) {
    this.defaultOptions = defaultOptions;
  }
  mergeOptions(options) {
    return mergeRpcOptions(this.defaultOptions, options);
  }
  /**
   * Create an URI for a gRPC web call.
   *
   * Takes the `baseUrl` option and appends:
   * - slash "/"
   * - package name
   * - dot "."
   * - service name
   * - slash "/"
   * - method name
   *
   * If the service was declared without a package, the package name and dot
   * are omitted.
   *
   * All names are used exactly like declared in .proto.
   */
  makeUrl(method, options) {
    let base = options.baseUrl;
    if (base.endsWith("/"))
      base = base.substring(0, base.length - 1);
    return `${base}/${method.service.typeName}/${method.name}`;
  }
  clientStreaming(method) {
    const e = new RpcError("Client streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  duplex(method) {
    const e = new RpcError("Duplex streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  serverStreaming(method, input, options) {
    var _a, _b, _c, _d, _e;
    let opt = options, format7 = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetch = (_b = opt.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch, fetchInit = (_c = opt.fetchInit) !== null && _c !== void 0 ? _c : {}, url2 = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), responseStream = new RpcOutputStreamController(), responseEmptyBody = true, maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
    fetch(url2, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createGrpcWebRequestHeader(new globalThis.Headers(), format7, opt.timeout, opt.meta),
      body: createGrpcWebRequestBody(inputBytes, format7),
      signal: (_d = options.abort) !== null && _d !== void 0 ? _d : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
      defHeader.resolve(meta);
      if (code != null && code !== GrpcStatusCode.OK)
        throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);
      if (code != null)
        maybeStatus = {
          code: GrpcStatusCode[code],
          detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
        };
      return fetchResponse;
    }).then((fetchResponse) => {
      if (!fetchResponse.body)
        throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type2, data) => {
        switch (type2) {
          case GrpcWebFrame.DATA:
            responseStream.notifyMessage(method.O.fromBinary(data, opt.binaryOptions));
            responseEmptyBody = false;
            break;
          case GrpcWebFrame.TRAILER:
            let code, detail;
            [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);
            maybeStatus = {
              code: GrpcStatusCode[code],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
            };
            break;
        }
      });
    }).then(() => {
      if (!maybeTrailer && !responseEmptyBody)
        throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeStatus)
        throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      if (maybeStatus.code !== "OK")
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      responseStream.notifyComplete();
      defStatus.resolve(maybeStatus);
      defTrailer.resolve(maybeTrailer || {});
    }).catch((reason) => {
      let error2;
      if (reason instanceof RpcError)
        error2 = reason;
      else if (reason instanceof Error && reason.name === "AbortError")
        error2 = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
      else
        error2 = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      error2.methodName = method.name;
      error2.serviceName = method.service.typeName;
      defHeader.rejectPending(error2);
      responseStream.notifyError(error2);
      defStatus.rejectPending(error2);
      defTrailer.rejectPending(error2);
    });
    return new ServerStreamingCall(method, (_e = opt.meta) !== null && _e !== void 0 ? _e : {}, input, defHeader.promise, responseStream, defStatus.promise, defTrailer.promise);
  }
  unary(method, input, options) {
    var _a, _b, _c, _d, _e;
    let opt = options, format7 = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetch = (_b = opt.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch, fetchInit = (_c = opt.fetchInit) !== null && _c !== void 0 ? _c : {}, url2 = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), maybeMessage, defMessage = new Deferred(), maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
    fetch(url2, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createGrpcWebRequestHeader(new globalThis.Headers(), format7, opt.timeout, opt.meta),
      body: createGrpcWebRequestBody(inputBytes, format7),
      signal: (_d = options.abort) !== null && _d !== void 0 ? _d : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
      defHeader.resolve(meta);
      if (code != null && code !== GrpcStatusCode.OK)
        throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);
      if (code != null)
        maybeStatus = {
          code: GrpcStatusCode[code],
          detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
        };
      return fetchResponse;
    }).then((fetchResponse) => {
      if (!fetchResponse.body)
        throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type2, data) => {
        switch (type2) {
          case GrpcWebFrame.DATA:
            if (maybeMessage)
              throw new RpcError(`unary call received 2nd message`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
            maybeMessage = method.O.fromBinary(data, opt.binaryOptions);
            break;
          case GrpcWebFrame.TRAILER:
            let code, detail;
            [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);
            maybeStatus = {
              code: GrpcStatusCode[code],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
            };
            break;
        }
      });
    }).then(() => {
      if (!maybeTrailer && maybeMessage)
        throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeStatus)
        throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      if (!maybeMessage && maybeStatus.code === "OK")
        throw new RpcError("expected error status", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeMessage)
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      defMessage.resolve(maybeMessage);
      if (maybeStatus.code !== "OK")
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      defStatus.resolve(maybeStatus);
      defTrailer.resolve(maybeTrailer || {});
    }).catch((reason) => {
      let error2;
      if (reason instanceof RpcError)
        error2 = reason;
      else if (reason instanceof Error && reason.name === "AbortError")
        error2 = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
      else
        error2 = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      error2.methodName = method.name;
      error2.serviceName = method.service.typeName;
      defHeader.rejectPending(error2);
      defMessage.rejectPending(error2);
      defStatus.rejectPending(error2);
      defTrailer.rejectPending(error2);
    });
    return new UnaryCall(method, (_e = opt.meta) !== null && _e !== void 0 ? _e : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b2) {
        if (arguments.length >= 2) {
          return body(a, b2);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b2, c) {
        if (arguments.length >= 3) {
          return body(a, b2, c);
        }
        return function(self) {
          return body(self, a, b2);
        };
      };
    case 4:
      return function(a, b2, c, d) {
        if (arguments.length >= 4) {
          return body(a, b2, c, d);
        }
        return function(self) {
          return body(self, a, b2, c);
        };
      };
    case 5:
      return function(a, b2, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b2, c, d, e);
        }
        return function(self) {
          return body(self, a, b2, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var unsafeCoerce = identity;
var constant = (value6) => () => value6;
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
var constVoid = constUndefined;
var compose = dual(2, (ab, bc) => (a) => bc(ab(a)));
var absurd = (_2) => {
  throw new Error("Called `absurd` function which should be uncallable");
};
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var hole = unsafeCoerce(absurd);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y2) => x === y2;
var strict = () => isStrictEquivalent;
var string = strict();
var number = strict();
var boolean = strict();
var bigint = strict();
var symbol = strict();
var combine = dual(2, (self, that) => make((x, y2) => self(x, y2) && that(x, y2)));
var combineMany = dual(2, (self, collection) => make((x, y2) => {
  if (!self(x, y2)) {
    return false;
  }
  for (const equivalence3 of collection) {
    if (!equivalence3(x, y2)) {
      return false;
    }
  }
  return true;
}));
var mapInput = dual(2, (self, f2) => make((x, y2) => self(f2(x), f2(y2))));
var Date2 = mapInput(number, (date3) => date3.getTime());
var product = dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map40) => dual(3, (self, name, f2) => map40(self, (a) => ({
  ...a,
  [name]: f2(a)
})));
var bindTo = (map40) => dual(2, (self, name) => map40(self, (a) => ({
  [name]: a
})));
var bind = (map40, flatMap22) => dual(3, (self, name, f2) => flatMap22(self, (a) => map40(f2(a), (b2) => ({
  ...a,
  [name]: b2
}))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id2, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id2)) {
    globalStore.set(id2, compute());
  }
  return globalStore.get(id2);
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Predicate.js
var mapInput2 = dual(2, (self, f2) => (b2) => self(f2(b2)));
var isTupleOf = dual(2, (self, n) => self.length === n);
var isTupleOfAtLeast = dual(2, (self, n) => self.length >= n);
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isPropertyKey = (u) => isString(u) || isNumber(u) || isSymbol(u);
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNotUndefined = (input) => input !== void 0;
var isNotNull = (input) => input !== null;
var isNever = (_2) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = dual(2, (self, property2) => isObject(self) && property2 in self);
var isTagged = dual(2, (self, tag3) => hasProperty(self, "_tag") && self["_tag"] === tag3);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isReadonlyRecord = isRecord;
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var compose2 = dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var or = dual(2, (self, that) => (a) => self(a) || that(a));
var and = dual(2, (self, that) => (a) => self(a) && that(a));
var xor = dual(2, (self, that) => (a) => self(a) !== that(a));
var eqv = dual(2, (self, that) => (a) => self(a) === that(a));
var implies = dual(2, (antecedent, consequent) => (a) => antecedent(a) ? consequent(a) : true);
var nor = dual(2, (self, that) => (a) => !(self(a) || that(a)));
var nand = dual(2, (self, that) => (a) => !(self(a) && that(a)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = Symbol.for("effect/Gen/GenKind");
var GenKindImpl = class {
  value;
  constructor(value6) {
    this.value = value6;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_2) => _2;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_2) => _2;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_2) => _2;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var adapter = () => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max11) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max11;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value6) {
    this.#value = value6;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Hash.js
var randomHashCache = globalValue(Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol2 = Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string2(self.toString(10));
    case "boolean":
      return string2(String(self));
    case "symbol":
      return string2(String(self));
    case "string":
      return string2(self);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string2("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol2]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine2 = (b2) => (self) => self * 53 ^ b2;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol2);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h2 = n | 0;
  if (h2 !== n) {
    h2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h2 ^= n /= 4294967295;
  }
  return optimize(h2);
};
var string2 = (str) => {
  let h2 = 5381, i = str.length;
  while (i) {
    h2 = h2 * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h2);
};
var structureKeys = (o, keys10) => {
  let h2 = 12289;
  for (let i = 0; i < keys10.length; i++) {
    h2 ^= pipe(string2(keys10[i]), combine2(hash(o[keys10[i]])));
  }
  return optimize(h2);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h2 = 6151;
  for (let i = 0; i < arr.length; i++) {
    h2 = pipe(h2, combine2(hash(arr[i])));
  }
  return optimize(h2);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash5) {
      Object.defineProperty(self2, symbol2, {
        value() {
          return hash5;
        },
        enumerable: false
      });
      return hash5;
    };
  }
  const self = arguments[0];
  const hash4 = arguments[1];
  Object.defineProperty(self, symbol2, {
    value() {
      return hash4;
    },
    enumerable: false
  });
  return hash4;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Equal.js
var symbol3 = Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol3](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v2, i) => compareBoth(v2, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol3);
var equivalence = () => equals;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value6) => typeof value6 === "object" && value6 !== null ? cache.includes(value6) ? void 0 : cache.push(value6) && (redactableState.fiberRefs !== void 0 && isRedactable(value6) ? value6[symbolRedactable](redactableState.fiberRefs) : value6) : value6, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context10, f2) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context10;
  try {
    return f2();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};
var Prototype = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Base = function() {
  function PipeableBase() {
  }
  PipeableBase.prototype = Prototype;
  return PipeableBase;
}();

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.17.13";
var getCurrentVersion = () => moduleVersion;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = Symbol.for("effect/Effect");
var StreamTypeId = Symbol.for("effect/Stream");
var SinkTypeId = Symbol.for("effect/Sink");
var ChannelTypeId = Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2,
  _V: getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _L: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol3](that) {
    return this === that;
  },
  [symbol2]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol2]() {
    return cached(this, structure(this));
  },
  [symbol3](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base2 = function() {
  function Base4() {
  }
  Base4.prototype = CommitPrototype;
  return Base4;
}();
var StructuralBase = function() {
  function Base4() {
  }
  Base4.prototype = StructuralCommitPrototype;
  return Base4;
}();

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/option.js
var TypeId = Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = Object.assign(Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol3](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = hash("None");
var NoneProto = Object.assign(Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol3](that) {
    return isOption(that) && isNone(that);
  },
  [symbol2]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = Object.create(NoneProto);
var some = (value6) => {
  const a = Object.create(SomeProto);
  a.value = value6;
  return a;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol3](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol3](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var getRight = (self) => isLeft(self) ? none : some(self.right);
var fromOption = dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Either.js
var right2 = right;
var void_ = right2(void 0);
var left2 = left;
var fromNullable = dual(2, (self, onNullable) => self == null ? left2(onNullable(self)) : right2(self));
var fromOption2 = fromOption;
var try_ = (evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x, y2) => isLeft2(x) ? isLeft2(y2) && left3(x.left, y2.left) : isRight2(y2) && right3(x.right, y2.right));
var mapBoth = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = dual(2, (self, f2) => isLeft2(self) ? left2(f2(self.left)) : right2(self.right));
var map = dual(2, (self, f2) => isRight2(self) ? right2(f2(self.right)) : left2(self.left));
var match = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var liftPredicate = dual(3, (a, predicate, orLeftWith) => predicate(a) ? right2(a) : left2(orLeftWith(a)));
var filterOrLeft = dual(3, (self, predicate, orLeftWith) => flatMap(self, (r) => predicate(r) ? right2(r) : left2(orLeftWith(r))));
var merge = match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);
var getOrNull = getOrElse(constNull);
var getOrUndefined = getOrElse(constUndefined);
var getOrThrowWith = dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var orElse = dual(2, (self, that) => isLeft2(self) ? that(self.left) : right2(self.right));
var flatMap = dual(2, (self, f2) => isLeft2(self) ? left2(self.left) : f2(self.right));
var andThen = dual(2, (self, f2) => flatMap(self, (a) => {
  const b2 = isFunction2(f2) ? f2(a) : f2;
  return isEither2(b2) ? b2 : right2(b2);
}));
var zipWith = dual(3, (self, that, f2) => flatMap(self, (r) => map(that, (r2) => f2(r, r2))));
var ap = dual(2, (self, that) => zipWith(self, that, (f2, a) => f2(a)));
var adapter2 = adapter();
var Do = right2({});
var bind2 = bind(map, flatMap);
var bindTo2 = bindTo(map);
var let_2 = let_(map);
var transposeMapOption = dual(2, (self, f2) => isNone(self) ? right2(none) : map(f2(self.value), some));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Order.js
var make2 = (compare2) => (self, that) => self === that ? 0 : compare2(self, that);
var string3 = make2((self, that) => self < that ? -1 : 1);
var number3 = make2((self, that) => self < that ? -1 : 1);
var boolean2 = make2((self, that) => self < that ? -1 : 1);
var bigint2 = make2((self, that) => self < that ? -1 : 1);
var combine3 = dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var combineMany2 = dual(2, (self, collection) => make2((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var mapInput3 = dual(2, (self, f2) => make2((b1, b2) => self(f2(b1), f2(b2))));
var Date3 = mapInput3(number3, (date3) => date3.getTime());
var product2 = dual(2, (self, that) => make2(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}));
var all = (collection) => {
  return make2((x, y2) => {
    const len = Math.min(x.length, y2.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y2[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
var productMany = dual(2, (self, collection) => {
  const O = all(collection);
  return make2((x, y2) => {
    const o = self(x[0], y2[0]);
    return o !== 0 ? o : O(x.slice(1), y2.slice(1));
  });
});
var tuple = (...elements) => all(elements);
var lessThan = (O) => dual(2, (self, that) => O(self, that) === -1);
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== -1);
var min = (O) => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
var max = (O) => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
var clamp = (O) => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
var between = (O) => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Option.js
var TypeId3 = Symbol.for("effect/Option");
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var getRight2 = getRight;
var getOrElse2 = dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse2 = dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var orElseEither = dual(2, (self, that) => isNone2(self) ? map2(that(), right) : map2(self, left));
var fromNullable2 = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrNull2 = getOrElse2(constNull);
var getOrUndefined2 = getOrElse2(constUndefined);
var liftThrowable = (f2) => (...a) => {
  try {
    return some2(f2(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = dual(2, (self, f2) => isNone2(self) ? none2() : some2(f2(self.value)));
var as = dual(2, (self, b2) => map2(self, () => b2));
var asVoid = as(void 0);
var void_2 = some2(void 0);
var flatMap2 = dual(2, (self, f2) => isNone2(self) ? none2() : f2(self.value));
var andThen2 = dual(2, (self, f2) => flatMap2(self, (a) => {
  const b2 = isFunction(f2) ? f2(a) : f2;
  return isOption2(b2) ? b2 : some2(b2);
}));
var flatMapNullable = dual(2, (self, f2) => isNone2(self) ? none2() : fromNullable2(f2(self.value)));
var flatten = flatMap2(identity);
var zipRight = dual(2, (self, that) => flatMap2(self, () => that));
var zipLeft = dual(2, (self, that) => tap(self, () => that));
var composeK = dual(2, (afb, bfc) => (a) => flatMap2(afb(a), bfc));
var tap = dual(2, (self, f2) => flatMap2(self, (a) => map2(f2(a), () => a)));
var product3 = (self, that) => isSome2(self) && isSome2(that) ? some2([self.value, that.value]) : none2();
var zipWith2 = dual(3, (self, that, f2) => map2(product3(self, that), ([a, b2]) => f2(a, b2)));
var ap2 = dual(2, (self, that) => zipWith2(self, that, (f2, a) => f2(a)));
var reduceCompact = dual(3, (self, b2, f2) => {
  let out = b2;
  for (const oa of self) {
    if (isSome2(oa)) {
      out = f2(out, oa.value);
    }
  }
  return out;
});
var partitionMap = dual(2, (self, f2) => {
  if (isNone2(self)) {
    return [none2(), none2()];
  }
  const e = f2(self.value);
  return isLeft(e) ? [some2(e.left), none2()] : [none2(), some2(e.right)];
});
var filterMap = flatMap2;
var filter = dual(2, (self, predicate) => filterMap(self, (b2) => predicate(b2) ? some(b2) : none));
var getEquivalence2 = (isEquivalent) => make((x, y2) => isNone2(x) ? isNone2(y2) : isNone2(y2) ? false : isEquivalent(x.value, y2.value));
var liftPredicate2 = dual(2, (b2, predicate) => predicate(b2) ? some2(b2) : none2());
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = equivalence();
var contains = containsWith(_equivalence);
var exists = dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var bindTo3 = bindTo(map2);
var let_3 = let_(map2);
var bind3 = bind(map2, flatMap2);
var Do2 = some2({});
var adapter3 = adapter();
var mergeWith = (f2) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f2(o1.value, o2.value));
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;
var map3 = dual(2, (self, fn) => self.map((element2) => fn(element2)));
var mapBoth2 = dual(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])]);
var mapFirst = dual(2, (self, f2) => [f2(self[0]), self[1]]);
var mapSecond = dual(2, (self, f2) => [self[0], f2(self[1])]);
var appendElement = dual(2, (self, that) => [...self, that]);
var at = dual(2, (self, index) => self[index]);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Iterable.js
var makeBy = (f2, options) => {
  const max11 = options?.length !== void 0 ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max11) {
            return {
              value: f2(i++),
              done: false
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
  };
};
var replicate = dual(2, (a, n) => makeBy(() => a, {
  length: n
}));
var prepend = dual(2, (self, head8) => prependAll(self, [head8]));
var prependAll = dual(2, (self, that) => appendAll(that, self));
var append = dual(2, (self, last6) => appendAll(self, [last6]));
var appendAll = dual(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}));
var scan = dual(3, (self, b2, f2) => ({
  [Symbol.iterator]() {
    let acc = b2;
    let iterator;
    function next5() {
      if (iterator === void 0) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f2(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next: next5
    };
  }
}));
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var take = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    let i = 0;
    const iterator = self[Symbol.iterator]();
    return {
      next() {
        if (i < n) {
          i++;
          return iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var takeWhile = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: void 0
          };
        }
        return result;
      }
    };
  }
}));
var drop = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}));
var findFirst = dual(2, (self, f2) => {
  let i = 0;
  for (const a of self) {
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var findLast = dual(2, (self, f2) => {
  let i = 0;
  let last6 = none2();
  for (const a of self) {
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        last6 = some2(a);
      }
    } else {
      if (isSome2(o)) {
        last6 = o;
      }
    }
    i++;
  }
  return last6;
});
var zip = dual(2, (self, that) => zipWith3(self, that, make3));
var zipWith3 = dual(3, (self, that, f2) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f2(selfResult.value, thatResult.value)
        };
      }
    };
  }
}));
var intersperse = dual(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next5 = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next5.done) {
          return next5;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next5;
        next5 = iterator.next();
        return result;
      }
    };
  }
}));
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = equivalence();
var contains2 = containsWith2(_equivalence2);
var chunksOf = dual(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === void 0) {
            return {
              done: true,
              value: void 0
            };
          }
          const chunk4 = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = void 0;
              return chunk4.length === 0 ? {
                done: true,
                value: void 0
              } : {
                done: false,
                value: chunk4
              };
            }
            chunk4.push(result.value);
          }
          return {
            done: false,
            value: chunk4
          };
        }
      };
    }
  };
});
var groupWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== void 0) {
          if (nextResult.done) {
            return {
              done: true,
              value: void 0
            };
          }
          result = nextResult;
          nextResult = void 0;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
        }
        const chunk4 = [result.value];
        while (true) {
          const next5 = iterator.next();
          if (next5.done || !isEquivalent(result.value, next5.value)) {
            nextResult = next5;
            return {
              done: false,
              value: chunk4
            };
          }
          chunk4.push(next5.value);
        }
      }
    };
  }
}));
var group = groupWith(equivalence());
var groupBy = dual(2, (self, f2) => {
  const out = {};
  for (const a of self) {
    const k2 = f2(a);
    if (Object.prototype.hasOwnProperty.call(out, k2)) {
      out[k2].push(a);
    } else {
      out[k2] = [a];
    }
  }
  return out;
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty = () => constEmpty;
var map4 = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f2(result.value, i++)
        };
      }
    };
  }
}));
var flatMap3 = dual(2, (self, f2) => flatten2(map4(self, f2)));
var flatten2 = (self) => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next5() {
      if (innerIterator === void 0) {
        const next6 = outerIterator.next();
        if (next6.done) {
          return next6;
        }
        innerIterator = next6.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = void 0;
        return next5();
      }
      return result;
    }
    return {
      next: next5
    };
  }
});
var filterMap2 = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          const b2 = f2(result.value, i++);
          if (isSome2(b2)) {
            return {
              done: false,
              value: b2.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var filterMapWhile = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const b2 = f2(result.value, i++);
        if (isSome2(b2)) {
          return {
            done: false,
            value: b2.value
          };
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var getSomes = filterMap2(identity);
var filter2 = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var flatMapNullable2 = dual(2, (self, f2) => filterMap2(self, (a) => {
  const b2 = f2(a);
  return b2 == null ? none2() : some2(b2);
}));
var some3 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
});
var forEach = dual(2, (self, f2) => {
  let i = 0;
  for (const a of self) {
    f2(a, i++);
  }
});
var reduce = dual(3, (self, b2, f2) => {
  if (Array.isArray(self)) {
    return self.reduce(f2, b2);
  }
  let i = 0;
  let result = b2;
  for (const n of self) {
    result = f2(result, n, i++);
  }
  return result;
});
var dedupeAdjacentWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let first4 = true;
    let last6;
    function next5() {
      const result = iterator.next();
      if (result.done) {
        return {
          done: true,
          value: void 0
        };
      }
      if (first4) {
        first4 = false;
        last6 = result.value;
        return result;
      }
      const current2 = result.value;
      if (isEquivalent(last6, current2)) {
        return next5();
      }
      last6 = current2;
      return result;
    }
    return {
      next: next5
    };
  }
}));
var dedupeAdjacent = dedupeAdjacentWith(equivalence());
var cartesianWith = dual(3, (self, that, f2) => flatMap3(self, (a) => map4(that, (b2) => f2(a, b2))));
var cartesian = dual(2, (self, that) => cartesianWith(self, that, (a, b2) => [a, b2]));
var countBy = dual(2, (self, f2) => {
  let count5 = 0;
  let i = 0;
  for (const a of self) {
    if (f2(a, i)) {
      count5++;
    }
    i++;
  }
  return count5;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Record.js
var empty2 = () => ({});
var isEmptyRecord = (self) => keys(self).length === 0;
var fromIterableWith = dual(2, (self, f2) => {
  const out = empty2();
  for (const a of self) {
    const [k2, b2] = f2(a);
    out[k2] = b2;
  }
  return out;
});
var collect = dual(2, (self, f2) => {
  const out = [];
  for (const key of keys(self)) {
    out.push(f2(key, self[key]));
  }
  return out;
});
var toEntries = collect((key, value6) => [key, value6]);
var has = dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));
var get = dual(2, (self, key) => has(self, key) ? some2(self[key]) : none2());
var modify = dual(3, (self, key, f2) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f2(self[key])
  };
});
var modifyOption = dual(3, (self, key, f2) => {
  if (!has(self, key)) {
    return none2();
  }
  return some2({
    ...self,
    [key]: f2(self[key])
  });
});
var replaceOption = dual(3, (self, key, b2) => modifyOption(self, key, () => b2));
var remove = dual(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
});
var pop = dual(2, (self, key) => has(self, key) ? some2([self[key], remove(self, key)]) : none2());
var map5 = dual(2, (self, f2) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f2(self[key], key);
  }
  return out;
});
var mapKeys = dual(2, (self, f2) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f2(key, a)] = a;
  }
  return out;
});
var mapEntries = dual(2, (self, f2) => {
  const out = {};
  for (const key of keys(self)) {
    const [k2, b2] = f2(self[key], key);
    out[k2] = b2;
  }
  return out;
});
var filterMap3 = dual(2, (self, f2) => {
  const out = empty2();
  for (const key of keys(self)) {
    const o = f2(self[key], key);
    if (isSome2(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
var filter3 = dual(2, (self, predicate) => {
  const out = empty2();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
});
var getSomes2 = filterMap3(identity);
var partitionMap2 = dual(2, (self, f2) => {
  const left3 = empty2();
  const right3 = empty2();
  for (const key of keys(self)) {
    const e = f2(self[key], key);
    if (isLeft2(e)) {
      left3[key] = e.left;
    } else {
      right3[key] = e.right;
    }
  }
  return [left3, right3];
});
var separate = partitionMap2(identity);
var partition = dual(2, (self, predicate) => {
  const left3 = empty2();
  const right3 = empty2();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right3[key] = self[key];
    } else {
      left3[key] = self[key];
    }
  }
  return [left3, right3];
});
var keys = (self) => Object.keys(self);
var set = dual(3, (self, key, value6) => {
  return {
    ...self,
    [key]: value6
  };
});
var replace = dual(3, (self, key, value6) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value6
    };
  }
  return {
    ...self
  };
});
var isSubrecordBy = (equivalence3) => dual(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence3(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
var isSubrecord = isSubrecordBy(equivalence());
var reduce2 = dual(3, (self, zero3, f2) => {
  let out = zero3;
  for (const key of keys(self)) {
    out = f2(out, self[key], key);
  }
  return out;
});
var every = dual(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
});
var some4 = dual(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
});
var union = dual(3, (self, that, combine18) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = empty2();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine18(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var intersection = dual(3, (self, that, combine18) => {
  const out = empty2();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine18(self[key], that[key]);
    }
  }
  return out;
});
var difference = dual(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var findFirst2 = dual(2, (self, f2) => {
  const k2 = keys(self);
  for (let i = 0; i < k2.length; i++) {
    const key = k2[i];
    if (f2(self[key], key)) {
      return some2([key, self[key]]);
    }
  }
  return none2();
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n);
var makeBy2 = dual(2, (n, f2) => {
  const max11 = Math.max(1, Math.floor(n));
  const out = new Array(max11);
  for (let i = 0; i < max11; i++) {
    out[i] = f2(i);
  }
  return out;
});
var replicate2 = dual(2, (a, n) => makeBy2(n, () => a));
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var match3 = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend2 = dual(2, (self, head8) => [head8, ...self]);
var prependAll2 = dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));
var append2 = dual(2, (self, last6) => [...self, last6]);
var appendAll2 = dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var scan2 = dual(3, (self, b2, f2) => {
  const out = [b2];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f2(out[i], a);
    i++;
  }
  return out;
});
var scanRight = dual(3, (self, b2, f2) => {
  const input = fromIterable(self);
  const out = new Array(input.length + 1);
  out[input.length] = b2;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f2(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as12) => i < 0 || i >= as12.length;
var clamp2 = (i, as12) => Math.floor(Math.min(Math.max(0, i), as12.length));
var get2 = dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = get2(0);
var headNonEmpty = unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tailNonEmpty = (self) => self.slice(1);
var initNonEmpty = (self) => self.slice(0, -1);
var take2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, clamp2(n, input));
});
var takeRight = dual(2, (self, n) => {
  const input = fromIterable(self);
  const i = clamp2(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile2 = dual(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp2(n, input), input.length);
});
var dropRight = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, input.length - clamp2(n, input));
});
var dropWhile = dual(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));
var findFirstIndex = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = dual(2, (self, predicate) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some2(i);
    }
  }
  return none2();
});
var findFirst3 = findFirst;
var findLast2 = dual(2, (self, f2) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var findFirstWithIndex = dual(2, (self, f2) => {
  let i = 0;
  for (const a of self) {
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2([a, i]);
      }
    } else {
      if (isSome2(o)) {
        return some2([o.value, i]);
      }
    }
    i++;
  }
  return none2();
});
var countBy2 = dual(2, (self, f2) => {
  let count5 = 0;
  const as12 = fromIterable(self);
  for (let i = 0; i < as12.length; i++) {
    const a = as12[i];
    if (f2(a, i)) {
      count5++;
    }
  }
  return count5;
});
var insertAt = dual(3, (self, i, b2) => {
  const out = Array.from(self);
  if (i < 0 || i > out.length) {
    return none2();
  }
  out.splice(i, 0, b2);
  return some2(out);
});
var replace2 = dual(3, (self, i, b2) => modify2(self, i, () => b2));
var replaceOption2 = dual(3, (self, i, b2) => modifyOption2(self, i, () => b2));
var modify2 = dual(3, (self, i, f2) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b2 = f2(out[i]);
  out[i] = b2;
  return out;
});
var modifyOption2 = dual(3, (self, i, f2) => {
  const arr = fromIterable(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  const b2 = f2(arr[i]);
  out[i] = b2;
  return some2(out);
});
var remove2 = dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var removeOption = dual(2, (self, i) => {
  const arr = fromIterable(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  out.splice(i, 1);
  return some2(out);
});
var reverse = (self) => Array.from(self).reverse();
var sort = dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var sortWith = dual(3, (self, f2, order) => Array.from(self).map((a) => [a, f2(a)]).sort(([, a], [, b2]) => order(a, b2)).map(([_2]) => _2));
var zip2 = dual(2, (self, that) => zipWith4(self, that, make3));
var zipWith4 = dual(3, (self, that, f2) => {
  const as12 = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as12) && isNonEmptyReadonlyArray(bs)) {
    const out = [f2(headNonEmpty(as12), headNonEmpty(bs))];
    const len = Math.min(as12.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f2(as12[i], bs[i]);
    }
    return out;
  }
  return [];
});
var intersperse2 = dual(2, (self, middle) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail = tailNonEmpty(input);
    for (let i = 0; i < tail.length; i++) {
      if (i < tail.length) {
        out.push(middle);
      }
      out.push(tail[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = dual(2, (self, f2) => [f2(headNonEmpty(self)), ...tailNonEmpty(self)]);
var setNonEmptyHead = dual(2, (self, b2) => modifyNonEmptyHead(self, () => b2));
var modifyNonEmptyLast = dual(2, (self, f2) => append2(initNonEmpty(self), f2(lastNonEmpty(self))));
var setNonEmptyLast = dual(2, (self, b2) => modifyNonEmptyLast(self, () => b2));
var rotate = dual(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m2 = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m2), input) || m2 === 0) {
      return copy2(input);
    }
    if (m2 < 0) {
      const [f2, s] = splitNonEmptyAt(input, -m2);
      return appendAll2(s, f2);
    } else {
      return rotate(self, m2 - len);
    }
  }
  return [];
});
var containsWith3 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence3 = equivalence();
var contains3 = containsWith3(_equivalence3);
var chop = dual(2, (self, f2) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b2, rest] = f2(input);
    const out = [b2];
    let next5 = rest;
    while (isNonEmptyArray(next5)) {
      const [b3, rest2] = f2(next5);
      out.push(b3);
      next5 = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy2(self), []] : [prepend2(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var split = dual(2, (self, n) => {
  const input = fromIterable(self);
  return chunksOf2(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));
var copy2 = (self) => self.slice();
var pad = dual(3, (self, n, fill) => {
  if (self.length >= n) {
    return take2(self, n);
  }
  return appendAll2(self, makeBy2(n - self.length, () => fill));
});
var chunksOf2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var window = dual(2, (self, n) => {
  const input = fromIterable(self);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_2, index) => input.slice(index, index + n));
  }
  return [];
});
var groupWith2 = dual(2, (self, isEquivalent) => chop(self, (as12) => {
  const h2 = headNonEmpty(as12);
  const out = [h2];
  let i = 1;
  for (; i < as12.length; i++) {
    const a = as12[i];
    if (isEquivalent(a, h2)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as12.slice(i)];
}));
var group2 = groupWith2(equivalence());
var groupBy2 = dual(2, (self, f2) => {
  const out = {};
  for (const a of self) {
    const k2 = f2(a);
    if (Object.prototype.hasOwnProperty.call(out, k2)) {
      out[k2].push(a);
    } else {
      out[k2] = [a];
    }
  }
  return out;
});
var unionWith = dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b2 = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b2)) {
      const dedupe2 = dedupeWith(isEquivalent);
      return dedupe2(appendAll2(a, b2));
    }
    return a;
  }
  return b2;
});
var union2 = dual(2, (self, that) => unionWith(self, that, _equivalence3));
var intersectionWith = (isEquivalent) => {
  const has17 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => has17(that, a)));
};
var intersection2 = intersectionWith(_equivalence3);
var differenceWith = (isEquivalent) => {
  const has17 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => !has17(that, a)));
};
var difference2 = differenceWith(_equivalence3);
var empty3 = () => [];
var of = (a) => [a];
var map6 = dual(2, (self, f2) => self.map(f2));
var flatMap4 = dual(2, (self, f2) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f2(self[i], i);
    for (let j2 = 0; j2 < inner.length; j2++) {
      out.push(inner[j2]);
    }
  }
  return out;
});
var flatten3 = flatMap4(identity);
var filterMap4 = dual(2, (self, f2) => {
  const as12 = fromIterable(self);
  const out = [];
  for (let i = 0; i < as12.length; i++) {
    const o = f2(as12[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile2 = dual(2, (self, f2) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b2 = f2(a, i);
    if (isSome2(b2)) {
      out.push(b2.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap3 = dual(2, (self, f2) => {
  const left3 = [];
  const right3 = [];
  const as12 = fromIterable(self);
  for (let i = 0; i < as12.length; i++) {
    const e = f2(as12[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes3 = filterMap4(identity);
var filter4 = dual(2, (self, predicate) => {
  const as12 = fromIterable(self);
  const out = [];
  for (let i = 0; i < as12.length; i++) {
    if (predicate(as12[i], i)) {
      out.push(as12[i]);
    }
  }
  return out;
});
var partition2 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as12 = fromIterable(self);
  for (let i = 0; i < as12.length; i++) {
    if (predicate(as12[i], i)) {
      right3.push(as12[i]);
    } else {
      left3.push(as12[i]);
    }
  }
  return [left3, right3];
});
var separate2 = partitionMap3(identity);
var reduce3 = dual(3, (self, b2, f2) => fromIterable(self).reduce((b3, a, i) => f2(b3, a, i), b2));
var reduceRight = dual(3, (self, b2, f2) => fromIterable(self).reduceRight((b3, a, i) => f2(b3, a, i), b2));
var fromNullable3 = (a) => a == null ? empty3() : [a];
var flatMapNullable3 = dual(2, (self, f2) => flatMap4(self, (a) => fromNullable3(f2(a))));
var every2 = dual(2, (self, refinement) => self.every(refinement));
var some5 = dual(2, (self, predicate) => self.some(predicate));
var extend = dual(2, (self, f2) => self.map((_2, i, as12) => f2(as12.slice(i))));
var min2 = dual(2, (self, O) => self.reduce(min(O)));
var max2 = dual(2, (self, O) => self.reduce(max(O)));
var unfold = (b2, f2) => {
  const out = [];
  let next5 = b2;
  let o;
  while (isSome2(o = f2(next5))) {
    const [a, b3] = o.value;
    out.push(a);
    next5 = b3;
  }
  return out;
};
var getEquivalence3 = array;
var forEach2 = dual(2, (self, f2) => fromIterable(self).forEach((a, i) => f2(a, i)));
var dedupeWith = dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var dedupeAdjacentWith2 = dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some2(a);
    }
  }
  return out;
});
var dedupeAdjacent2 = dedupeAdjacentWith2(equivalence());
var join = dual(2, (self, sep) => fromIterable(self).join(sep));
var mapAccum = dual(3, (self, s, f2) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f2(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith2 = dual(3, (self, that, f2) => flatMap4(self, (a) => map6(that, (b2) => f2(a, b2))));
var cartesian2 = dual(2, (self, that) => cartesianWith2(self, that, (a, b2) => [a, b2]));
var Do3 = of({});
var bind4 = bind(map6, flatMap4);
var bindTo4 = bindTo(map6);
var let_4 = let_(map6);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure = class _PreconditionFailure extends Error {
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = _PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err2) {
    return err2 != null && err2.footprint === _PreconditionFailure.SharedFootPrint;
  }
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
var Nil = class {
  [Symbol.iterator]() {
    return this;
  }
  next(value6) {
    return { value: value6, done: true };
  }
};
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f2) {
  for (const v2 of g) {
    yield f2(v2);
  }
}
function* flatMapHelper(g, f2) {
  for (const v2 of g) {
    yield* f2(v2);
  }
}
function* filterHelper(g, f2) {
  for (const v2 of g) {
    if (f2(v2)) {
      yield v2;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f2) {
  let cur = g.next();
  while (!cur.done && f2(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class _Stream {
  static nil() {
    return new _Stream(nilHelper());
  }
  static of(...elements) {
    return new _Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f2) {
    return new _Stream(mapHelper(this.g, f2));
  }
  flatMap(f2) {
    return new _Stream(flatMapHelper(this.g, f2));
  }
  dropWhile(f2) {
    let foundEligible = false;
    function* helper(v2) {
      if (foundEligible || !f2(v2)) {
        foundEligible = true;
        yield v2;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f2) {
    return new _Stream(takeWhileHelper(this.g, f2));
  }
  take(n) {
    return new _Stream(takeNHelper(this.g, n));
  }
  filter(f2) {
    return new _Stream(filterHelper(this.g, f2));
  }
  every(f2) {
    for (const v2 of this.g) {
      if (!f2(v2)) {
        return false;
      }
    }
    return true;
  }
  has(f2) {
    for (const v2 of this.g) {
      if (f2(v2)) {
        return [true, v2];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new _Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last6 = null;
    for (const v2 of this.g) {
      if (remaining-- === 0)
        return v2;
      last6 = v2;
    }
    return last6;
  }
};
function stream(g) {
  return new Stream(g);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  constructor(value_, context10, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context10;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
var ChainArbitrary = class extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return false;
  }
  shrink(value6, context10) {
    if (this.isSafeContext(context10)) {
      return (!context10.stoppedForOriginal ? this.arb.shrink(context10.originalValue, context10.originalContext).map((v2) => this.valueChainer(v2, context10.clonedMrng.clone(), context10.clonedMrng, context10.originalBias)) : Stream.nil()).join(context10.chainedArbitrary.shrink(value6, context10.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context10), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v2, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v2.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context10 = {
      originalBias: biasFactor,
      originalValue: v2.value_,
      originalContext: v2.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context10);
  }
  isSafeContext(context10) {
    return context10 != null && typeof context10 === "object" && "originalBias" in context10 && "originalValue" in context10 && "originalContext" in context10 && "stoppedForOriginal" in context10 && "chainedArbitrary" in context10 && "chainedContext" in context10 && "clonedMrng" in context10;
  }
};
var MapArbitrary = class extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v2) => this.valueMapper(v2);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value6) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value6);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value6, context10) {
    if (this.isSafeContext(context10)) {
      return this.arb.shrink(context10.originalValue, context10.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value6);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v2) {
    const sourceValue = v2.value;
    const mappedValue = this.mapper(sourceValue);
    if (v2.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v2)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v2) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v2);
    const context10 = { originalValue: sourceValue, originalContext: v2.context };
    return new Value(mappedValue, context10);
  }
  isSafeContext(context10) {
    return context10 != null && typeof context10 === "object" && "originalValue" in context10 && "originalContext" in context10;
  }
};
var FilterArbitrary = class extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v2) => this.refinementOnValue(v2);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6) && this.refinement(value6);
  }
  shrink(value6, context10) {
    return this.arb.shrink(value6, context10).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v2) {
    return this.refinement(v2.value);
  }
};
var NoShrinkArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
var NoBiasArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(value6, context10) {
    return this.arb.shrink(value6, context10);
  }
  noBias() {
    return this;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f2) {
  try {
    return f2.apply;
  } catch (err2) {
    return void 0;
  }
}
function safeApplyHacky(f2, instance, args2) {
  const ff = f2;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f2, instance, args2) {
  if (safeExtractApply(f2) === untouchedApply) {
    return f2.apply(instance, args2);
  }
  return safeApplyHacky(f2, instance, args2);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err2) {
    return void 0;
  }
}
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err2) {
    return void 0;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err2) {
    return void 0;
  }
}
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err2) {
    return void 0;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err2) {
    return void 0;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err2) {
    return void 0;
  }
}
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
function safeMap(instance, fn) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn);
  }
  return safeApply(untouchedMap, instance, [fn]);
}
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err2) {
    return void 0;
  }
}
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err2) {
    return void 0;
  }
}
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err2) {
    return void 0;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err2) {
    return void 0;
  }
}
function safeMapSet(instance, key, value6) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value6);
  }
  return safeApply(untouchedMapSet, instance, [key, value6]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err2) {
    return void 0;
  }
}
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err2) {
    return void 0;
  }
}
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
function safeCharCodeAt(instance, index) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index);
  }
  return safeApply(untouchedCharCodeAt, instance, [index]);
}
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err2) {
    return void 0;
  }
}
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
var untouchedToString = Object.prototype.toString;
function safeToString(instance) {
  return safeApply(untouchedToString, instance, []);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
var LazyIterableIterator = class {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var safeArrayIsArray = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IRawProperty.js
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
var globalParameters = {};
function readConfigureGlobal() {
  return globalParameters;
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value6) {
  if (value6.context !== void 0) {
    return value6;
  }
  if (value6.hasToBeCloned) {
    return new Value(value6.value_, UndefinedContextPlaceholder, () => value6.value);
  }
  return new Value(value6.value_, UndefinedContextPlaceholder);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class _AsyncProperty {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v2, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output = await this.predicate(v2);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err2) {
      if (PreconditionFailure.isFailure(err2))
        return err2;
      if (err2 instanceof SError && err2.stack) {
        return { error: err2, errorMessage: err2.stack };
      }
      return { error: err2, errorMessage: SString(err2) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
AsyncProperty.dummyHook = () => {
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property = class _Property {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = _Property.dummyHook, afterEach = _Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v2, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output = this.predicate(v2);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err2) {
      if (PreconditionFailure.isFailure(err2))
        return err2;
      if (err2 instanceof SError && err2.stack) {
        return { error: err2, errorMessage: err2.stack };
      }
      return { error: err2, errorMessage: SString(err2) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
Property.dummyHook = () => {
};

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
function generateN(rng, num) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
function unsafeSkipN(rng, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng.unsafeNext();
  }
}
function skipN(rng, num) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
  return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v3 = computeValueFromNextSeed(this.seed);
    var vnext = v3 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
}();
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
var __read = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
  function MersenneTwister2(states, index) {
    this.states = states;
    this.index = index;
  }
  MersenneTwister2.twist = function(prev) {
    var mt2 = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt2[idx] & MersenneTwister2.MASK_UPPER) + (mt2[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt2[idx] = mt2[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt2[idx] & MersenneTwister2.MASK_UPPER) + (mt2[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt2[idx] = mt2[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y2 = (mt2[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt2[0] & MersenneTwister2.MASK_LOWER);
    mt2[MersenneTwister2.N - 1] = mt2[MersenneTwister2.M - 1] ^ y2 >>> 1 ^ -(y2 & 1) & MersenneTwister2.A;
    return mt2;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y2 = this.states[this.index];
    y2 ^= this.states[this.index] >>> MersenneTwister2.U;
    y2 ^= y2 << MersenneTwister2.S & MersenneTwister2.B;
    y2 ^= y2 << MersenneTwister2.T & MersenneTwister2.C;
    y2 ^= y2 >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y2;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state) {
    var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state.slice(1), state[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
}();
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XorShift.js
var XorShift128Plus = function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
}();
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
}();
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index = data.length - 1; index >= 0; --index) {
    if (data[index] === 4294967295) {
      data[index] = 0;
    } else {
      data[index] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index = 0; index < maxLength2; ++index) {
    var indexA = index + dataA.length - maxLength2;
    var indexB = index + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index = 0; index !== rangeLength; ++index) {
      var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index] = g;
    }
    for (var index = 0; index !== rangeLength; ++index) {
      var current2 = out[index];
      var currentInRange = rangeSize[index];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff12 = to - from + SBigInt(1);
  var MinRng = SBigInt(-2147483648);
  var NumValues = SBigInt(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff12) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff12;
  while (true) {
    var value6 = SBigInt(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng.unsafeNext();
      value6 = NumValues * value6 + (SBigInt(out) - MinRng);
    }
    if (value6 < MaxAcceptedRandom) {
      var inDiff = value6 % diff12;
      return inDiff + from;
    }
  }
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class _QualifiedParameters {
  constructor(op) {
    const p = op || {};
    this.seed = _QualifiedParameters.readSeed(p);
    this.randomType = _QualifiedParameters.readRandomType(p);
    this.numRuns = _QualifiedParameters.readNumRuns(p);
    this.verbose = _QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v2) => {
      console.log(v2);
    });
    this.path = _QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined2 = (value6) => value6 !== null ? value6 : void 0;
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined2(this.timeout),
      skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined2(this.reporter),
      asyncReporter: orUndefined2(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new _QualifiedParameters(op);
  }
};
QualifiedParameters.createQualifiedRandomGenerator = (random3) => {
  return (seed) => {
    const rng = random3(seed);
    if (rng.unsafeJump === void 0) {
      rng.unsafeJump = () => unsafeSkipN(rng, 42);
    }
    return rng;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value6 = p[key];
  return value6 != null ? value6 : defaultValue;
};
QualifiedParameters.safeTimeout = (value6) => {
  if (value6 === null) {
    return null;
  }
  return safeMathMin(value6, 2147483647);
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/stringify.js
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m2 = findSymbolNameRegex.exec(SString(s));
  return m2 && m2[1].length ? m2[1] : null;
}
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index in arr) {
    const numberedIndex = Number(index);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value6, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value6];
  if (typeof value6 === "object") {
    if (safeIndexOf(previousValues, value6) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value6)) {
    const content = getAsyncContent(value6);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value6)) {
    try {
      return value6[toStringMethod]();
    } catch (err2) {
    }
  }
  switch (safeToString(value6)) {
    case "[object Array]": {
      const arr = value6;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index in arr) {
          if (!safeNumberIsNaN(Number(index)))
            safePush(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v2) => stringifyInternal(v2, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value6}n`;
    case "[object Boolean]": {
      const unboxedToString = value6 == true ? "true" : "false";
      return typeof value6 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value6;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value6 === "number" ? stringifyNumber(value6) : `new Number(${stringifyNumber(Number(value6))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value6.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value6.toString();
        }
      } catch (err2) {
        return "[object Object]";
      }
      const mapper = (k2) => `${k2 === "__proto__" ? '["__proto__"]' : typeof k2 === "symbol" ? `[${stringifyInternal(k2, currentValues, getAsyncContent)}]` : safeJsonStringify(k2)}:${stringifyInternal(value6[k2], currentValues, getAsyncContent)}`;
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value6), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value6), (s) => {
          const descriptor2 = safeObjectGetOwnPropertyDescriptor(value6, s);
          return descriptor2 && descriptor2.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value6) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value6 === "string" ? safeJsonStringify(value6) : `new String(${safeJsonStringify(value6)})`;
    case "[object Symbol]": {
      const s = value6;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value6);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value6 instanceof Error) {
        return `new Error(${stringifyInternal(value6.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value6)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value6.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value6);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray = value6;
        const valuesFromTypedArr = typedArray.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value6.toString();
  } catch (_a) {
    return safeToString(value6);
  }
}
function stringify(value6) {
  return stringifyInternal(value6, [], () => ({ state: "unknown", value: void 0 }));
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class _RunExecution {
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status2, value6) {
    const currentTree = { status: status2, value: value6, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value6, id2, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value6);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id2}`;
    else
      this.pathToFailure += `:${id2}`;
    this.value = value6;
    this.failure = failure;
  }
  skip(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures2 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures2.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures2;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
RunExecution.mergePaths = (offsetPath, path) => {
  if (offsetPath.length === 0)
    return path;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/random/generator/Random.js
var Random = class _Random {
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new _Random(this.internalRng);
  }
  next(bits) {
    return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min9, max11) {
    return unsafeUniformIntDistribution(min9 == null ? _Random.MIN_INT : min9, max11 == null ? _Random.MAX_INT : max11, this.internalRng);
  }
  nextBigInt(min9, max11) {
    return unsafeUniformBigIntDistribution(min9, max11, this.internalRng);
  }
  nextArrayInt(min9, max11) {
    return unsafeUniformArrayIntDistribution(min9, max11, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b2 = this.next(27);
    return (a * _Random.DBL_FACTOR + b2) * _Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
var safeArrayIsArray2 = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v2) {
  return safeMathFloor(safeMathLog2(v2) / safeMathLog2(2));
}
function biasNumericRange(min9, max11, logLike) {
  if (min9 === max11) {
    return [{ min: min9, max: max11 }];
  }
  if (min9 < 0 && max11 > 0) {
    const logMin = logLike(-min9);
    const logMax = logLike(max11);
    return [
      { min: -logMin, max: logMax },
      { min: max11 - logMax, max: max11 },
      { min: min9, max: min9 + logMin }
    ];
  }
  const logGap = logLike(max11 - min9);
  const arbCloseToMin = { min: min9, max: min9 + logGap };
  const arbCloseToMax = { min: max11 - logGap, max: max11 };
  return min9 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next5 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next5, previous2);
      previous2 = next5;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next5 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next5, previous2);
      previous2 = next5;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;
var IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
  constructor(min9, max11) {
    super();
    this.min = min9;
    this.max = max11;
  }
  generate(mrng, biasFactor) {
    const range3 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range3.min, range3.max), void 0);
  }
  canShrinkWithoutContext(value6) {
    return typeof value6 === "number" && safeNumberIsInteger(value6) && !safeObjectIs(value6, -0) && this.min <= value6 && value6 <= this.max;
  }
  shrink(current2, context10) {
    if (!_IntegerArbitrary.isValidContext(current2, context10)) {
      const target = this.defaultTarget();
      return shrinkInteger(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context10)) {
      return Stream.of(new Value(context10, void 0));
    }
    return shrinkInteger(current2, context10, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id2 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id2 < 0 ? ranges[0] : ranges[id2 + 1];
  }
  isLastChanceTry(current2, context10) {
    if (current2 > 0)
      return current2 === context10 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context10 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context10) {
    if (context10 === void 0) {
      return false;
    }
    if (typeof context10 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context10 !== 0 && safeMathSign(current2) !== safeMathSign(context10)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min9 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max11 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min9, max: max11 };
}
function integer(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context10 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context10);
  return context10;
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator = class {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index = 0; index !== this.slices.length; ++index) {
        const slice = this.slices[index];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], void 0);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray3 = Array.isArray;
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
var ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength2;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength2;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer({ min: minLength2, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index = 0; index !== tab.length; ++index) {
      s.tryAdd(tab[index]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N2 && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N2 - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N2, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N2);
    for (let index = 0; index !== N2; ++index) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N2, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N2 - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N2, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      _ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context10 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context10);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value6) {
    if (!safeArrayIsArray3(value6) || this.minLength > value6.length || value6.length > this.maxLength) {
      return false;
    }
    for (let index = 0; index !== value6.length; ++index) {
      if (!(index in value6)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value6[index])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value6, (item) => new Value(item, void 0)));
    return filtered.length === value6.length;
  }
  shrinkItemByItem(value6, safeContext, endIndex) {
    const shrinks2 = [];
    for (let index = safeContext.startIndex; index < endIndex; ++index) {
      safePush(shrinks2, makeLazy(() => this.arb.shrink(value6[index], safeContext.itemsContexts[index]).map((v2) => {
        const beforeCurrent = safeMap(safeSlice(value6, 0, index), (v3, i) => new Value(cloneIfNeeded(v3), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value6, index + 1), (v3, i) => new Value(cloneIfNeeded(v3), safeContext.itemsContexts[i + index + 1]));
        return [
          [...beforeCurrent, v2, ...afterCurrent],
          void 0,
          index
        ];
      })));
    }
    return Stream.nil().join(...shrinks2);
  }
  shrinkImpl(value6, context10) {
    if (value6.length === 0) {
      return Stream.nil();
    }
    const safeContext = context10 !== void 0 ? context10 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value6.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value6.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value6.length - lengthValue.value;
      return [
        safeMap(safeSlice(value6, sliceStart), (v2, index) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[index + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value6.length > this.minLength ? this.shrinkItemByItem(value6, safeContext, 1) : this.shrinkItemByItem(value6, safeContext, value6.length))).join(value6.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value6, 1), subContext).filter((v2) => this.minLength <= v2[0].length + 1).map((v2) => {
        return [[new Value(cloneIfNeeded(value6[0]), safeContext.itemsContexts[0]), ...v2[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value6, context10) {
    return this.shrinkImpl(value6, context10).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength2, size23) {
  switch (size23) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size23}`);
  }
}
function relativeSizeToSize(size23, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size23);
  if (sizeInRelative === -1) {
    return size23;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size23, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size23 !== void 0 ? size23 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array4(arb, constraints = {}) {
  const size23 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size23, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min9, max11, mapToCode, unmapFromCode) {
  return integer({ min: min9, max: max11 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v2) {
  if (v2 < 95)
    return v2 + 32;
  if (v2 <= 126)
    return v2 - 95;
  return v2;
}
function indexToPrintableIndexUnmapper(v2) {
  if (v2 >= 32 && v2 <= 126)
    return v2 - 32;
  if (v2 >= 0 && v2 <= 31)
    return v2 + 95;
  return v2;
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char.js
function identity2(v2) {
  return v2;
}
function char() {
  return buildCharacterArbitrary(32, 126, identity2, identity2);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v2) {
  if (v2 < 55296)
    return indexToPrintableIndexMapper(v2);
  return v2 + gapSize;
}
function unicodeUnmapper(v2) {
  if (v2 < 55296)
    return indexToPrintableIndexUnmapper(v2);
  if (v2 <= 57343)
    return -1;
  return v2 - gapSize;
}
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicode.js
var gapSize2 = 57343 + 1 - 55296;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/context.js
var ContextImplem = class _ContextImplem {
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new _ContextImplem();
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
var safeIsArray = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
var safeNumberIsNaN4 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/nat.js
var safeNumberIsInteger4 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var safeStringFromCharCode = String.fromCharCode;
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
function percentCharArbUnmapper(value6) {
  if (typeof value6 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value6);
  return decoded;
}
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
var safeStringFromCodePoint = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
var AdaptedValue = Symbol("adapted-value");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer, f64.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
var safeNumberIsInteger5 = Number.isInteger;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var f32 = new Float32Array(1);
var u322 = new Uint32Array(f32.buffer, f32.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
var safeNumberParseInt = Number.parseInt;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeArrayIsArray4 = SArray.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var safeArrayIsArray5 = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
function encodeSymbol(symbol5) {
  return symbol5 < 10 ? SString(symbol5) : encodeSymbolLookupTable[symbol5];
}
function pad2(value6, paddingLength) {
  let extraPadding = "";
  while (value6.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value6;
}
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next5 = remaining >> 5;
    const current2 = remaining - (next5 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next5;
  }
  return base32Str;
}
function uintToBase32StringMapper(num, paddingLength) {
  const head8 = ~~(num / 1073741824);
  const tail = num & 1073741823;
  return pad2(smallUintToBase32StringMapper(head8), paddingLength - 6) + pad2(smallUintToBase32StringMapper(tail), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
  return function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  };
}

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
var CommandsIterable = class _CommandsIterable {
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
var defaultSchedulerAct = (f2) => f2();
var SchedulerImplem = class _SchedulerImplem {
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status2, data) {
    this.triggeredTasks.push({
      status: status2,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve, reject2) => {
      trigger = () => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve(data);
        }, (err2) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err2);
          return reject2(err2);
        });
      };
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status2 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: (f2) => f2() };
    let resolveSequenceTask = () => {
    };
    const sequenceTask = new Promise((resolve) => resolveSequenceTask = resolve);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status2.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status2.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status2, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status2.done, faulty: status2.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    };
    const handleNotified = () => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    };
    const clearAndReplaceWatcher = () => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    };
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err2) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err2;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err2;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log3) => `-> ${log3}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new _SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var memoizeThunk = (f2) => {
  let done14 = false;
  let a;
  return () => {
    if (done14) {
      return a;
    }
    a = f2();
    done14 = true;
    return a;
  };
};
var formatDate = (date3) => {
  try {
    return date3.toISOString();
  } catch {
    return String(date3);
  }
};
var CIRCULAR = "[Circular]";
function formatUnknown(input, whitespace = 0) {
  const seen = /* @__PURE__ */ new WeakSet();
  const gap = !whitespace ? "" : typeof whitespace === "number" ? " ".repeat(whitespace) : whitespace;
  const ind = (d) => gap.repeat(d);
  const safeToString2 = (x) => {
    try {
      const s = x.toString();
      return typeof s === "string" ? s : String(s);
    } catch {
      return "[toString threw]";
    }
  };
  const wrap = (v2, body) => {
    const ctor = v2?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  };
  const ownKeys = (o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  };
  function go4(v2, d = 0) {
    if (Array.isArray(v2)) {
      if (seen.has(v2)) return CIRCULAR;
      seen.add(v2);
      if (!gap || v2.length <= 1) return `[${v2.map((x) => go4(x, d)).join(",")}]`;
      const inner = v2.map((x) => go4(x, d + 1)).join(",\n" + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v2)) return formatDate(v2);
    if (hasProperty(v2, "toString") && isFunction2(v2["toString"]) && v2["toString"] !== Object.prototype.toString) return safeToString2(v2);
    if (isString(v2)) return JSON.stringify(v2);
    if (isNumber(v2) || v2 == null || isBoolean(v2) || isSymbol(v2)) return String(v2);
    if (isBigInt(v2)) return String(v2) + "n";
    if (v2 instanceof Set || v2 instanceof Map) {
      if (seen.has(v2)) return CIRCULAR;
      seen.add(v2);
      return `${v2.constructor.name}(${go4(Array.from(v2), d)})`;
    }
    if (isObject(v2)) {
      if (seen.has(v2)) return CIRCULAR;
      seen.add(v2);
      const keys10 = ownKeys(v2);
      if (!gap || keys10.length <= 1) {
        const body2 = `{${keys10.map((k2) => `${formatPropertyKey(k2)}:${go4(v2[k2], d)}`).join(",")}}`;
        return wrap(v2, body2);
      }
      const body = `{
${keys10.map((k2) => `${ind(d + 1)}${formatPropertyKey(k2)}: ${go4(v2[k2], d + 1)}`).join(",\n")}
${ind(d)}}`;
      return wrap(v2, body);
    }
    return String(v2);
  }
  return go4(input, 0);
}
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
var isNonEmpty = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage = (details) => getErrorMessage("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast);
var getMissingAnnotationErrorMessage = (details, path, ast) => getErrorMessage("Missing annotation", details, path, ast);
var getArbitraryMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating an Arbitrary for this schema requires an "arbitrary" annotation`, path, ast);
var getArbitraryEmptyEnumErrorMessage = (path) => getErrorMessage("Empty Enums schema", "Generating an Arbitrary for this schema requires at least one enum", path);
var getEquivalenceUnsupportedErrorMessage = (ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast);
var getPrettyMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a Pretty for this schema requires a "pretty" annotation`, path, ast);
var getPrettyNeverErrorMessage = "Cannot pretty print a `never` value";
var getPrettyNoMatchingSchemaErrorMessage = (actual, path, ast) => getErrorMessage("Unexpected Error", `Cannot find a matching schema for ${formatUnknown(actual)}`, path, ast);
var getSchemaExtendErrorMessage = (x, y2, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y2}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage = (ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast);
var getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type2) => getErrorMessage("Duplicate index signature", `${type2} index signature`);
var getASTIndexSignatureParameterErrorMessage = getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTUnsupportedRenameSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = Symbol.for("effect/SchemaId/ItemsCount");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Number.js
var sum = dual(2, (self, that) => self + that);
var subtract = dual(2, (minuend, subtrahend) => minuend - subtrahend);
var multiply = dual(2, (multiplier, multiplicand) => multiplier * multiplicand);
var divide = dual(2, (dividend, divisor) => divisor === 0 ? none : some(dividend / divisor));
var unsafeDivide = dual(2, (dividend, divisor) => dividend / divisor);
var Order = number3;
var lessThan2 = lessThan(Order);
var lessThanOrEqualTo2 = lessThanOrEqualTo(Order);
var greaterThan2 = greaterThan(Order);
var greaterThanOrEqualTo2 = greaterThanOrEqualTo(Order);
var between2 = between(Order);
var clamp3 = clamp(Order);
var min3 = min(Order);
var max3 = max(Order);
var remainder = dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};
var round = dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/RegExp.js
var escape = (string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = Symbol.for("effect/annotation/StableFilter");
var getAnnotation = dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = getAnnotation(BrandAnnotationId);
var getSchemaIdAnnotation = getAnnotation(SchemaIdAnnotationId);
var getMessageAnnotation = getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = getAnnotation(JSONSchemaAnnotationId);
var getDocumentationAnnotation = getAnnotation(DocumentationAnnotationId);
var getConcurrencyAnnotation = getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b2) => b2 === true);
var JSONIdentifierAnnotationId = Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse2(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown4, encodeUnknown3, annotations3 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag3) => (ast) => ast._tag === tag3;
var isDeclaration = createASTGuard("Declaration");
var Literal = class {
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal2, annotations3 = {}) {
    this.literal = literal2;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = createASTGuard("Literal");
var $null = new Literal(null);
var UniqueSymbol = class {
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol5, annotations3 = {}) {
    this.symbol = symbol5;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isUniqueSymbol = createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var isUndefinedKeyword = createASTGuard("UndefinedKeyword");
var VoidKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "VoidKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var isVoidKeyword = createASTGuard("VoidKeyword");
var NeverKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var isUnknownKeyword = createASTGuard("UnknownKeyword");
var AnyKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var isAnyKeyword = createASTGuard("AnyKeyword");
var StringKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = createASTGuard("StringKeyword");
var NumberKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var isBigIntKeyword = createASTGuard("BigIntKeyword");
var SymbolKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var isObjectKeyword = createASTGuard("ObjectKeyword");
var Enums = class {
  enums;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Enums";
  constructor(enums, annotations3 = {}) {
    this.enums = enums;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_2, value6]) => JSON.stringify(value6)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isEnums = createASTGuard("Enums");
var isTemplateLiteralSpanType = (ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
};
var templateLiteralSpanUnionTypeToString = (type2) => {
  switch (type2._tag) {
    case "Literal":
      return JSON.stringify(String(type2.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type2);
    case "Union":
      return type2.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
};
var templateLiteralSpanTypeToString = (type2) => {
  switch (type2._tag) {
    case "Literal":
      return String(type2.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type2) + "}";
    case "Union":
      return "${" + type2.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
};
var TemplateLiteralSpan = class {
  literal;
  /**
   * @since 3.10.0
   */
  type;
  constructor(type2, literal2) {
    this.literal = literal2;
    if (isTemplateLiteralSpanType(type2)) {
      this.type = type2;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type2));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral = class {
  head;
  spans;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TemplateLiteral";
  constructor(head8, spans, annotations3 = {}) {
    this.head = head8;
    this.spans = spans;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span3) => span3.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map(String).join("") + "`";
var isTemplateLiteral = createASTGuard("TemplateLiteral");
var Type = class {
  type;
  annotations;
  constructor(type2, annotations3 = {}) {
    this.type = type2;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  isOptional;
  constructor(type2, isOptional, annotations3 = {}) {
    super(type2, annotations3);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations3 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations3;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head8, tail) => {
      const formattedHead = String(head8);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var isTupleType = createASTGuard("TupleType");
var PropertySignature = class extends OptionalType {
  name;
  isReadonly;
  constructor(name, type2, isOptional, isReadonly, annotations3) {
    super(type2, isOptional, annotations3);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type2, isReadonly) {
    this.type = type2;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations3 = {}) {
    this.annotations = annotations3;
    const keys10 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys10, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys10[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = createASTGuard("TypeLiteral");
var sortCandidates = sort(mapInput3(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten4 = (candidates) => flatMap4(candidates, (ast) => isUnion(ast) ? flatten4(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type2 = typeof ast.literal;
        switch (type2) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type2];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var Union = class _Union {
  types;
  annotations;
  static make = (types, annotations3) => {
    return isMembers(types) ? new _Union(types, annotations3) : types.length === 1 ? types[0] : neverKeyword;
  };
  /** @internal */
  static unify = (candidates, annotations3) => {
    return _Union.make(unify(flatten4(candidates)), annotations3);
  };
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations3 = {}) {
    this.types = types;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var mapMembers = (members, f2) => members.map(f2);
var isMembers = (as12) => as12.length > 1;
var isUnion = createASTGuard("Union");
var toJSONMemoMap = globalValue(Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f2, annotations3 = {}) {
    this.f = f2;
    this.annotations = annotations3;
    this.f = memoizeThunk(f2);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse2(() => flatMap2(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse2(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var isSuspend = createASTGuard("Suspend");
var Refinement = class {
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter18, annotations3 = {}) {
    this.from = from;
    this.filter = filter18;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse2(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations3 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = createASTGuard("Transformation");
var FinalTransformation = class {
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode6, encode5) {
    this.decode = decode6;
    this.encode = encode5;
  }
};
var createTransformationGuard = (tag3) => (ast) => ast._tag === tag3;
var isFinalTransformation = createTransformationGuard("FinalTransformation");
var ComposeTransformation = class {
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
var composeTransformation = new ComposeTransformation();
var isComposeTransformation = createTransformationGuard("ComposeTransformation");
var PropertySignatureTransformation = class {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode6, encode5) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode5;
  }
};
var isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;
var TypeLiteralTransformation = class {
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value6 = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value6[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value6;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof = (ast) => Union.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type2, capture2) => {
  switch (type2._tag) {
    case "Literal":
      return escape(String(type2.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type2, capture2, false);
    case "Union":
      return type2.types.map((type3) => getTemplateLiteralSpanTypePattern(type3, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type2, s, capture2, top) => {
  if (isUnion(type2)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head8 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head8})` : head8;
  }
  for (const span3 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span3.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span3.type, spanPattern, capture2, top);
    if (span3.literal !== "") {
      const literal2 = escape(span3.literal);
      pattern2 += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern2;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var getTemplateLiteralCapturingRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
var getIndexSignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
};
var getNumberIndexedAccess = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getTypeLiteralPropertySignature = (ast, name) => {
  const ops = findFirst3(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is3 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is3.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is3.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is3.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is3 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is3.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is3.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess = (ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getPropertyKeys = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection2(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record2 = (key, value6) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go4 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value6, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value6, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_2, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value6, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value6, false, true));
        break;
      case "Union":
        key2.types.forEach(go4);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go4(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick = (ast, keys10) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick(annotation.value, keys10);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys10.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys10) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys10.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick(ast.f(), keys10);
    case "Refinement":
      return pick(ast.from, keys10);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick(ast.from, keys10), pick(ast.to, keys10), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k2 of keys10) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k2);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k2);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys10), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var omit = (ast, keys10) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is3) => isStringKeyword(getEncodedParameter(is3.parameter)))) {
      indexSignatures = indexSignatures.filter((is3) => !isTemplateLiteral(getEncodedParameter(is3.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick(ast, getPropertyKeys(ast).filter((name) => !keys10.includes(name)));
};
var orUndefined = (ast) => Union.make([ast, undefinedKeyword]);
var partial = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is3) => new IndexSignature(is3.parameter, orUndefined(is3.type), is3.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var required = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f2) => new PropertySignature(f2.name, f2.type, false, f2.isReadonly, f2.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var mutable = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => is3.isReadonly === false ? is3 : new IndexSignature(is3.parameter, is3.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var getCompiler = (match28) => {
  const compile2 = (ast, path) => match28[ast._tag](ast, compile2, path);
  return compile2;
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = void 0;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out === void 0) {
        out = {};
      }
      out[id2] = annotated.annotations[id2];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id2 of annotationIds) {
    delete out[id2];
  }
  return out;
};
var preserveTransformationAnnotations = pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = typeAST(e.type);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type2) => new Type(type2)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type2 = typeAST(p.type);
        return type2 === p.type ? p : new PropertySignature(p.name, type2, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = typeAST(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
function changeMap(as12, f2) {
  let changed = false;
  const out = allocate(as12.length);
  for (let i = 0; i < as12.length; i++) {
    const a = as12[i];
    const fa = f2(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as12;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = encodedAST_(e.type, isBound);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type2 = encodedAST_(ps.type, isBound);
        return type2 === ps.type ? ps : new PropertySignature(ps.name, type2, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = encodedAST_(is3.type, isBound);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = void 0;
      const identifier2 = getJSONIdentifier(ast);
      if (isSome2(identifier2)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier2.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) return ast;
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var encodedBoundAST = (ast) => encodedAST_(ast, true);
var toJSONAnnotations = (annotations3) => {
  const out = {};
  for (const k2 of Object.getOwnPropertySymbols(annotations3)) {
    out[String(k2)] = annotations3[k2];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var equals2 = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
var equalsTemplateLiteralSpan = getEquivalence3((self, that) => {
  return self.literal === that.literal && equals2(self.type, that.type);
});
var equalsEnums = getEquivalence3((self, that) => that[0] === self[0] && that[1] === self[1]);
var equalsUnion = getEquivalence3(equals2);
var intersection3 = intersectionWith(equals2);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is3) => getEncodedParameter(is3.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection3(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var compose3 = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of Reflect.ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
};
var formatKeyword = (ast) => getOrElse2(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse2(() => getDescriptionAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse2(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var pruneUndefined = (ast, self, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined = false;
      for (const type2 of ast.types) {
        const pruned = self(type2);
        if (pruned) {
          hasUndefined = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type2);
        }
      }
      if (hasUndefined) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Arbitrary.js
var makeStringConstraints = (options) => {
  const out = {
    _tag: "StringConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  if (isString(options.pattern)) {
    out.pattern = options.pattern;
  }
  return out;
};
var makeNumberConstraints = (options) => {
  const out = {
    _tag: "NumberConstraints",
    constraints: {},
    isInteger: options.isInteger ?? false
  };
  if (isNumber(options.min)) {
    out.constraints.min = Math.fround(options.min);
  }
  if (isBoolean(options.minExcluded)) {
    out.constraints.minExcluded = options.minExcluded;
  }
  if (isNumber(options.max)) {
    out.constraints.max = Math.fround(options.max);
  }
  if (isBoolean(options.maxExcluded)) {
    out.constraints.maxExcluded = options.maxExcluded;
  }
  if (isBoolean(options.noNaN)) {
    out.constraints.noNaN = options.noNaN;
  }
  if (isBoolean(options.noDefaultInfinity)) {
    out.constraints.noDefaultInfinity = options.noDefaultInfinity;
  }
  return out;
};
var makeBigIntConstraints = (options) => {
  const out = {
    _tag: "BigIntConstraints",
    constraints: {}
  };
  if (isBigInt(options.min)) {
    out.constraints.min = options.min;
  }
  if (isBigInt(options.max)) {
    out.constraints.max = options.max;
  }
  return out;
};
var makeArrayConstraints = (options) => {
  const out = {
    _tag: "ArrayConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  return out;
};
var makeDateConstraints = (options) => {
  const out = {
    _tag: "DateConstraints",
    constraints: {}
  };
  if (isDate(options.min)) {
    out.constraints.min = options.min;
  }
  if (isDate(options.max)) {
    out.constraints.max = options.max;
  }
  if (isBoolean(options.noInvalidDate)) {
    out.constraints.noInvalidDate = options.noInvalidDate;
  }
  return out;
};
var getArbitraryAnnotation = getAnnotation(ArbitraryAnnotationId);
var getASTConstraints = (ast) => {
  const TypeAnnotationId = ast.annotations[SchemaIdAnnotationId];
  if (isPropertyKey(TypeAnnotationId)) {
    const out = ast.annotations[TypeAnnotationId];
    if (isReadonlyRecord(out)) {
      return out;
    }
  }
};
var idMemoMap = globalValue(Symbol.for("effect/Arbitrary/IdMemoMap"), () => /* @__PURE__ */ new Map());
var counter = 0;
function wrapGetDescription(f2, g) {
  return (ast, path) => f2(ast, g(ast, path));
}
function parseMeta(ast) {
  const jsonSchema = getJSONSchemaAnnotation(ast).pipe(filter(isReadonlyRecord), getOrUndefined2);
  const schemaId = getOrElse2(getSchemaIdAnnotation(ast), () => void 0);
  const schemaParams = fromNullable2(schemaId).pipe(map2((id2) => ast.annotations[id2]), filter(isReadonlyRecord), getOrUndefined2);
  return [schemaId, {
    ...schemaParams,
    ...jsonSchema
  }];
}
var getDescription = wrapGetDescription((ast, description) => {
  const annotation = getArbitraryAnnotation(ast);
  if (isSome2(annotation)) {
    return {
      ...description,
      annotations: [...description.annotations, annotation.value]
    };
  }
  return description;
}, (ast, path) => {
  const [schemaId, meta] = parseMeta(ast);
  switch (ast._tag) {
    case "Refinement": {
      const from = getDescription(ast.from, path);
      switch (from._tag) {
        case "StringKeyword":
          return {
            ...from,
            constraints: [...from.constraints, makeStringConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        case "NumberKeyword": {
          const c = schemaId === NonNaNSchemaId ? makeNumberConstraints({
            noNaN: true
          }) : schemaId === FiniteSchemaId || schemaId === JsonNumberSchemaId ? makeNumberConstraints({
            noDefaultInfinity: true,
            noNaN: true
          }) : makeNumberConstraints({
            isInteger: "type" in meta && meta.type === "integer",
            noNaN: void 0,
            noDefaultInfinity: void 0,
            min: meta.exclusiveMinimum ?? meta.minimum,
            minExcluded: "exclusiveMinimum" in meta ? true : void 0,
            max: meta.exclusiveMaximum ?? meta.maximum,
            maxExcluded: "exclusiveMaximum" in meta ? true : void 0
          });
          return {
            ...from,
            constraints: [...from.constraints, c],
            refinements: [...from.refinements, ast]
          };
        }
        case "BigIntKeyword": {
          const c = getASTConstraints(ast);
          return {
            ...from,
            constraints: c !== void 0 ? [...from.constraints, makeBigIntConstraints(c)] : from.constraints,
            refinements: [...from.refinements, ast]
          };
        }
        case "TupleType":
          return {
            ...from,
            constraints: [...from.constraints, makeArrayConstraints({
              minLength: meta.minItems,
              maxLength: meta.maxItems
            })],
            refinements: [...from.refinements, ast]
          };
        case "DateFromSelf":
          return {
            ...from,
            constraints: [...from.constraints, makeDateConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        default:
          return {
            ...from,
            refinements: [...from.refinements, ast]
          };
      }
    }
    case "Declaration": {
      if (schemaId === DateFromSelfSchemaId) {
        return {
          _tag: "DateFromSelf",
          constraints: [makeDateConstraints(meta)],
          path,
          refinements: [],
          annotations: []
        };
      }
      return {
        _tag: "Declaration",
        typeParameters: ast.typeParameters.map((ast2) => getDescription(ast2, path)),
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "Literal": {
      return {
        _tag: "Literal",
        literal: ast.literal,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "UniqueSymbol": {
      return {
        _tag: "UniqueSymbol",
        symbol: ast.symbol,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Enums": {
      return {
        _tag: "Enums",
        enums: ast.enums,
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "TemplateLiteral": {
      return {
        _tag: "TemplateLiteral",
        head: ast.head,
        spans: ast.spans.map((span3) => ({
          description: getDescription(span3.type, path),
          literal: span3.literal
        })),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "StringKeyword":
      return {
        _tag: "StringKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "NumberKeyword":
      return {
        _tag: "NumberKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "BigIntKeyword":
      return {
        _tag: "BigIntKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "TupleType":
      return {
        _tag: "TupleType",
        constraints: [],
        elements: ast.elements.map((element2, i) => ({
          isOptional: element2.isOptional,
          description: getDescription(element2.type, [...path, i])
        })),
        rest: ast.rest.map((element2, i) => getDescription(element2.type, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "TypeLiteral":
      return {
        _tag: "TypeLiteral",
        propertySignatures: ast.propertySignatures.map((ps) => ({
          isOptional: ps.isOptional,
          name: ps.name,
          value: getDescription(ps.type, [...path, ps.name])
        })),
        indexSignatures: ast.indexSignatures.map((is3) => ({
          parameter: getDescription(is3.parameter, path),
          value: getDescription(is3.type, path)
        })),
        path,
        refinements: [],
        annotations: []
      };
    case "Union":
      return {
        _tag: "Union",
        members: ast.types.map((member, i) => getDescription(member, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "Suspend": {
      const memoId = idMemoMap.get(ast);
      if (memoId !== void 0) {
        return {
          _tag: "Ref",
          id: memoId,
          ast,
          path,
          refinements: [],
          annotations: []
        };
      }
      counter++;
      const id2 = `__id-${counter}__`;
      idMemoMap.set(ast, id2);
      return {
        _tag: "Suspend",
        id: id2,
        ast,
        description: () => getDescription(ast.f(), path),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Transformation":
      return getDescription(ast.to, path);
    case "NeverKeyword":
      return {
        _tag: "NeverKeyword",
        path,
        refinements: [],
        annotations: [],
        ast
      };
    default: {
      return {
        _tag: "Keyword",
        value: ast._tag,
        path,
        refinements: [],
        annotations: []
      };
    }
  }
});
function getMax(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n2 : n1;
}
function getMin(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n1 : n2;
}
var getOr = (a, b2) => {
  return a === void 0 ? b2 : b2 === void 0 ? a : a || b2;
};
function mergePattern(pattern1, pattern2) {
  if (pattern1 === void 0) {
    return pattern2;
  }
  if (pattern2 === void 0) {
    return pattern1;
  }
  return `(?:${pattern1})|(?:${pattern2})`;
}
function mergeStringConstraints(c1, c2) {
  return makeStringConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength),
    pattern: mergePattern(c1.pattern, c2.pattern)
  });
}
function buildStringConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeStringConstraints);
}
function mergeNumberConstraints(c1, c2) {
  return makeNumberConstraints({
    isInteger: c1.isInteger || c2.isInteger,
    min: getMax(c1.constraints.min, c2.constraints.min),
    minExcluded: getOr(c1.constraints.minExcluded, c2.constraints.minExcluded),
    max: getMin(c1.constraints.max, c2.constraints.max),
    maxExcluded: getOr(c1.constraints.maxExcluded, c2.constraints.maxExcluded),
    noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),
    noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)
  });
}
function buildNumberConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeNumberConstraints);
}
function mergeBigIntConstraints(c1, c2) {
  return makeBigIntConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max)
  });
}
function buildBigIntConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeBigIntConstraints);
}
function mergeDateConstraints(c1, c2) {
  return makeDateConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max),
    noInvalidDate: getOr(c1.constraints.noInvalidDate, c2.constraints.noInvalidDate)
  });
}
function buildDateConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeDateConstraints);
}
var constArrayConstraints = makeArrayConstraints({});
function mergeArrayConstraints(c1, c2) {
  return makeArrayConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)
  });
}
function buildArrayConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeArrayConstraints);
}
var arbitraryMemoMap = globalValue(Symbol.for("effect/Arbitrary/arbitraryMemoMap"), () => /* @__PURE__ */ new WeakMap());
function applyFilters(filters, arb) {
  return (fc) => filters.reduce((arb2, filter18) => arb2.filter(filter18), arb(fc));
}
function absurd2(message) {
  return () => {
    throw new Error(message);
  };
}
function getContextConstraints(description) {
  switch (description._tag) {
    case "StringKeyword":
      return buildStringConstraints(description);
    case "NumberKeyword":
      return buildNumberConstraints(description);
    case "BigIntKeyword":
      return buildBigIntConstraints(description);
    case "DateFromSelf":
      return buildDateConstraints(description);
    case "TupleType":
      return buildArrayConstraints(description);
  }
}
function wrapGo(f2, g) {
  return (description, ctx) => f2(description, ctx, g(description, ctx));
}
var go = wrapGo((description, ctx, lazyArb) => {
  const annotation = description.annotations[description.annotations.length - 1];
  if (annotation === void 0) {
    switch (description._tag) {
      case "Declaration":
      case "NeverKeyword":
        throw new Error(getArbitraryMissingAnnotationErrorMessage(description.path, description.ast));
      case "Enums":
        if (description.enums.length === 0) {
          throw new Error(getArbitraryEmptyEnumErrorMessage(description.path));
        }
    }
  }
  const filters = description.refinements.map((ast) => (a) => isNone2(ast.filter(a, defaultParseOption, ast)));
  if (annotation === void 0) {
    return applyFilters(filters, lazyArb);
  }
  const constraints = getContextConstraints(description);
  if (constraints !== void 0) {
    ctx = {
      ...ctx,
      constraints
    };
  }
  if (description._tag === "Declaration") {
    return applyFilters(filters, annotation(...description.typeParameters.map((p) => go(p, ctx)), ctx));
  }
  if (description.refinements.length > 0) {
    return applyFilters(filters, annotation(lazyArb, ctx));
  }
  return annotation(ctx);
}, (description, ctx) => {
  switch (description._tag) {
    case "DateFromSelf": {
      const constraints = buildDateConstraints(description);
      return (fc) => fc.date(constraints?.constraints);
    }
    case "Declaration":
    case "NeverKeyword":
      return absurd2(`BUG: cannot generate an arbitrary for ${description._tag}`);
    case "Literal":
      return (fc) => fc.constant(description.literal);
    case "UniqueSymbol":
      return (fc) => fc.constant(description.symbol);
    case "Keyword": {
      switch (description.value) {
        case "UndefinedKeyword":
          return (fc) => fc.constant(void 0);
        case "VoidKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
          return (fc) => fc.anything();
        case "BooleanKeyword":
          return (fc) => fc.boolean();
        case "SymbolKeyword":
          return (fc) => fc.string().map((s) => Symbol.for(s));
        case "ObjectKeyword":
          return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()));
      }
    }
    case "Enums":
      return (fc) => fc.oneof(...description.enums.map(([_2, value6]) => fc.constant(value6)));
    case "TemplateLiteral": {
      return (fc) => {
        const string7 = fc.string({
          maxLength: 5
        });
        const number5 = fc.float({
          noDefaultInfinity: true,
          noNaN: true
        });
        const getTemplateLiteralArb = (description2) => {
          const components = description2.head !== "" ? [fc.constant(description2.head)] : [];
          const getTemplateLiteralSpanTypeArb = (description3) => {
            switch (description3._tag) {
              case "StringKeyword":
                return string7;
              case "NumberKeyword":
                return number5;
              case "Literal":
                return fc.constant(String(description3.literal));
              case "Union":
                return fc.oneof(...description3.members.map(getTemplateLiteralSpanTypeArb));
              case "TemplateLiteral":
                return getTemplateLiteralArb(description3);
              default:
                return fc.constant("");
            }
          };
          description2.spans.forEach((span3) => {
            components.push(getTemplateLiteralSpanTypeArb(span3.description));
            if (span3.literal !== "") {
              components.push(fc.constant(span3.literal));
            }
          });
          return fc.tuple(...components).map((spans) => spans.join(""));
        };
        return getTemplateLiteralArb(description);
      };
    }
    case "StringKeyword": {
      const constraints = buildStringConstraints(description);
      const pattern2 = constraints?.pattern;
      return pattern2 !== void 0 ? (fc) => fc.stringMatching(new RegExp(pattern2)) : (fc) => fc.string(constraints?.constraints);
    }
    case "NumberKeyword": {
      const constraints = buildNumberConstraints(description);
      return constraints?.isInteger ? (fc) => fc.integer(constraints.constraints) : (fc) => fc.float(constraints?.constraints);
    }
    case "BigIntKeyword": {
      const constraints = buildBigIntConstraints(description);
      return (fc) => fc.bigInt(constraints?.constraints ?? {});
    }
    case "TupleType": {
      const elements = [];
      let hasOptionals = false;
      for (const element2 of description.elements) {
        elements.push(go(element2.description, ctx));
        if (element2.isOptional) {
          hasOptionals = true;
        }
      }
      const rest = description.rest.map((d) => go(d, ctx));
      return (fc) => {
        let output = fc.tuple(...elements.map((arb) => arb(fc)));
        if (hasOptionals) {
          const indexes = fc.tuple(...description.elements.map((element2) => element2.isOptional ? fc.boolean() : fc.constant(true)));
          output = output.chain((tuple4) => indexes.map((booleans) => {
            for (const [i, b2] of booleans.reverse().entries()) {
              if (!b2) {
                tuple4.splice(booleans.length - i, 1);
              }
            }
            return tuple4;
          }));
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const constraints = buildArrayConstraints(description) ?? constArrayConstraints;
          const [head8, ...tail] = rest;
          const item = head8(fc);
          output = output.chain((as12) => {
            const len = as12.length;
            const restArrayConstraints = subtractElementsLength(constraints.constraints, len);
            if (restArrayConstraints.maxLength === 0) {
              return fc.constant(as12);
            }
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, restArrayConstraints) : fc.array(item, restArrayConstraints);
            if (len === 0) {
              return arr;
            }
            return arr.map((rest2) => [...as12, ...rest2]);
          });
          for (let j2 = 0; j2 < tail.length; j2++) {
            output = output.chain((as12) => tail[j2](fc).map((a) => [...as12, a]));
          }
        }
        return output;
      };
    }
    case "TypeLiteral": {
      const propertySignatures = [];
      const requiredKeys = [];
      for (const ps of description.propertySignatures) {
        if (!ps.isOptional) {
          requiredKeys.push(ps.name);
        }
        propertySignatures.push(go(ps.value, ctx));
      }
      const indexSignatures = description.indexSignatures.map((is3) => [go(is3.parameter, ctx), go(is3.value, ctx)]);
      return (fc) => {
        const pps = {};
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = description.propertySignatures[i];
          pps[ps.name] = propertySignatures[i](fc);
        }
        let output = fc.record(pps, {
          requiredKeys
        });
        for (let i = 0; i < indexSignatures.length; i++) {
          const key = indexSignatures[i][0](fc);
          const value6 = indexSignatures[i][1](fc);
          output = output.chain((o) => {
            const item = fc.tuple(key, value6);
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, {
              maxLength: 2
            }) : fc.array(item);
            return arr.map((tuples) => ({
              ...Object.fromEntries(tuples),
              ...o
            }));
          });
        }
        return output;
      };
    }
    case "Union": {
      const members = description.members.map((member) => go(member, ctx));
      return (fc) => fc.oneof(...members.map((arb) => arb(fc)));
    }
    case "Suspend": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      if (ctx.depthIdentifier === void 0) {
        ctx = {
          ...ctx,
          depthIdentifier: description.id
        };
      }
      const get34 = memoizeThunk(() => {
        return go(description.description(), ctx);
      });
      const out = (fc) => fc.constant(null).chain(() => get34()(fc));
      arbitraryMemoMap.set(description.ast, out);
      return out;
    }
    case "Ref": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      throw new Error(`BUG: Ref ${JSON.stringify(description.id)} not found`);
    }
  }
});
function subtractElementsLength(constraints, len) {
  if (len === 0 || constraints.minLength === void 0 && constraints.maxLength === void 0) {
    return constraints;
  }
  const out = {
    ...constraints
  };
  if (out.minLength !== void 0) {
    out.minLength = Math.max(out.minLength - len, 0);
  }
  if (out.maxLength !== void 0) {
    out.maxLength = Math.max(out.maxLength - len, 0);
  }
  return out;
}
var getSuspendedArray = (fc, depthIdentifier, maxDepth, item, constraints) => {
  const maxLengthLimit = Math.max(2, constraints.minLength ?? 0);
  if (constraints.maxLength !== void 0 && constraints.maxLength > maxLengthLimit) {
    constraints = {
      ...constraints,
      maxLength: maxLengthLimit
    };
  }
  return fc.oneof({
    maxDepth,
    depthIdentifier
  }, fc.constant([]), fc.array(item, constraints));
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/BigDecimal.js
var DEFAULT_PRECISION = 100;
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId4 = Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId4]: TypeId4,
  [symbol2]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine2(number2(normalized.scale)), cached(this));
  },
  [symbol3](that) {
    return isBigDecimal(that) && equals3(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId4);
var make4 = (value6, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value6;
  o.scale = scale2;
  return o;
};
var unsafeMakeNormalized = (value6, scale2) => {
  if (value6 !== bigint0 && value6 % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make4(value6, scale2);
  o.normalized = o;
  return o;
};
var bigint0 = BigInt(0);
var bigint1 = BigInt(1);
var bigint10 = BigInt(10);
var zero = unsafeMakeNormalized(bigint0, 0);
var normalize = (self) => {
  if (self.normalized === void 0) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value6 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value6, scale2);
    }
  }
  return self.normalized;
};
var scale = dual(2, (self, scale2) => {
  if (scale2 > self.scale) {
    return make4(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make4(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
});
var sum2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return that;
  }
  if (self.scale > that.scale) {
    return make4(scale(that, self.scale).value + self.value, self.scale);
  }
  if (self.scale < that.scale) {
    return make4(scale(self, that.scale).value + that.value, that.scale);
  }
  return make4(self.value + that.value, self.scale);
});
var multiply2 = dual(2, (self, that) => {
  if (that.value === bigint0 || self.value === bigint0) {
    return zero;
  }
  return make4(self.value * that.value, self.scale + that.scale);
});
var subtract2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return make4(-that.value, that.scale);
  }
  if (self.scale > that.scale) {
    return make4(self.value - scale(that, self.scale).value, self.scale);
  }
  if (self.scale < that.scale) {
    return make4(scale(self, that.scale).value - that.value, that.scale);
  }
  return make4(self.value - that.value, self.scale);
});
var divideWithPrecision = (num, den, scale2, precision) => {
  const numNegative = num < bigint0;
  const denNegative = den < bigint0;
  const negateResult = numNegative !== denNegative;
  num = numNegative ? -num : num;
  den = denNegative ? -den : den;
  while (num < den) {
    num *= bigint10;
    scale2++;
  }
  let quotient = num / den;
  let remainder3 = num % den;
  if (remainder3 === bigint0) {
    return make4(negateResult ? -quotient : quotient, scale2);
  }
  let count5 = `${quotient}`.length;
  remainder3 *= bigint10;
  while (remainder3 !== bigint0 && count5 < precision) {
    const q2 = remainder3 / den;
    const r = remainder3 % den;
    quotient = quotient * bigint10 + q2;
    remainder3 = r * bigint10;
    count5++;
    scale2++;
  }
  if (remainder3 !== bigint0) {
    quotient += roundTerminal(remainder3 / den);
  }
  return make4(negateResult ? -quotient : quotient, scale2);
};
var roundTerminal = (n) => {
  const pos = n >= bigint0 ? 0 : 1;
  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
var divide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return none2();
  }
  if (self.value === bigint0) {
    return some2(zero);
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return some2(make4(bigint1, scale2));
  }
  return some2(divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION));
});
var unsafeDivide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  if (self.value === bigint0) {
    return zero;
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return make4(bigint1, scale2);
  }
  return divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION);
});
var Order2 = make2((self, that) => {
  const scmp = number3(sign(self), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return bigint2(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return bigint2(scale(self, that.scale).value, that.value);
  }
  return bigint2(self.value, that.value);
});
var lessThan3 = lessThan(Order2);
var lessThanOrEqualTo3 = lessThanOrEqualTo(Order2);
var greaterThan3 = greaterThan(Order2);
var greaterThanOrEqualTo3 = greaterThanOrEqualTo(Order2);
var between3 = between(Order2);
var clamp4 = clamp(Order2);
var min4 = min(Order2);
var max4 = max(Order2);
var sign = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make4(-n.value, n.scale) : n;
var remainder2 = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    return none2();
  }
  const max11 = Math.max(self.scale, divisor.scale);
  return some2(make4(scale(self, max11).value % scale(divisor, max11).value, max11));
});
var unsafeRemainder = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  const max11 = Math.max(self.scale, divisor.scale);
  return make4(scale(self, max11).value % scale(divisor, max11).value, max11);
});
var Equivalence = make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals3 = dual(2, (self, that) => Equivalence(self, that));
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string7 = `${n}`;
  if (string7.includes("e")) {
    return fromString(string7);
  }
  const [lead, trail = ""] = string7.split(".");
  return some2(make4(BigInt(`${lead}${trail}`), trail.length));
};
var fromString = (s) => {
  if (s === "") {
    return some2(zero);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some2(make4(BigInt(digits), scale2));
};
var format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative2 = normalized.value < bigint0;
  const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before2 = absolute.slice(0, location);
    }
  }
  const complete4 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative2 ? `-${complete4}` : complete4;
};
var toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head8 = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head8}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format2(n));
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;
var isBigDecimalArgs = (args2) => isBigDecimal(args2[0]);
var ceil = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isPositive(self) && lessThan3(truncated, self)) {
    return sum2(truncated, make4(1n, scale2));
  }
  return truncated;
});
var floor = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isNegative(self) && greaterThan3(truncated, self)) {
    return sum2(truncated, make4(-1n, scale2));
  }
  return truncated;
});
var truncate = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  if (self.scale <= scale2) {
    return self;
  }
  return make4(self.value / 10n ** BigInt(self.scale - scale2), scale2);
});
var digitAt = dual(2, (self, scale2) => {
  if (self.scale < scale2) {
    return 0n;
  }
  const scaled = self.value / 10n ** BigInt(self.scale - scale2);
  return scaled % 10n;
});
var round2 = dual(isBigDecimalArgs, (self, options) => {
  const mode = options?.mode ?? "half-from-zero";
  const scale2 = options?.scale ?? 0;
  switch (mode) {
    case "ceil":
      return ceil(self, scale2);
    case "floor":
      return floor(self, scale2);
    case "to-zero":
      return truncate(self, scale2);
    case "from-zero":
      return isPositive(self) ? ceil(self, scale2) : floor(self, scale2);
    case "half-ceil":
      return floor(sum2(self, make4(5n, scale2 + 1)), scale2);
    case "half-floor":
      return ceil(sum2(self, make4(-5n, scale2 + 1)), scale2);
    case "half-to-zero":
      return isNegative(self) ? floor(sum2(self, make4(5n, scale2 + 1)), scale2) : ceil(sum2(self, make4(-5n, scale2 + 1)), scale2);
    case "half-from-zero":
      return isNegative(self) ? ceil(sum2(self, make4(-5n, scale2 + 1)), scale2) : floor(sum2(self, make4(5n, scale2 + 1)), scale2);
  }
  const halfCeil = floor(sum2(self, make4(5n, scale2 + 1)), scale2);
  const halfFloor = ceil(sum2(self, make4(-5n, scale2 + 1)), scale2);
  const digit = digitAt(halfCeil, scale2);
  switch (mode) {
    case "half-even":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfCeil : halfFloor;
    case "half-odd":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfFloor : halfCeil;
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/BigInt.js
var bigint02 = BigInt(0);
var bigint12 = BigInt(1);
var bigint22 = BigInt(2);
var sum3 = dual(2, (self, that) => self + that);
var multiply3 = dual(2, (self, that) => self * that);
var subtract3 = dual(2, (self, that) => self - that);
var divide3 = dual(2, (self, that) => that === bigint02 ? none2() : some2(self / that));
var unsafeDivide3 = dual(2, (self, that) => self / that);
var Order3 = bigint2;
var lessThan4 = lessThan(Order3);
var lessThanOrEqualTo4 = lessThanOrEqualTo(Order3);
var greaterThan4 = greaterThan(Order3);
var greaterThanOrEqualTo4 = greaterThanOrEqualTo(Order3);
var between4 = between(Order3);
var clamp5 = clamp(Order3);
var min5 = min(Order3);
var max5 = max(Order3);
var gcd = dual(2, (self, that) => {
  while (that !== bigint02) {
    const t = that;
    that = self % that;
    self = t;
  }
  return self;
});
var lcm = dual(2, (self, that) => self * that / gcd(self, that));
var toNumber = (b2) => {
  if (b2 > BigInt(Number.MAX_SAFE_INTEGER) || b2 < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some2(Number(b2));
};
var fromString2 = (s) => {
  try {
    return s.trim() === "" ? none2() : some2(BigInt(s));
  } catch {
    return none2();
  }
};
var fromNumber = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some2(BigInt(n));
  } catch {
    return none2();
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Boolean.js
var match4 = dual(2, (value6, options) => value6 ? options.onTrue() : options.onFalse());
var not = (self) => !self;
var and2 = dual(2, (self, that) => self && that);
var nand2 = dual(2, (self, that) => !(self && that));
var or2 = dual(2, (self, that) => self || that);
var nor2 = dual(2, (self, that) => !(self || that));
var xor2 = dual(2, (self, that) => !self && that || self && !that);
var eqv2 = dual(2, (self, that) => !xor2(self, that));
var implies2 = dual(2, (self, that) => self ? that : true);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Brand.js
var BrandTypeId = Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = Symbol.for("effect/Brand/Refined");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = Symbol.for("effect/Context/Tag");
var ReferenceTypeId = Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_2) => _2,
    _Identifier: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make5(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag3 = Object.create(TagProto);
  Object.defineProperty(tag3, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag3.key = key;
  return tag3;
};
var Tag = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id2, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id2;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId5 = Symbol.for("effect/Context");
var ContextProto = {
  [TypeId5]: {
    _Services: (_2) => _2
  },
  [symbol3](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k2 of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k2) || !equals(this.unsafeMap.get(k2), that.unsafeMap.get(k2))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol2]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context10 = Object.create(ContextProto);
  context10.unsafeMap = unsafeMap;
  return context10;
};
var serviceNotFoundError = (tag3) => {
  const error2 = new Error(`Service not found${tag3.key ? `: ${String(tag3.key)}` : ""}`);
  if (tag3.stack) {
    const lines = tag3.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error2.message = error2.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error2.stack) {
    const lines = error2.stack.split("\n");
    lines.splice(1, 3);
    error2.stack = lines.join("\n");
  }
  return error2;
};
var isContext = (u) => hasProperty(u, TypeId5);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = makeContext(/* @__PURE__ */ new Map());
var empty4 = () => _empty;
var make5 = (tag3, service3) => makeContext(/* @__PURE__ */ new Map([[tag3.key, service3]]));
var add = dual(3, (self, tag3, service3) => {
  const map40 = new Map(self.unsafeMap);
  map40.set(tag3.key, service3);
  return makeContext(map40);
});
var defaultValueCache = globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag3) => {
  if (defaultValueCache.has(tag3.key)) {
    return defaultValueCache.get(tag3.key);
  }
  const value6 = tag3.defaultValue();
  defaultValueCache.set(tag3.key, value6);
  return value6;
};
var unsafeGetReference = (self, tag3) => {
  return self.unsafeMap.has(tag3.key) ? self.unsafeMap.get(tag3.key) : getDefaultValue(tag3);
};
var unsafeGet2 = dual(2, (self, tag3) => {
  if (!self.unsafeMap.has(tag3.key)) {
    if (ReferenceTypeId in tag3) return getDefaultValue(tag3);
    throw serviceNotFoundError(tag3);
  }
  return self.unsafeMap.get(tag3.key);
});
var get3 = unsafeGet2;
var getOrElse3 = dual(3, (self, tag3, orElse15) => {
  if (!self.unsafeMap.has(tag3.key)) {
    return isReference(tag3) ? getDefaultValue(tag3) : orElse15();
  }
  return self.unsafeMap.get(tag3.key);
});
var getOption = dual(2, (self, tag3) => {
  if (!self.unsafeMap.has(tag3.key)) {
    return isReference(tag3) ? some(getDefaultValue(tag3)) : none;
  }
  return some(self.unsafeMap.get(tag3.key));
});
var merge2 = dual(2, (self, that) => {
  const map40 = new Map(self.unsafeMap);
  for (const [tag3, s] of that.unsafeMap) {
    map40.set(tag3, s);
  }
  return makeContext(map40);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var empty5 = empty4;
var make6 = make5;
var add2 = add;
var get4 = get3;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Chunk.js
var TypeId6 = Symbol.for("effect/Chunk");
function copy3(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence4 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value6, i) => isEquivalent(value6, unsafeGet4(that, i))));
var _equivalence4 = getEquivalence4(equals);
var ChunkProto = {
  [TypeId6]: {
    _A: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isChunk(that) && _equivalence4(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
  }
  return chunk4;
};
var isChunk = (u) => hasProperty(u, TypeId6);
var _empty2 = makeChunk({
  _tag: "IEmpty"
});
var empty6 = () => _empty2;
var make7 = (...as12) => unsafeFromNonEmptyArray(as12);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array7, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy3(self.backing.array, 0, array7, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array7, initial);
      copyToArray(self.right, array7, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array7[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j2 = initial;
      while (i < self.length) {
        array7[j2] = unsafeGet4(self, i);
        i += 1;
        j2 += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var reverse2 = reverseChunk;
var get5 = dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty6() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append3 = dual(2, (self, a) => appendAll3(self, of2(a)));
var prepend3 = dual(2, (self, elem) => appendAll3(of2(elem), self));
var take3 = dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take3(self.right, n - self.left.length)
          });
        }
        return take3(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop3 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop3(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop3(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var dropRight2 = dual(2, (self, n) => take3(self, Math.max(0, self.length - n)));
var dropWhile2 = dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop3(self, i);
});
var prependAll3 = dual(2, (self, that) => appendAll3(that, self));
var appendAll3 = dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff12 = that.depth - self.depth;
  if (Math.abs(diff12) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff12 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll3(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll3(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll3(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll3(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap5 = dual(2, (self, f2) => unsafeFromArray(filterMap4(self, f2)));
var filter5 = dual(2, (self, predicate) => unsafeFromArray(filter4(self, predicate)));
var filterMapWhile3 = dual(2, (self, f2) => unsafeFromArray(filterMapWhile2(self, f2)));
var flatMap5 = dual(2, (self, f2) => {
  if (self.backing._tag === "ISingleton") {
    return f2(self.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k2 of self) {
    out = appendAll3(out, f2(k2, i++));
  }
  return out;
});
var forEach3 = dual(2, (self, f2) => toReadonlyArray(self).forEach(f2));
var flatten5 = flatMap5(identity);
var chunksOf3 = dual(2, (self, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection4 = dual(2, (self, that) => unsafeFromArray(intersection2(toReadonlyArray(self), toReadonlyArray(that))));
var isEmpty = (self) => self.length === 0;
var isNonEmpty2 = (self) => self.length > 0;
var head2 = get5(0);
var unsafeHead2 = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead2;
var last2 = (self) => get5(self, self.length - 1);
var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
var map7 = dual(2, (self, f2) => self.backing._tag === "ISingleton" ? of2(f2(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map6((a, i) => f2(a, i)))));
var mapAccum2 = dual(3, (self, s, f2) => {
  const [s1, as12] = mapAccum(self, s, f2);
  return [s1, unsafeFromArray(as12)];
});
var partition3 = dual(2, (self, predicate) => pipe(partition2(toReadonlyArray(self), predicate), ([l2, r]) => [unsafeFromArray(l2), unsafeFromArray(r)]));
var partitionMap4 = dual(2, (self, f2) => pipe(partitionMap3(toReadonlyArray(self), f2), ([l2, r]) => [unsafeFromArray(l2), unsafeFromArray(r)]));
var sort2 = dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
var sortWith2 = dual(3, (self, f2, order) => sort2(self, mapInput3(order, f2)));
var splitAt2 = dual(2, (self, n) => [take3(self, n), drop3(self, n)]);
var splitNonEmptyAt2 = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty6()] : [take3(self, _n), drop3(self, _n)];
});
var split2 = dual(2, (self, n) => chunksOf3(self, Math.ceil(self.length / Math.floor(n))));
var splitWhere2 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self, i);
});
var tailNonEmpty2 = (self) => drop3(self, 1);
var takeRight2 = dual(2, (self, n) => drop3(self, self.length - n));
var takeWhile3 = dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union3 = dual(2, (self, that) => unsafeFromArray(union2(toReadonlyArray(self), toReadonlyArray(that))));
var zipWith5 = dual(3, (self, that, f2) => unsafeFromArray(zipWith4(self, that, f2)));
var zip3 = dual(2, (self, that) => zipWith5(self, that, (a, b2) => [a, b2]));
var remove3 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return self;
  return unsafeFromArray(remove2(toReadonlyArray(self), i));
});
var removeOption2 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return none2();
  return some2(unsafeFromArray(remove2(toReadonlyArray(self), i)));
});
var modifyOption3 = dual(3, (self, i, f2) => {
  if (i < 0 || i >= self.length) return none2();
  return some2(unsafeFromArray(modify2(toReadonlyArray(self), i, f2)));
});
var modify3 = dual(3, (self, i, f2) => getOrElse2(modifyOption3(self, i, f2), () => self));
var replace3 = dual(3, (self, i, b2) => modify3(self, i, () => b2));
var replaceOption3 = dual(3, (self, i, b2) => modifyOption3(self, i, () => b2));
var makeBy3 = dual(2, (n, f2) => fromIterable2(makeBy2(n, f2)));
var range = (start5, end6) => start5 <= end6 ? makeBy3(end6 - start5 + 1, (i) => start5 + i) : of2(start5);
var findFirst4 = findFirst3;
var every3 = dual(2, (self, refinement) => fromIterable(self).every(refinement));
var some6 = dual(2, (self, predicate) => fromIterable(self).some(predicate));
var reduce4 = reduce3;
var reduceRight2 = reduceRight;
var difference3 = dual(2, (self, that) => unsafeFromArray(difference2(that, self)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Duration.js
var TypeId7 = Symbol.for("effect/Duration");
var bigint03 = BigInt(0);
var bigint24 = BigInt(24);
var bigint60 = BigInt(60);
var bigint1e3 = BigInt(1e3);
var bigint1e6 = BigInt(1e6);
var bigint1e9 = BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match28 = DURATION_REGEX.exec(input);
    if (match28) {
      const [_2, valueStr, unit] = match28;
      const value6 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value6);
        case "second":
        case "seconds":
          return seconds(value6);
        case "minute":
        case "minutes":
          return minutes(value6);
        case "hour":
        case "hours":
          return hours(value6);
        case "day":
        case "days":
          return days(value6);
        case "week":
        case "weeks":
          return weeks(value6);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId7]: TypeId7,
  [symbol2]() {
    return cached(this, structure(this.value));
  },
  [symbol3](that) {
    return isDuration(that) && equals4(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make8 = (input) => {
  const duration3 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration3.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration3.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration3.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration3.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint03) {
    duration3.value = zeroValue;
  } else {
    duration3.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration3;
};
var isDuration = (u) => hasProperty(u, TypeId7);
var isFinite = (self) => self.value._tag !== "Infinity";
var isZero2 = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint03;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero2 = make8(0);
var infinity = make8(Infinity);
var nanos = (nanos2) => make8(nanos2);
var micros = (micros2) => make8(micros2 * bigint1e3);
var millis = (millis2) => make8(millis2);
var seconds = (seconds2) => make8(seconds2 * 1e3);
var minutes = (minutes2) => make8(minutes2 * 6e4);
var hours = (hours2) => make8(hours2 * 36e5);
var days = (days2) => make8(days2 * 864e5);
var weeks = (weeks2) => make8(weeks2 * 6048e5);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order4 = make2((self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0,
  onNanos: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0
}));
var between5 = between(mapInput3(Order4, decode));
var Equivalence2 = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var _min = min(Order4);
var min6 = dual(2, (self, that) => _min(decode(self), decode(that)));
var _max = max(Order4);
var max6 = dual(2, (self, that) => _max(decode(self), decode(that)));
var _clamp = clamp(Order4);
var clamp6 = dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some2(make8(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some2(make8(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => make8(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero2;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make8(nanos2 / BigInt(by));
  }
}));
var times = dual(2, (self, times2) => match5(self, {
  onMillis: (millis2) => make8(millis2 * times2),
  onNanos: (nanos2) => make8(nanos2 * BigInt(times2))
}));
var subtract4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make8(self2 - that2),
  onNanos: (self2, that2) => make8(self2 - that2)
}));
var sum4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make8(self2 + that2),
  onNanos: (self2, that2) => make8(self2 + that2)
}));
var lessThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2,
  onNanos: (self2, that2) => self2 < that2
}));
var lessThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 > that2,
  onNanos: (self2, that2) => self2 > that2
}));
var greaterThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals4 = dual(2, (self, that) => Equivalence2(decode(self), decode(that)));
var parts = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration3);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min9 = sec / bigint60;
  const hr = min9 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min9 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format3 = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration3)) {
    return "0";
  }
  const fragments = parts(duration3);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = Math.pow(2, SIZE);
var MASK2 = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h2) {
  return h2 >>> shift2 & MASK2;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stack.js
var make9 = (value6, previous2) => ({
  value: value6,
  previous: previous2
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate5, at5, v2, arr) {
  let out = arr;
  if (!mutate5) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at5] = v2;
  return out;
}
function arraySpliceOut(mutate5, at5, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate5) {
    i = g = at5;
  } else {
    out = new Array(newLen);
    while (i < at5) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate5) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate5, at5, v2, arr) {
  const len = arr.length;
  if (mutate5) {
    let i2 = len;
    while (i2 >= at5) arr[i2--] = arr[i2];
    arr[at5] = v2;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at5) out[g++] = arr[i++];
  out[at5] = v2;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f2, hash4, key, size23) {
    const v2 = f2(none2());
    if (isNone2(v2)) return new _EmptyNode();
    ++size23.value;
    return new LeafNode(edit, hash4, key, v2);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash4, key, value6) {
    this.edit = edit;
    this.hash = hash4;
    this.key = key;
    this.value = value6;
  }
  modify(edit, shift2, f2, hash4, key, size23) {
    if (equals(key, this.key)) {
      const v3 = f2(this.value);
      if (v3 === this.value) return this;
      else if (isNone2(v3)) {
        --size23.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v3;
        return this;
      }
      return new _LeafNode(edit, hash4, key, v3);
    }
    const v2 = f2(none2());
    if (isNone2(v2)) return this;
    ++size23.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new _LeafNode(edit, hash4, key, v2));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash4, children2) {
    this.edit = edit;
    this.hash = hash4;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash4, key, size23) {
    if (hash4 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f2, key, size23);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v2 = f2(none2());
    if (isNone2(v2)) return this;
    ++size23.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new LeafNode(edit, hash4, key, v2));
  }
  updateCollisionList(mutate5, edit, hash4, list, f2, key, size23) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value6 = child.value;
        const newValue2 = f2(value6);
        if (newValue2 === value6) return list;
        if (isNone2(newValue2)) {
          --size23.value;
          return arraySpliceOut(mutate5, i, list);
        }
        return arrayUpdate(mutate5, i, new LeafNode(edit, hash4, key, newValue2), list);
      }
    }
    const newValue = f2(none2());
    if (isNone2(newValue)) return list;
    ++size23.value;
    return arrayUpdate(mutate5, len, new LeafNode(edit, hash4, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children2) {
    this.edit = edit;
    this.mask = mask;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash4, key, size23) {
    const mask = this.mask;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash4);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists4 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists4) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f2, hash4, key, size23);
      if (!_newChild) return this;
      return children2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children2) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children2));
    }
    const current2 = children2[indx];
    const child = current2.modify(edit, shift2 + SIZE, f2, hash4, key, size23);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children2.length <= 2 && isLeafNode(children2[indx ^ 1])) {
        return children2[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children2);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children2);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size23, children2) {
    this.edit = edit;
    this.size = size23;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash4, key, size23) {
    let count5 = this.size;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash4);
    const child = children2[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f2, hash4, key, size23);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count5;
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count5;
      if (count5 <= MIN_ARRAY_NODE) {
        return pack(edit, count5, frag, children2);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children2);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    }
    if (canEdit) {
      this.size = count5;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count5, newChildren);
  }
};
function pack(edit, count5, removed, elements) {
  const children2 = new Array(count5 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children2[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children2);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count5 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count5++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count5 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children2);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k2, v2) => [k2, v2]);
  },
  [symbol2]() {
    let hash4 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size23) => {
  const map40 = Object.create(HashMapProto);
  map40._editable = editable;
  map40._edit = edit;
  map40._root = root;
  map40._size = size23;
  return map40;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map40, f2) {
    this.map = map40;
    this.f = f2;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f2, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f2(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children2 = node.children;
      return visitLazyChildren(children2.length, children2, 0, f2, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children2, i, f2, cont) => {
  while (i < len) {
    const child = children2[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f2, [len, children2, i, f2, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = makeImpl(false, 0, new EmptyNode(), 0);
var empty7 = () => _empty3;
var make10 = (...entries3) => fromIterable3(entries3);
var fromIterable3 = (entries3) => {
  const map40 = beginMutation(empty7());
  for (const entry of entries3) {
    set2(map40, entry[0], entry[1]);
  }
  return endMutation(map40);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get6 = dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = dual(3, (self, key, hash4) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash4 === node.hash) {
          const children2 = node.children;
          for (let i = 0, len = children2.length; i < len; ++i) {
            const child = children2[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash4);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash4)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet5 = dual(2, (self, key) => {
  const element2 = getHash(self, key, hash(key));
  if (isNone2(element2)) {
    throw new Error("Expected map to contain key");
  }
  return element2.value;
});
var has2 = dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var hasHash = dual(3, (self, key, hash4) => isSome2(getHash(self, key, hash4)));
var hasBy = dual(2, (self, predicate) => isSome2(findFirst5(self, predicate)));
var set2 = dual(3, (self, key, value6) => modifyAt(self, key, () => some2(value6)));
var setTree = dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var countBy3 = dual(2, (self, f2) => {
  let count5 = 0;
  for (const [k2, a] of self) {
    if (f2(a, k2)) {
      count5++;
    }
  }
  return count5;
});
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var mutate = dual(2, (self, f2) => {
  const transient = beginMutation(self);
  f2(transient);
  return endMutation(transient);
});
var modifyAt = dual(3, (self, key, f2) => modifyHash(self, key, hash(key), f2));
var modifyHash = dual(4, (self, key, hash4, f2) => {
  const size23 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f2, hash4, key, size23);
  return pipe(self, setTree(newRoot, size23.value));
});
var modify4 = dual(3, (self, key, f2) => modifyAt(self, key, map2(f2)));
var union4 = dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach4(that, (v2, k2) => set2(result, k2, v2));
  return endMutation(result);
});
var remove4 = dual(2, (self, key) => modifyAt(self, key, none2));
var removeMany = dual(2, (self, keys10) => mutate(self, (map40) => {
  for (const key of keys10) {
    remove4(key)(map40);
  }
}));
var map8 = dual(2, (self, f2) => reduce5(self, empty7(), (map40, value6, key) => set2(map40, key, f2(value6, key))));
var flatMap6 = dual(2, (self, f2) => reduce5(self, empty7(), (zero3, value6, key) => mutate(zero3, (map40) => forEach4(f2(value6, key), (value7, key2) => set2(map40, key2, value7)))));
var forEach4 = dual(2, (self, f2) => reduce5(self, void 0, (_2, value6, key) => f2(value6, key)));
var reduce5 = dual(3, (self, zero3, f2) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f2(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children2;
  while (children2 = toVisit.pop()) {
    for (let i = 0, len = children2.length; i < len; ) {
      const child = children2[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f2(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter6 = dual(2, (self, f2) => mutate(empty7(), (map40) => {
  for (const [k2, a] of self) {
    if (f2(a, k2)) {
      set2(map40, k2, a);
    }
  }
}));
var filterMap6 = dual(2, (self, f2) => mutate(empty7(), (map40) => {
  for (const [k2, a] of self) {
    const option6 = f2(a, k2);
    if (isSome2(option6)) {
      set2(map40, k2, option6.value);
    }
  }
}));
var findFirst5 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return some2(ka);
    }
  }
  return none2();
});
var some7 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every4 = dual(2, (self, predicate) => !some7(self, (a, k2) => !predicate(a, k2)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol3](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set19 = Object.create(HashSetProto);
  set19._keyMap = keyMap;
  return set19;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = makeImpl2(empty7());
var empty8 = () => _empty4;
var fromIterable4 = (elements) => {
  const set19 = beginMutation2(empty8());
  for (const value6 of elements) {
    add3(set19, value6);
  }
  return endMutation2(set19);
};
var make11 = (...elements) => {
  const set19 = beginMutation2(empty8());
  for (const value6 of elements) {
    add3(set19, value6);
  }
  return endMutation2(set19);
};
var has3 = dual(2, (self, value6) => has2(self._keyMap, value6));
var some8 = dual(2, (self, f2) => {
  let found = false;
  for (const value6 of self) {
    found = f2(value6);
    if (found) {
      break;
    }
  }
  return found;
});
var every5 = dual(2, (self, refinement) => !some8(self, (a) => !refinement(a)));
var isSubset = dual(2, (self, that) => every5(self, (value6) => has3(that, value6)));
var values = (self) => keys2(self._keyMap);
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate2 = dual(2, (self, f2) => {
  const transient = beginMutation2(self);
  f2(transient);
  return endMutation2(transient);
});
var add3 = dual(2, (self, value6) => self._keyMap._editable ? (set2(value6, true)(self._keyMap), self) : makeImpl2(set2(value6, true)(self._keyMap)));
var remove5 = dual(2, (self, value6) => self._keyMap._editable ? (remove4(value6)(self._keyMap), self) : makeImpl2(remove4(value6)(self._keyMap)));
var difference4 = dual(2, (self, that) => mutate2(self, (set19) => {
  for (const value6 of that) {
    remove5(set19, value6);
  }
}));
var intersection5 = dual(2, (self, that) => mutate2(empty8(), (set19) => {
  for (const value6 of that) {
    if (has3(value6)(self)) {
      add3(value6)(set19);
    }
  }
}));
var union5 = dual(2, (self, that) => mutate2(empty8(), (set19) => {
  forEach5(self, (value6) => add3(set19, value6));
  for (const value6 of that) {
    add3(set19, value6);
  }
}));
var toggle = dual(2, (self, value6) => has3(self, value6) ? remove5(self, value6) : add3(self, value6));
var map9 = dual(2, (self, f2) => mutate2(empty8(), (set19) => {
  forEach5(self, (a) => {
    const b2 = f2(a);
    if (!has3(set19, b2)) {
      add3(set19, b2);
    }
  });
}));
var flatMap7 = dual(2, (self, f2) => mutate2(empty8(), (set19) => {
  forEach5(self, (a) => {
    for (const b2 of f2(a)) {
      if (!has3(set19, b2)) {
        add3(set19, b2);
      }
    }
  });
}));
var forEach5 = dual(2, (self, f2) => forEach4(self._keyMap, (_2, k2) => f2(k2)));
var reduce6 = dual(3, (self, zero3, f2) => reduce5(self._keyMap, zero3, (z2, _2, a) => f2(z2, a)));
var filter7 = dual(2, (self, f2) => {
  return mutate2(empty8(), (set19) => {
    const iterator = values(self);
    let next5;
    while (!(next5 = iterator.next()).done) {
      const value6 = next5.value;
      if (f2(value6)) {
        add3(set19, value6);
      }
    }
  });
});
var partition4 = dual(2, (self, predicate) => {
  const iterator = values(self);
  let next5;
  const right3 = beginMutation2(empty8());
  const left3 = beginMutation2(empty8());
  while (!(next5 = iterator.next()).done) {
    const value6 = next5.value;
    if (predicate(value6)) {
      add3(right3, value6);
    } else {
      add3(left3, value6);
    }
  }
  return [endMutation2(left3), endMutation2(right3)];
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty9 = empty8;
var fromIterable5 = fromIterable4;
var make12 = make11;
var has4 = has3;
var every6 = every5;
var size3 = size2;
var add4 = add3;
var remove6 = remove5;
var difference5 = difference4;
var union6 = union5;
var forEach6 = forEach5;
var reduce7 = reduce6;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MutableRef.js
var TypeId8 = Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId8]: TypeId8,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value6) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value6;
  return ref;
};
var compareAndSet = dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var decrementAndGet = (self) => updateAndGet(self, (n) => n - 1);
var get7 = (self) => self.current;
var getAndSet = dual(2, (self, value6) => {
  const ret = self.current;
  self.current = value6;
  return ret;
});
var getAndUpdate = dual(2, (self, f2) => getAndSet(self, f2(get7(self))));
var incrementAndGet = (self) => updateAndGet(self, (n) => n + 1);
var set3 = dual(2, (self, value6) => {
  self.current = value6;
  return self;
});
var setAndGet = dual(2, (self, value6) => {
  self.current = value6;
  return self.current;
});
var update = dual(2, (self, f2) => set3(self, f2(get7(self))));
var updateAndGet = dual(2, (self, f2) => setAndGet(self, f2(get7(self))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = string2(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol2]() {
    return emptyHash;
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id2, startTimeMillis) {
    this.id = id2;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol2]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol2]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine2(hash(this.left)), combine2(hash(this.right)), cached(this));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = new None();
var runtime = (id2, startTimeMillis) => {
  return new Runtime(id2, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var isNone3 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every6((id2) => isNone3(id2)));
};
var combine4 = dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll2 = (fiberIds) => {
  return pipe(fiberIds, reduce7(none3, (a, b2) => combine4(b2)(a)));
};
var getOrElse4 = dual(2, (self, that) => isNone3(self) ? that : self);
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty9();
    }
    case OP_RUNTIME: {
      return make12(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union6(ids(self.right)));
    }
  }
};
var _fiberCounter = globalValue(Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id2, startTimeSeconds) => {
  return new Runtime(id2, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty9();
    }
    case OP_RUNTIME: {
      return make12(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union6(toSet(self.right)));
    }
  }
};
var unsafeMake2 = () => {
  const id2 = get7(_fiberCounter);
  pipe(_fiberCounter, set3(id2 + 1));
  return new Runtime(id2, Date.now());
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine5 = combine4;
var combineAll3 = combineAll2;
var getOrElse5 = getOrElse4;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty10 = empty7;
var make16 = make10;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get8 = get6;
var unsafeGet6 = unsafeGet5;
var has5 = has2;
var set4 = set2;
var keys3 = keys2;
var size4 = size;
var modifyAt2 = modifyAt;
var remove7 = remove4;
var map10 = map8;
var reduce8 = reduce5;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/List.js
var TypeId9 = Symbol.for("effect/List");
var toArray2 = (self) => fromIterable(self);
var getEquivalence5 = (isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray2);
var _equivalence5 = getEquivalence5(equals);
var ConsProto = {
  [TypeId9]: TypeId9,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag && _equivalence5(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done14 = false;
    let self = this;
    return {
      next() {
        if (done14) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done14 = true;
          return this.return();
        }
        const value6 = self.head;
        self = self.tail;
        return {
          done: done14,
          value: value6
        };
      },
      return(value6) {
        if (!done14) {
          done14 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head8, tail) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head8;
  cons2.tail = tail;
  return cons2;
};
var NilHash = string2("Nil");
var NilProto = {
  [TypeId9]: TypeId9,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2]() {
    return NilHash;
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId9);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var size5 = (self) => {
  let these = self;
  let len = 0;
  while (!isNil(these)) {
    len += 1;
    these = these.tail;
  }
  return len;
};
var nil = () => _Nil;
var cons = (head8, tail) => makeCons(head8, tail);
var empty11 = nil;
var of3 = (value6) => makeCons(value6, _Nil);
var fromIterable7 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next5;
  if ((next5 = iterator.next()) && !next5.done) {
    const result = makeCons(next5.value, _Nil);
    let curr = result;
    while ((next5 = iterator.next()) && !next5.done) {
      const temp = makeCons(next5.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var make17 = (...elements) => fromIterable7(elements);
var append4 = dual(2, (self, element2) => appendAll4(self, of3(element2)));
var appendAll4 = dual(2, (self, that) => prependAll4(that, self));
var prepend4 = dual(2, (self, element2) => cons(element2, self));
var prependAll4 = dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var prependAllReversed = dual(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
});
var drop4 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= size5(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
});
var every7 = dual(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
});
var some9 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
});
var filter8 = dual(2, (self, predicate) => noneIn(self, predicate, false));
var noneIn = (self, predicate, isFlipped) => {
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
var allIn = (start5, remaining, predicate, isFlipped) => {
  while (true) {
    if (isNil(remaining)) {
      return start5;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start5, remaining, predicate, isFlipped);
      }
    }
  }
};
var partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(unsafeHead3(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(unsafeHead3(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = unsafeCoerce(newElem);
    toProcess = unsafeCoerce(toProcess.tail);
  }
  let next5 = firstMiss.tail;
  let nextToCopy = unsafeCoerce(next5);
  while (!isNil(next5)) {
    const head8 = unsafeHead3(next5);
    if (predicate(head8) !== isFlipped) {
      next5 = next5.tail;
    } else {
      while (!(nextToCopy === next5)) {
        const newElem = makeCons(unsafeHead3(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = unsafeCoerce(nextToCopy.tail);
      }
      nextToCopy = unsafeCoerce(next5.tail);
      next5 = next5.tail;
    }
  }
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
var filterMap7 = dual(2, (self, f2) => {
  const bs = [];
  for (const a of self) {
    const oa = f2(a);
    if (isSome2(oa)) {
      bs.push(oa.value);
    }
  }
  return fromIterable7(bs);
});
var findFirst6 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return some2(these.head);
    }
    these = these.tail;
  }
  return none2();
});
var flatMap8 = dual(2, (self, f2) => {
  let rest = self;
  let head8 = void 0;
  let tail = void 0;
  while (!isNil(rest)) {
    let bs = f2(rest.head);
    while (!isNil(bs)) {
      const next5 = makeCons(bs.head, _Nil);
      if (tail === void 0) {
        head8 = next5;
      } else {
        tail.tail = next5;
      }
      tail = next5;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head8 === void 0) {
    return _Nil;
  }
  return head8;
});
var forEach7 = dual(2, (self, f2) => {
  let these = self;
  while (!isNil(these)) {
    f2(these.head);
    these = these.tail;
  }
});
var map11 = dual(2, (self, f2) => {
  if (isNil(self)) {
    return self;
  } else {
    let i = 0;
    const head8 = makeCons(f2(self.head, i++), _Nil);
    let nextHead = head8;
    let rest = self.tail;
    while (!isNil(rest)) {
      const next5 = makeCons(f2(rest.head, i++), _Nil);
      nextHead.tail = next5;
      nextHead = next5;
      rest = rest.tail;
    }
    return head8;
  }
});
var partition5 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    if (predicate(a)) {
      right3.push(a);
    } else {
      left3.push(a);
    }
  }
  return [fromIterable7(left3), fromIterable7(right3)];
});
var partitionMap5 = dual(2, (self, f2) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    const e = f2(a);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [fromIterable7(left3), fromIterable7(right3)];
});
var reduce9 = dual(3, (self, zero3, f2) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f2(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reduceRight3 = dual(3, (self, zero3, f2) => {
  let acc = zero3;
  let these = reverse3(self);
  while (!isNil(these)) {
    acc = f2(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self) => {
  let result = empty11();
  let these = self;
  while (!isNil(these)) {
    result = prepend4(result, these.head);
    these = these.tail;
  }
  return result;
};
var splitAt3 = dual(2, (self, n) => [take4(self, n), drop4(self, n)]);
var take4 = dual(2, (self, n) => {
  if (n <= 0) {
    return _Nil;
  }
  if (n >= size5(self)) {
    return self;
  }
  let these = make17(unsafeHead3(self));
  let current2 = unsafeTail(self);
  for (let i = 1; i < n; i++) {
    these = makeCons(unsafeHead3(current2), these);
    current2 = unsafeTail(current2);
  }
  return reverse3(these);
});
var getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
var unsafeHead3 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
var unsafeTail = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.tail;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = Object.assign(Object.create(Array.prototype), {
  [symbol2]() {
    return cached(this, array2(this));
  },
  [symbol3](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v2, i) => equals(v2, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as12) => Object.assign(Object.create(StructuralPrototype), as12);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = Object.assign(Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = Object.create(EmptyProto);
var AndThenProto = Object.assign(Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first4, second) => {
  const o = Object.create(AndThenProto);
  o.first = first4;
  o.second = second;
  return o;
};
var AppendProto = Object.assign(Object.create(PatchProto), {
  _tag: "Append"
});
var SliceProto = Object.assign(Object.create(PatchProto), {
  _tag: "Slice"
});
var UpdateProto = Object.assign(Object.create(PatchProto), {
  _tag: "Update"
});
var combine6 = dual(2, (self, that) => makeAndThen(self, that));
var patch = dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let chunk4 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend3(head8.first)(prepend3(head8.second)(tail));
        break;
      }
      case "Append": {
        chunk4 = appendAll3(head8.values)(chunk4);
        patches = tail;
        break;
      }
      case "Slice": {
        const array7 = toReadonlyArray(chunk4);
        chunk4 = unsafeFromArray(array7.slice(head8.from, head8.until));
        patches = tail;
        break;
      }
      case "Update": {
        const array7 = toReadonlyArray(chunk4);
        array7[head8.index] = differ3.patch(head8.patch, array7[head8.index]);
        chunk4 = unsafeFromArray(array7);
        patches = tail;
        break;
      }
    }
  }
  return chunk4;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first4, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first4;
  o.second = second;
  return o;
};
var AddServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
};
var RemoveServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update10) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update10;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch13 = empty12();
  for (const [tag3, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag3)) {
      const old = missingServices.get(tag3);
      missingServices.delete(tag3);
      if (!equals(old, newService)) {
        patch13 = combine7(makeUpdateService(tag3, () => newService))(patch13);
      }
    } else {
      missingServices.delete(tag3);
      patch13 = combine7(makeAddService(tag3, newService))(patch13);
    }
  }
  for (const [tag3] of missingServices.entries()) {
    patch13 = combine7(makeRemoveService(tag3))(patch13);
  }
  return patch13;
};
var combine7 = dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = dual(2, (self, context10) => {
  if (self._tag === "Empty") {
    return context10;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context10.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head8.key, head8.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend3(prepend3(tail, head8.second), head8.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head8.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head8.key, head8.update(updatedContext.get(head8.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map40 = /* @__PURE__ */ new Map();
  for (const [tag3] of context10.unsafeMap) {
    if (updatedContext.has(tag3)) {
      map40.set(tag3, updatedContext.get(tag3));
      updatedContext.delete(tag3);
    }
  }
  for (const [tag3, s] of updatedContext) {
    map40.set(tag3, s);
  }
  return makeContext(map40);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = Object.create(EmptyProto3);
var AndThenProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first4, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first4;
  o.second = second;
  return o;
};
var AddProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Add"
});
var RemoveProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Remove"
});
var UpdateProto2 = Object.assign(Object.create(PatchProto3), {
  _tag: "Update"
});
var combine8 = dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let map40 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend3(head8.first)(prepend3(head8.second)(tail));
        break;
      }
      case "Add": {
        map40 = set4(head8.key, head8.value)(map40);
        patches = tail;
        break;
      }
      case "Remove": {
        map40 = remove7(head8.key)(map40);
        patches = tail;
        break;
      }
      case "Update": {
        const option6 = get8(head8.key)(map40);
        if (option6._tag === "Some") {
          map40 = set4(head8.key, differ3.patch(head8.patch, option6.value))(map40);
        }
        patches = tail;
        break;
      }
    }
  }
  return map40;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty8 = Object.create(EmptyProto4);
var empty13 = () => _empty8;
var AndThenProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen4 = (first4, second) => {
  const o = Object.create(AndThenProto4);
  o.first = first4;
  o.second = second;
  return o;
};
var AddProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd = (value6) => {
  const o = Object.create(AddProto2);
  o.value = value6;
  return o;
};
var RemoveProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove = (value6) => {
  const o = Object.create(RemoveProto2);
  o.value = value6;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch13] = reduce7([oldValue, empty13()], ([set19, patch14], value6) => {
    if (has4(value6)(set19)) {
      return [remove6(value6)(set19), patch14];
    }
    return [set19, combine9(makeAdd(value6))(patch14)];
  })(newValue);
  return reduce7(patch13, (patch14, value6) => combine9(makeRemove(value6))(patch14))(removed);
};
var combine9 = dual(2, (self, that) => makeAndThen4(self, that));
var patch4 = dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set19 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend3(head8.first)(prepend3(head8.second)(tail));
        break;
      }
      case "Add": {
        set19 = add4(head8.value)(set19);
        patches = tail;
        break;
      }
      case "Remove": {
        set19 = remove6(head8.value)(set19);
        patches = tail;
      }
    }
  }
  return set19;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};
var EmptyProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "Empty"
});
var _empty9 = Object.create(EmptyProto5);
var empty14 = () => _empty9;
var AndThenProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "AndThen"
});
var makeAndThen5 = (first4, second) => {
  const o = Object.create(AndThenProto5);
  o.first = first4;
  o.second = second;
  return o;
};
var SetLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetLeft"
});
var makeSetLeft = (value6) => {
  const o = Object.create(SetLeftProto);
  o.value = value6;
  return o;
};
var SetRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetRight"
});
var makeSetRight = (value6) => {
  const o = Object.create(SetRightProto);
  o.value = value6;
  return o;
};
var UpdateLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateLeft"
});
var makeUpdateLeft = (patch13) => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch13;
  return o;
};
var UpdateRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateRight"
});
var makeUpdateRight = (patch13) => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch13;
  return o;
};
var diff3 = (options) => {
  switch (options.oldValue._tag) {
    case "Left": {
      switch (options.newValue._tag) {
        case "Left": {
          const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
          if (equals(valuePatch, options.left.empty)) {
            return empty14();
          }
          return makeUpdateLeft(valuePatch);
        }
        case "Right": {
          return makeSetRight(options.newValue.right);
        }
      }
    }
    case "Right": {
      switch (options.newValue._tag) {
        case "Left": {
          return makeSetLeft(options.newValue.left);
        }
        case "Right": {
          const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
          if (equals(valuePatch, options.right.empty)) {
            return empty14();
          }
          return makeUpdateRight(valuePatch);
        }
      }
    }
  }
};
var combine10 = dual(2, (self, that) => makeAndThen5(self, that));
var patch5 = dual(2, (self, {
  left: left3,
  oldValue,
  right: right3
}) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let patches = of2(self);
  let result = oldValue;
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend3(head8.first)(prepend3(head8.second)(tail));
        break;
      }
      case "UpdateLeft": {
        if (result._tag === "Left") {
          result = left2(left3.patch(head8.patch, result.left));
        }
        patches = tail;
        break;
      }
      case "UpdateRight": {
        if (result._tag === "Right") {
          result = right2(right3.patch(head8.patch, result.right));
        }
        patches = tail;
        break;
      }
      case "SetLeft": {
        result = left2(head8.value);
        patches = tail;
        break;
      }
      case "SetRight": {
        result = right2(head8.value);
        patches = tail;
        break;
      }
    }
  }
  return result;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty10 = Object.create(EmptyProto6);
var empty15 = () => _empty10;
var AndThenProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen6 = (first4, second) => {
  const o = Object.create(AndThenProto6);
  o.first = first4;
  o.second = second;
  return o;
};
var AppendProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend = (values7) => {
  const o = Object.create(AppendProto2);
  o.values = values7;
  return o;
};
var SliceProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto2);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto3 = Object.assign(Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate = (index, patch13) => {
  const o = Object.create(UpdateProto3);
  o.index = index;
  o.patch = patch13;
  return o;
};
var diff4 = (options) => {
  let i = 0;
  let patch13 = empty15();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch13 = combine11(patch13, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch13 = combine11(patch13, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch13 = combine11(patch13, makeAppend(drop2(i)(options.newValue)));
  }
  return patch13;
};
var combine11 = dual(2, (self, that) => makeAndThen6(self, that));
var patch6 = dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head8 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head8.first, head8.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value6 of head8.values) {
          readonlyArray2.push(value6);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head8.from, head8.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray2[head8.index] = differ3.patch(head8.patch, readonlyArray2[head8.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray2;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make18 = (params) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params.empty;
  differ3.diff = params.diff;
  differ3.combine = params.combine;
  differ3.patch = params.patch;
  return differ3;
};
var environment = () => make18({
  empty: empty12(),
  combine: (first4, second) => combine7(second)(first4),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch13, oldValue) => patch2(oldValue)(patch13)
});
var hashSet = () => make18({
  empty: empty13(),
  combine: (first4, second) => combine9(second)(first4),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch13, oldValue) => patch4(oldValue)(patch13)
});
var orElseEither2 = dual(2, (self, that) => make18({
  empty: empty14(),
  combine: (first4, second) => combine10(first4, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    left: self,
    right: that
  }),
  patch: (patch13, oldValue) => patch5(patch13, {
    oldValue,
    left: self,
    right: that
  })
}));
var readonlyArray = (differ3) => make18({
  empty: empty15(),
  combine: (first4, second) => combine11(first4, second),
  diff: (oldValue, newValue) => diff4({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch13, oldValue) => patch6(patch13, oldValue, differ3)
});
var transform = dual(2, (self, {
  toNew,
  toOld
}) => make18({
  empty: self.empty,
  combine: (first4, second) => self.combine(first4, second),
  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
  patch: (patch13, oldValue) => toNew(self.patch(patch13, toOld(oldValue)))
}));
var update2 = () => updateWith((_2, a) => a);
var updateWith = (f2) => make18({
  empty: identity,
  combine: (first4, second) => {
    if (first4 === identity) {
      return second;
    }
    if (second === identity) {
      return first4;
    }
    return (a) => second(first4(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch13, oldValue) => f2(oldValue, patch13(oldValue))
});
var zip4 = dual(2, (self, that) => make18({
  empty: [self.empty, that.empty],
  combine: (first4, second) => [self.combine(first4[0], second[0]), that.combine(first4[1], second[1])],
  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
  patch: (patch13, oldValue) => [self.patch(patch13[0], oldValue[0]), that.patch(patch13[1], oldValue[1])]
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch13) => patch13 & BIT_MASK;
var enabled = (patch13) => patch13 >> BIT_SHIFT & BIT_MASK;
var make19 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty18 = make19(0, 0);
var enable = (flag) => make19(flag, flag);
var disable = (flag) => make19(flag, 0);
var isActive = dual(2, (self, flag) => (active(self) & flag) !== 0);
var isEnabled = dual(2, (self, flag) => (enabled(self) & flag) !== 0);
var isDisabled = dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
var exclude = dual(2, (self, flag) => make19(active(self) & ~flag, enabled(self)));
var both = dual(2, (self, that) => make19(active(self) | active(that), enabled(self) & enabled(that)));
var either = dual(2, (self, that) => make19(active(self) | active(that), enabled(self) | enabled(that)));
var andThen3 = dual(2, (self, that) => self | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self) => isEnabled2(self, CooperativeYielding);
var disable2 = dual(2, (self, flag) => self & ~flag);
var disableAll = dual(2, (self, flags) => self & ~flags);
var enable2 = dual(2, (self, flag) => self | flag);
var enableAll = dual(2, (self, flags) => self | flags);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled2(self, Interruption);
var isDisabled2 = dual(2, (self, flag) => !isEnabled2(self, flag));
var isEnabled2 = dual(2, (self, flag) => (self & flag) !== 0);
var make20 = (...flags) => flags.reduce((a, b2) => a | b2, 0);
var none5 = make20(None2);
var runtimeMetrics = (self) => isEnabled2(self, RuntimeMetrics);
var windDown = (self) => isEnabled2(self, WindDown);
var diff7 = dual(2, (self, that) => make19(self ^ that, that));
var patch7 = dual(2, (self, patch13) => self & (invert(active(patch13)) | enabled(patch13)) | active(patch13) & enabled(patch13));
var differ = make18({
  empty: empty18,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first4, second) => andThen3(second)(first4),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty19 = empty18;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/blockedRequests.js
var empty20 = {
  _tag: "Empty"
};
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten6 = (self) => {
  let current2 = of3(self);
  let updated = empty11();
  while (1) {
    const [parallel5, sequential5] = reduce9(current2, [parallelCollectionEmpty(), empty11()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll4(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse3(updated);
    }
    current2 = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty11();
  let sequential5 = empty11();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l2 = left3.left;
            const r = left3.right;
            current2 = par(seq(l2, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l2 = left3.left;
            const r = left3.right;
            current2 = seq(l2, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current2);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
};
var EntryTypeId = Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request2, result, listeners, ownerId, state) {
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map40) {
    this.map = map40;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty10());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_2) => orElseSome(map2(_2, append3(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce8(self.map, that.map, (map40, value6, key) => set4(map40, key, match2(get8(map40, key), {
  onNone: () => value6,
  onSome: (other) => appendAll3(value6, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty3(self.map);
var parallelCollectionKeys = (self) => Array.from(keys3(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map10(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map40) {
    this.map = map40;
  }
};
var sequentialCollectionMake = (map40) => new SequentialImpl(map40);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce8(that.map, self.map, (map40, value6, key) => set4(map40, key, match2(get8(map40, key), {
  onNone: () => empty6(),
  onSome: (a) => appendAll3(a, value6)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys3(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = Symbol.for(CauseSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _E: (_2) => _2
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol2]() {
    return pipe(hash(CauseSymbolKey), combine2(hash(flattenCause(this))), cached(this));
  },
  [symbol3](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty21 = (() => {
  const o = Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error2) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error2;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId3) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId3;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isEmpty5 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce10(self, true, (acc, cause2) => {
    switch (cause2._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse2(reduce10(self, empty6(), (list, cause2) => cause2._tag === OP_FAIL ? some2(pipe(list, prepend3(cause2.error))) : none2()));
var defects = (self) => reverse2(reduce10(self, empty6(), (list, cause2) => cause2._tag === OP_DIE ? some2(pipe(list, prepend3(cause2.defect))) : none2()));
var interruptors = (self) => reduce10(self, empty9(), (set19, cause2) => cause2._tag === OP_INTERRUPT ? some2(pipe(set19, add4(cause2.fiberId))) : none2());
var failureOption = (self) => find(self, (cause2) => cause2._tag === OP_FAIL ? some2(cause2.error) : none2());
var failureOrCause = (self) => {
  const option6 = failureOption(self);
  switch (option6._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option6.value);
    }
  }
};
var flipCauseOption = (self) => match6(self, {
  onEmpty: some2(empty21),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId3) => some2(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause2) => cause2._tag === OP_INTERRUPT ? some2(cause2.fiberId) : none2());
var keepDefects = (self) => match6(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self) => match6(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self) => match6(self, {
  onEmpty: empty21,
  onFail: () => empty21,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match6(self, {
  onEmpty: empty21,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var stripSomeDefects = dual(2, (self, pf) => match6(self, {
  onEmpty: some2(empty21),
  onFail: (error2) => some2(fail(error2)),
  onDie: (defect) => {
    const option6 = pf(defect);
    return isSome2(option6) ? none2() : some2(die(defect));
  },
  onInterrupt: (fiberId3) => some2(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}));
var as2 = dual(2, (self, error2) => map13(self, () => error2));
var map13 = dual(2, (self, f2) => flatMap10(self, (e) => fail(f2(e))));
var flatMap10 = dual(2, (self, f2) => match6(self, {
  onEmpty: empty21,
  onFail: (error2) => f2(error2),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId3) => interrupt(fiberId3),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var andThen4 = dual(2, (self, f2) => isFunction2(f2) ? flatMap10(self, f2) : flatMap10(self, () => f2));
var contains4 = dual(2, (self, that) => {
  if (that._tag === OP_EMPTY || self === that) {
    return true;
  }
  return reduce10(self, false, (accumulator, cause2) => {
    return some2(accumulator || causeEquals(cause2, that));
  });
});
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce10([empty9(), empty6()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union6(par2)), pipe(sequential5, appendAll3(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce10([empty9(), empty6()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union6(par2)), pipe(sequential5, appendAll3(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause2) => {
  return flattenCauseLoop(of2(cause2), empty6());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce3([empty9(), empty6()], ([parallel6, sequential6], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return [pipe(parallel6, union6(par2)), pipe(sequential6, appendAll3(seq2))];
    }));
    const updated = size3(parallel5) > 0 ? pipe(flattened, prepend3(parallel5)) : flattened;
    if (isEmpty(sequential5)) {
      return reverse2(updated);
    }
    causes = sequential5;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option6 = pf(item);
    switch (option6._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option6;
      }
    }
  }
  return none2();
});
var filter9 = dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
var evaluateCause = (self) => {
  let cause2 = self;
  const stack = [];
  let _parallel = empty9();
  let _sequential = empty6();
  while (cause2 !== void 0) {
    switch (cause2._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause2._tag, cause2.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause2.left._tag) {
          case OP_EMPTY: {
            cause2 = cause2.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause2 = sequential(cause2.left.left, sequential(cause2.left.right, cause2.right));
            break;
          }
          case OP_PARALLEL: {
            cause2 = parallel(sequential(cause2.left.left, cause2.right), sequential(cause2.left.right, cause2.right));
            break;
          }
          default: {
            _sequential = prepend3(_sequential, cause2.right);
            cause2 = cause2.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_2, left3, right3) => left3 && right3,
  parallelCase: (_2, left3, right3) => left3 && right3
};
var FilterCauseReducer = (predicate) => ({
  emptyCase: () => empty21,
  failCase: (_2, error2) => fail(error2),
  dieCase: (_2, defect) => die(defect),
  interruptCase: (_2, fiberId3) => interrupt(fiberId3),
  sequentialCase: (_2, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return sequential(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty21;
  },
  parallelCase: (_2, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return parallel(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty21;
  }
});
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match6 = dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_2, error2) => onFail(error2),
    dieCase: (_2, defect) => onDie(defect),
    interruptCase: (_2, fiberId3) => onInterrupt3(fiberId3),
    sequentialCase: (_2, left3, right3) => onSequential(left3, right3),
    parallelCase: (_2, left3, right3) => onParallel(left3, right3)
  });
});
var reduce10 = dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause2 = self;
  const causes = [];
  while (cause2 !== void 0) {
    const option6 = pf(accumulator, cause2);
    accumulator = isSome2(option6) ? option6.value : accumulator;
    switch (cause2._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      default: {
        cause2 = void 0;
        break;
      }
    }
    if (cause2 === void 0 && causes.length > 0) {
      cause2 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = dual(3, (self, context10, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause2 = input.pop();
    switch (cause2._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context10)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context10, cause2.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context10, cause2.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context10, cause2.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either8 = output.pop();
    switch (either8._tag) {
      case "Left": {
        switch (either8.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.sequentialCase(context10, left3, right3);
            accumulator.push(value6);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.parallelCase(context10, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either8.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause2, options) => {
  if (isInterruptedOnly(cause2)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause2).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause2, prefix) => {
  const lines = cause2.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause2.cause) {
    stack += ` {
${renderErrorCause(cause2.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span3) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span3) {
    let current2 = span3;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match28 = false;
          for (const [, location] of locationMatchAll) {
            match28 = true;
            out.push(`    at ${current2.name} (${location})`);
          }
          if (!match28) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined2(current2.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause2) => reduceWithContext(cause2, void 0, {
  emptyCase: () => [],
  dieCase: (_2, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_2, error2) => {
    return [new PrettyError(error2)];
  },
  interruptCase: () => [],
  parallelCase: (_2, l2, r) => [...l2, ...r],
  sequentialCase: (_2, l2, r) => [...l2, ...r]
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch13, op) {
    this.patch = patch13;
    this.op = op;
  }
};
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol3](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol3](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = dual(3, (acquire3, use, release3) => uninterruptibleMask((restore) => flatMap11(acquire3, (a) => flatMap11(exit(suspend(() => restore(use(a)))), (exit4) => {
  return suspend(() => release3(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause2) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause2));
        case OP_SUCCESS:
          return failCause(cause2);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as3 = dual(2, (self, value6) => flatMap11(self, () => succeed(value6)));
var asVoid2 = (self) => as3(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_2) => isEffect(cancelerRef) ? cancelerRef : void_3);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_2) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_3;
    }) : effect4;
  });
};
var catchAllCause = dual(2, (self, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var catchAll = dual(2, (self, f2) => matchEffect(self, {
  onFailure: f2,
  onSuccess: succeed
}));
var catchIf = dual(3, (self, predicate, f2) => catchAllCause(self, (cause2) => {
  const either8 = failureOrCause(cause2);
  switch (either8._tag) {
    case "Left":
      return predicate(either8.left) ? f2(either8.left) : failCause(cause2);
    case "Right":
      return failCause(either8.right);
  }
}));
var catchSome = dual(2, (self, pf) => catchAllCause(self, (cause2) => {
  const either8 = failureOrCause(cause2);
  switch (either8._tag) {
    case "Left":
      return pipe(pf(either8.left), getOrElse2(() => failCause(cause2)));
    case "Right":
      return failCause(either8.right);
  }
}));
var originalSymbol = Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span3) => {
  if (isSome2(span3)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span3.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate3) => flatMap11(sync(evaluate3), die2);
var either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error2) => isObject(error2) && !(spanSymbol in error2) ? withFiberRuntime((fiber) => failCause(fail(capture(error2, currentSpanFromFiber(fiber))))) : failCause(fail(error2));
var failSync = (evaluate3) => flatMap11(sync(evaluate3), fail2);
var failCause = (cause2) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause2;
  return effect4;
};
var failCauseSync = (evaluate3) => flatMap11(sync(evaluate3), failCause);
var fiberId = withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f2) => withFiberRuntime((state) => f2(state.id()));
var flatMap11 = dual(2, (self, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var andThen5 = dual(2, (self, f2) => flatMap11(self, (a) => {
  const b2 = typeof f2 === "function" ? f2(a) : f2;
  if (isEffect(b2)) {
    return b2;
  } else if (isPromiseLike(b2)) {
    return unsafeAsync((resume2) => {
      b2.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b2);
}));
var step2 = (self) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self;
  return effect4;
};
var flatten7 = (self) => flatMap11(self, identity);
var flip = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause2) => succeed(options.onFailure(cause2)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = dual(2, (self, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(electFailures(cause2));
    }
    const failures2 = failures(cause2);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause2);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = dual(2, (self, f2) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as3(whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: (b2) => {
      ret[i++] = b2;
    }
  }), ret);
}));
var forEachSequentialDiscard = dual(2, (self, f2) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self, options) => isEffect(self) ? flatMap11(self, (b2) => b2 ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = flatMap11(fiberId, (fiberId3) => interruptWith(fiberId3));
var interruptWith = (fiberId3) => failCause(interrupt(fiberId3));
var interruptible2 = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var interruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var intoDeferred = dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap11(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map14 = dual(2, (self, f2) => flatMap11(self, (a) => sync(() => f2(a))));
var mapBoth3 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const either8 = failureOrCause(cause2);
    switch (either8._tag) {
      case "Left": {
        return failSync(() => f2(either8.left));
      }
      case "Right": {
        return failCause(either8.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_3 : cleanup(exit4.effect_instruction_i0)));
var onExit = dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }
})));
var onInterrupt = dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause2) => isInterruptedOnly(cause2) ? asVoid2(cleanup(interruptors(cause2))) : void_3,
  onSuccess: () => void_3
})));
var orElse3 = dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = dual(2, (self, f2) => matchEffect(self, {
  onFailure: (e) => die2(f2(e)),
  onSuccess: succeed
}));
var partitionMap6 = partitionMap3;
var runtimeFlags = withFiberRuntime((_2, status2) => succeed(status2.runtimeFlags));
var succeed = (value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
};
var suspend = (evaluate3) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate3;
  return effect4;
};
var sync = (thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
};
var tap2 = dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self, f2) => flatMap11(self, (a) => {
  const b2 = typeof f2 === "function" ? f2(a) : f2;
  if (isEffect(b2)) {
    return as3(b2, a);
  } else if (isPromiseLike(b2)) {
    return unsafeAsync((resume2) => {
      b2.then((_2) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f2) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse2(() => state.scope()));
  return f2(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
});
var attemptOrElse = dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause2)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var uninterruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var void_3 = succeed(void 0);
var updateRuntimeFlags = (patch13) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch13;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = dual(2, (self, condition) => flatMap11(condition, (b2) => {
  if (b2) {
    return pipe(self, map14(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var fromIterator = (iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
});
var gen2 = function() {
  const f2 = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f2(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = dual(2, (self, update10) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update10;
  effect4.effect_instruction_i1 = () => self;
  return effect4;
});
var withTracerEnabled = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip5 = dual(2, (self, that) => flatMap11(self, (a) => map14(that, (b2) => [a, b2])));
var zipFlatten = dual(2, (self, that) => flatMap11(self, (a) => map14(that, (b2) => [...a, b2])));
var zipLeft2 = dual(2, (self, that) => flatMap11(self, (a) => as3(that, a)));
var zipRight2 = dual(2, (self, that) => flatMap11(self, () => that));
var zipWith6 = dual(3, (self, that, f2) => flatMap11(self, (a) => map14(that, (b2) => f2(a, b2))));
var never = asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap11(fiberId, (fiberId3) => pipe(self, interruptAsFiber(fiberId3)));
var interruptAsFiber = dual(2, (self, fiberId3) => flatMap11(self.interruptAsFork(fiberId3), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetAndSet = dual(2, (self, value6) => fiberRefModify(self, (v2) => [v2, value6]));
var fiberRefGetAndUpdate = dual(2, (self, f2) => fiberRefModify(self, (v2) => [v2, f2(v2)]));
var fiberRefGetAndUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v2) => [v2, getOrElse2(pf(v2), () => v2)]));
var fiberRefGetWith = dual(2, (self, f2) => flatMap11(fiberRefGet(self), f2));
var fiberRefSet = dual(2, (self, value6) => fiberRefModify(self, () => [void 0, value6]));
var fiberRefDelete = (self) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self);
  return void_3;
});
var fiberRefModify = dual(2, (self, f2) => withFiberRuntime((state) => {
  const [b2, a] = f2(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b2);
}));
var fiberRefUpdate = dual(2, (self, f2) => fiberRefModify(self, (v2) => [void 0, f2(v2)]));
var fiberRefUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v2) => [void 0, getOrElse2(pf(v2), () => v2)]));
var fiberRefUpdateAndGet = dual(2, (self, f2) => fiberRefModify(self, (v2) => {
  const result = f2(v2);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = dual(2, (self, pf) => fiberRefModify(self, (v2) => {
  const result = getOrElse2(pf(v2), () => v2);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var RequestResolverImpl = class _RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol2]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol3](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var resolverLocally = dual(3, (use, self, value6) => new RequestResolverImpl((requests) => fiberRefLocally(use.runAll(requests), self, value6), make7("Locally", use, self, value6)));
var fiberRefLocally = dual(3, (use, self, value6) => acquireUseRelease(zipLeft2(fiberRefGet(self), fiberRefSet(self, value6)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = dual(3, (use, self, f2) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f2(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update2(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ3 = readonlyArray(update2());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first4, second) => options.differ.combine(first4, second),
    patch: (patch13) => (oldValue) => options.differ.patch(patch13, oldValue),
    fork: options.fork,
    join: options.join ?? ((_2, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = globalValue(Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty5()));
var currentSchedulingPriority = globalValue(Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = globalValue(Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = globalValue(Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = globalValue(Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = globalValue(Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = dual(2, (self, scheduler2) => fiberRefLocally(self, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = dual(2, (self, scheduler2) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = globalValue(Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = globalValue(Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var withUnhandledErrorLogLevel = dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = globalValue(Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty3()));
var metricLabels = fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = globalValue(Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _2) => parent
}));
var currentInterruptedCause = globalValue(Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty21, {
  fork: () => empty21,
  join: (parent, _2) => parent
}));
var currentTracerEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty10()));
var currentTracerSpanLinks = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty6()));
var ScopeTypeId = Symbol.for("effect/Scope");
var CloseableScopeTypeId = Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer2) => self.addFinalizer(() => asVoid2(finalizer2));
var scopeAddFinalizerExit = (self, finalizer2) => self.addFinalizer(finalizer2);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = dual(2, (self, f2) => {
  const option6 = pipe(self, failureOption, map2(f2));
  switch (option6._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self)).flatMap((fiberId3) => fromIterable(ids2(fiberId3)).map((id2) => `#${id2}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option6.value;
    }
  }
});
var YieldableError = function() {
  class YieldableError3 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype);
  return YieldableError3;
}();
var makeException = (proto16, tag3) => {
  class Base4 extends YieldableError {
    _tag = tag3;
  }
  Object.assign(Base4.prototype, proto16);
  Base4.prototype.name = tag3;
  return Base4;
};
var RuntimeExceptionTypeId = Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration3) => new TimeoutException(`Operation timed out after '${format3(duration3)}'`);
var UnknownExceptionTypeId = Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = function() {
  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause2, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause2
      });
      this.error = cause2;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitAs = dual(2, (self, value6) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value6);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitExists = dual(2, (self, refinement) => {
  switch (self._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self.effect_instruction_i0);
  }
});
var exitFail = (error2) => exitFailCause(fail(error2));
var exitFailCause = (cause2) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause2;
  return effect4;
};
var exitFlatMap = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f2(self.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f2(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
var exitForEachEffect = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f2(self.effect_instruction_i0));
    }
  }
});
var exitGetOrElse = dual(2, (self, orElse15) => {
  switch (self._tag) {
    case OP_FAILURE:
      return orElse15(self.effect_instruction_i0);
    case OP_SUCCESS:
      return self.effect_instruction_i0;
  }
});
var exitInterrupt = (fiberId3) => exitFailCause(interrupt(fiberId3));
var exitMap = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f2(self.effect_instruction_i0));
  }
});
var exitMapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMapError = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(f2)));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMapErrorCause = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(f2(self.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMatch = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
};
var exitVoid = exitSucceed(void 0);
var exitZip = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _2) => a,
  onFailure: sequential
}));
var exitZipRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_2, a2) => a2,
  onFailure: sequential
}));
var exitZipPar = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
var exitZipParLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _2) => a,
  onFailure: parallel
}));
var exitZipParRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_2, a2) => a2,
  onFailure: parallel
}));
var exitZipWith = dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce3(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value6) => pipe(list2, prepend3(value6)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some2);
};
var deferredUnsafeMake = (fiberId3) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId3
  };
  return _deferred;
};
var deferredMake = () => flatMap11(fiberId, (id2) => deferredMakeAs(id2));
var deferredMakeAs = (fiberId3) => sync(() => deferredUnsafeMake(fiberId3));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = dual(2, (self, effect4) => intoDeferred(effect4, self));
var deferredCompleteWith = dual(2, (self, effect4) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set3(self.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = dual(2, (self, error2) => deferredCompleteWith(self, fail2(error2)));
var deferredFailSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, failSync(evaluate3)));
var deferredFailCause = dual(2, (self, cause2) => deferredCompleteWith(self, failCause(cause2)));
var deferredFailCauseSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, failCauseSync(evaluate3)));
var deferredDie = dual(2, (self, defect) => deferredCompleteWith(self, die2(defect)));
var deferredDieSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, dieSync(evaluate3)));
var deferredInterrupt = (self) => flatMap11(fiberId, (fiberId3) => deferredCompleteWith(self, interruptWith(fiberId3)));
var deferredInterruptWith = dual(2, (self, fiberId3) => deferredCompleteWith(self, interruptWith(fiberId3)));
var deferredIsDone = (self) => sync(() => get7(self.state)._tag === OP_STATE_DONE);
var deferredPoll = (self) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = dual(2, (self, value6) => deferredCompleteWith(self, succeed(value6)));
var deferredSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, sync(evaluate3)));
var deferredUnsafeDone = (self, effect4) => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set3(self.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context2 = () => constContext;
var contextWithEffect = (f2) => flatMap11(context2(), f2);
var provideContext = dual(2, (self, context10) => fiberRefLocally(currentContext, context10)(self));
var provideSomeContext = dual(2, (self, context10) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context10))(self));
var mapInputContext = dual(2, (self, f2) => contextWithEffect((context10) => provideContext(self, f2(context10))));
var filterEffectOrElse = dual(2, (self, options) => flatMap11(self, (a) => flatMap11(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = dual(2, (self, options) => filterEffectOrElse(self, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span3 = fiber.currentSpan;
  return span3 !== void 0 && span3._tag === "Span" ? some2(span3) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: BigInt(0),
    endTime: BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Deferred.js
var make21 = deferredMake;
var _await = deferredAwait;
var done2 = deferredDone;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isFailure = exitIsFailure;
var isSuccess = exitIsSuccess;
var all2 = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause3 = exitFailCause;
var flatten8 = exitFlatten;
var forEachEffect = exitForEachEffect;
var interrupt4 = exitInterrupt;
var map15 = exitMap;
var match7 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_4 = exitVoid;
var zip6 = exitZip;
var zipRight3 = exitZipRight;
var zipWith7 = exitZipWith;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId10 = Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId10]: TypeId10,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty22 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var get9 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove17 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      const value6 = bucket[i][1];
      if (remove17) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value6);
    }
  }
  return none2();
};
var has6 = dual(2, (self, key) => isSome2(get9(self, key)));
var set5 = dual(3, (self, key, value6) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value6);
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    self.buckets.set(hash4, [[key, value6]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value6]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
var modify5 = dual(3, (self, key, f2) => {
  if (isEqual(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f2(self.referential.get(key)));
    }
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return self;
  }
  const value6 = getFromBucket(self, bucket, key, true);
  if (isNone2(value6)) {
    return self;
  }
  bucket.push([key, f2(value6.value)]);
  self.bucketsSize++;
  return self;
});
var modifyAt3 = dual(3, (self, key, f2) => {
  if (isEqual(key) === false) {
    const result2 = f2(get9(self, key));
    if (isSome2(result2)) {
      set5(self, key, result2.value);
    } else {
      remove8(self, key);
    }
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    const result2 = f2(none2());
    return isSome2(result2) ? set5(self, key, result2.value) : self;
  }
  const result = f2(getFromBucket(self, bucket, key, true));
  if (isNone2(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash4);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
});
var remove8 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash4);
  }
  return self;
});
var clear = (self) => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
var size6 = (self) => {
  return self.referential.size + self.bucketsSize;
};
var forEach8 = dual(2, (self, f2) => {
  self.referential.forEach(f2);
  for (const bucket of self.buckets.values()) {
    for (const [key, value6] of bucket) {
      f2(value6, key);
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MutableList.js
var TypeId11 = Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    let done14 = false;
    let head8 = this.head;
    return {
      next() {
        if (done14) {
          return this.return();
        }
        if (head8 == null) {
          done14 = true;
          return this.return();
        }
        const value6 = head8.value;
        head8 = head8.next;
        return {
          done: done14,
          value: value6
        };
      },
      return(value6) {
        if (!done14) {
          done14 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value6) => ({
  value: value6,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty23 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var isEmpty6 = (self) => length(self) === 0;
var length = (self) => self._length;
var forEach9 = dual(2, (self, f2) => {
  let current2 = self.head;
  while (current2 !== void 0) {
    f2(current2.value);
    current2 = current2.next;
  }
});
var append5 = dual(2, (self, value6) => {
  const node = makeNode(value6);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head8 = self.head;
  if (head8 !== void 0) {
    remove9(self, head8);
    return head8.value;
  }
  return void 0;
};
var prepend5 = dual(2, (self, value6) => {
  const node = makeNode(value6);
  node.next = self.head;
  if (self.head !== void 0) {
    self.head.prev = node;
  }
  self.head = node;
  if (self.tail === void 0) {
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var remove9 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MutableQueue.js
var TypeId12 = Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make22 = (capacity7) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty23();
  queue.capacity = capacity7;
  return queue;
};
var bounded = (capacity7) => make22(capacity7);
var unbounded = () => make22(void 0);
var length2 = (self) => length(self.queue);
var isEmpty7 = (self) => isEmpty6(self.queue);
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = dual(2, (self, value6) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append5(value6)(self.queue);
  return true;
});
var offerAll = dual(2, (self, values7) => {
  const iterator = values7[Symbol.iterator]();
  let next5;
  let remainder3 = empty6();
  let offering = true;
  while (offering && (next5 = iterator.next()) && !next5.done) {
    offering = offer(next5.value)(self);
  }
  while (next5 != null && !next5.done) {
    remainder3 = prepend3(next5.value)(remainder3);
    next5 = iterator.next();
  }
  return reverse2(remainder3);
});
var poll2 = dual(2, (self, def) => {
  if (isEmpty6(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = dual(2, (self, n) => {
  let result = empty6();
  let count5 = 0;
  while (count5 < n) {
    const element2 = poll2(EmptyMutableQueue)(self);
    if (element2 === EmptyMutableQueue) {
      break;
    }
    result = prepend3(element2)(result);
    count5 += 1;
  }
  return reverse2(result);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = Symbol.for(ClockSymbolKey);
var clockTag = GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration3) {
    const millis2 = toMillis(duration3);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = function() {
  const bigint1e62 = BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = performanceNowNanos() - processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration3) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_3), duration3);
      return asVoid2(sync(canceler));
    });
  }
};
var make23 = () => new ClockImpl();

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error2 = Object.create(proto2);
  error2._op = OP_AND;
  error2.left = self;
  error2.right = that;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error2, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error2;
};
var Or = (self, that) => {
  const error2 = Object.create(proto2);
  error2._op = OP_OR;
  error2.left = self;
  error2.right = that;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error2, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error2;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_INVALID_DATA;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_MISSING_DATA;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var SourceUnavailable = (path, message, cause2, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_SOURCE_UNAVAILABLE;
  error2.path = path;
  error2.message = message;
  error2.cause = cause2;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_UNSUPPORTED;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var prefixed = dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_2, left3, right3) => left3 && right3,
  orCase: (_2, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = dual(3, (self, context10, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error2 = input.pop();
    switch (error2._op) {
      case OP_AND: {
        input.push(error2.right);
        input.push(error2.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error2.right);
        input.push(error2.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context10, error2.path, error2.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context10, error2.path, error2.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context10, error2.path, error2.message, error2.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context10, error2.path, error2.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either8 = output.pop();
    switch (either8._op) {
      case "Left": {
        switch (either8.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.andCase(context10, left3, right3);
            accumulator.push(value6);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.orCase(context10, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either8.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, void 0, IsMissingDataOnlyReducer);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty24 = {
  _tag: "Empty"
};
var andThen6 = dual(2, (self, that) => ({
  _tag: "AndThen",
  first: self,
  second: that
}));
var mapName = dual(2, (self, f2) => andThen6(self, {
  _tag: "MapName",
  f: f2
}));
var nested = dual(2, (self, name) => andThen6(self, {
  _tag: "Nested",
  name
}));
var unnested = dual(2, (self, name) => andThen6(self, {
  _tag: "Unnested",
  name
}));
var patch8 = dual(2, (path, patch13) => {
  let input = of3(patch13);
  let output = path;
  while (isCons(input)) {
    const patch14 = input.head;
    switch (patch14._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch14.first, cons(patch14.second, input.tail));
        break;
      }
      case "MapName": {
        output = map6(output, patch14.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend2(output, patch14.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch14.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch14.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l2, r) => [...l2, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = Symbol.for(FlatConfigProviderSymbolKey);
var make25 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config2, split6 = true) => options.load(path, config2, split6),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make25({
  load: (config2) => flatMap11(fromFlatLoop(flat, empty3(), config2, false), (chunk4) => match2(head(chunk4), {
    onNone: () => fail2(MissingData(empty3(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive2, split6 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some2(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap11((value6) => parsePrimitive(value6, path, primitive2, seqDelim, split6)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current2 = getEnv();
    const keys10 = Object.keys(current2);
    const keyPaths = keys10.map((value6) => unmakePathString(value6.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty24
  }));
};
var extend2 = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config2, split6) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split6));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split6)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split6), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split6));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split6), flatMap11(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split6));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap11((prefix2) => pipe(flat.load(prefix2, op, split6), flatMap11((values7) => {
        if (values7.length === 0) {
          const name = pipe(last(prefix2), getOrElse2(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values7);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap11((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap11(indicesFrom), flatMap11((indices) => {
        if (indices.length === 0) {
          return suspend(() => map14(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append2(prefix, `[${index}]`), op.config, true)), map14((chunkChunk) => {
          const flattened = flatten3(chunkChunk);
          if (flattened.length === 0) {
            return of(empty3());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap11((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap11((keys10) => {
        return pipe(keys10, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split6)), map14((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map6((values7) => fromIterable6(zip2(fromIterable(keys10), values7))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split6), either2, flatMap11((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split6), either2, flatMap11((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail20 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend2(fail20, fail20, pipe(left3.right, map6(right2)), pipe(right3.right, map6(right2)));
          return pipe(lefts, zip2(rights), forEachSequential(([left4, right4]) => pipe(zip5(left4, right4), map14(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var mapInputPath = dual(2, (self, f2) => fromFlat(mapInputPathFlat(self.flattened, f2)));
var mapInputPathFlat = (self, f2) => makeFlat({
  load: (path, config2, split6 = true) => self.load(path, config2, split6),
  enumerateChildren: (path) => self.enumerateChildren(path),
  patch: mapName(self.patch, f2)
});
var nested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: nested(self.flattened.patch, name)
})));
var unnested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: unnested(self.flattened.patch, name)
})));
var orElse4 = dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
var orElseFlat = (self, that) => makeFlat({
  load: (path, config2, split6) => pipe(patch8(path, self.patch), flatMap11((patch13) => self.load(patch13, config2, split6)), catchAll((error1) => pipe(sync(that), flatMap11((that2) => pipe(patch8(path, that2.patch), flatMap11((patch13) => that2.load(patch13, config2, split6)), catchAll((error2) => fail2(Or(error1, error2)))))))),
  enumerateChildren: (path) => pipe(patch8(path, self.patch), flatMap11((patch13) => self.enumerateChildren(patch13)), either2, flatMap11((left3) => pipe(sync(that), flatMap11((that2) => pipe(patch8(path, that2.patch), flatMap11((patch13) => that2.enumerateChildren(patch13)), either2, flatMap11((right3) => {
    if (isLeft2(left3) && isLeft2(right3)) {
      return fail2(And(left3.left, right3.left));
    }
    if (isLeft2(left3) && isRight2(right3)) {
      return succeed(right3.right);
    }
    if (isRight2(left3) && isLeft2(right3)) {
      return succeed(left3.right);
    }
    if (isRight2(left3) && isRight2(right3)) {
      return succeed(pipe(left3.right, union6(right3.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: empty24
});
var within = dual(3, (self, path, f2) => {
  const unnest = reduce3(path, self, (provider, name) => unnested2(provider, name));
  const nest = reduceRight(path, f2(unnest), (provider, name) => nested2(provider, name));
  return orElse4(nest, () => self);
});
var splitPathString = (text, delim) => {
  const split6 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split6;
};
var parsePrimitive = (text, path, primitive2, delimiter, split6) => {
  if (!split6) {
    return pipe(primitive2.parse(text), mapBoth3({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char2) => primitive2.parse(char2.trim())), mapError(prefixed(path)));
};
var transpose = (array7) => {
  return Object.keys(array7[0]).map((column) => array7.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth3({
  onFailure: () => empty3(),
  onSuccess: sort(Order)
}), either2, map14(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match28 = str.match(QUOTED_INDEX_REGEX);
  if (match28 !== null) {
    const matchedIndex = match28[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap2(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId13 = Symbol.for("effect/Console");
var consoleTag = GenericTag("effect/Console");
var defaultConsole = {
  [TypeId13]: TypeId13,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = Symbol.for(RandomSymbolKey);
var randomTag = GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map14(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min9, max11) {
    return map14(this.next, (n) => (max11 - min9) * n + min9);
  }
  nextIntBetween(min9, max11) {
    return sync(() => this.PRNG.integer(max11 - min9) + min9);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap11((buffer3) => {
    const numbers = [];
    for (let i = buffer3.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map14((k2) => swap(buffer3, n - 1, k2)))), as3(fromIterable2(buffer3)));
  })));
};
var swap = (buffer3, index1, index2) => {
  const tmp = buffer3[index1];
  buffer3[index1] = buffer3[index2];
  buffer3[index2] = tmp;
  return buffer3;
};
var make26 = (seed) => new RandomImpl(hash(seed));
var FixedRandomImpl = class {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values7) {
    this.values = values7;
    if (values7.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value6 = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value6;
  }
  get next() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number") {
        return Math.max(0, Math.min(1, value6));
      }
      return hash(value6) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "boolean") {
        return value6;
      }
      return hash(value6) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.round(value6);
      }
      return Math.abs(hash(value6));
    });
  }
  nextRange(min9, max11) {
    return map14(this.next, (n) => (max11 - min9) * n + min9);
  }
  nextIntBetween(min9, max11) {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.max(min9, Math.min(max11 - 1, Math.round(value6)));
      }
      const hash4 = Math.abs(hash(value6));
      return min9 + hash4 % (max11 - min9);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var fixed = (values7) => new FixedRandomImpl(values7);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = Symbol.for("effect/Tracer");
var make27 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = GenericTag("effect/Tracer");
var spanTag = GenericTag("effect/ParentSpan");
var randomHexString = function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length4) {
    let result = "";
    for (let i = 0; i < length4; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context10, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context10;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value6) {
    this.attributes.set(key, value6);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = make27({
  span: (name, parent, context10, links, startTime, kind) => new NativeSpan(name, parent, context10, links, startTime, kind),
  context: (f2) => f2()
});
var DisablePropagation = Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = pipe(empty5(), add2(clockTag, make23()), add2(consoleTag, defaultConsole), add2(randomTag, make26(Math.random())), add2(configProviderTag, fromEnv()), add2(tracerTag, nativeTracer));
var currentServices = globalValue(Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration3) => {
  const decodedDuration = decode(duration3);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f2) => withFiberRuntime((fiber) => f2(fiber.currentDefaultServices));
var clockWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = clockWith((clock3) => clock3.currentTimeNanos);
var withClock = dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect4));
var withConfigProvider = dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
var configProviderWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_2) => _2.load(config2));
var randomWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(randomTag.key)));
var withRandom = dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add2(randomTag, value6))(effect4));
var next = randomWith((random3) => random3.next);
var nextInt = randomWith((random3) => random3.nextInt);
var nextBoolean = randomWith((random3) => random3.nextBoolean);
var tracerWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(tracerTag.key)));
var withTracer = dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add2(tracerTag, value6))(effect4));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var clockWith2 = clockWith;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty25() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym = Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = dual(3, (self, fiberId3, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol3](fiberId3)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId3, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch13 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch13)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol3](fiberId3)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId3, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = dual(2, (self, childId) => {
  const map40 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map40, childId);
  return new FiberRefsImpl(map40);
});
var unsafeForkAs = (self, map40, fiberId3) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map40.set(fiberRef, stack);
    } else {
      map40.set(fiberRef, [[fiberId3, newValue], ...stack]);
    }
  });
};
var delete_ = dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get10 = dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = dual(2, (self, fiberRef) => pipe(get10(self, fiberRef), getOrElse2(() => fiberRef.initial)));
var updateAs = dual(2, (self, {
  fiberId: fiberId3,
  fiberRef,
  value: value6
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId3, value6]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId3, fiberRef, value6);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId3, fiberRef, value6) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol3](fiberId3)) {
      if (equals(currentValue, value6)) {
        return;
      } else {
        newStack = [[fiberId3, value6], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId3, value6], ...oldStack];
    }
  } else {
    newStack = [[fiberId3, value6]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = dual(2, (self, {
  entries: entries3,
  forkAs: forkAs2
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self, locals, forkAs2);
  }
  entries3.forEach(([fiberRef, values7]) => {
    if (values7.length === 1) {
      unsafeUpdateAs(locals, values7[0][0], fiberRef, values7[0][1]);
    } else {
      values7.forEach(([fiberId3, value6]) => {
        unsafeUpdateAs(locals, fiberId3, fiberRef, value6);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberRefs.js
var delete_2 = delete_;
var getOrDefault2 = getOrDefault;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty26 = empty25;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var locally = dual(2, (use, self) => fiberRefLocally(use, currentLogLevel, self));
var Order5 = pipe(Order, mapInput3((level) => level.ordinal));
var lessThan6 = lessThan(Order5);
var lessThanEqual = lessThanOrEqualTo(Order5);
var greaterThan6 = greaterThan(Order5);
var greaterThanEqual = greaterThanOrEqualTo(Order5);
var fromLiteral = (literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/logSpan.js
var make28 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now3) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now3 - self.startTime}ms`;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/LogSpan.js
var make29 = make28;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base3 = Base2;
var Class2 = class extends Base3 {
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Readable.js
var TypeId14 = Symbol.for("effect/Readable");
var Proto = {
  [TypeId14]: TypeId14,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make30 = (get34) => {
  const self = Object.create(Proto);
  self.get = get34;
  return self;
};
var map16 = dual(2, (self, f2) => make30(map14(self.get, f2)));
var mapEffect = dual(2, (self, f2) => make30(flatMap11(self.get, f2)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var RefImpl = class extends Class2 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId14] = TypeId14;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get7(this.ref));
  }
  get;
  modify(f2) {
    return sync(() => {
      const current2 = get7(this.ref);
      const [b2, a] = f2(current2);
      if (current2 !== a) {
        set3(a)(this.ref);
      }
      return b2;
    });
  }
};
var unsafeMake6 = (value6) => new RefImpl(make13(value6));
var make31 = (value6) => sync(() => unsafeMake6(value6));
var get11 = (self) => self.get;
var set6 = dual(2, (self, value6) => self.modify(() => [void 0, value6]));
var getAndSet2 = dual(2, (self, value6) => self.modify((a) => [a, value6]));
var getAndUpdate2 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome = dual(2, (self, pf) => self.modify((value6) => {
  const option6 = pf(value6);
  switch (option6._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [value6, option6.value];
    }
  }
}));
var setAndGet2 = dual(2, (self, value6) => self.modify(() => [value6, value6]));
var modify6 = dual(2, (self, f2) => self.modify(f2));
var modifySome = dual(3, (self, fallback, pf) => self.modify((value6) => {
  const option6 = pf(value6);
  switch (option6._tag) {
    case "None": {
      return [fallback, value6];
    }
    case "Some": {
      return option6.value;
    }
  }
}));
var update3 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet2 = dual(2, (self, f2) => self.modify((a) => {
  const result = f2(a);
  return [result, result];
}));
var updateSome = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b2) => b2
})]));
var updateSomeAndGet = dual(2, (self, pf) => self.modify((value6) => {
  const option6 = pf(value6);
  switch (option6._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [option6.value, option6.value];
    }
  }
}));
var unsafeGet7 = (self) => get7(self.ref);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make32 = make31;
var get12 = get11;
var getAndSet3 = getAndSet2;
var modify7 = modify6;
var set7 = set6;
var update4 = update3;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty27 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch13 = empty27;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch13 = combine12({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch13);
      }
    } else {
      patch13 = combine12({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch13);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch13 = combine12({
      _tag: OP_REMOVE,
      fiberRef
    })(patch13);
  }
  return patch13;
};
var combine12 = dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch9 = dual(3, (self, fiberId3, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head8 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head8._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head8.fiberRef,
          value: head8.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head8.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value6 = getOrDefault(fiberRefs3, head8.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head8.fiberRef,
          value: head8.fiberRef.patch(head8.patch)(value6)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend2(head8.first)(prepend2(head8.second)(tail));
        break;
      }
    }
  }
  return fiberRefs3;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value6) {
    this.key = key;
    this.value = value6;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make33 = (key, value6) => {
  return new MetricLabelImpl(key, value6);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set4(acc, key, value6), annotations3));
});
var asSome = (self) => map14(self, some2);
var try_2 = (arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error2) {
      return fail2(onFailure ? internalCall(() => onFailure(error2)) : new UnknownException(error2, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = dual(3, (self, tag3, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag3) && e[tag3] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = dual(2, (self, f2) => catchAllCause(self, (cause2) => {
  const option6 = find(cause2, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option6._tag) {
    case "None": {
      return failCause(cause2);
    }
    case "Some": {
      return f2(option6.value.defect);
    }
  }
}));
var catchSomeCause = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const option6 = f2(cause2);
    switch (option6._tag) {
      case "None": {
        return failCause(cause2);
      }
      case "Some": {
        return option6.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = dual(2, (self, pf) => catchAllCause(self, (cause2) => {
  const option6 = find(cause2, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option6._tag) {
    case "None": {
      return failCause(cause2);
    }
    case "Some": {
      const optionEffect = pf(option6.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause2);
    }
  }
}));
var catchTag = dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f2 = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag3 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag3) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag3) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f2);
});
var catchTags = dual(2, (self, cases) => {
  let keys10;
  return catchIf(self, (e) => {
    keys10 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys10.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var clockWith3 = clockWith2;
var clock = clockWith3(succeed);
var delay2 = dual(2, (self, duration3) => zipRight2(sleep2(duration3), self));
var descriptorWith = (f2) => withFiberRuntime((state, status2) => f2({
  id: state.id(),
  status: status2,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = descriptorWith((descriptor2) => size3(descriptor2.interruptors) > 0 ? interrupt2 : void_3);
var descriptor = descriptorWith(succeed);
var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff8);
var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip5(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do4 = succeed({});
var bind5 = bind(map14, flatMap11);
var bindTo5 = bindTo(map14);
var let_5 = let_(map14);
var dropUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next5;
  let dropping7 = succeed(false);
  let i = 0;
  while ((next5 = iterator.next()) && !next5.done) {
    const a = next5.value;
    const index = i++;
    dropping7 = flatMap11(dropping7, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map14(dropping7, () => builder);
}));
var dropWhile3 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next5;
  let dropping7 = succeed(true);
  let i = 0;
  while ((next5 = iterator.next()) && !next5.done) {
    const a = next5.value;
    const index = i++;
    dropping7 = flatMap11(dropping7, (d) => map14(d ? predicate(a, index) : succeed(false), (b2) => {
      if (!b2) {
        builder.push(a);
      }
      return b2;
    }));
  }
  return map14(dropping7, () => builder);
}));
var contextWith = (f2) => map14(context2(), f2);
var eventually = (self) => orElse3(self, () => flatMap11(yieldNow(), () => eventually(self)));
var filterMap8 = dual(2, (elements, pf) => map14(forEachSequential(elements, identity), filterMap4(pf)));
var filterOrDie = dual(3, (self, predicate, orDieWith5) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith5(a))));
var filterOrDieMessage = dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = dual(3, (self, predicate, orElse15) => flatMap11(self, (a) => predicate(a) ? succeed(a) : orElse15(a)));
var liftPredicate3 = dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
var filterOrFail = dual((args2) => isEffect(args2[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst7 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next5 = iterator.next();
  if (!next5.done) {
    return findLoop(iterator, 0, predicate, next5.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f2, value6) => flatMap11(f2(value6, index), (result) => {
  if (result) {
    return succeed(some2(value6));
  }
  const next5 = iterator.next();
  if (!next5.done) {
    return findLoop(iterator, index + 1, f2, next5.value);
  }
  return succeed(none2());
});
var flipWith = dual(2, (self, f2) => flip(f2(flip(self))));
var match8 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every8 = dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f2) => {
  const next5 = iterator.next();
  return next5.done ? succeed(true) : flatMap11(f2(next5.value, index), (b2) => b2 ? forAllLoop(iterator, index + 1, f2) : succeed(b2));
};
var forever = (self) => {
  const loop3 = flatMap11(flatMap11(self, () => yieldNow()), () => loop3);
  return loop3;
};
var fiberRefs2 = withFiberRuntime((state) => succeed(state.getFiberRefs()));
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable2(level);
  let cause2 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== void 0) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === void 0) {
    cause2 = empty21;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_3;
  });
};
var log = logWithLevel();
var logTrace = logWithLevel(Trace);
var logDebug = logWithLevel(Debug);
var logInfo = logWithLevel(Info);
var logWarning = logWithLevel(Warning);
var logError = logWithLevel(Error2);
var logFatal = logWithLevel(Fatal);
var withLogSpan = dual(2, (effect4, label) => flatMap11(currentTimeMillis2, (now3) => fiberRefLocallyWith(effect4, currentLogSpan, prepend4(make29(label, now3)))));
var logAnnotations = fiberRefGet(currentLogAnnotations);
var mapAccum3 = dual(3, (elements, initial, f2) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next5;
  let i = 0;
  while (!(next5 = iterator.next()).done) {
    const index = i++;
    const value6 = next5.value;
    result = flatMap11(result, (state) => map14(f2(state, value6, index), ([z2, b2]) => {
      builder.push(b2);
      return z2;
    }));
  }
  return map14(result, (z2) => [z2, builder]);
}));
var mapErrorCause = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f2(c)),
  onSuccess: succeed
}));
var memoize = (self) => pipe(deferredMake(), flatMap11((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map14((complete4) => zipRight2(complete4, pipe(deferredAwait(deferred), flatMap11(([patch13, a]) => as3(zip5(patchFiberRefs(patch13[0]), updateRuntimeFlags(patch13[1])), a))))))));
var negate = (self) => map14(self, (b2) => !b2);
var once = (self) => map14(make32(true), (ref) => asVoid2(whenEffect(self, getAndSet3(ref, false))));
var orElseFail = dual(2, (self, evaluate3) => orElse3(self, () => failSync(evaluate3)));
var orElseSucceed = dual(2, (self, evaluate3) => orElse3(self, () => sync(evaluate3)));
var patchFiberRefs = (patch13) => updateFiberRefs((fiberId3, fiberRefs3) => pipe(patch13, patch9(fiberId3, fiberRefs3)));
var provideService = dual(3, (self, tag3, service3) => contextWithEffect((env) => provideContext(self, add2(env, tag3, service3))));
var provideServiceEffect = dual(3, (self, tag3, effect4) => contextWithEffect((env) => flatMap11(effect4, (service3) => provideContext(self, pipe(env, add2(tag3, service3))))));
var random2 = randomWith(succeed);
var reduce12 = dual(3, (elements, zero3, f2) => fromIterable(elements).reduce((acc, el, i) => flatMap11(acc, (a) => f2(a, el, i)), succeed(zero3)));
var reduceRight4 = dual(3, (elements, zero3, f2) => fromIterable(elements).reduceRight((acc, el, i) => flatMap11(acc, (a) => f2(el, a, i)), succeed(zero3)));
var reduceWhile = dual(3, (elements, zero3, options) => flatMap11(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f2) => {
  const next5 = iterator.next();
  if (!next5.done && predicate(state)) {
    return flatMap11(f2(state, next5.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f2));
  }
  return succeed(state);
};
var repeatN = dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap11(self, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self, n - 1)));
var sleep3 = sleep2;
var succeedNone = succeed(none2());
var summarized = dual(3, (self, summary6, f2) => flatMap11(summary6, (start5) => flatMap11(self, (value6) => map14(summary6, (end6) => [f2(start5, end6), value6]))));
var tagMetrics = dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make33(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k2, v2]) => make33(k2, v2)));
});
var labelMetrics = dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union2(old, labels)));
var takeUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next5;
  let effect4 = succeed(false);
  let i = 0;
  while ((next5 = iterator.next()) && !next5.done) {
    const a = next5.value;
    const index = i++;
    effect4 = flatMap11(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map14(effect4, () => builder);
}));
var takeWhile4 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next5;
  let taking = succeed(true);
  let i = 0;
  while ((next5 = iterator.next()) && !next5.done) {
    const a = next5.value;
    const index = i++;
    taking = flatMap11(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map14((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map14(taking, () => builder);
}));
var tapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const either8 = failureOrCause(cause2);
    switch (either8._tag) {
      case "Left": {
        return zipRight2(onFailure(either8.left), failCause(cause2));
      }
      case "Right": {
        return failCause(cause2);
      }
    }
  },
  onSuccess: (a) => as3(onSuccess(a), a)
}));
var tapDefect = dual(2, (self, f2) => catchAllCause(self, (cause2) => match2(keepDefects(cause2), {
  onNone: () => failCause(cause2),
  onSome: (a) => zipRight2(f2(a), failCause(cause2))
})));
var tapError = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const either8 = failureOrCause(cause2);
    switch (either8._tag) {
      case "Left":
        return zipRight2(f2(either8.left), failCause(cause2));
      case "Right":
        return failCause(cause2);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = dual(3, (self, k2, f2) => tapError(self, (e) => {
  if (isTagged(e, k2)) {
    return f2(e);
  }
  return void_3;
}));
var tapErrorCause = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause2) => zipRight2(f2(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var timedWith = dual(2, (self, nanos2) => summarized(self, nanos2, (start5, end6) => nanos(end6 - start5)));
var tracerWith3 = tracerWith2;
var tracer = tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail20 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate3.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail20(e)));
      } catch (e) {
        resolve(fail20(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate3().then((a) => resolve(succeed(a)), (e) => resolve(fail20(e)));
    } catch (e) {
      resolve(fail20(e));
    }
  });
};
var tryMap = dual(2, (self, options) => flatMap11(self, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = dual(2, (self, options) => flatMap11(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = dual(2, (self, condition) => flatMap11(condition, (b2) => b2 ? succeedNone : asSome(self)));
var updateFiberRefs = (f2) => withFiberRuntime((state) => {
  state.setFiberRefs(f2(state.id(), state.getFiberRefs()));
  return void_3;
});
var updateService = dual(3, (self, tag3, f2) => mapInputContext(self, (context10) => add2(context10, tag3, f2(unsafeGet3(context10, tag3)))));
var when = dual(2, (self, condition) => suspend(() => condition() ? map14(self, some2) : succeed(none2())));
var whenFiberRef = dual(3, (self, fiberRef, predicate) => flatMap11(fiberRefGet(fiberRef), (s) => predicate(s) ? map14(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = dual(3, (self, ref, predicate) => flatMap11(get12(ref), (s) => predicate(s) ? map14(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = dual(2, (self, metric) => metric(self));
var serviceOptional = (tag3) => flatMap11(context2(), getOption2(tag3));
var annotateSpans = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set4(acc, key, value6), annotations3));
});
var currentParentSpan = serviceOptional(spanTag);
var currentSpan = flatMap11(context2(), (context10) => {
  const span3 = context10.unsafeMap.get(spanTag.key);
  return span3 !== void 0 && span3._tag === "Span" ? succeed(span3) : fail2(new NoSuchElementException());
});
var linkSpans = dual((args2) => isEffect(args2[0]), (self, span3, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append3({
  _tag: "SpanLink",
  span: span3,
  attributes: attributes ?? {}
})));
var bigint04 = BigInt(0);
var filterDisablePropagation = flatMap2((span3) => get4(span3.context, DisablePropagation) ? span3._tag === "Span" ? filterDisablePropagation(span3.parent) : none2() : some2(span3));
var spanAnnotations = fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = fiberRefGet(currentTracerSpanLinks);
var withParentSpan = dual(2, (self, span3) => provideService(self, spanTag, span3));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;
var match9 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_SEQUENTIAL2: {
      return options.onSequential();
    }
    case OP_PARALLEL2: {
      return options.onParallel();
    }
    case OP_PARALLEL_N: {
      return options.onParallelN(self.parallelism);
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9 = diff8;
var patch10 = patch9;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = string2(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol2]() {
    return DoneHash;
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol2]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol2]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), combine2(hash(this.blockingOn)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;
var isSuspended = (self) => self._tag === OP_SUSPENDED;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;
var isSuspended2 = isSuspended;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Micro.js
var TypeId15 = Symbol.for("effect/Micro");
var MicroExitTypeId = Symbol.for("effect/Micro/MicroExit");
var isMicro = (u) => typeof u === "object" && u !== null && TypeId15 in u;
var MicroCauseTypeId = Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Fail = class extends MicroCauseImpl {
  error;
  constructor(error2, traces = []) {
    super("Fail", error2, traces);
    this.error = error2;
  }
};
var causeFail = (error2, traces = []) => new Fail(error2, traces);
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsFail = (self) => self._tag === "Fail";
var causeIsDie = (self) => self._tag === "Die";
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var causeWithTrace = dual(2, (self, trace2) => {
  const traces = [...self.traces, trace2];
  switch (self._tag) {
    case "Die":
      return causeDie(self.defect, traces);
    case "Interrupt":
      return causeInterrupt(traces);
    case "Fail":
      return causeFail(self.error, traces);
  }
});
var MicroFiberTypeId = Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context10, interruptible5 = true) {
    this.context = context10;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap12(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap12(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error2) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error2);
    }
  }
  getCont(symbol5) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol5]: cont
      };
      if (op[symbol5]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value6) {
    this._yielded = value6;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberAwait = (self) => async((resume2) => sync2(self.addObserver((exit4) => resume2(succeed4(exit4)))));
var fiberInterrupt = (self) => suspend2(() => {
  self.unsafeInterrupt();
  return asVoid3(fiberAwait(self));
});
var fiberInterruptAll = (fibers2) => suspend2(() => {
  for (const fiber of fibers2) fiber.unsafeInterrupt();
  const iter = fibers2[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_2) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
});
var identifier = Symbol.for("effect/Micro/identifier");
var args = Symbol.for("effect/Micro/args");
var evaluate = Symbol.for("effect/Micro/evaluate");
var successCont = Symbol.for("effect/Micro/successCont");
var failureCont = Symbol.for("effect/Micro/failureCont");
var ensureCont = Symbol.for("effect/Micro/ensureCont");
var Yield = Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId15]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto8 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto8);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options) => {
  const Proto8 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol3](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol2]() {
      return cached(this, combine2(string2(options.op))(hash(this[args])));
    }
  };
  return function(value6) {
    const self = Object.create(Proto8);
    self[args] = value6;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed4 = makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause4 = makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var fail5 = (error2) => failCause4(causeFail(error2));
var sync2 = makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value6 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value6, fiber) : fiber.yieldWith(exitSucceed2(value6));
  }
});
var suspend2 = makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = yieldNowWith(0);
var succeedNone2 = succeed4(none2());
var void_5 = succeed4(void 0);
var withMicroFiber = makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var yieldFlush = withMicroFiber((fiber) => {
  fiber.getRef(CurrentScheduler).flush();
  return exitVoid2;
});
var asyncOptions = makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause2, _fiber) {
    return causeIsInterrupt(cause2) ? flatMap12(this[args](), () => failCause4(cause2)) : failCause4(cause2);
  }
});
var async = (register) => asyncOptions(register, register.length >= 2);
var never2 = async(function() {
  const interval = setInterval(constVoid, 2147483646);
  return sync2(() => clearInterval(interval));
});
var fromIterator2 = makePrimitive({
  op: "Iterator",
  contA(value6, fiber) {
    const state = this[args].next(value6);
    if (state.done) return succeed4(state.value);
    fiber._stack.push(this);
    return yieldWrapGet(state.value);
  },
  eval(fiber) {
    return this[successCont](void 0, fiber);
  }
});
var as4 = dual(2, (self, value6) => map17(self, (_2) => value6));
var asSome2 = (self) => map17(self, some2);
var andThen7 = dual(2, (self, f2) => flatMap12(self, (a) => {
  const value6 = isMicro(f2) ? f2 : typeof f2 === "function" ? f2(a) : f2;
  return isMicro(value6) ? value6 : succeed4(value6);
}));
var tap3 = dual(2, (self, f2) => flatMap12(self, (a) => {
  const value6 = isMicro(f2) ? f2 : typeof f2 === "function" ? f2(a) : f2;
  return isMicro(value6) ? as4(value6, a) : succeed4(a);
}));
var asVoid3 = (self) => flatMap12(self, (_2) => exitVoid2);
var exit2 = (self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
});
var raceAll = (all11) => withMicroFiber((parent) => async((resume2) => {
  const effects = fromIterable(all11);
  const len = effects.length;
  let doneCount = 0;
  let done14 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const causes = [];
  const onExit3 = (exit4) => {
    doneCount++;
    if (exit4._tag === "Failure") {
      causes.push(exit4.cause);
      if (doneCount >= len) {
        resume2(failCause4(causes[0]));
      }
      return;
    }
    done14 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap12(uninterruptible2(fiberInterruptAll(fibers2)), () => exit4));
  };
  for (let i = 0; i < len; i++) {
    if (done14) break;
    const fiber = unsafeFork(parent, interruptible3(effects[i]), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit3(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var raceAllFirst = (all11) => withMicroFiber((parent) => async((resume2) => {
  let done14 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const onExit3 = (exit4) => {
    done14 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap12(fiberInterruptAll(fibers2), () => exit4));
  };
  for (const effect4 of all11) {
    if (done14) break;
    const fiber = unsafeFork(parent, interruptible3(effect4), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit3(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var race = dual(2, (self, that) => raceAll([self, that]));
var raceFirst = dual(2, (self, that) => raceAllFirst([self, that]));
var flatMap12 = dual(2, (self, f2) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f2;
  return onSuccess;
});
var OnSuccessProto = makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map17 = dual(2, (self, f2) => flatMap12(self, (a) => succeed4(f2(a))));
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed4;
var exitFailCause2 = failCause4;
var exitInterrupt2 = exitFailCause2(causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitIsFailure2 = (self) => self._tag === "Failure";
var exitIsInterrupt = (self) => exitIsFailure2(self) && self.cause._tag === "Interrupt";
var exitVoid2 = exitSucceed2(void 0);
var exitVoidAll = (exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
};
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f2) => setTimeout(f2, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var service = (tag3) => withMicroFiber((fiber) => succeed4(unsafeGet3(fiber.context, tag3)));
var updateContext = dual(2, (self, f2) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f2(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_5;
  });
}));
var updateService2 = dual(3, (self, tag3, f2) => withMicroFiber((fiber) => {
  const prev = unsafeGet3(fiber.context, tag3);
  fiber.context = add2(fiber.context, tag3, f2(prev));
  return onExit2(self, () => {
    fiber.context = add2(fiber.context, tag3, prev);
    return void_5;
  });
}));
var getContext = withMicroFiber((fiber) => succeed4(fiber.context));
var provideContext2 = dual(2, (self, provided) => updateContext(self, merge3(provided)));
var provideService2 = dual(3, (self, tag3, service3) => updateContext(self, add2(tag3, service3)));
var provideServiceEffect2 = dual(3, (self, tag3, acquire3) => flatMap12(acquire3, (service3) => provideService2(self, tag3, service3)));
var MaxOpsBeforeYield = class extends Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
}) {
};
var CurrentConcurrency = class extends Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
}) {
};
var CurrentScheduler = class extends Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
}) {
};
var withConcurrency2 = dual(2, (self, concurrency) => provideService2(self, CurrentConcurrency, concurrency));
var zip7 = dual((args2) => isMicro(args2[1]), (self, that, options) => zipWith8(self, that, (a, a2) => [a, a2], options));
var zipWith8 = dual((args2) => isMicro(args2[1]), (self, that, f2, options) => options?.concurrent ? map17(all4([self, that], {
  concurrency: 2
}), ([a, a2]) => f2(a, a2)) : flatMap12(self, (a) => map17(that, (a2) => f2(a, a2))));
var filterOrFailCause = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap12(self, (a) => refinement(a) ? succeed4(a) : failCause4(orFailWith(a))));
var filterOrFail2 = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap12(self, (a) => refinement(a) ? succeed4(a) : fail5(orFailWith(a))));
var when2 = dual(2, (self, condition) => flatMap12(isMicro(condition) ? condition : sync2(condition), (pass) => pass ? asSome2(self) : succeedNone2));
var repeatExit = dual(2, (self, options) => suspend2(() => {
  const startedAt = options.schedule ? Date.now() : 0;
  let attempt2 = 0;
  const loop3 = flatMap12(exit2(self), (exit4) => {
    if (options.while !== void 0 && !options.while(exit4)) {
      return exit4;
    } else if (options.times !== void 0 && attempt2 >= options.times) {
      return exit4;
    }
    attempt2++;
    let delayEffect = yieldNow2;
    if (options.schedule !== void 0) {
      const elapsed2 = Date.now() - startedAt;
      const duration3 = options.schedule(attempt2, elapsed2);
      if (isNone2(duration3)) {
        return exit4;
      }
      delayEffect = sleep4(duration3.value);
    }
    return flatMap12(delayEffect, () => loop3);
  });
  return loop3;
}));
var repeat = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Success" && (options?.while === void 0 || options.while(exit4.value))
}));
var replicate3 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = dual((args2) => isMicro(args2[0]), (self, n, options) => all4(replicate3(self, n), options));
var scheduleAddDelay = dual(2, (self, f2) => (attempt2, elapsed2) => map2(self(attempt2, elapsed2), (duration3) => duration3 + f2()));
var scheduleWithMaxDelay = dual(2, (self, max11) => (attempt2, elapsed2) => map2(self(attempt2, elapsed2), (duration3) => Math.min(duration3, max11)));
var scheduleWithMaxElapsed = dual(2, (self, max11) => (attempt2, elapsed2) => elapsed2 < max11 ? self(attempt2, elapsed2) : none2());
var scheduleUnion = dual(2, (self, that) => (attempt2, elapsed2) => zipWith2(self(attempt2, elapsed2), that(attempt2, elapsed2), (d1, d2) => Math.min(d1, d2)));
var scheduleIntersect = dual(2, (self, that) => (attempt2, elapsed2) => zipWith2(self(attempt2, elapsed2), that(attempt2, elapsed2), (d1, d2) => Math.max(d1, d2)));
var catchAllCause2 = dual(2, (self, f2) => {
  const onFailure = Object.create(OnFailureProto);
  onFailure[args] = self;
  onFailure[failureCont] = f2;
  return onFailure;
});
var OnFailureProto = makePrimitiveProto({
  op: "OnFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var catchCauseIf = dual(3, (self, predicate, f2) => catchAllCause2(self, (cause2) => predicate(cause2) ? f2(cause2) : failCause4(cause2)));
var catchAll2 = dual(2, (self, f2) => catchCauseIf(self, causeIsFail, (cause2) => f2(cause2.error)));
var catchAllDefect2 = dual(2, (self, f2) => catchCauseIf(self, causeIsDie, (die12) => f2(die12.defect)));
var tapErrorCause2 = dual(2, (self, f2) => tapErrorCauseIf(self, constTrue, f2));
var tapErrorCauseIf = dual(3, (self, refinement, f2) => catchCauseIf(self, refinement, (cause2) => andThen7(f2(cause2), failCause4(cause2))));
var tapError2 = dual(2, (self, f2) => tapErrorCauseIf(self, causeIsFail, (fail20) => f2(fail20.error)));
var tapDefect2 = dual(2, (self, f2) => tapErrorCauseIf(self, causeIsDie, (die12) => f2(die12.defect)));
var catchIf2 = dual(3, (self, predicate, f2) => catchCauseIf(self, (f3) => causeIsFail(f3) && predicate(f3.error), (fail20) => f2(fail20.error)));
var catchTag2 = dual(3, (self, k2, f2) => catchIf2(self, isTagged(k2), f2));
var mapErrorCause2 = dual(2, (self, f2) => catchAllCause2(self, (cause2) => failCause4(f2(cause2))));
var mapError2 = dual(2, (self, f2) => catchAll2(self, (error2) => fail5(f2(error2))));
var orElseSucceed2 = dual(2, (self, f2) => catchAll2(self, (_2) => sync2(f2)));
var retry = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Failure" && exit4.cause._tag === "Fail" && (options?.while === void 0 || options.while(exit4.cause.error))
}));
var matchCauseEffect2 = dual(2, (self, options) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self;
  primitive2[successCont] = options.onSuccess;
  primitive2[failureCont] = options.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause2) => sync2(() => options.onFailure(cause2)),
  onSuccess: (value6) => sync2(() => options.onSuccess(value6))
}));
var matchEffect3 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause2) => cause2._tag === "Fail" ? options.onFailure(cause2.error) : failCause4(cause2),
  onSuccess: options.onSuccess
}));
var match10 = dual(2, (self, options) => matchEffect3(self, {
  onFailure: (error2) => sync2(() => options.onFailure(error2)),
  onSuccess: (value6) => sync2(() => options.onSuccess(value6))
}));
var sleep4 = (millis2) => async((resume2) => {
  const timeout4 = setTimeout(() => {
    resume2(void_5);
  }, millis2);
  return sync2(() => {
    clearTimeout(timeout4);
  });
});
var delay3 = dual(2, (self, millis2) => andThen7(sleep4(millis2), self));
var timeoutOrElse = dual(2, (self, options) => raceFirst(self, andThen7(interruptible3(sleep4(options.duration)), options.onTimeout)));
var timeout = dual(2, (self, millis2) => timeoutOrElse(self, {
  duration: millis2,
  onTimeout: () => fail5(new TimeoutException2())
}));
var timeoutOption = dual(2, (self, millis2) => raceFirst(asSome2(self), as4(interruptible3(sleep4(millis2)), none2())));
var MicroScopeTypeId = Symbol.for("effect/Micro/MicroScope");
var MicroScope = GenericTag("effect/Micro/MicroScope");
var MicroScopeImpl = class _MicroScopeImpl {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer2) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer2);
    }
  }
  addFinalizer(finalizer2) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer2);
        return void_5;
      }
      return finalizer2(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer2) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer2);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap12(forEach11(finalizers, (finalizer2) => exit2(finalizer2(microExit))), exitVoidAll);
      }
      return void_5;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_2) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var scopeMake = sync2(() => new MicroScopeImpl());
var scope = service(MicroScope);
var provideScope = dual(2, (self, scope5) => provideService2(self, MicroScope, scope5));
var onExit2 = dual(2, (self, f2) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause2) => flatMap12(f2(exitFailCause2(cause2)), () => failCause4(cause2)),
  onSuccess: (a) => flatMap12(f2(exitSucceed2(a)), () => succeed4(a))
})));
var ensuring = dual(2, (self, finalizer2) => onExit2(self, (_2) => finalizer2));
var onExitIf = dual(3, (self, refinement, f2) => onExit2(self, (exit4) => refinement(exit4) ? f2(exit4) : exitVoid2));
var onError2 = dual(2, (self, f2) => onExitIf(self, exitIsFailure2, (exit4) => f2(exit4.cause)));
var onInterrupt2 = dual(2, (self, finalizer2) => onExitIf(self, exitIsInterrupt, (_2) => finalizer2));
var interrupt5 = failCause4(causeInterrupt());
var uninterruptible2 = (self) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return self;
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return self;
});
var setInterruptible = makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f2) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f2(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f2(interruptible3);
});
var all4 = (arg, options) => {
  if (Array.isArray(arg) || isIterable(arg)) {
    return forEach11(arg, identity, options);
  } else if (options?.discard) {
    return forEach11(Object.values(arg), identity, options);
  }
  return suspend2(() => {
    const out = {};
    return as4(forEach11(Object.entries(arg), ([key, effect4]) => map17(effect4, (value6) => {
      out[key] = value6;
    }), {
      discard: true,
      concurrency: options?.concurrency
    }), out);
  });
};
var whileLoop2 = makePrimitive({
  op: "While",
  contA(value6, fiber) {
    this[args].step(value6);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach11 = (iterable, f2, options) => withMicroFiber((parent) => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable(iterable);
  let length4 = items.length;
  if (length4 === 0) {
    return options?.discard ? void_5 : succeed4([]);
  }
  const out = options?.discard ? void 0 : new Array(length4);
  let index = 0;
  if (concurrency === 1) {
    return as4(whileLoop2({
      while: () => index < items.length,
      body: () => f2(items[index], index),
      step: out ? (b2) => out[index++] = b2 : (_2) => index++
    }), out);
  }
  return async((resume2) => {
    const fibers2 = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted3 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length4) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f2(item, currentIndex), true, true);
          fibers2.add(child);
          child.addObserver((exit4) => {
            fibers2.delete(child);
            if (interrupted3) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length4 = index;
                fibers2.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length4) {
              resume2(result ?? succeed4(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err2) {
          result = exitDie2(err2);
          length4 = index;
          fibers2.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend2(() => {
      interrupted3 = true;
      index = length4;
      return fiberInterruptAll(fibers2);
    });
  });
});
var Do5 = succeed4({});
var bindTo6 = bindTo(map17);
var bind6 = bind(map17, flatMap12);
var let_6 = let_(map17);
var unsafeFork = (parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
};
var forkDaemon = (self) => withMicroFiber((fiber) => succeed4(unsafeFork(fiber, self, false, true)));
var forkIn = dual(2, (self, scope5) => uninterruptibleMask2((restore) => flatMap12(scope5.fork, (scope6) => tap3(restore(forkDaemon(onExit2(self, (exit4) => scope6.close(exit4)))), (fiber) => scope6.addFinalizer((_2) => fiberInterrupt(fiber))))));
var runFork = (effect4, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};
var YieldableError2 = function() {
  class YieldableError3 extends globalThis.Error {
  }
  Object.assign(YieldableError3.prototype, MicroProto, StructuralPrototype, {
    [identifier]: "Failure",
    [evaluate]() {
      return fail5(this);
    },
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    },
    toJSON() {
      return {
        ...this
      };
    },
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}
${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  });
  return YieldableError3;
}();
var Error3 = /* @__PURE__ */ function() {
  return class extends YieldableError2 {
    constructor(args2) {
      super();
      if (args2) {
        Object.assign(this, args2);
      }
    }
  };
}();
var TaggedError = (tag3) => {
  class Base4 extends Error3 {
    _tag = tag3;
  }
  ;
  Base4.prototype.name = tag3;
  return Base4;
};
var NoSuchElementException2 = class extends TaggedError("NoSuchElementException") {
};
var TimeoutException2 = class extends TaggedError("TimeoutException") {
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length4 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length4; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length4) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_2, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = globalValue(Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_2, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = globalValue(Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = dual(2, (self, scheduler2) => fiberRefLocally(self, currentScheduler, scheduler2));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = globalValue(Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/concurrency.js
var match11 = (concurrency, sequential5, unbounded10, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded10();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded10() : concurrency2 > 1 ? bounded8(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var matchSimple = (concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId3, parent) {
    this.fiberId = fiberId3;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake7 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = globalValue(Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = Symbol.for(RuntimeFiberSymbolKey);
var Order6 = pipe(tuple(Order, Order), mapInput3((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await2 = (self) => self.await;
var done5 = (exit4) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join2(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit4),
    children: succeed([]),
    inheritAll: void_3,
    poll: succeed(some2(exit4)),
    interruptAsFork: () => void_3
  };
  return _fiber;
};
var failCause5 = (cause2) => done5(failCause3(cause2));
var inheritAll = (self) => self.inheritAll;
var interruptAllAs = dual(2, fnUntraced(function* (fibers2, fiberId3) {
  for (const fiber of fibers2) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId3);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId3);
  }
  for (const fiber of fibers2) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = dual(2, (self, fiberId3) => self.interruptAsFork(fiberId3));
var join2 = (self) => zipLeft2(flatten7(self.await), self.inheritAll);
var map18 = dual(2, (self, f2) => mapEffect2(self, (a) => sync(() => f2(a))));
var mapEffect2 = dual(2, (self, f2) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join2(this);
    },
    ...fiberProto,
    id: () => self.id(),
    await: flatMap11(self.await, forEachEffect(f2)),
    children: self.children,
    inheritAll: self.inheritAll,
    poll: flatMap11(self.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f2), map14(some2));
      }
    }),
    interruptAsFork: (id2) => self.interruptAsFork(id2)
  };
  return _fiber;
});
var mapFiber = dual(2, (self, f2) => map14(self.await, match7({
  onFailure: (cause2) => failCause5(cause2),
  onSuccess: (a) => f2(a)
})));
var match12 = dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: succeed([]),
  inheritAll: never,
  poll: succeed(none2()),
  interruptAsFork: () => never
};
var orElse5 = dual(2, (self, that) => ({
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => getOrElse5(self.id(), that.id()),
  await: zipWith6(self.await, that.await, (exit1, exit22) => isSuccess(exit1) ? exit1 : exit22),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id2) => pipe(interruptAsFiber(self, id2), zipRight2(pipe(that, interruptAsFiber(id2))), asVoid2)
}));
var orElseEither3 = dual(2, (self, that) => orElse5(map18(self, left2), map18(that, right2)));
var poll3 = (self) => self.poll;
var unsafeRoots = () => Array.from(globalScope.roots);
var roots = sync(unsafeRoots);
var succeed5 = (value6) => done5(succeed3(value6));
var void_6 = succeed5(void 0);
var currentFiberURI = "effect/FiberCurrent";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_2) => _2,
  /* c8 ignore next */
  _Output: (_2) => _2
};
var makeLogger = (log3) => ({
  [LoggerTypeId]: loggerVariance,
  log: log3,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var mapInput4 = dual(2, (self, f2) => makeLogger((options) => self.log({
  ...options,
  message: f2(options.message)
})));
var mapInputOptions = dual(2, (self, f2) => makeLogger((options) => self.log(f2(options))));
var filterLogLevel = dual(2, (self, f2) => makeLogger((options) => f2(options.logLevel) ? some2(self.log(options)) : none2()));
var map19 = dual(2, (self, f2) => makeLogger((options) => f2(self.log(options))));
var none6 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var zip8 = dual(2, (self, that) => makeLogger((options) => [self.log(options), that.log(options)]));
var zipLeft3 = dual(2, (self, that) => map19(zip8(self, that), (tuple4) => tuple4[0]));
var zipRight4 = dual(2, (self, that) => map19(zip8(self, that), (tuple4) => tuple4[1]));
var textOnly = /^[^\s"=]*$/;
var format4 = (quoteValue, whitespace) => ({
  annotations: annotations3,
  cause: cause2,
  date: date3,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const formatValue = (value6) => value6.match(textOnly) ? value6 : quoteValue(value6);
  const format7 = (label, value6) => `${formatLabel(label)}=${formatValue(value6)}`;
  const append6 = (label, value6) => " " + format7(label, value6);
  let out = format7("timestamp", date3.toISOString());
  out += append6("level", logLevel2.label);
  out += append6("fiber", threadName(fiberId3));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append6("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span3 of spans) {
    out += " " + render(date3.getTime())(span3);
  }
  for (const [label, value6] of annotations3) {
    out += append6(label, toStringUnknown(value6, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = makeLogger(format4(escapeDoubleQuotes));
var logfmtLogger = makeLogger(format4(JSON.stringify, 0));
var structuredLogger = makeLogger(({
  annotations: annotations3,
  cause: cause2,
  date: date3,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const now3 = date3.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size4(annotations3) > 0) {
    for (const [k2, v2] of annotations3) {
      annotationsObj[k2] = structuredMessage(v2);
    }
  }
  if (isCons(spans)) {
    for (const span3 of spans) {
      spansObj[span3.label] = now3 - span3.startTime;
    }
  }
  const messageArr = ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel2.label,
    timestamp: date3.toISOString(),
    cause: isEmpty5(cause2) ? void 0 : pretty(cause2, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId3)
  };
});
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var jsonLogger = map19(structuredLogger, stringifyCircular);
var withColor = (text, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date3) => `${date3.getHours().toString().padStart(2, "0")}:${date3.getMinutes().toString().padStart(2, "0")}:${date3.getSeconds().toString().padStart(2, "0")}.${date3.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode_ = options?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options?.colors === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = options?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options?.stderr === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations3,
    cause: cause2,
    context: context10,
    date: date3,
    fiberId: fiberId3,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context10, currentServices);
    const console3 = get4(services, consoleTag).unsafe;
    const log3 = options.stderr === true ? console3.error : console3.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date3)}]`, colors.white) + ` ${color(logLevel2.label, ...logLevelColors[logLevel2._tag])} (${threadName(fiberId3)})`;
    if (isCons(spans)) {
      const now3 = date3.getTime();
      const render3 = render(now3);
      for (const span3 of spans) {
        firstLine += " " + render3(span3);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log3(firstLine);
    if (!processIsBun) console3.group();
    if (!isEmpty5(cause2)) {
      log3(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log3(redact(message[messageIndex]));
      }
    }
    if (size4(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        log3(color(`${key}:`, colors.bold, colors.white), redact(value6));
      }
    }
    if (!processIsBun) console3.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations3,
    cause: cause2,
    context: context10,
    date: date3,
    fiberId: fiberId3,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context10, currentServices);
    const console3 = get4(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date3)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel2.label}${color} (${threadName(fiberId3)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel2._tag], "");
    }
    if (isCons(spans)) {
      const now3 = date3.getTime();
      const render3 = render(now3);
      for (const span3 of spans) {
        firstLine += " " + render3(span3);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console3.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty5(cause2)) {
      console3.error(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console3.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        const redacted2 = redact(value6);
        if (options.colors) {
          console3.log(`%c${key}:`, "color:gray", redacted2);
        } else {
          console3.log(`${key}:`, redacted2);
        }
      }
    }
    console3.groupEnd();
  });
};
var prettyLoggerDefault = globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values7) {
    this.values = values7;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine2(array2(this.values)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable8 = (iterable) => {
  const values7 = pipe(iterable, appendAll2(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values7);
};
var exponential = (options) => pipe(makeBy2(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable8);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint3) {
    this.incremental = incremental;
    this.bigint = bigint3;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = string2(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol2]() {
    return FrequencyKeyTypeHash;
  }
  [symbol3](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = string2(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint3) {
    this.bigint = bigint3;
  }
  [symbol2]() {
    return GaugeKeyTypeHash;
  }
  [symbol3](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine2(hash(this.boundaries)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryKeyType = class {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error2, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error2;
    this.quantiles = quantiles;
    this._hash = pipe(string2(SummaryKeyTypeSymbolKey), combine2(hash(this.maxAge)), combine2(hash(this.maxSize)), combine2(hash(this.error)), combine2(array2(this.quantiles)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter2 = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2
};
var arrayEquivilence = getEquivalence3(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags2 = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags2;
    this._hash = pipe(string2(this.name + this.description), combine2(hash(this.keyType)), combine2(array2(this.tags)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter3 = (name, options) => new MetricKeyImpl(name, counter2(options), fromNullable2(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable2(description));
var tagged = dual(3, (self, key, value6) => taggedWithLabels(self, [make33(key, value6)]));
var taggedWithLabels = dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union2(self.tags, extraTags)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count5) {
    this.count = count5;
  }
  [symbol2]() {
    return pipe(hash(CounterStateSymbolKey), combine2(hash(this.count)), cached(this));
  }
  [symbol3](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = getEquivalence3(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol2]() {
    return pipe(string2(FrequencyStateSymbolKey), combine2(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol3](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value6) {
    this.value = value6;
  }
  [symbol2]() {
    return pipe(hash(GaugeStateSymbolKey), combine2(hash(this.value)), cached(this));
  }
  [symbol3](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count5, min9, max11, sum6) {
    this.buckets = buckets;
    this.count = count5;
    this.min = min9;
    this.max = max11;
    this.sum = sum6;
  }
  [symbol2]() {
    return pipe(hash(HistogramStateSymbolKey), combine2(hash(this.buckets)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error2, quantiles, count5, min9, max11, sum6) {
    this.error = error2;
    this.quantiles = quantiles;
    this.count = count5;
    this.min = min9;
    this.max = max11;
    this.sum = sum6;
  }
  [symbol2]() {
    return pipe(hash(SummaryStateSymbolKey), combine2(hash(this.error)), combine2(hash(this.quantiles)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter4 = (count5) => new CounterState(count5);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count5) => new GaugeState(count5);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var make34 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var onModify = dual(2, (self, f2) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: self.update,
  modify: (input) => {
    self.modify(input);
    return f2(input);
  }
}));
var onUpdate = dual(2, (self, f2) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: (input) => {
    self.update(input);
    return f2(input);
  },
  modify: self.modify
}));
var bigint05 = BigInt(0);
var counter5 = (key) => {
  let sum6 = key.keyType.bigint ? bigint05 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value6) => value6 >= bigint05 : (value6) => value6 >= 0 : (_value) => true;
  const update10 = (value6) => {
    if (canUpdate(value6)) {
      sum6 = sum6 + value6;
    }
  };
  return make34({
    get: () => counter4(sum6),
    update: update10,
    modify: update10
  });
};
var frequency3 = (key) => {
  const values7 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values7.set(word, 0);
  }
  const update10 = (word) => {
    const slotCount = values7.get(word) ?? 0;
    values7.set(word, slotCount + 1);
  };
  return make34({
    get: () => frequency2(values7),
    update: update10,
    modify: update10
  });
};
var gauge3 = (_key, startAt) => {
  let value6 = startAt;
  return make34({
    get: () => gauge2(value6),
    update: (v2) => {
      value6 = v2;
    },
    modify: (v2) => {
      value6 = value6 + v2;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size23 = bounds.length;
  const values7 = new Uint32Array(size23 + 1);
  const boundaries = new Float32Array(size23);
  let count5 = 0;
  let sum6 = 0;
  let min9 = Number.MAX_VALUE;
  let max11 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map6((n, i) => {
    boundaries[i] = n;
  }));
  const update10 = (value6) => {
    let from = 0;
    let to = size23;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value6 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value6 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values7[from] = values7[from] + 1;
    count5 = count5 + 1;
    sum6 = sum6 + value6;
    if (value6 < min9) {
      min9 = value6;
    }
    if (value6 > max11) {
      max11 = value6;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size23);
    let cumulated = 0;
    for (let i = 0; i < size23; i++) {
      const boundary = boundaries[i];
      const value6 = values7[i];
      cumulated = cumulated + value6;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make34({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count5,
      min: min9,
      max: max11,
      sum: sum6
    }),
    update: update10,
    modify: update10
  });
};
var summary3 = (key) => {
  const {
    error: error2,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values7 = allocate(maxSize);
  let head8 = 0;
  let count5 = 0;
  let sum6 = 0;
  let min9 = 0;
  let max11 = 0;
  const snapshot2 = (now3) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values7[i];
      if (item != null) {
        const [t, v2] = item;
        const age = millis(now3 - t);
        if (greaterThanOrEqualTo5(age, zero2) && lessThanOrEqualTo5(age, maxAge)) {
          builder.push(v2);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error2, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value6, timestamp) => {
    if (maxSize > 0) {
      head8 = head8 + 1;
      const target = head8 % maxSize;
      values7[target] = [timestamp, value6];
    }
    min9 = count5 === 0 ? value6 : Math.min(min9, value6);
    max11 = count5 === 0 ? value6 : Math.max(max11, value6);
    count5 = count5 + 1;
    sum6 = sum6 + value6;
  };
  return make34({
    get: () => summary2({
      error: error2,
      quantiles: snapshot2(Date.now()),
      count: count5,
      min: min9,
      max: max11,
      sum: sum6
    }),
    update: ([value6, timestamp]) => observe(value6, timestamp),
    modify: ([value6, timestamp]) => observe(value6, timestamp)
  });
};
var calculateQuantiles = (error2, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty3();
  }
  const head8 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error2, sampleCount, none2(), 0, head8, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error2, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map6(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error2, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error2;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error2;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2
};
var unsafeMake8 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = empty22();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake8(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get9(key), getOrUndefined2);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value6 = pipe(this.map, get9(key), getOrUndefined2);
    if (value6 == null) {
      const counter7 = counter5(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, counter7));
      }
      value6 = counter7;
    }
    return value6;
  }
  getFrequency(key) {
    let value6 = pipe(this.map, get9(key), getOrUndefined2);
    if (value6 == null) {
      const frequency6 = frequency3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, frequency6));
      }
      value6 = frequency6;
    }
    return value6;
  }
  getGauge(key) {
    let value6 = pipe(this.map, get9(key), getOrUndefined2);
    if (value6 == null) {
      const gauge6 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, gauge6));
      }
      value6 = gauge6;
    }
    return value6;
  }
  getHistogram(key) {
    let value6 = pipe(this.map, get9(key), getOrUndefined2);
    if (value6 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, histogram6));
      }
      value6 = histogram6;
    }
    return value6;
  }
  getSummary(key) {
    let value6 = pipe(this.map, get9(key), getOrUndefined2);
    if (value6 == null) {
      const summary6 = summary3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, summary6));
      }
      value6 = summary6;
    }
    return value6;
  }
};
var make35 = () => {
  return new MetricRegistryImpl();
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var globalMetricRegistry = globalValue(Symbol.for("effect/Metric/globalMetricRegistry"), () => make35());
var make36 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update5(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var mapInput5 = dual(2, (self, f2) => make36(self.keyType, (input, extraTags) => self.unsafeUpdate(f2(input), extraTags), self.unsafeValue, (input, extraTags) => self.unsafeModify(f2(input), extraTags)));
var counter6 = (name, options) => fromMetricKey(counter3(name, options));
var withConstantInput = dual(2, (self, input) => mapInput5(self, () => input));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make36(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var incrementBy = dual(2, (self, amount) => isCounterKey(self.keyType) ? update5(self, amount) : modify8(self, amount));
var map20 = dual(2, (self, f2) => make36(self.keyType, self.unsafeUpdate, (extraTags) => f2(self.unsafeValue(extraTags)), self.unsafeModify));
var mapType = dual(2, (self, f2) => make36(f2(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));
var modify8 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags2) => sync(() => self.unsafeModify(input, tags2))));
var set8 = dual(2, (self, value6) => update5(self, value6));
var tagged2 = dual(3, (self, key, value6) => taggedWithLabels2(self, [make33(key, value6)]));
var taggedWithLabelsInput = dual(2, (self, f2) => map20(make36(self.keyType, (input, extraTags) => self.unsafeUpdate(input, union2(f2(input), extraTags)), self.unsafeValue, (input, extraTags) => self.unsafeModify(input, union2(f2(input), extraTags))), constVoid));
var taggedWithLabels2 = dual(2, (self, extraTags) => {
  return make36(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union2(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union2(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union2(extraTags, extraTags1)));
});
var trackAll = dual(2, (self, input) => (effect4) => matchCauseEffect(effect4, {
  onFailure: (cause2) => zipRight2(update5(self, input), failCause(cause2)),
  onSuccess: (value6) => zipRight2(update5(self, input), succeed(value6))
}));
var trackDefect = dual(2, (self, metric) => trackDefectWith(self, metric, identity));
var trackDefectWith = dual(3, (self, metric, f2) => {
  const updater = (defect) => update5(metric, f2(defect));
  return tapDefect(self, (cause2) => forEachSequentialDiscard(defects(cause2), updater));
});
var trackDuration = dual(2, (self, metric) => trackDurationWith(self, metric, identity));
var trackDurationWith = dual(3, (self, metric, f2) => clockWith2((clock3) => {
  const startTime = clock3.unsafeCurrentTimeNanos();
  return tap2(self, (_2) => {
    const endTime = clock3.unsafeCurrentTimeNanos();
    const duration3 = nanos(endTime - startTime);
    return update5(metric, f2(duration3));
  });
}));
var trackError = dual(2, (self, metric) => trackErrorWith(self, metric, (a) => a));
var trackErrorWith = dual(3, (self, metric, f2) => {
  const updater = (error2) => update5(metric, f2(error2));
  return tapError(self, updater);
});
var trackSuccess = dual(2, (self, metric) => trackSuccessWith(self, metric, (a) => a));
var trackSuccessWith = dual(3, (self, metric, f2) => {
  const updater = (value6) => update5(metric, f2(value6));
  return tap2(self, updater);
});
var update5 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags2) => sync(() => self.unsafeUpdate(input, tags2))));
var value = (self) => fiberRefGetWith(currentMetricLabels, (tags2) => sync(() => self.unsafeValue(tags2)));
var zip9 = dual(2, (self, that) => make36([self.keyType, that.keyType], (input, extraTags) => {
  const [l2, r] = input;
  self.unsafeUpdate(l2, extraTags);
  that.unsafeUpdate(r, extraTags);
}, (extraTags) => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)], (input, extraTags) => {
  const [l2, r] = input;
  self.unsafeModify(l2, extraTags);
  that.unsafeModify(r, extraTags);
}));
var unsafeSnapshot = () => globalMetricRegistry.snapshot();
var snapshot = sync(unsafeSnapshot);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var Class3 = function() {
  function Class8(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Class8.prototype = RequestPrototype;
  return Class8;
}();
var complete = dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map40) => sync(() => {
  if (map40.has(self)) {
    const entry = map40.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var completeEffect = dual(2, (self, effect4) => matchEffect(effect4, {
  onFailure: (error2) => complete(self, exitFail(error2)),
  onSuccess: (value6) => complete(self, exitSucceed(value6))
}));
var fail6 = dual(2, (self, error2) => complete(self, exitFail(error2)));
var failCause6 = dual(2, (self, cause2) => complete(self, exitFailCause(cause2)));
var succeed6 = dual(2, (self, value6) => complete(self, exitSucceed(value6)));
var Listeners = class {
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f2) {
    this.observers.add(f2);
  }
  removeObserver(f2) {
    this.observers.delete(f2);
  }
  increment() {
    this.count++;
    this.observers.forEach((f2) => f2(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f2) => f2(this.count));
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone2 = ({
  color,
  count: count5,
  key,
  left: left3,
  right: right3,
  value: value6
}) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count5
});
function swap2(n, v2) {
  n.key = v2.key;
  n.value = v2.value;
  n.left = v2.left;
  n.right = v2.right;
  n.color = v2.color;
  n.count = v2.count;
}
var repaint = ({
  count: count5,
  key,
  left: left3,
  right: right3,
  value: value6
}, color) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count5
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol2]() {
    let hash4 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty28 = (ord) => makeImpl3(ord, void 0);
var fromIterable9 = dual(2, (entries3, ord) => {
  let tree = empty28(ord);
  for (const [key, value6] of entries3) {
    tree = insert(tree, key, value6);
  }
  return tree;
});
var atBackwards = dual(2, (self, index) => at2(self, index, Direction.Backward));
var atForwards = dual(2, (self, index) => at2(self, index, Direction.Forward));
var at2 = (self, index, direction) => {
  return {
    [Symbol.iterator]: () => {
      if (index < 0) {
        return new RedBlackTreeIterator(self, [], direction);
      }
      let node = self._root;
      const stack = [];
      while (node !== void 0) {
        stack.push(node);
        if (node.left !== void 0) {
          if (index < node.left.count) {
            node = node.left;
            continue;
          }
          index -= node.left.count;
        }
        if (!index) {
          return new RedBlackTreeIterator(self, stack, direction);
        }
        index -= 1;
        if (node.right !== void 0) {
          if (index >= node.right.count) {
            break;
          }
          node = node.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(self, [], direction);
    }
  };
};
var findAll = dual(2, (self, key) => {
  const stack = [];
  let node = self._root;
  let result = empty6();
  while (node !== void 0 || stack.length > 0) {
    if (node) {
      stack.push(node);
      node = node.left;
    } else {
      const current2 = stack.pop();
      if (equals(key, current2.key)) {
        result = prepend3(current2.value)(result);
      }
      node = current2.right;
    }
  }
  return result;
});
var findFirst8 = dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var getAt = dual(2, (self, index) => {
  if (index < 0) {
    return none2();
  }
  let root = self._root;
  let node = void 0;
  while (root !== void 0) {
    node = root;
    if (root.left) {
      if (index < root.left.count) {
        root = root.left;
        continue;
      }
      index -= root.left.count;
    }
    if (!index) {
      return some2([node.key, node.value]);
    }
    index -= 1;
    if (root.right) {
      if (index >= root.right.count) {
        break;
      }
      root = root.right;
    } else {
      break;
    }
  }
  return none2();
});
var getOrder = (tree) => tree._ord;
var has7 = dual(2, (self, key) => isSome2(findFirst8(self, key)));
var insert = dual(3, (self, key, value6) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value6,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y2 = pp.right;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y2 = pp.right;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y2 = pp.left;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y2 = pp.left;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys4(self, Direction.Forward);
var keys4 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count5 = 0;
  return {
    [Symbol.iterator]: () => keys4(self, direction),
    next: () => {
      count5++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count5
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var greaterThanBackwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Backward));
var greaterThanForwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Forward));
var greaterThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var greaterThanEqualBackwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Backward));
var greaterThanEqualForwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Forward));
var greaterThanEqual2 = (self, key, direction = Direction.Forward) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanBackwards = dual(2, (self, key) => lessThan7(self, key, Direction.Backward));
var lessThanForwards = dual(2, (self, key) => lessThan7(self, key, Direction.Forward));
var lessThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanEqualBackwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Backward));
var lessThanEqualForwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Forward));
var lessThanEqual2 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var forEach12 = dual(2, (self, f2) => {
  const root = self._root;
  if (root !== void 0) {
    visitFull(root, (key, value6) => {
      f2(key, value6);
      return none2();
    });
  }
});
var forEachGreaterThanEqual = dual(3, (self, min9, f2) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitGreaterThanEqual(root, min9, ord, (key, value6) => {
      f2(key, value6);
      return none2();
    });
  }
});
var forEachLessThan = dual(3, (self, max11, f2) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitLessThan(root, max11, ord, (key, value6) => {
      f2(key, value6);
      return none2();
    });
  }
});
var forEachBetween = dual(2, (self, {
  body,
  max: max11,
  min: min9
}) => {
  const root = self._root;
  const ord = self._ord;
  if (root) {
    visitBetween(root, min9, max11, ord, (key, value6) => {
      body(key, value6);
      return none2();
    });
  }
});
var reduce13 = dual(3, (self, zero3, f2) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f2(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var removeFirst = dual(2, (self, key) => {
  if (!has7(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split6 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v2 = cstack[split6 - 1];
    cstack.push({
      color: n.color,
      key: v2.key,
      value: v2.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split6 - 1].key = n.key;
    cstack[split6 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split6; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split6 - 1].left = cstack[split6];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var visitFull = (node, visit) => {
  let current2 = node;
  let stack = void 0;
  let done14 = false;
  while (!done14) {
    if (current2 != null) {
      stack = make9(current2, stack);
      current2 = current2.left;
    } else if (stack != null) {
      const value6 = visit(stack.value.key, stack.value.value);
      if (isSome2(value6)) {
        return value6;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done14 = true;
    }
  }
  return none2();
};
var visitGreaterThanEqual = (node, min9, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done14 = false;
  while (!done14) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      if (ord(min9, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0) {
      if (ord(min9, stack.value.key) <= 0) {
        const value6 = visit(stack.value.key, stack.value.value);
        if (isSome2(value6)) {
          return value6;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done14 = true;
    }
  }
  return none2();
};
var visitLessThan = (node, max11, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done14 = false;
  while (!done14) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      current2 = current2.left;
    } else if (stack !== void 0 && ord(max11, stack.value.key) > 0) {
      const value6 = visit(stack.value.key, stack.value.value);
      if (isSome2(value6)) {
        return value6;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done14 = true;
    }
  }
  return none2();
};
var visitBetween = (node, min9, max11, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done14 = false;
  while (!done14) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      if (ord(min9, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0 && ord(max11, stack.value.key) > 0) {
      if (ord(min9, stack.value.key) <= 0) {
        const value6 = visit(stack.value.key, stack.value.value);
        if (isSome2(value6)) {
          return value6;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done14 = true;
    }
  }
  return none2();
};
var fixDoubleBlack = (stack) => {
  let n, p, s, z2;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone2(s);
        z2 = s.right = clone2(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z2;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z2.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone2(s);
        z2 = s.left = clone2(s.left);
        p.right = z2.left;
        s.left = z2.right;
        z2.left = p;
        z2.right = s;
        z2.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z2);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z2;
          } else {
            pp.right = z2;
          }
        }
        stack[i - 1] = z2;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone2(s);
        z2 = s.left = clone2(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z2;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z2.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone2(s);
        z2 = s.right = clone2(s.right);
        p.left = z2.right;
        s.right = z2.left;
        z2.right = p;
        z2.left = s;
        z2.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z2);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z2;
          } else {
            pp.left = z2;
          }
        }
        stack[i - 1] = z2;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/RedBlackTree.js
var empty29 = empty28;
var fromIterable10 = fromIterable9;
var findFirst9 = findFirst8;
var getOrder2 = getOrder;
var has8 = has7;
var insert2 = insert;
var keys5 = keysForward;
var forEach13 = forEach12;
var reduce14 = reduce13;
var removeFirst2 = removeFirst;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/SortedSet.js
var TypeId16 = Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId16]: {
    _A: (_2) => _2
  },
  [symbol2]() {
    return pipe(hash(this.keyTree), combine2(hash(TypeId16)), cached(this));
  },
  [symbol3](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId16);
var empty30 = (O) => fromTree(empty29(O));
var fromIterable11 = dual(2, (iterable, ord) => fromTree(fromIterable10(Array.from(iterable).map((k2) => [k2, true]), ord)));
var add5 = dual(2, (self, value6) => has8(self.keyTree, value6) ? self : fromTree(insert2(self.keyTree, value6, true)));
var difference6 = dual(2, (self, that) => {
  let out = self;
  for (const value6 of that) {
    out = remove10(out, value6);
  }
  return out;
});
var every9 = dual(2, (self, predicate) => {
  for (const value6 of self) {
    if (!predicate(value6)) {
      return false;
    }
  }
  return true;
});
var filter10 = dual(2, (self, predicate) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value6 of self) {
    if (predicate(value6)) {
      out = add5(out, value6);
    }
  }
  return out;
});
var flatMap13 = dual(3, (self, O, f2) => {
  let out = empty30(O);
  forEach14(self, (a) => {
    for (const b2 of f2(a)) {
      out = add5(out, b2);
    }
  });
  return out;
});
var forEach14 = dual(2, (self, f2) => forEach13(self.keyTree, f2));
var has9 = dual(2, (self, value6) => has8(self.keyTree, value6));
var intersection6 = dual(2, (self, that) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value6 of that) {
    if (has9(self, value6)) {
      out = add5(out, value6);
    }
  }
  return out;
});
var isSubset2 = dual(2, (self, that) => every9(self, (a) => has9(that, a)));
var map21 = dual(3, (self, O, f2) => {
  let out = empty30(O);
  forEach14(self, (a) => {
    const b2 = f2(a);
    if (!has9(out, b2)) {
      out = add5(out, b2);
    }
  });
  return out;
});
var partition6 = dual(2, (self, predicate) => {
  const ord = getOrder2(self.keyTree);
  let right3 = empty30(ord);
  let left3 = empty30(ord);
  for (const value6 of self) {
    if (predicate(value6)) {
      right3 = add5(right3, value6);
    } else {
      left3 = add5(left3, value6);
    }
  }
  return [left3, right3];
});
var remove10 = dual(2, (self, value6) => fromTree(removeFirst2(self.keyTree, value6)));
var some10 = dual(2, (self, predicate) => {
  for (const value6 of self) {
    if (predicate(value6)) {
      return true;
    }
  }
  return false;
});
var toggle2 = dual(2, (self, value6) => has9(self, value6) ? remove10(self, value6) : add5(self, value6));
var union7 = dual(2, (self, that) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value6 of self) {
    out = add5(value6)(out);
  }
  for (const value6 of that) {
    out = add5(value6)(out);
  }
  return out;
});
var values3 = (self) => keys5(self.keyTree);
var getEquivalence6 = () => (a, b2) => isSubset2(a, b2) && isSubset2(b2, a);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_2) => _2
};
var ProxySupervisor = class _ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context10, effect4, parent, fiber) {
    this.underlying.onStart(context10, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.underlying.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f2) {
    return new _ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip5(this.left.value, this.right.value);
  }
  onStart(context10, effect4, parent, fiber) {
    this.left.onStart(context10, effect4, parent, fiber);
    this.right.onStart(context10, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.left.onEnd(value6, fiber);
    this.right.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var Track = class {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect4) {
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn = class {
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync(() => get7(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), remove10(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = () => {
  return new Track();
};
var track = sync(unsafeTrack);
var fromEffect = (effect4) => {
  return new Const(effect4);
};
var none7 = globalValue("effect/Supervisor/none", () => fromEffect(void_3));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Differ.js
var diff10 = dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));
var combine13 = dual(3, (self, first4, second) => self.combine(first4, second));
var patch11 = dual(3, (self, patch13, oldValue) => self.patch(patch13, oldValue));
var make38 = make18;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty31 = {
  _tag: OP_EMPTY3
};
var combine14 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch12 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head8 = headNonEmpty2(patches);
    switch (head8._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head8.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head8.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend3(head8.first)(prepend3(head8.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none7;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet2 = (self) => {
  if (equals(self, none7)) {
    return empty9();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union6(toSet2(self.right)));
    } else {
      return make12(self);
    }
  }
};
var diff11 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty31;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference5(oldSupervisors), reduce7(empty31, (patch13, supervisor) => combine14(patch13, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference5(newSupervisors), reduce7(empty31, (patch13, supervisor) => combine14(patch13, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine14(added, removed);
};
var differ2 = make38({
  empty: empty31,
  patch: patch12,
  combine: combine14,
  diff: diff11
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = counter6("effect_fiber_started", {
  incremental: true
});
var fiberActive = counter6("effect_fiber_active");
var fiberSuccesses = counter6("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = counter6("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = tagged2(histogram5("effect_fiber_lifetimes", exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var absurd3 = (_2) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_2)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_2, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i1(value6));
  },
  ["OnStep"]: (_2, _cont, value6) => {
    return exitSucceed(exitSucceed(value6));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_2, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i2(value6));
  },
  [OP_REVERT_FLAGS]: (self, cont, value6) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value6);
    }
  },
  [OP_WHILE]: (self, cont, value6) => {
    internalCall(() => cont.effect_instruction_i2(value6));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_3;
    }
  },
  [OP_ITERATOR]: (self, cont, value6) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value6));
    if (state.done) return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap11(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten6(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map40 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map40.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map40);
}, false, false));
var _version = getCurrentVersion();
var FiberRuntime = class extends Class2 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = new Array();
  _children = null;
  _observers = new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId3, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId3;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags2);
      fiberActive.unsafeUpdate(1, tags2);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_2, status2) => status2);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status2) => {
      if (isDone3(status2)) {
        return state.currentRuntimeFlags;
      }
      return status2.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake7(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f2) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status2) => {
        deferredUnsafeDone(deferred, sync(() => f2(fiber, status2)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _2) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _2) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch13 = pipe(
        diff7(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch13);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable2(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId3) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId3))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId3) {
    this.tell(interruptSignal(interrupt(fiberId3)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value6) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value6
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children2 = this._children;
    this._children = null;
    if (children2 !== null && children2.size > 0) {
      for (const child of children2) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it2 = this._children.values();
      this._children = null;
      let isDone8 = false;
      const body = () => {
        const next5 = it2.next();
        if (!next5.done) {
          return asVoid2(next5.value.await);
        } else {
          return sync(() => {
            isDone8 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone8,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags2);
      fiberActive.unsafeUpdate(-1, tags2);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags2);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags2);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel2 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel2, logLevel2)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations3 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get4(this.getFiberRef(currentServices), clockTag);
      const date3 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause2,
            context: contextMap,
            spans,
            annotations: annotations3,
            date: date3
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd3(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect4 = flatMap11(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch13) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch13);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_2) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_2) => {
          abortResume(void_3);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value6 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, value6);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value6);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd3(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap11(forkDaemon2(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check4 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check4()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap11(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty21, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
var currentMinimumLogLevel = globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.log(self.log(opts));
});
var defaultLogger = globalValue(Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = globalValue(Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = globalValue(Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var prettyLogger2 = globalValue(Symbol.for("effect/Logger/prettyLogger"), () => prettyLoggerDefault);
var structuredLogger2 = globalValue(Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = globalValue(Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations3,
  cause: cause2,
  context: context10,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message
}) => {
  const span3 = getOption2(getOrDefault(context10, currentContext), spanTag);
  if (span3._tag === "None" || span3.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context10, currentServices), clockTag);
  const attributes = {};
  for (const [key, value6] of annotations3) {
    attributes[key] = value6;
  }
  attributes["effect.fiberId"] = threadName2(fiberId3);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span3.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = globalValue(Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make12(defaultLogger, tracerLogger)));
var batchedLogger = dual(3, (self, window2, f2) => flatMap11(scope2, (scope5) => {
  let buffer3 = [];
  const flush = suspend(() => {
    if (buffer3.length === 0) {
      return void_3;
    }
    const arr = buffer3;
    buffer3 = [];
    return f2(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window2), zipRight2(flush), forever, restore, forkDaemon2, flatMap11((fiber) => scopeAddFinalizer(scope5, interruptFiber(fiber))), zipRight2(addFinalizer(() => flush)), as3(makeLogger((options) => {
    buffer3.push(self.log(options));
  }))));
}));
var whenLogLevel = dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel2 = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel2, requiredLogLevel)) {
      return succeed(none2());
    }
    return map14(effect4, some2);
  });
});
var acquireRelease = dual((args2) => isEffect(args2[0]), (acquire3, release3) => uninterruptible(tap2(acquire3, (a) => addFinalizer((exit4) => release3(a, exit4)))));
var acquireReleaseInterruptible = dual((args2) => isEffect(args2[0]), (acquire3, release3) => ensuring2(acquire3, addFinalizer((exit4) => release3(exit4))));
var addFinalizer = (finalizer2) => withFiberRuntime((runtime5) => {
  const acquireRefs = runtime5.getFiberRefs();
  const acquireFlags = disable2(runtime5.currentRuntimeFlags, Interruption);
  return flatMap11(scope2, (scope5) => scopeAddFinalizerExit(scope5, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring2(withRuntimeFlags(finalizer2(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var _existsParFound = Symbol.for("effect/Effect/existsPar/found");
var exists2 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach15(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_3
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f2) => {
  const next5 = iterator.next();
  if (next5.done) {
    return succeed(false);
  }
  return flatMap11(f2(next5.value, index), (b2) => b2 ? succeed(b2) : existsLoop(iterator, index + 1, f2));
};
var filter11 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map14(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect4, a, i) => zipWith6(effect4, suspend(() => predicate_(a, i)), (list, b2) => b2 ? [a, ...list] : list), sync(() => new Array()))), () => map14(forEach15(elements, (a, i) => map14(predicate_(a, i), (b2) => b2 ? some2(a) : none2()), options), getSomes3));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys10 = Object.keys(input);
  const size23 = keys10.length;
  return [keys10.map((k2) => input[k2]), some2((values7) => {
    const res = {};
    for (let i = 0; i < size23; i++) {
      ;
      res[keys10[i]] = values7[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  return flatMap11(forEach15(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none10 = none2();
    const size23 = eithers.length;
    const errors = new Array(size23);
    const successes = new Array(size23);
    let errored = false;
    for (let i = 0; i < size23; i++) {
      const either8 = eithers[i];
      if (either8._tag === "Left") {
        errors[i] = some2(either8.left);
        errored = true;
      } else {
        successes[i] = either8.right;
        errors[i] = none10;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_3;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  if (options?.discard) {
    return forEach15(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map14(forEach15(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all5 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map14(forEach15(effects, identity, options), reconcile.value) : forEach15(effects, identity, options);
};
var replicate4 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect2 = dual((args2) => isEffect(args2[0]), (self, n, options) => all5(replicate4(self, n), options));
var forEach15 = dual((args2) => isIterable(args2[0]), (self, f2, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match11(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f2(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match11(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f2(a, i)), true) : forEachSequential(self, (a, i) => restore(f2(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f2, batching) => suspend(() => {
  const as12 = fromIterable(self);
  const array7 = new Array(as12.length);
  const fn = (a, i) => flatMap11(f2(a, i), (b2) => sync(() => array7[i] = b2));
  return zipRight2(forEachConcurrentDiscard(as12, fn, batching, false), succeed(array7));
});
var forEachConcurrentDiscard = (self, f2, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_3;
  }
  let counter7 = 0;
  let interrupted3 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers2 = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll2 = () => fibers2.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b2) => a.index < b2.index ? -1 : a.index === b2.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted3 = true;
    interruptAll2();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted3) {
          onInterruptSignal();
        }
      }
    };
    const next5 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter7++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter7++;
          return flatMap11(yieldNow(), () => flatMap11(stepOrExit(restore(f2(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap11(stepOrExit(restore(f2(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers2.add(fiber);
        if (interrupted3) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers2.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse2(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse2(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next5();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next5();
    }
  }));
  return asVoid2(onExit(flatten7(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count5 = 0;
        let index = 0;
        const check4 = (index2, hitNext) => (exit4) => {
          exits[index2] = exit4;
          count5++;
          if (count5 === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next5();
          }
        };
        const next5 = () => {
          runFiber(toPop.pop(), true).addObserver(check4(index, true));
          index++;
        };
        processingFiber.addObserver(check4(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next5();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f3) => f3.inheritAll)
  })));
})));
var forEachParN = (self, n, f2, batching) => suspend(() => {
  const as12 = fromIterable(self);
  const array7 = new Array(as12.length);
  const fn = (a, i) => map14(f2(a, i), (b2) => array7[i] = b2);
  return zipRight2(forEachConcurrentDiscard(as12, fn, batching, false, n), succeed(array7));
});
var fork = (self) => withFiberRuntime((state, status2) => succeed(unsafeFork2(self, state, status2.runtimeFlags)));
var forkDaemon2 = (self) => forkWithScopeOverride(self, globalScope);
var forkWithErrorHandler = dual(2, (self, handler) => fork(onError(self, (cause2) => {
  const either8 = failureOrCause(cause2);
  switch (either8._tag) {
    case "Left":
      return handler(either8.left);
    case "Right":
      return failCause(either8.right);
  }
})));
var unsafeFork2 = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some2(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse2(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll2 = dual((args2) => isFunction2(args2[2]), (elements, zero3, f2, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f2(acc2, a2, i)), succeed(zero3)), () => flatMap11(make32(zero3), (acc) => flatMap11(forEach15(elements, (effect4, i) => flatMap11(effect4, (a) => update4(acc, (b2) => f2(b2, a, i))), options), () => get12(acc)))));
var partition7 = dual((args2) => isIterable(args2[0]), (elements, f2, options) => pipe(forEach15(elements, (a, i) => either2(f2(a, i)), options), map14((chunk4) => partitionMap6(chunk4, identity))));
var validateAll = dual((args2) => isIterable(args2[0]), (elements, f2, options) => flatMap11(partition7(elements, f2, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_3 : succeed(bs)));
var reduceEffect = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f2, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f2(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll2([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f2(acc.value, elem, i));
    }
  }
}, options), map14((option6) => {
  switch (option6._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option6.value;
    }
  }
})))));
var parallelFinalizers = (self) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap11(scopeFork(scope5, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap11(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope5) => {
    if (concurrentFinalizers === true) {
      const patch13 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch13(self(parallelFinalizers));
        case "Sequential":
          return patch13(self(sequentialFinalizers));
        case "ParallelN":
          return patch13(self(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f2) => flatMap11(scopeTag, f2);
var scopedWith = (f2) => flatMap11(scopeMake2(), (scope5) => onExit(f2(scope5), (exit4) => scope5.close(exit4)));
var scopedEffect = (effect4) => flatMap11(scopeMake2(), (scope5) => scopeUse(effect4, scope5));
var sequentialFinalizers = (self) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap11(scopeFork(scope5, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var using = dual(2, (self, use) => scopedWith((scope5) => flatMap11(scopeExtend(self, scope5), use)));
var validate = dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b2) => [a, b2], options));
var validateWith = dual((args2) => isEffect(args2[1]), (self, that, f2, options) => flatten7(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f2,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateAllPar = dual(2, (elements, f2) => flatMap11(partition7(elements, f2), ([es, bs]) => es.length === 0 ? succeed(bs) : fail2(es)));
var validateAllParDiscard = dual(2, (elements, f2) => flatMap11(partition7(elements, f2), ([es, _2]) => es.length === 0 ? void_3 : fail2(es)));
var validateFirst = dual((args2) => isIterable(args2[0]), (elements, f2, options) => flip(forEach15(elements, (a, i) => flip(f2(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var zipOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b2) => [a, b2], options));
var zipLeftOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft2(self, that);
  }
  return zipWithOptions(self, that, (a, _2) => a, options);
});
var zipRightOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight2(self, that);
  }
  return zipWithOptions(self, that, (_2, b2) => b2, options);
});
var zipWithOptions = dual((args2) => isEffect(args2[1]), (self, that, f2, options) => map14(all5([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f2(a, a2)));
var withRuntimeFlagsScoped = (update10) => {
  if (update10 === empty19) {
    return void_3;
  }
  return pipe(runtimeFlags, flatMap11((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update10);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update10), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
};
var scopeTag = GenericTag("effect/Scope");
var scope2 = scopeTag;
var scopeUnsafeAddFinalizer = (scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_2) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_3;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_3;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap11((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap11((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap11((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_3;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
};
var scopeMake2 = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make6(scopeTag, scope5))
));
var scopeUse = dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit4) => scope5.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty31
});
var fiberRefLocallyScoped = dual(2, (self, value6) => asVoid2(acquireRelease(flatMap11(fiberRefGet(self), (oldValue) => as3(fiberRefSet(self, value6), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = dual(2, (self, f2) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f2(a))));
var fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options));
var fiberRefMakeWith = (ref) => acquireRelease(tap2(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef));
var currentRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = fiberRefUnsafeMakeSupervisor(none7);
var fiberAll = (fibers2) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers2).reduce((id2, fiber) => combine5(id2, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers2, (fiber) => flatten7(fiber.await), false)),
    children: map14(forEachParUnbounded(fibers2, (fiber) => fiber.children, false), flatten3),
    inheritAll: forEachSequentialDiscard(fibers2, (fiber) => fiber.inheritAll),
    poll: map14(forEachSequential(fibers2, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk4) => [a, ...chunk4],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId3) => forEachSequentialDiscard(fibers2, (fiber) => fiber.interruptAsFork(fiberId3))
  };
  return _fiberAll;
};
var raceWith = dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap11(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap11(winner.inheritAll, () => options.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap11(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap11(winner.inheritAll, () => options.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit4, loser);
      }
    }
  })
}));
var race2 = dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value6) => pipe(right3, interruptAsFiber(parentFiberId), as3(value6))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value6) => pipe(left3, interruptAsFiber(parentFiberId), as3(value6))
  })
})));
var raceFibersWith = dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine5(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring2 = dual(2, (self, finalizer2) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer2, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as3(finalizer2, a)
})));
var invokeWithInterrupt = (self, entries3, onInterrupt3) => fiberIdWith((id2) => flatMap11(flatMap11(forkDaemon2(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries3.map((_2) => _2.listeners.count);
  const checkDone = () => {
    if (counts.every((count5) => count5 === 0)) {
      if (entries3.every((_2) => {
        if (_2.result.state.current._tag === "Pending") {
          return true;
        } else if (_2.result.state.current._tag === "Done" && exitIsExit(_2.result.state.current.effect) && _2.result.state.current.effect._tag === "Failure" && isInterrupted(_2.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f2) => f2());
        onInterrupt3?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f2) => f2());
    cb(exit4);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = (count5) => {
      counts[i] = count5;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f2) => f2());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id2)));
})));
var interruptWhenPossible = dual(2, (self, all11) => fiberRefGetWith(currentRequestMap, (map40) => suspend(() => {
  const entries3 = fromIterable(all11).flatMap((_2) => map40.has(_2) ? [map40.get(_2)] : []);
  return invokeWithInterrupt(self, entries3);
})));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit4, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete4) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete4
});
var MapKeyTypeId = Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current2) {
    this.current = current2;
  }
  [symbol2]() {
    return pipe(hash(this.current), combine2(hash(this.previous)), combine2(hash(this.next)), cached(this));
  }
  [symbol3](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next5 = key.next;
        if (next5 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next5;
            next5.previous = previous2;
          } else {
            this.head = next5;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next5 = key.next;
      if (next5 !== void 0) {
        key.next = void 0;
        this.head = next5;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map40, keys10, accesses, updating, hits, misses) => ({
  map: map40,
  keys: keys10,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty22(), makeKeySet(), unbounded(), make13(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Error: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Error: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var CacheImpl = class {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity7, context10, fiberId3, lookup, timeToLive) {
    this.capacity = capacity7;
    this.context = context10;
    this.fiberId = fiberId3;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map14(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size6(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value6) => this.resolveMapValue(value6)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value6) => this.resolveMapValue(value6, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option6 = get9(this.cacheState.map, key);
      if (isSome2(option6)) {
        switch (option6.value._tag) {
          case "Complete": {
            const loaded = option6.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option6.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k2 = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value6 = getOrUndefined2(get9(this.cacheState.map, k2));
      if (value6 === void 0) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k2);
        if (has6(this.cacheState.map, k2)) {
          value6 = getOrUndefined2(get9(this.cacheState.map, k2));
        } else {
          set5(this.cacheState.map, k2, pending2(mapKey, deferred));
        }
      }
      if (value6 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map14(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap11(this.resolveMapValue(value6), match2({
          onNone: () => this.getEither(key),
          onSome: (value7) => succeed(left2(value7))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove8(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when7) {
    return sync(() => {
      const value6 = get9(this.cacheState.map, key);
      if (isSome2(value6) && value6.value._tag === "Complete") {
        if (value6.value.exit._tag === "Success") {
          if (when7(value6.value.exit.value)) {
            remove8(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty22();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k2 = key;
      const deferred = unsafeMake4(this.fiberId);
      let value6 = getOrUndefined2(get9(this.cacheState.map, k2));
      if (value6 === void 0) {
        if (has6(this.cacheState.map, k2)) {
          value6 = getOrUndefined2(get9(this.cacheState.map, k2));
        } else {
          set5(this.cacheState.map, k2, pending2(makeMapKey(k2), deferred));
        }
      }
      if (value6 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value6._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
              const found = getOrUndefined2(get9(this.cacheState.map, k2));
              if (equals(found, value6)) {
                remove8(this.cacheState.map, k2);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined2(get9(this.cacheState.map, k2));
              if (equals(current2, value6)) {
                const mapValue = refreshing(deferred, value6);
                set5(this.cacheState.map, k2, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await(value6.deferred);
          }
          case "Refreshing": {
            return _await(value6.deferred);
          }
        }
      }
    }));
  }
  set(key, value6) {
    return clockWith3((clock3) => sync(() => {
      const now3 = clock3.unsafeCurrentTimeMillis();
      const k2 = key;
      const lookupResult = succeed3(value6);
      const mapValue = complete2(makeMapKey(k2), lookupResult, makeEntryStats(now3), now3 + toMillis(decode(this.timeToLive(lookupResult))));
      set5(this.cacheState.map, k2, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size6(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values7 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values7.push(entry[1].exit.value);
        }
      }
      return values7;
    });
  }
  get entries() {
    return sync(() => {
      const values7 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values7.push([entry[0], entry[1].exit.value]);
        }
      }
      return values7;
    });
  }
  get keys() {
    return sync(() => {
      const keys10 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys10.push(entry[0]);
        }
      }
      return keys10;
    });
  }
  resolveMapValue(value6, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value6._tag) {
        case "Complete": {
          this.trackAccess(value6.key);
          if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
            remove8(this.cacheState.map, value6.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map14(value6.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value6.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map14(_await(value6.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value6.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value6.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map14(_await(value6.deferred), some2);
          }
          return map14(value6.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size23 = size6(this.cacheState.map);
      loop3 = size23 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove8(this.cacheState.map, key2.current);
            size23 = size23 - 1;
            loop3 = size23 > this.capacity;
          }
        } else {
          loop3 = false;
        }
      }
      set3(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap11((exit4) => {
        const now3 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now3);
        const value6 = complete2(makeMapKey(key), exit4, stats, now3 + toMillis(decode(this.timeToLive(exit4))));
        set5(this.cacheState.map, key, value6);
        return zipRight2(done2(deferred, exit4), exit4);
      }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
        remove8(this.cacheState.map, key);
      }))));
    }));
  }
};
var unsafeMakeWith = (capacity7, lookup, timeToLive) => new CacheImpl(capacity7, empty5(), none3, lookup, (exit4) => decode(timeToLive(exit4)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Cause.js
var empty32 = empty21;
var fail7 = fail;
var die4 = die;
var interrupt6 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map22 = map13;
var squash = causeSquash;
var reduceWithContext3 = reduceWithContext;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException3 = NoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var pretty2 = pretty;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = Symbol.for(IntervalSymbolKey);
var empty33 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make40 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty33;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan8 = dual(2, (self, that) => min7(self, that) === self);
var min7 = dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var max7 = dual(2, (self, that) => min7(self, that) === self ? that : self);
var isEmpty8 = (self) => {
  return self.startMillis >= self.endMillis;
};
var intersect = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end6 = Math.min(self.endMillis, that.endMillis);
  return make40(start5, end6);
});
var size10 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var union8 = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end6 = Math.min(self.endMillis, that.endMillis);
  return start5 < end6 ? none2() : some2(make40(start5, end6));
});
var after = (startMilliseconds) => {
  return make40(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ScheduleInterval.js
var make41 = make40;
var empty34 = empty33;
var lessThan9 = lessThan8;
var isEmpty9 = isEmpty8;
var intersect2 = intersect;
var size11 = size10;
var after2 = after;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = Symbol.for(IntervalsSymbolKey);
var make42 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var empty35 = make42(empty6());
var union9 = dual(2, (self, that) => {
  if (!isNonEmpty2(that.intervals)) {
    return self;
  }
  if (!isNonEmpty2(self.intervals)) {
    return that;
  }
  if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty6());
  }
  return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty6());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty2(self) || isNonEmpty2(that)) {
    if (!isNonEmpty2(self) && isNonEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty6();
      } else {
        interval = make41(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty6();
      }
    } else if (isNonEmpty2(self) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(self);
        that = empty6();
        self = tailNonEmpty2(self);
      } else {
        interval = make41(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty6();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty2(self) && isNonEmpty2(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend3(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make41(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make41(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make42(pipe(acc, prepend3(interval), reverse2));
};
var intersect3 = dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty6()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend3(interval));
    if (pipe(headNonEmpty2(left3), lessThan9(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make42(reverse2(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse2(() => empty34)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse2(() => empty34)).endMillis;
};
var lessThan10 = dual(2, (self, that) => start(self) < start(that));
var isNonEmpty4 = (self) => {
  return isNonEmpty2(self.intervals);
};
var max8 = dual(2, (self, that) => lessThan10(self, that) ? that : self);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ScheduleIntervals.js
var make43 = make42;
var union10 = union9;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan11 = lessThan10;
var isNonEmpty5 = isNonEmpty4;
var max9 = max8;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make43(of2(interval))
  };
};
var done6 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done7 = done6;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend3 = scopeExtend;
var fork2 = scopeFork;
var make44 = scopeMake2;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f2) => withFiberRuntime((fiber) => {
    this.taken = f2(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = this.updateTaken((_2) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap11(restore(this.take(n)), (permits) => ensuring2(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring2(restore(asSome(self)), this.release(n));
  }));
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class2 {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_3;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_3;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    return this.unsafeSchedule(fiber);
  });
  await = asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_3);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self) => {
    return zipRight2(this.await, self);
  };
};
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var cached2 = dual(2, (self, timeToLive) => map14(cachedInvalidateWithTTL(self, timeToLive), (tuple4) => tuple4[0]));
var cachedInvalidateWithTTL = dual(2, (self, timeToLive) => {
  const duration3 = decode(timeToLive);
  return flatMap11(context2(), (env) => map14(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration3, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self, deferred)), map14((deferred) => some2([start5 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap11((time2) => updateSomeAndGetEffectSynchronized(cache, (option6) => {
  switch (option6._tag) {
    case "None": {
      return some2(computeCachedValue(self, timeToLive, time2));
    }
    case "Some": {
      const [end6] = option6.value;
      return end6 - time2 <= 0 ? some2(computeCachedValue(self, timeToLive, time2)) : none2();
    }
  }
})), flatMap11((option6) => isNone2(option6) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option6.value[1])))));
var invalidateCache = (cache) => set6(cache, none2());
var ensuringChild = dual(2, (self, f2) => ensuringChildren(self, (children2) => f2(fiberAll(children2))));
var ensuringChildren = dual(2, (self, children2) => flatMap11(track, (supervisor) => pipe(supervised(self, supervisor), ensuring2(flatMap11(supervisor.value, children2)))));
var forkAll = dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map14(forEachSequential(effects, fork), fiberAll));
var forkIn2 = dual(2, (self, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer2 = () => fiberIdWith((fiberId3) => equals(fiberId3, fiber.id()) ? void_3 : asVoid2(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer2);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self) => scopeWith((scope5) => forkIn2(self, scope5));
var memoKeySymbol = Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol3](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol2]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var raceFirst2 = dual(2, (self, that) => pipe(exit(self), race2(exit(that)), (effect4) => flatten7(effect4)));
var supervised = dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout2 = dual(2, (self, duration3) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration3),
  duration: duration3
}));
var timeoutFail = dual(2, (self, {
  duration: duration3,
  onTimeout
}) => flatten7(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutFailCause = dual(2, (self, {
  duration: duration3,
  onTimeout
}) => flatten7(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutOption2 = dual(2, (self, duration3) => timeoutTo(self, {
  duration: duration3,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = dual(2, (self, {
  duration: duration3,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration3)), {
  onSelfWin: (winner, loser) => flatMap11(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap11(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap11(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap11(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap11(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap11(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var SynchronizedImpl = class extends Class2 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId14] = TypeId14;
  constructor(ref, withLock2) {
    super();
    this.ref = ref;
    this.withLock = withLock2;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f2) {
    return this.modifyEffect((a) => succeed(f2(a)));
  }
  modifyEffect(f2) {
    return this.withLock(pipe(flatMap11(get11(this.ref), f2), flatMap11(([b2, a]) => as3(set6(this.ref, a), b2))));
  }
};
var makeSynchronized = (value6) => sync(() => unsafeMakeSynchronized(value6));
var unsafeMakeSynchronized = (value6) => {
  const ref = unsafeMake6(value6);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = dual(2, (self, pf) => self.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([value6, value6]);
    }
    case "Some": {
      return map14(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, b2) => [a, b2]));
var zipLeftFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, _2) => a));
var zipRightFiber = dual(2, (self, that) => zipWithFiber(self, that, (_2, b2) => b2));
var zipWithFiber = dual(3, (self, that, f2) => ({
  ...CommitPrototype2,
  commit() {
    return join2(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: () => pipe(self.id(), getOrElse5(that.id())),
  await: pipe(self.await, flatten7, zipWithOptions(flatten7(that.await), f2, {
    concurrent: true
  }), exit),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap2((exitA) => pipe(optionB, map2((exitB) => zipWith7(exitA, exitB, {
    onSuccess: f2,
    onFailure: parallel
  })))))),
  interruptAsFork: (id2) => zipRight2(self.interruptAsFork(id2), that.interruptAsFork(id2)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = dual((args2) => isEffect(args2[0]), (self, f2, options) => flatMap11(self, (a) => all5(f2(a), options).pipe(map14((record3) => Object.assign({}, a, record3)))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId17 = Symbol.for("effect/ManagedRuntime");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var inheritAll2 = inheritAll;
var interrupt7 = interruptFiber;
var interruptAs = interruptAsFiber;
var join3 = join2;
var poll4 = poll3;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f2) => function() {
  if (arguments.length === 1) {
    const runtime5 = arguments[0];
    return (effect4, ...args2) => f2(runtime5, effect4, ...args2);
  }
  return f2.apply(this, arguments);
};
var unsafeFork3 = makeDual((runtime5, self, options) => {
  const fiberId3 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId3, runtime5.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId3, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime5.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId3
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId3);
  }
  const fiberRuntime = new FiberRuntime(fiberId3, fiberRefs3, runtime5.runtimeFlags);
  let effect4 = self;
  if (options?.scope) {
    effect4 = flatMap11(fork2(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_3 : interruptAsFiber(fiberRuntime, id2))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none7) {
    supervisor.onStart(runtime5.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime5.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = makeDual((runtime5, effect4, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime5, effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options.onExit(exit4);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime5)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit4) => cancelOptions.onExit(flatten8(exit4)) : void 0
  });
});
var unsafeRunSync = makeDual((runtime5, effect4) => {
  const result = unsafeRunSyncExit(runtime5)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error2 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error2;
};
var FiberFailureId = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head8 = prettyErrors(cause2)[0];
    super(head8?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head8 ? `(FiberFailure) ${head8.name}` : "FiberFailure";
    if (head8?.stack) {
      this.stack = head8.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error2 = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error2;
};
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = makeDual((runtime5, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime5)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = makeDual((runtime5, effect4, options) => unsafeRunPromiseExit(runtime5, effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = makeDual((runtime5, effect4, options) => new Promise((resolve) => {
  const op = fastPath(effect4);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork3(runtime5)(effect4);
  fiber.addObserver((exit4) => {
    resolve(exit4);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context10, runtimeFlags2, fiberRefs3) {
    this.context = context10;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make45 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = make20(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = make45({
  context: empty5(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: empty26()
});
var updateRuntimeFlags2 = dual(2, (self, f2) => make45({
  context: self.context,
  runtimeFlags: f2(self.runtimeFlags),
  fiberRefs: self.fiberRefs
}));
var disableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, disable2(flag)));
var enableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, enable2(flag)));
var updateContext2 = dual(2, (self, f2) => make45({
  context: f2(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var provideService3 = dual(3, (self, tag3, service3) => updateContext2(self, add2(tag3, service3)));
var updateFiberRefs2 = dual(2, (self, f2) => make45({
  context: self.context,
  runtimeFlags: self.runtimeFlags,
  fiberRefs: f2(self.fiberRefs)
}));
var setFiberRef = dual(3, (self, fiberRef, value6) => updateFiberRefs2(self, updateAs2({
  fiberId: none4,
  fiberRef,
  value: value6
})));
var deleteFiberRef = dual(2, (self, fiberRef) => updateFiberRefs2(self, delete_2(fiberRef)));
var unsafeRunEffect = unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/synchronizedRef.js
var getAndUpdateEffect = dual(2, (self, f2) => self.modifyEffect((value6) => map14(f2(value6), (result) => [value6, result])));
var getAndUpdateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([value6, value6]);
    }
    case "Some": {
      return map14(result.value, (newValue) => [value6, newValue]);
    }
  }
}));
var modify9 = dual(2, (self, f2) => self.modify(f2));
var modifyEffect = dual(2, (self, f2) => self.modifyEffect(f2));
var modifySomeEffect = dual(3, (self, fallback, pf) => self.modifyEffect((value6) => pipe(pf(value6), getOrElse2(() => succeed([fallback, value6])))));
var updateEffect = dual(2, (self, f2) => self.modifyEffect((value6) => map14(f2(value6), (result) => [void 0, result])));
var updateAndGetEffect = dual(2, (self, f2) => self.modifyEffect((value6) => map14(f2(value6), (result) => [result, result])));
var updateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([void 0, value6]);
    }
    case "Some": {
      return map14(result.value, (a) => [void 0, a]);
    }
  }
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _ROut: (_2) => _2
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope5) {
    return pipe(modifyEffect(this.ref, (map40) => {
      const inMap = map40.get(layer);
      if (inMap !== void 0) {
        const [acquire3, release3] = inMap;
        const cached3 = pipe(acquire3, flatMap11(([patch13, b2]) => pipe(patchFiberRefs(patch13), as3(b2))), onExit(exitMatch({
          onFailure: () => void_3,
          onSuccess: () => scopeAddFinalizerExit(scope5, release3)
        })));
        return succeed([cached3, map40]);
      }
      return pipe(make31(0), flatMap11((observers) => pipe(deferredMake(), flatMap11((deferred) => pipe(make31(() => void_3), map14((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake2(), flatMap11((innerScope) => pipe(restore(flatMap11(makeBuilder(layer, innerScope, true), (f2) => diffFiberRefs(f2(this)))), exit, flatMap11((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit4)), zipRight2(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set6(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify6(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update3(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope5, (exit5) => pipe(sync(() => map40.delete(layer)), zipRight2(get11(finalizerRef)), flatMap11((finalizer2) => finalizer2(exit5))))), zipRight2(deferredSucceed(deferred, exit4.effect_instruction_i0)), as3(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_3,
          onSuccess: () => update3(observers, (n) => n + 1)
        }))), (exit4) => pipe(get11(finalizerRef), flatMap11((finalizer2) => finalizer2(exit4)))];
        return [resource, isFresh(layer) ? map40 : map40.set(layer, memoized)];
      }))))));
    }), flatten7);
  }
};
var makeMemoMap = suspend(() => map14(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var buildWithScope = dual(2, (self, scope5) => flatMap11(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope5)));
var buildWithMemoMap = dual(3, (self, memoMap, scope5) => flatMap11(makeBuilder(self, scope5), (run4) => provideService(run4(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope5, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope5),
        onSuccess: (value6) => memoMap.getOrElseMemoize(op.successK(value6), scope5)
      })));
    }
    case "Fresh": {
      return sync(() => (_2) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_2) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap11((env) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_2) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith6(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope5), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll3 = dual(2, (self, onFailure) => match13(self, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause3 = dual(2, (self, onFailure) => matchCause3(self, {
  onFailure,
  onSuccess: succeedContext
}));
var context3 = () => fromEffectContext(context2());
var fail9 = (error2) => failCause7(fail7(error2));
var failSync2 = (evaluate3) => failCauseSync2(() => fail7(evaluate3()));
var failCause7 = (cause2) => fromEffectContext(failCause(cause2));
var failCauseSync2 = (evaluate3) => fromEffectContext(failCauseSync(evaluate3));
var flatMap14 = dual(2, (self, f2) => match13(self, {
  onFailure: fail9,
  onSuccess: f2
}));
var flatten10 = dual(2, (self, tag3) => flatMap14(self, get4(tag3)));
var fresh = (self) => {
  const fresh2 = Object.create(proto3);
  fresh2._op_layer = OP_FRESH;
  fresh2.layer = self;
  return fresh2;
};
var fromEffect3 = dual(2, (a, b2) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b2;
  const effect4 = tagFirst ? b2 : a;
  return fromEffectContext(map14(effect4, (service3) => make6(tag3, service3)));
});
function fromEffectContext(effect4) {
  const fromEffect10 = Object.create(proto3);
  fromEffect10._op_layer = OP_FROM_EFFECT;
  fromEffect10.effect = effect4;
  return fromEffect10;
}
var fiberRefLocally2 = dual(3, (self, ref, value6) => locallyEffect(self, fiberRefLocally(ref, value6)));
var locallyEffect = dual(2, (self, f2) => {
  const locally3 = Object.create(proto3);
  locally3._op_layer = "Locally";
  locally3.self = self;
  locally3.f = f2;
  return locally3;
});
var fiberRefLocallyWith2 = dual(3, (self, ref, value6) => locallyEffect(self, fiberRefLocallyWith(ref, value6)));
var map23 = dual(2, (self, f2) => flatMap14(self, (context10) => succeedContext(f2(context10))));
var mapError3 = dual(2, (self, f2) => catchAll3(self, (error2) => failSync2(() => f2(error2))));
var matchCause3 = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold2 = Object.create(proto3);
  fold2._op_layer = OP_FOLD;
  fold2.layer = self;
  fold2.failureK = onFailure;
  fold2.successK = onSuccess;
  return fold2;
});
var match13 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCause3(self, {
  onFailure: (cause2) => {
    const failureOrCause3 = failureOrCause2(cause2);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause7(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var merge5 = dual(2, (self, that) => zipWith9(self, that, (a, b2) => merge3(a, b2)));
var mergeAll3 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge5(final, layers[i]);
  }
  return final;
};
var orElse6 = dual(2, (self, that) => catchAll3(self, that));
var project = dual(4, (self, tagA, tagB, f2) => map23(self, (context10) => make6(tagB, f2(unsafeGet3(context10, tagA)))));
var retry2 = dual(2, (self, schedule2) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed7(stateTag, {
    state: schedule2.initial
  }), flatMap14((env) => retryLoop(self, schedule2, stateTag, pipe(env, get4(stateTag)).state)));
}));
var retryLoop = (self, schedule2, stateTag, state) => {
  return pipe(self, catchAll3((error2) => pipe(retryUpdate(schedule2, stateTag, error2, state), flatMap14((env) => fresh(retryLoop(self, schedule2, stateTag, pipe(env, get4(stateTag)).state))))));
};
var retryUpdate = (schedule2, stateTag, error2, state) => {
  return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap11((now3) => pipe(schedule2.step(now3, error2, state), flatMap11(([state2, _2, decision]) => isDone5(decision) ? fail2(error2) : pipe(sleep2(millis(start2(decision.intervals) - now3)), as3({
    state: state2
  })))))));
};
var scoped = dual(2, (a, b2) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b2;
  const effect4 = tagFirst ? b2 : a;
  return scopedContext(map14(effect4, (service3) => make6(tag3, service3)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as3(empty5())));
var scopedContext = (effect4) => {
  const scoped6 = Object.create(proto3);
  scoped6._op_layer = OP_SCOPED;
  scoped6.effect = effect4;
  return scoped6;
};
var scope3 = scopedContext(map14(acquireRelease(scopeMake2(), (scope5, exit4) => scope5.close(exit4)), (scope5) => make6(Scope, scope5)));
var succeed7 = dual(2, (a, b2) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b2;
  const resource = tagFirst ? b2 : a;
  return fromEffectContext(succeed(make6(tag3, resource)));
});
var succeedContext = (context10) => {
  return fromEffectContext(succeed(context10));
};
var empty36 = succeedContext(empty5());
var suspend3 = (evaluate3) => {
  const suspend12 = Object.create(proto3);
  suspend12._op_layer = OP_SUSPEND;
  suspend12.evaluate = evaluate3;
  return suspend12;
};
var sync3 = dual(2, (a, b2) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b2;
  const evaluate3 = tagFirst ? b2 : a;
  return fromEffectContext(sync(() => make6(tag3, evaluate3())));
});
var syncContext = (evaluate3) => {
  return fromEffectContext(sync(evaluate3));
};
var tap4 = dual(2, (self, f2) => flatMap14(self, (context10) => fromEffectContext(as3(f2(context10), context10))));
var tapError3 = dual(2, (self, f2) => catchAll3(self, (e) => fromEffectContext(flatMap11(f2(e), () => fail2(e)))));
var tapErrorCause3 = dual(2, (self, f2) => catchAllCause3(self, (cause2) => fromEffectContext(flatMap11(f2(cause2), () => failCause(cause2)))));
var toRuntimeWithMemoMap = dual(2, (self, memoMap) => flatMap11(scopeWith((scope5) => buildWithMemoMap(self, memoMap, scope5)), (context10) => pipe(runtime3(), provideContext(context10))));
var provide = dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context3(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll3(...that) : that
    },
    zipK: {
      value: (a, b2) => pipe(a, merge3(b2))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = dual(2, (that, self) => {
  const zipWith16 = Object.create(proto3);
  zipWith16._op_layer = OP_PROVIDE_MERGE;
  zipWith16.first = self;
  zipWith16.second = provide(that, self);
  zipWith16.zipK = (a, b2) => {
    return pipe(a, merge3(b2));
  };
  return zipWith16;
});
var zipWith9 = dual(3, (self, that, f2) => suspend3(() => {
  const zipWith16 = Object.create(proto3);
  zipWith16._op_layer = OP_ZIP_WITH2;
  zipWith16.first = self;
  zipWith16.second = that;
  zipWith16.zipK = f2;
  return zipWith16;
}));
var unwrapEffect = (self) => {
  const tag3 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap14(fromEffect3(tag3, self), (context10) => get4(context10, tag3));
};
var unwrapScoped = (self) => {
  const tag3 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap14(scoped(tag3, self), (context10) => get4(context10, tag3));
};
var annotateLogs2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set4(acc, key, value6), annotations3));
});
var annotateSpans2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set4(acc, key, value6), annotations3));
});
var withParentSpan2 = dual(2, (self, span3) => provide(self, succeedContext(make6(spanTag, span3))));
var provideSomeLayer = dual(2, (self, layer) => scopedWith((scope5) => flatMap11(buildWithScope(layer, scope5), (context10) => provideSomeContext(self, context10))));
var provideSomeRuntime = dual(2, (self, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring2(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_3;
    }));
  }));
});
var effect_provide = dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll3(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId17 in source) {
    return flatMap11(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/console.js
var console2 = map14(fiberRefGet(currentServices), get4(consoleTag));
var consoleWith = (f2) => fiberRefGetWith(currentServices, (services) => f2(get4(services, consoleTag)));
var withConsole = dual(2, (effect4, value6) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value6)));
var clear2 = consoleWith((_2) => _2.clear);
var withGroup = dual((args2) => isEffect(args2[0]), (self, options) => consoleWith((_2) => acquireUseRelease(_2.group(options), () => self, () => _2.groupEnd)));
var withTime = dual((args2) => isEffect(args2[0]), (self, label) => consoleWith((_2) => acquireUseRelease(_2.time(label), () => self, () => _2.timeEnd(label))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var array5 = (as12) => unsafeArray(as12.slice(0));
var unsafeArray = (as12) => Object.setPrototypeOf(as12, ArrayProto);
var Class4 = Structural;
var Error4 = function() {
  const plainArgsSymbol = Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError2 = (tag3) => {
  const O = {
    BaseEffectError: class extends Error4 {
      _tag = tag3;
    }
  };
  O.BaseEffectError.prototype.name = tag3;
  return O.BaseEffectError;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/dateTime.js
var TypeId18 = Symbol.for("effect/DateTime");
var TimeZoneTypeId = Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId18]: TypeId18,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol2]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol2]() {
    return pipe(number2(this.epochMillis), combine2(hash(this.zone)), cached(this));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol2]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol2]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var isDateTime = (u) => hasProperty(u, TypeId18);
var isDateTimeArgs = (args2) => isDateTime(args2[0]);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var isTimeZoneOffset = (u) => isTimeZone(u) && u._tag === "Offset";
var isTimeZoneNamed = (u) => isTimeZone(u) && u._tag === "Named";
var isUtc = (self) => self._tag === "Utc";
var isZoned = (self) => self._tag === "Zoned";
var Equivalence3 = make((a, b2) => a.epochMillis === b2.epochMillis);
var Order7 = make2((self, that) => self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0);
var clamp7 = clamp(Order7);
var makeUtc = (epochMillis) => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var unsafeFromDate = (date3) => {
  const epochMillis = date3.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
};
var unsafeMake9 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date3 = /* @__PURE__ */ new Date(0);
    setPartsDate(date3, input);
    return unsafeFromDate(date3);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
};
var hasZone = (input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input);
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake9(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new RangeError(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === void 0) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone, options?.disambiguation ?? "compatible");
};
var makeZoned = liftThrowable(unsafeMakeZoned);
var make46 = liftThrowable(unsafeMake9);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = (input) => {
  const match28 = zonedStringRegex.exec(input);
  if (match28 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match28;
  return makeZoned(isoString, {
    timeZone
  });
};
var now = map14(currentTimeMillis2, makeUtc);
var nowAsDate = map14(currentTimeMillis2, (millis2) => new Date(millis2));
var setZone = dual(isDateTimeArgs, (self, zone, options) => options?.adjustForTimeZone === true ? makeZonedFromAdjusted(self.epochMillis, zone, options?.disambiguation ?? "compatible") : makeZonedProto(self.epochMillis, zone, self.partsUtc));
var setZoneOffset = dual(isDateTimeArgs, (self, offset, options) => setZone(self, zoneMakeOffset(offset), options));
var validZoneCache = globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = (format7) => {
  const zoneId = format7.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format7;
  validZoneCache.set(zoneId, zone);
  return zone;
};
var zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
};
var zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
};
var zoneMakeNamed = liftThrowable(zoneUnsafeMakeNamed);
var zoneMakeNamedEffect = (zoneId) => try_2({
  try: () => zoneUnsafeMakeNamed(zoneId),
  catch: (e) => e
});
var zoneMakeLocal = () => zoneMakeIntl(new Intl.DateTimeFormat("en-US", formatOptions));
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some2(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
var zoneToString = (self) => {
  if (self._tag === "Offset") {
    return offsetToString(self.offset);
  }
  return self.id;
};
var setZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => map2(zoneMakeNamed(zoneId), (zone) => setZone(self, zone, options)));
var unsafeSetZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => setZone(self, zoneUnsafeMakeNamed(zoneId), options));
var distance = dual(2, (self, other) => toEpochMillis(other) - toEpochMillis(self));
var distanceDurationEither = dual(2, (self, other) => {
  const diffMillis = distance(self, other);
  return diffMillis > 0 ? right2(millis(diffMillis)) : left2(millis(-diffMillis));
});
var distanceDuration = dual(2, (self, other) => millis(Math.abs(distance(self, other))));
var min8 = min(Order7);
var max10 = max(Order7);
var greaterThan8 = greaterThan(Order7);
var greaterThanOrEqualTo6 = greaterThanOrEqualTo(Order7);
var lessThan12 = lessThan(Order7);
var lessThanOrEqualTo6 = lessThanOrEqualTo(Order7);
var between6 = between(Order7);
var toDateUtc = (self) => new Date(self.epochMillis);
var toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== void 0) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_2) => _2.type !== "literal");
  const date3 = /* @__PURE__ */ new Date(0);
  date3.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date3.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date3.getTime();
  return date3;
};
var zonedOffset = (self) => {
  const date3 = toDate(self);
  return date3.getTime() - toEpochMillis(self);
};
var offsetToString = (offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self) => offsetToString(zonedOffset(self));
var toEpochMillis = (self) => self.epochMillis;
var dateToParts = (date3) => ({
  millis: date3.getUTCMilliseconds(),
  seconds: date3.getUTCSeconds(),
  minutes: date3.getUTCMinutes(),
  hours: date3.getUTCHours(),
  day: date3.getUTCDate(),
  weekDay: date3.getUTCDay(),
  month: date3.getUTCMonth() + 1,
  year: date3.getUTCFullYear()
});
var toParts = (self) => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== void 0) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
};
var toPartsUtc = (self) => {
  if (self.partsUtc !== void 0) {
    return self.partsUtc;
  }
  self.partsUtc = withDateUtc(self, dateToParts);
  return self.partsUtc;
};
var getPartUtc = dual(2, (self, part) => toPartsUtc(self)[part]);
var getPart = dual(2, (self, part) => toParts(self)[part]);
var setPartsDate = (date3, parts2) => {
  if (parts2.year !== void 0) {
    date3.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date3.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date3.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff12 = parts2.weekDay - date3.getUTCDay();
    date3.setUTCDate(date3.getUTCDate() + diff12);
  }
  if (parts2.hours !== void 0) {
    date3.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date3.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date3.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date3.setUTCMilliseconds(parts2.millis);
  }
};
var setParts = dual(2, (self, parts2) => mutate4(self, (date3) => setPartsDate(date3, parts2)));
var setPartsUtc = dual(2, (self, parts2) => mutateUtc(self, (date3) => setPartsDate(date3, parts2)));
var constDayMillis = 24 * 60 * 60 * 1e3;
var makeZonedFromAdjusted = (adjustedMillis, zone, disambiguation) => {
  if (zone._tag === "Offset") {
    return makeZonedProto(adjustedMillis - zone.offset, zone);
  }
  const beforeOffset = calculateNamedOffset(adjustedMillis - constDayMillis, adjustedMillis, zone);
  const afterOffset = calculateNamedOffset(adjustedMillis + constDayMillis, adjustedMillis, zone);
  if (beforeOffset === afterOffset) {
    return makeZonedProto(adjustedMillis - beforeOffset, zone);
  }
  const isForwards = beforeOffset < afterOffset;
  const transitionMillis = beforeOffset - afterOffset;
  if (isForwards) {
    const currentAfterOffset = calculateNamedOffset(adjustedMillis - afterOffset, adjustedMillis, zone);
    if (currentAfterOffset === afterOffset) {
      return makeZonedProto(adjustedMillis - afterOffset, zone);
    }
    const before2 = makeZonedProto(adjustedMillis - beforeOffset, zone);
    const beforeAdjustedMillis = toDate(before2).getTime();
    if (adjustedMillis !== beforeAdjustedMillis) {
      switch (disambiguation) {
        case "reject": {
          const formatted = new Date(adjustedMillis).toISOString();
          throw new RangeError(`Gap time: ${formatted} does not exist in time zone ${zone.id}`);
        }
        case "earlier":
          return makeZonedProto(adjustedMillis - afterOffset, zone);
        case "compatible":
        case "later":
          return before2;
      }
    }
    return before2;
  }
  const currentBeforeOffset = calculateNamedOffset(adjustedMillis - beforeOffset, adjustedMillis, zone);
  if (currentBeforeOffset === beforeOffset) {
    if (disambiguation === "earlier" || disambiguation === "compatible") {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    const laterOffset = calculateNamedOffset(adjustedMillis - beforeOffset + transitionMillis, adjustedMillis + transitionMillis, zone);
    if (laterOffset === beforeOffset) {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    if (disambiguation === "reject") {
      const formatted = new Date(adjustedMillis).toISOString();
      throw new RangeError(`Ambiguous time: ${formatted} occurs twice in time zone ${zone.id}`);
    }
  }
  return makeZonedProto(adjustedMillis - afterOffset, zone);
};
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = (offset) => {
  const match28 = offsetRegex.exec(offset);
  if (match28 === null) {
    return null;
  }
  const [, sign3, hours2, minutes2] = match28;
  return (sign3 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
};
var calculateNamedOffset = (utcMillis, adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(utcMillis).find((_2) => _2.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
var mutate4 = dual(isDateTimeArgs, (self, f2, options) => {
  if (self._tag === "Utc") {
    const date3 = toDateUtc(self);
    f2(date3);
    return makeUtc(date3.getTime());
  }
  const adjustedDate = toDate(self);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f2(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone, options?.disambiguation ?? "compatible");
});
var mutateUtc = dual(2, (self, f2) => mapEpochMillis(self, (millis2) => {
  const date3 = new Date(millis2);
  f2(date3);
  return date3.getTime();
}));
var mapEpochMillis = dual(2, (self, f2) => {
  const millis2 = f2(toEpochMillis(self));
  return self._tag === "Utc" ? makeUtc(millis2) : makeZonedProto(millis2, self.zone);
});
var withDate = dual(2, (self, f2) => f2(toDate(self)));
var withDateUtc = dual(2, (self, f2) => f2(toDateUtc(self)));
var match14 = dual(2, (self, options) => self._tag === "Utc" ? options.onUtc(self) : options.onZoned(self));
var addDuration = dual(2, (self, duration3) => mapEpochMillis(self, (millis2) => millis2 + toMillis(duration3)));
var subtractDuration = dual(2, (self, duration3) => mapEpochMillis(self, (millis2) => millis2 - toMillis(duration3)));
var addMillis = (date3, amount) => {
  date3.setTime(date3.getTime() + amount);
};
var add6 = dual(2, (self, parts2) => mutate4(self, (date3) => {
  if (parts2.millis) {
    addMillis(date3, parts2.millis);
  }
  if (parts2.seconds) {
    addMillis(date3, parts2.seconds * 1e3);
  }
  if (parts2.minutes) {
    addMillis(date3, parts2.minutes * 60 * 1e3);
  }
  if (parts2.hours) {
    addMillis(date3, parts2.hours * 60 * 60 * 1e3);
  }
  if (parts2.days) {
    date3.setUTCDate(date3.getUTCDate() + parts2.days);
  }
  if (parts2.weeks) {
    date3.setUTCDate(date3.getUTCDate() + parts2.weeks * 7);
  }
  if (parts2.months) {
    const day = date3.getUTCDate();
    date3.setUTCMonth(date3.getUTCMonth() + parts2.months + 1, 0);
    if (day < date3.getUTCDate()) {
      date3.setUTCDate(day);
    }
  }
  if (parts2.years) {
    const day = date3.getUTCDate();
    const month = date3.getUTCMonth();
    date3.setUTCFullYear(date3.getUTCFullYear() + parts2.years, month + 1, 0);
    if (day < date3.getUTCDate()) {
      date3.setUTCDate(day);
    }
  }
}));
var subtract5 = dual(2, (self, parts2) => {
  const newParts = {};
  for (const key in parts2) {
    newParts[key] = -1 * parts2[key];
  }
  return add6(self, newParts);
});
var startOfDate = (date3, part, options) => {
  switch (part) {
    case "second": {
      date3.setUTCMilliseconds(0);
      break;
    }
    case "minute": {
      date3.setUTCSeconds(0, 0);
      break;
    }
    case "hour": {
      date3.setUTCMinutes(0, 0, 0);
      break;
    }
    case "day": {
      date3.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "week": {
      const weekStartsOn = options?.weekStartsOn ?? 0;
      const day = date3.getUTCDay();
      const diff12 = (day - weekStartsOn + 7) % 7;
      date3.setUTCDate(date3.getUTCDate() - diff12);
      date3.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "month": {
      date3.setUTCDate(1);
      date3.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "year": {
      date3.setUTCMonth(0, 1);
      date3.setUTCHours(0, 0, 0, 0);
      break;
    }
  }
};
var startOf = dual(isDateTimeArgs, (self, part, options) => mutate4(self, (date3) => startOfDate(date3, part, options)));
var endOfDate = (date3, part, options) => {
  switch (part) {
    case "second": {
      date3.setUTCMilliseconds(999);
      break;
    }
    case "minute": {
      date3.setUTCSeconds(59, 999);
      break;
    }
    case "hour": {
      date3.setUTCMinutes(59, 59, 999);
      break;
    }
    case "day": {
      date3.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "week": {
      const weekStartsOn = options?.weekStartsOn ?? 0;
      const day = date3.getUTCDay();
      const diff12 = (day - weekStartsOn + 7) % 7;
      date3.setUTCDate(date3.getUTCDate() - diff12 + 6);
      date3.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "month": {
      date3.setUTCMonth(date3.getUTCMonth() + 1, 0);
      date3.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "year": {
      date3.setUTCMonth(11, 31);
      date3.setUTCHours(23, 59, 59, 999);
      break;
    }
  }
};
var endOf = dual(isDateTimeArgs, (self, part, options) => mutate4(self, (date3) => endOfDate(date3, part, options)));
var nearest = dual(isDateTimeArgs, (self, part, options) => mutate4(self, (date3) => {
  if (part === "milli") return;
  const millis2 = date3.getTime();
  const start5 = new Date(millis2);
  startOfDate(start5, part, options);
  const startMillis = start5.getTime();
  const end6 = new Date(millis2);
  endOfDate(end6, part, options);
  const endMillis = end6.getTime() + 1;
  const diffStart = millis2 - startMillis;
  const diffEnd = endMillis - millis2;
  if (diffStart < diffEnd) {
    date3.setTime(startMillis);
  } else {
    date3.setTime(endMillis);
  }
}));
var intlTimeZone = (self) => {
  if (self._tag === "Named") {
    return self.id;
  }
  return offsetToString(self.offset);
};
var format5 = dual(isDateTimeArgs, (self, options) => {
  try {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: self._tag === "Utc" ? "UTC" : intlTimeZone(self.zone),
      ...options
    }).format(self.epochMillis);
  } catch {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: "UTC",
      ...options
    }).format(toDate(self));
  }
});
var formatLocal = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, options).format(self.epochMillis));
var formatUtc = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, {
  ...options,
  timeZone: "UTC"
}).format(self.epochMillis));
var formatIntl = dual(2, (self, format7) => format7.format(self.epochMillis));
var formatIso = (self) => toDateUtc(self).toISOString();
var formatIsoOffset = (self) => {
  const date3 = toDate(self);
  return self._tag === "Utc" ? date3.toISOString() : `${date3.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
var formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/String.js
var concat2 = dual(2, (self, that) => self + that);
var toUpperCase = (self) => self.toUpperCase();
var toLowerCase = (self) => self.toLowerCase();
var capitalize = (self) => {
  if (self.length === 0) return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var uncapitalize = (self) => {
  if (self.length === 0) return self;
  return toLowerCase(self[0]) + self.slice(1);
};
var isNonEmpty6 = (self) => self.length > 0;
var split3 = dual(2, (self, separator) => {
  const out = self.split(separator);
  return isNonEmptyArray(out) ? out : [self];
});
var charCodeAt = dual(2, (self, index) => filter(some2(self.charCodeAt(index)), (charCode) => !isNaN(charCode)));
var at3 = dual(2, (self, index) => fromNullable2(self.at(index)));
var charAt = dual(2, (self, index) => filter(some2(self.charAt(index)), isNonEmpty6));
var codePointAt = dual(2, (self, index) => fromNullable2(self.codePointAt(index)));
var search = dual(2, (self, regexp) => filter(some2(self.search(regexp)), greaterThanOrEqualTo2(0)));
var takeLeft = dual(2, (self, n) => self.slice(0, Math.max(n, 0)));
var takeRight3 = dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
var CR = 13;
var LF = 10;
var linesWithSeparators = (s) => linesSeparated(s, false);
var stripMarginWith = dual(2, (self, marginChar) => {
  let out = "";
  for (const line of linesWithSeparators(self)) {
    let index = 0;
    while (index < line.length && line.charAt(index) <= " ") {
      index = index + 1;
    }
    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;
    out = out + stripped;
  }
  return out;
});
var LinesIterator = class _LinesIterator {
  s;
  stripped;
  index;
  length;
  constructor(s, stripped = false) {
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const start5 = this.index;
    while (!this.done && !isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end6 = this.index;
    if (!this.done) {
      const char2 = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done && isLineBreak2(char2, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end6 = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start5, end6)
    };
  }
  [Symbol.iterator]() {
    return new _LinesIterator(this.s, this.stripped);
  }
  get done() {
    return this.index >= this.length;
  }
};
var isLineBreak = (char2) => {
  const code = char2.charCodeAt(0);
  return code === CR || code === LF;
};
var isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;
var linesSeparated = (self, stripped) => new LinesIterator(self, stripped);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Cron.js
var TypeId19 = Symbol.for("effect/Cron");
var CronProto = {
  [TypeId19]: TypeId19,
  [symbol3](that) {
    return isCron(that) && equals5(this, that);
  },
  [symbol2]() {
    return pipe(hash(this.tz), combine2(array2(fromIterable(this.seconds))), combine2(array2(fromIterable(this.minutes))), combine2(array2(fromIterable(this.hours))), combine2(array2(fromIterable(this.days))), combine2(array2(fromIterable(this.months))), combine2(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable(this.seconds),
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId19);
var ParseErrorTypeId = Symbol.for("effect/Cron/errors/ParseError");
var ParseError = class extends TaggedError2("CronParseError") {
  /**
   * @since 2.0.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
};
var Equivalence4 = make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = array(number);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable(self), fromIterable(that));
var equals5 = dual(2, (self, that) => Equivalence4(self, that));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Random.js
var next2 = next;
var fixed2 = fixed;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata = Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = (iterationMetaRef, now3, input, output) => update3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now3,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now3
} : {
  now: now3,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now3 - prev.start),
  elapsedSincePrevious: millis(now3 - prev.now),
  start: prev.start
});
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule2, ref) {
    this.schedule = schedule2;
    this.ref = ref;
  }
  get state() {
    return map14(get11(this.ref), (tuple4) => tuple4[1]);
  }
  get last() {
    return flatMap11(get11(this.ref), ([element2, _2]) => {
      switch (element2._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element2.value);
        }
      }
    });
  }
  iterationMeta = unsafeMake6(defaultIterationMetadata);
  get reset() {
    return set6(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set6(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map14(get11(this.ref), (tuple4) => tuple4[1]), flatMap11((state) => pipe(currentTimeMillis2, flatMap11((now3) => pipe(suspend(() => this.schedule.step(now3, input, state)), flatMap11(([state2, out, decision]) => {
      const setState = set6(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now3;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now3, input, out)), as3(out));
      }
      const duration3 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now3, input, out)), zipRight2(sleep3(duration3)), as3(out));
    }))))));
  }
};
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = dual(2, (self, f2) => addDelayEffect(self, (out) => sync(() => f2(out))));
var addDelayEffect = dual(2, (self, f2) => modifyDelayEffect(self, (out, duration3) => map14(f2(out), (delay4) => sum4(duration3, decode(delay4)))));
var andThen8 = dual(2, (self, that) => map24(andThenEither(self, that), merge));
var andThenEither = dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now3, input, state) => state[2] ? flatMap11(self.step(now3, input, state[0]), ([lState, out, decision]) => {
  if (isDone5(decision)) {
    return map14(that.step(now3, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
  }
  return succeed([[lState, state[1], true], left2(out), decision]);
}) : map14(that.step(now3, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
var as5 = dual(2, (self, out) => map24(self, () => out));
var asVoid4 = (self) => map24(self, constVoid);
var bothInOut = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, [in1, in2], state) => zipWith6(self.step(now3, in1, state[0]), that.step(now3, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union10(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done7];
})));
var check2 = dual(2, (self, test2) => checkEffect(self, (input, out) => sync(() => test2(input, out))));
var checkEffect = dual(2, (self, test2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done7]);
  }
  return map14(test2(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
})));
var compose4 = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, input, state) => flatMap11(self.step(now3, input, state[0]), ([lState, out, lDecision]) => map14(that.step(now3, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max9(rDecision.intervals)))]))));
var mapInput6 = dual(2, (self, f2) => mapInputEffect(self, (input2) => sync(() => f2(input2))));
var mapInputContext2 = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => mapInputContext(self.step(now3, input, state), f2)));
var mapInputEffect = dual(2, (self, f2) => makeWithState(self.initial, (now3, input2, state) => flatMap11(f2(input2), (input) => self.step(now3, input, state))));
var delayed = dual(2, (self, f2) => delayedEffect(self, (duration3) => sync(() => f2(duration3))));
var delayedEffect = dual(2, (self, f2) => modifyDelayEffect(self, (_2, delay4) => f2(delay4)));
var mapBoth4 = dual(2, (self, {
  onInput,
  onOutput
}) => map24(mapInput6(self, onInput), onOutput));
var mapBothEffect = dual(2, (self, {
  onInput,
  onOutput
}) => mapEffect3(mapInputEffect(self, onInput), onOutput));
var driver = (self) => pipe(make31([none2(), self.initial]), map14((ref) => new ScheduleDriverImpl(self, ref)));
var either3 = dual(2, (self, that) => union11(self, that));
var eitherWith = dual(3, (self, that, f2) => unionWith2(self, that, f2));
var ensuring3 = dual(2, (self, finalizer2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => isDone5(decision) ? as3(finalizer2, [state2, out, decision]) : succeed([state2, out, decision]))));
var intersect5 = dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = dual(3, (self, that, f2) => makeWithState([self.initial, that.initial], (now3, input, state) => pipe(zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), (a, b2) => [a, b2]), flatMap11(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f2);
  }
  return succeed([[lState, rState], [out, out2], done7]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f2) => {
  const combined = f2(lInterval, rInterval);
  if (isNonEmpty5(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan11(rInterval))) {
    return flatMap11(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f2);
    });
  }
  return flatMap11(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f2);
  });
};
var jitteredWith = dual(2, (self, options) => {
  const {
    max: max11,
    min: min9
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, (duration3) => map14(next2, (random3) => {
    const d = toMillis(duration3);
    const jittered2 = d * min9 * (1 - random3) + d * max11 * random3;
    return millis(jittered2);
  }));
});
var map24 = dual(2, (self, f2) => mapEffect3(self, (out) => sync(() => f2(out))));
var mapEffect3 = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => map14(f2(out), (out2) => [state2, out2, decision]))));
var modifyDelay = dual(2, (self, f2) => modifyDelayEffect(self, (out, duration3) => sync(() => f2(out, duration3))));
var modifyDelayEffect = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay4 = size11(make41(now3, start2(intervals)));
  return map14(f2(out, delay4), (durationInput) => {
    const duration3 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now3 + toMillis(duration3);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make41(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var onDecision = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => as3(f2(out, decision), [state2, out, decision]))));
var passthrough = (self) => makeWithState(self.initial, (now3, input, state) => pipe(self.step(now3, input, state), map14(([state2, _2, decision]) => [state2, input, decision])));
var provideContext3 = dual(2, (self, context10) => makeWithState(self.initial, (now3, input, state) => provideContext(self.step(now3, input, state), context10)));
var provideService4 = dual(3, (self, tag3, service3) => makeWithState(self.initial, (now3, input, state) => contextWithEffect((env) => provideContext(
  // @ts-expect-error
  self.step(now3, input, state),
  add2(env, tag3, service3)
))));
var recurUpTo = (durationInput) => {
  const duration3 = decode(durationInput);
  return whileOutput(elapsed, (elapsed2) => lessThan5(elapsed2, duration3));
};
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var reduce15 = dual(3, (self, zero3, f2) => reduceEffect2(self, zero3, (z2, out) => sync(() => f2(z2, out))));
var reduceEffect2 = dual(3, (self, zero3, f2) => makeWithState([self.initial, zero3], (now3, input, [s, z2]) => flatMap11(self.step(now3, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z2], z2, decision]) : map14(f2(z2, out), (z22) => [[s2, z22], z2, decision]))));
var resetAfter = dual(2, (self, durationInput) => {
  const duration3 = decode(durationInput);
  return pipe(self, intersect5(elapsed), resetWhen(([, time2]) => greaterThanOrEqualTo5(time2, duration3)), map24((out) => out[0]));
});
var resetWhen = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap11(self.step(now3, input, state), ([state2, out, decision]) => f2(out) ? self.step(now3, input, self.initial) : succeed([state2, out, decision]))));
var run = dual(3, (self, now3, input) => pipe(runLoop(self, now3, fromIterable2(input), self.initial, empty6()), map14((list) => reverse2(list))));
var runLoop = (self, now3, inputs, state, acc) => {
  if (!isNonEmpty2(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap11(self.step(now3, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend3(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend3(acc, out));
  });
};
var spaced = (duration3) => addDelay(forever2, () => duration3);
var tapInput = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => zipRight2(f2(input), self.step(now3, input, state))));
var tapOutput = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => tap2(self.step(now3, input, state), ([, out]) => f2(out))));
var unfold2 = (initial, f2) => makeWithState(initial, (now3, _2, state) => sync(() => [f2(state), state, continueWith2(after2(now3))]));
var union11 = dual(2, (self, that) => unionWith2(self, that, union10));
var unionWith2 = dual(3, (self, that, f2) => makeWithState([self.initial, that.initial], (now3, input, state) => zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), ([lState, l2, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l2, r], done7];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l2, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l2, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f2(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l2, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = dual(2, (self, f2) => check2(self, (input, _2) => !f2(input)));
var untilInputEffect = dual(2, (self, f2) => checkEffect(self, (input, _2) => negate(f2(input))));
var untilOutput = dual(2, (self, f2) => check2(self, (_2, out) => !f2(out)));
var untilOutputEffect = dual(2, (self, f2) => checkEffect(self, (_2, out) => negate(f2(out))));
var upTo = dual(2, (self, duration3) => zipLeft4(self, recurUpTo(duration3)));
var whileInput = dual(2, (self, f2) => check2(self, (input, _2) => f2(input)));
var whileInputEffect = dual(2, (self, f2) => checkEffect(self, (input, _2) => f2(input)));
var whileOutput = dual(2, (self, f2) => check2(self, (_2, out) => f2(out)));
var whileOutputEffect = dual(2, (self, f2) => checkEffect(self, (_2, out) => f2(out)));
var zipLeft4 = dual(2, (self, that) => map24(intersect5(self, that), (out) => out[0]));
var zipRight5 = dual(2, (self, that) => map24(intersect5(self, that), (out) => out[1]));
var zipWith10 = dual(3, (self, that, f2) => map24(intersect5(self, that), ([out, out2]) => f2(out, out2)));
var ScheduleDefectTypeId = Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error2) {
    this.error = error2;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_2) => isDieType(_2) && isScheduleDefect(_2.defect) ? some2(_2.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error2) => fail(error2.error)
});
var scheduleDefectRefail = (effect4) => catchAllCause(effect4, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = dual(2, (self, schedule2) => repeatOrElse_Effect(self, schedule2, (e, _2) => fail2(e)));
var repeat_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map24((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = dual(3, (self, schedule2, orElse15) => flatMap11(driver(schedule2), (driver3) => matchEffect(self, {
  onFailure: (error2) => orElse15(error2, none2()),
  onSuccess: (value6) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (error2, option6) => provideServiceEffect(orElse15(error2, option6), CurrentIterationMetadata, get11(driver3.iterationMeta)), value6)
})));
var repeatOrElseEffectLoop = (self, driver3, orElse15, value6) => matchEffect(driver3.next(value6), {
  onFailure: () => orDie(driver3.last),
  onSuccess: (b2) => matchEffect(self, {
    onFailure: (error2) => orElse15(error2, some2(b2)),
    onSuccess: (value7) => repeatOrElseEffectLoop(self, driver3, orElse15, value7)
  })
});
var retry_Effect = dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _2) => fail2(e)));
var retry_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = dual(3, (self, policy, orElse15) => flatMap11(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse15(e, out), CurrentIterationMetadata, get11(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver3, orElse15) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap11((out) => orElse15(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver3, orElse15)
  }));
};
var schedule_Effect = dual(2, (self, schedule2) => scheduleFrom_Effect(self, void 0, schedule2));
var scheduleFrom_Effect = dual(3, (self, initial, schedule2) => flatMap11(driver(schedule2), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = (self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap11(self, (a) => scheduleFrom_EffectLoop(self, a, driver3))
});
var count = unfold2(0, (n) => n + 1);
var elapsed = makeWithState(none2(), (now3, _2, state) => {
  switch (state._tag) {
    case "None": {
      return succeed([some2(now3), zero2, continueWith2(after2(now3))]);
    }
    case "Some": {
      return succeed([some2(state.value), millis(now3 - state.value), continueWith2(after2(now3))]);
    }
  }
});
var forever2 = unfold2(0, (n) => n + 1);
var once2 = asVoid4(recurs(1));
var stop = asVoid4(recurs(0));
var scheduleForked = dual(2, (self, schedule2) => forkScoped(schedule_Effect(self, schedule2)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId20 = Symbol.for("effect/ExecutionPlan");
var withExecutionPlan = dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap11(whileLoop({
    while: () => i < plan.steps.length && (result === void 0 || isLeft2(result)),
    body: () => {
      const step3 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step3.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
      } else {
        const schedule2 = scheduleFromStep(step3, true);
        nextEffect = schedule2 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule2)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either8) => {
      result = either8;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step3, first4) => {
  if (!first4) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? void 0 : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : void 0
  });
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/query.js
var currentCache = globalValue(Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map14(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = globalValue(Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap11(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap11(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap11(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap11(exit(blocked(empty20, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap11(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap11(deferredMake(), (ref) => ensuring2(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var withRequestCaching = dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;
var Class5 = Class3;
var EntryTypeId2 = Symbol.for("effect/RequestBlock.Entry");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var all7 = all5;
var dropUntil2 = dropUntil;
var dropWhile4 = dropWhile3;
var filter12 = filter11;
var findFirst10 = findFirst7;
var forEach16 = forEach15;
var reduce16 = reduce12;
var async2 = async_;
var withFiberRuntime2 = withFiberRuntime;
var fail10 = fail2;
var failSync3 = failSync;
var failCause8 = failCause;
var die5 = die2;
var dieMessage2 = dieMessage;
var gen3 = gen2;
var never4 = never;
var succeed8 = succeed;
var succeedNone3 = succeedNone;
var suspend4 = suspend;
var sync4 = sync;
var _void = void_3;
var catchAll4 = catchAll;
var catchAllCause4 = catchAllCause;
var catchSomeCause2 = catchSomeCause;
var ignore2 = ignore;
var interrupt8 = interrupt2;
var interruptible4 = interruptible2;
var uninterruptible3 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var as6 = as3;
var asSome3 = asSome;
var asVoid5 = asVoid2;
var map25 = map14;
var mapBoth5 = mapBoth3;
var mapError4 = mapError;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var ensuring4 = ensuring2;
var scope4 = scope2;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var diffFiberRefs2 = diffFiberRefs;
var fiberIdWith2 = fiberIdWith;
var forkDaemon3 = forkDaemon2;
var forkIn3 = forkIn2;
var forkScoped2 = forkScoped;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var context4 = context2;
var contextWith2 = contextWith;
var provide2 = effect_provide;
var provideService5 = provideService;
var provideServiceEffect3 = provideServiceEffect;
var either4 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var when3 = when;
var flatMap15 = flatMap11;
var flatten11 = flatten7;
var race3 = race2;
var raceFirst3 = raceFirst2;
var raceWith2 = raceWith;
var tap5 = tap2;
var tapErrorCause4 = tapErrorCause;
var forever3 = forever;
var repeat2 = repeat_combined;
var match16 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect4 = matchEffect;
var orDie2 = orDie;
var orElse7 = orElse3;
var withRandom2 = withRandom;
var withRandomFixed = dual(2, (effect4, values7) => withRandom2(effect4, fixed2(values7)));
var runtime4 = runtime3;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var runFork2 = unsafeForkEffect;
var runPromise = unsafeRunPromiseEffect;
var runSync = unsafeRunSyncEffect;
var zip10 = zipOptions;
var zipLeft5 = zipLeftOptions;
var zipRight6 = zipRightOptions;
var zipWith11 = zipWithOptions;
var ap3 = dual(2, (self, that) => zipWith11(self, that, (f2, a) => f2(a)));
var request = dual((args2) => isRequest2(args2[0]), fromRequest);
var transposeMapOption2 = dual(2, (self, f2) => isNone(self) ? succeedNone3 : map25(f2(self.value), some));
var fnUntraced2 = fnUntraced;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberRef.js
var unsafeMake10 = fiberRefUnsafeMake;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentScheduler2 = currentScheduler;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/layer/circular.js
var withMinimumLogLevel = dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));
var addLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add4(logger)));
var addLoggerEffect = (effect4) => unwrapEffect(map14(effect4, addLogger));
var addLoggerScoped = (effect4) => unwrapScoped(map14(effect4, addLogger));
var removeLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove6(logger)));
var replaceLogger = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLogger(that)));
var replaceLoggerEffect = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLoggerEffect(that)));
var replaceLoggerScoped = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLoggerScoped(that)));
var enableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(enable(CooperativeYielding)));
var enableInterruption = scopedDiscard(withRuntimeFlagsScoped(enable(Interruption)));
var enableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(enable(OpSupervision)));
var enableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(enable(RuntimeMetrics)));
var enableWindDown = scopedDiscard(withRuntimeFlagsScoped(enable(WindDown)));
var disableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(disable(CooperativeYielding)));
var disableInterruption = scopedDiscard(withRuntimeFlagsScoped(disable(Interruption)));
var disableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(disable(OpSupervision)));
var disableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(disable(RuntimeMetrics)));
var disableWindDown = scopedDiscard(withRuntimeFlagsScoped(disable(WindDown)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Layer.js
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var buildWithScope2 = buildWithScope;
var context5 = context3;
var effect = fromEffect3;
var map26 = map23;
var merge7 = merge5;
var scopedContext2 = scopedContext;
var succeedContext2 = succeedContext;
var sync5 = sync3;
var provide3 = provide;
var unwrapScoped2 = unwrapScoped;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = dual(3, (layer, tag3, f2) => provide3(layer, map26(context5(), (c) => add2(c, tag3, f2(unsafeGet3(c, tag3))))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_2) => _2
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2
};
var QueueImpl = class extends Class2 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map14(this.size, (size23) => size23 <= 0);
  }
  get isFull() {
    return map14(this.size, (size23) => size23 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value6);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value6);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value6);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value6);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value6], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const values7 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values7.length)) : empty3;
      const [forTakers, remaining] = pipe(values7, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get7(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values7 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values7);
      });
    });
  }
  takeUpTo(max11) {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values7 = this.queue.pollUpTo(max11);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values7);
    }));
  }
  takeBetween(min9, max11) {
    return suspend(() => takeRemainderLoop(this, min9, max11, empty6()));
  }
};
var takeRemainderLoop = (self, min9, max11, acc) => {
  if (max11 < min9) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max11), flatMap11((bs) => {
    const remaining = min9 - bs.length;
    if (remaining === 1) {
      return pipe(take5(self), map14((b2) => pipe(acc, appendAll3(bs), append3(b2))));
    }
    if (remaining > 1) {
      return pipe(take5(self), flatMap11((b2) => takeRemainderLoop(self, remaining - 1, max11 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b2)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap11((queue) => make47(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap11((queue) => make47(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap11((queue) => make47(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap11((queue) => make47(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake11 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make47 = (queue, strategy) => pipe(deferredMake(), map14((deferred) => unsafeMake11(queue, unbounded(), deferred, make13(false), strategy)));
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable3) {
    this.mutable = mutable3;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element2) {
    return offer(this.mutable, element2);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable3) => new BackingQueueFromMutableQueue(mutable3);
var capacity2 = (self) => self.capacity();
var size12 = (self) => self.size;
var isFull = (self) => self.isFull;
var isEmpty10 = (self) => self.isEmpty;
var isShutdown = (self) => self.isShutdown;
var awaitShutdown = (self) => self.awaitShutdown;
var shutdown = (self) => self.shutdown;
var offer2 = dual(2, (self, value6) => self.offer(value6));
var unsafeOffer = dual(2, (self, value6) => self.unsafeOffer(value6));
var offerAll2 = dual(2, (self, iterable) => self.offerAll(iterable));
var poll5 = (self) => map14(self.takeUpTo(1), head2);
var take5 = (self) => self.take;
var takeAll = (self) => self.takeAll;
var takeUpTo = dual(2, (self, max11) => self.takeUpTo(max11));
var takeBetween = dual(3, (self, min9, max11) => self.takeBetween(min9, max11));
var takeN = dual(2, (self, n) => self.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap11((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap11((putters) => forEachConcurrentDiscard(putters, ([_2, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_3, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get7(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend3(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value6 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value6, deferred, true]));
      } else {
        pipe(this.putters, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter5(([, _2]) => _2 !== deferred)));
  }
};
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next5;
    let offering = true;
    while (!(next5 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next5.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as12) => {
  return pipe(queue, offerAll(as12));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max11) => {
  return pipe(queue, pollUpTo(max11));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter5((b2) => a !== b2)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element2 = queue.poll(EmptyMutableQueue);
      if (element2 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element2);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend3(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set19 = subscribers.get(subscription);
  set19.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set19 = subscribers.get(subscription);
  set19.delete(pollers);
  if (set19.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new BackPressureStrategy2());
});
var dropping2 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var sliding2 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new SlidingStrategy2());
});
var unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var shutdown2 = (self) => self.shutdown;
var publish = dual(2, (self, value6) => self.publish(value6));
var publishAll = dual(2, (self, elements) => self.publishAll(elements));
var subscribe = (self) => self.subscribe;
var makeBoundedPubSub = (capacity7) => {
  const options = typeof capacity7 === "number" ? {
    capacity: capacity7
  } : capacity7;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : void 0);
var makeSubscription = (pubsub, subscribers, strategy) => map14(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make13(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
var BoundedPubSubArb = class {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value6;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk4 = fromIterable2(elements);
    const n = chunk4.length;
    const size23 = this.publisherIndex - this.subscribersIndex;
    const available2 = this.capacity - size23;
    const forPubSub = Math.min(n, available2);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk4, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop3(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty6();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size23 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size23);
    if (toPoll <= 0) {
      return empty6();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.mask = capacity7 - 1;
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value6;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk4 = fromIterable2(elements);
    const n = chunk4.length;
    const size23 = this.publisherIndex - this.subscribersIndex;
    const available2 = this.capacity - size23;
    const forPubSub = Math.min(n, available2);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk4, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop3(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty6();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size23 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size23);
    if (toPoll <= 0) {
      return empty6();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value6;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk4 = fromIterable2(elements);
    if (isEmpty(chunk4)) {
      return chunk4;
    }
    if (this.publish(unsafeHead2(chunk4))) {
      return drop3(chunk4, 1);
    } else {
      return chunk4;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty6();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value6,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty6();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty46 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty46 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty46;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var SubscriptionImpl = class extends Class2 {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map14(this.size, (size23) => size23 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set3(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const as12 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty6();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll3(this.replayWindow.takeAll(), as12));
      }
      return succeed(as12);
    });
  }
  takeUpTo(max11) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max11) {
        const as13 = this.replayWindow.takeN(max11);
        return succeed(as13);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max11 = max11 - replay.length;
      }
      const as12 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max11) : empty6();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll3(replay, as12)) : succeed(as12);
    });
  }
  takeBetween(min9, max11) {
    return suspend(() => takeRemainderLoop2(this, min9, max11, empty6()));
  }
};
var takeRemainderLoop2 = (self, min9, max11, acc) => {
  if (max11 < min9) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max11), flatMap11((bs) => {
    const remaining = min9 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map14((b2) => pipe(acc, appendAll3(bs), append3(b2))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap11((b2) => takeRemainderLoop2(self, remaining - 1, max11 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b2)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var PubSubImpl = class {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map14(this.size, (size23) => size23 === this.capacity());
  }
  get isEmpty() {
    return map14(this.size, (size23) => size23 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value6)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value6), this.shutdownFlag);
    });
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value6)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire3 = tap2(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
    return map14(acquireRelease(acquire3, (tuple4, exit4) => tuple4[0].close(exit4)), (tuple4) => tuple4[1]);
  }
  offer(value6) {
    return this.publish(value6);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = (pubsub, strategy) => flatMap11(scopeMake2(), (scope5) => map14(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make13(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity7) => {
  if (capacity7 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity7}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as12) => {
  return pipe(queue, offerAll(as12));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max11) => {
  return subscription.pollUpTo(max11);
};
var unsafePublishAll = (pubsub, as12) => {
  return pubsub.publishAll(as12);
};
var unsafeRemove2 = (queue, value6) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter5((elem) => elem !== value6)));
};
var BackPressureStrategy2 = class {
  publishers = unbounded();
  get shutdown() {
    return flatMap11(fiberId, (fiberId3) => flatMap11(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_2, deferred, last6]) => last6 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_3, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get7(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend3(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next5 = iterator.next();
    if (!next5.done) {
      while (1) {
        const value6 = next5.value;
        next5 = iterator.next();
        if (next5.done) {
          pipe(this.publishers, offer([value6, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter5(([_2, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it2 = elements[Symbol.iterator]();
    let next5 = it2.next();
    if (!next5.done && pubsub.capacity > 0) {
      let a = next5.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next5 = it2.next()) && !next5.done) {
          a = next5.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty7(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend3(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};
var ReplayBuffer = class {
  capacity;
  constructor(capacity7) {
    this.capacity = capacity7;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as12) {
    for (const a of as12) {
      this.offer(a);
    }
  }
};
var ReplayWindowImpl = class {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer3) {
    this.buffer = buffer3;
    this.index = buffer3.index;
    this.remaining = buffer3.size;
    this.head = buffer3.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value6 = this.head.value;
    this.head = this.head.next;
    return value6;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty6();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value6 = this.head.value;
      this.head = this.head.next;
      items[i] = value6;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty6(),
  takeAll: () => empty6()
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var shutdown3 = shutdown2;
var publish2 = publish;
var subscribe2 = subscribe;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Queue.js
var DequeueTypeId2 = DequeueTypeId;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity4 = capacity2;
var size14 = size12;
var isEmpty12 = isEmpty10;
var isFull3 = isFull;
var isShutdown3 = isShutdown;
var awaitShutdown3 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take6 = take5;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_2) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};
var match17 = dual(2, (self, {
  onClose,
  onContinue,
  onYield
}) => {
  switch (self._tag) {
    case OP_CONTINUE2: {
      return onContinue();
    }
    case OP_CLOSE: {
      return onClose(self.value);
    }
    case OP_YIELD2: {
      return onYield();
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr2: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone2: (_2) => _2
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer2) {
    this.finalizer = finalizer2;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
var match18 = dual(2, (self, {
  onAllEnqueued,
  onNext
}) => {
  switch (self._tag) {
    case OP_PULL_AFTER_NEXT: {
      return onNext(self.emitSeparator);
    }
    case OP_PULL_AFTER_ALL_ENQUEUED: {
      return onAllEnqueued(self.emitSeparator);
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = dual(2, (self, release3) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release3;
  return op;
});
var catchAllCause5 = dual(2, (self, f2) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed9, f2);
  return op;
});
var collectElements = (self) => {
  return suspend5(() => {
    const builder = [];
    return flatMap16(pipeTo(self, collectElementsReader(builder)), (value6) => sync6(() => [fromIterable2(builder), value6]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap16(sync6(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail11,
  onDone: succeedNow
});
var concatAllWith = (channels, f2, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f2;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = dual(4, (self, f2, g, h2) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f2;
  return op;
});
var concatMapWithCustom = dual(6, (self, f2, g, h2, onPull, onEmit) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = onPull;
  op.onEmit = onEmit;
  op.value = () => self;
  op.k = f2;
  return op;
});
var embedInput = dual(2, (self, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = dual(2, (self, finalizer2) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer2;
  return op;
});
var fail11 = (error2) => failCause9(fail7(error2));
var failCause9 = (cause2) => failCauseSync3(() => cause2);
var failCauseSync3 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
};
var flatMap16 = dual(2, (self, f2) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f2, failCause9);
  return op;
});
var foldCauseChannel = dual(2, (self, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect4 = (effect4) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = dual(2, (self, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var provideContext4 = dual(2, (self, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self;
  return op;
});
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause2) => match(failureOrCause2(cause2), {
    onLeft: options.onFailure,
    onRight: failCause9
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed9 = (value6) => sync6(() => value6);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend5 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
};
var sync6 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
};
var void_7 = succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect4) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone2) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone2;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : void 0;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith11(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next5) => {
      if (acc !== void 0 && next5 !== void 0) {
        return zipWith11(acc, exit3(next5), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next5 !== void 0) {
        return exit3(next5);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next5) => {
      if (acc !== void 0 && next5 !== void 0) {
        return zipWith11(acc, exit3(next5), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next5 !== void 0) {
        return exit3(next5);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value6, next5) {
    this.value = value6;
    this.next = next5;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value6) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value6;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};
var match19 = dual(2, (self, {
  onNoUpstream,
  onPulled
}) => {
  switch (self._tag) {
    case OP_PULLED: {
      return onPulled(self.value);
    }
    case OP_NO_UPSTREAM: {
      return onNoUpstream(self.activeDownstreamCount);
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap15(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match7(inputExecutor.getDone(), {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: (value6) => bridgeInput.done(value6)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap15(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause2) => bridgeInput.error(cause2));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap15(forkDaemon3(interruptible4(drainer())), (fiber) => sync4(() => this.addFinalizer((exit4) => flatMap15(interrupt7(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync4(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight6(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value6) => channel.k(value6), void 0, [], (x, y2) => channel.combineInners(x, y2), (x, y2) => channel.combineAll(x, y2), (request2) => channel.onPull(request2), (value6) => channel.onEmit(value6));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_7;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect4, {
                  onFailure: (cause2) => {
                    const state = this.doneHalt(cause2);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value6) => {
                    const state = this.doneSucceed(value6);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync4(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read2 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read2.more(emitted);
                  } catch (error2) {
                    this._currentChannel = read2.done.onExit(die3(error2));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit3 = (exit5) => {
                    return read2.done.onExit(exit5);
                  };
                  this._currentChannel = onExit3(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error2) {
          this._currentChannel = failCause9(die4(error2));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer2) {
    this._inProgressFinalizer = finalizer2;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next5 = this._doneStack.pop();
    while (next5) {
      if (next5._tag === "ContinuationFinalizer") {
        finalizers.push(next5.finalizer);
      }
      next5 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer2 = this._inProgressFinalizer;
    if (finalizer2 !== void 0) {
      runInProgressFinalizers = pipe(finalizer2, ensuring4(sync4(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring4(sync4(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip10(exit3(ifNotNull(runInProgressFinalizers))),
      zip10(exit3(ifNotNull(closeSelf))),
      map25(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible3,
      // TODO: remove
      flatMap15((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value6) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const head8 = this._doneStack[this._doneStack.length - 1];
    if (head8._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head8.onSuccess(value6);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), succeed3(value6));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync4(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap15(() => sync4(() => this.doneSucceed(value6))));
    return fromEffect5(effect4);
  }
  doneHalt(cause2) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const head8 = this._doneStack[this._doneStack.length - 1];
    if (head8._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head8.onHalt(cause2);
      } catch (error2) {
        this._currentChannel = failCause9(die4(error2));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), failCause3(cause2));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync4(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap15(() => sync4(() => this.doneHalt(cause2))));
    return fromEffect5(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible3(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause2) => sync4(() => {
        this._currentChannel = failCause9(cause2);
      }),
      onSuccess: (out) => sync4(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring9) {
    this.addFinalizer(ensuring9.finalizer);
    this._currentChannel = ensuring9.channel;
  }
  addFinalizer(f2) {
    this._doneStack.push(new ContinuationFinalizerImpl(f2));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match7(exit4, {
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value6) => this.doneSucceed(value6)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach16((closeFunc) => pipe(sync4(() => closeFunc(subexecutorDone)), flatMap15((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match7({
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value6) => this.doneSucceed(value6)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match7({
      onFailure: (cause2) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause2), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight6(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map25(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain4 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map25(() => this.replaceSubexecutor(drain4)));
        }
        this.replaceSubexecutor(drain4);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map15((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach16(finalizers, (fin) => exit3(fin(exit4))), map25((exits) => pipe(all2(exits), getOrElse2(() => void_4))), flatMap15((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read2 = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read2());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read2());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause4((cause2) => suspend4(() => {
          const doneEffect = current2.onDone(failCause3(cause2));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read2());
      }
    }
  };
  return read2();
};
var runIn = dual(2, (self, scope5) => {
  const run4 = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync4(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight6(_await(channelDeferred)), zipLeft5(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause4(finalize, (cause2) => addFinalizer2(scope6, failCause8(cause2)));
  });
  return uninterruptibleMask3((restore) => all7([fork2(scope5, sequential3), make21(), make21()]).pipe(flatMap15(([child, channelDeferred, scopeDeferred]) => restore(run4(channelDeferred, scopeDeferred, child)).pipe(forkIn3(scope5), flatMap15((fiber) => scope5.addFinalizer((exit4) => {
    const interruptors3 = isFailure(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap15((isDone8) => isDone8 ? succeed2(scopeDeferred, void 0).pipe(zipRight6(_await3(fiber)), zipRight6(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight6(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll3(interruptors3)) : interrupt7(fiber)), zipRight6(inheritAll2(fiber)))));
  }).pipe(zipRight6(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap15(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
    }
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_2) => _2,
    _E0: (_2) => _2,
    _Z0: (_2) => _2,
    _E: (_2) => _2,
    _Z: (_2) => _2
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f2) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f2;
  return op;
};
var match20 = dual(2, (self, {
  onAwait,
  onDone: onDone2
}) => {
  const op = self;
  switch (op._tag) {
    case OP_DONE4:
      return onDone2(op.effect);
    case OP_AWAIT:
      return onAwait(op.f);
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f2) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f2;
  return op;
};
var RightDone = (f2) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f2;
  return op;
};
var match21 = dual(2, (self, {
  onBothRunning,
  onLeftDone,
  onRightDone
}) => {
  switch (self._tag) {
    case OP_BOTH_RUNNING: {
      return onBothRunning(self.left, self.right);
    }
    case OP_LEFT_DONE: {
      return onLeftDone(self.f);
    }
    case OP_RIGHT_DONE: {
      return onRightDone(self.f);
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_2) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_2) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match22 = dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause2) => ({
  _tag: OP_STATE_ERROR,
  cause: cause2
});
var stateDone = (done14) => ({
  _tag: OP_STATE_DONE2,
  done: done14
});
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten11(modify7(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt6(fiberId3)));
  }
  done(value6) {
    return flatten11(modify7(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value6)), {
            discard: true
          }), stateDone(value6)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  emit(element2) {
    return flatMap15(make21(), (deferred) => flatten11(modify7(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    })));
  }
  error(cause2) {
    return flatten11(modify7(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => failCause2(deferred, cause2), {
            discard: true
          }), stateError(cause2)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause2) => failCause3(map22(cause2, left2)), (elem) => succeed3(elem), (done14) => fail4(right2(done14)));
  }
  takeWith(onError5, onElement, onDone2) {
    return flatMap15(make21(), (deferred) => flatten11(modify7(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight6(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError5(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone2(state.done)), state];
        }
      }
    })));
  }
};
var make48 = () => pipe(make21(), flatMap15((deferred) => make32(stateEmpty(deferred))), map25((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/channel.js
var as7 = dual(2, (self, value6) => map27(self, () => value6));
var buffer = (options) => suspend5(() => {
  const doBuffer = (empty46, isEmpty20, ref) => unwrap(modify7(ref, (inElem) => isEmpty20(inElem) ? [readWith({
    onInput: (input) => flatMap16(write(input), () => doBuffer(empty46, isEmpty20, ref)),
    onFailure: (error2) => fail11(error2),
    onDone: (done14) => succeedNow(done14)
  }), inElem] : [flatMap16(write(inElem), () => doBuffer(empty46, isEmpty20, ref)), empty46]));
  return doBuffer(options.empty, options.isEmpty, options.ref);
});
var bufferChunk = (ref) => buffer({
  empty: empty6(),
  isEmpty,
  ref
});
var catchAll5 = dual(2, (self, f2) => catchAllCause5(self, (cause2) => match(failureOrCause2(cause2), {
  onLeft: f2,
  onRight: failCause9
})));
var concatMap = dual(2, (self, f2) => concatMapWith(self, f2, () => void 0, () => void 0));
var collect2 = dual(2, (self, pf) => {
  const collector = readWith({
    onInput: (out) => match2(pf(out), {
      onNone: () => collector,
      onSome: (out2) => flatMap16(write(out2), () => collector)
    }),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(self, collector);
});
var mapInput7 = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(write(inElem), () => reader),
    onFailure: fail11,
    onDone: (done14) => succeedNow(f2(done14))
  });
  return pipeTo(reader, self);
});
var mapInputEffect2 = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(write(inElem), () => reader),
    onFailure: fail11,
    onDone: (done14) => fromEffect4(f2(done14))
  });
  return pipeTo(reader, self);
});
var mapInputError = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(write(inElem), () => reader),
    onFailure: (error2) => fail11(f2(error2)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputErrorEffect = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(write(inElem), () => reader),
    onFailure: (error2) => fromEffect4(f2(error2)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputIn = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(write(f2(inElem)), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputInEffect = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap16(flatMap16(fromEffect4(f2(inElem)), write), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var doneCollect = (self) => suspend5(() => {
  const builder = [];
  return pipe(pipeTo(self, doneCollectReader(builder)), flatMap16((outDone) => succeed9([unsafeFromArray(builder), outDone])));
});
var doneCollectReader = (builder) => {
  return readWith({
    onInput: (outElem) => flatMap16(sync6(() => {
      builder.push(outElem);
    }), () => doneCollectReader(builder)),
    onFailure: fail11,
    onDone: succeed9
  });
};
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause9,
    onDone: succeed9
  });
  return pipeTo(self, drainer);
};
var ensuring5 = dual(2, (self, finalizer2) => ensuringWith(self, () => finalizer2));
var context6 = () => fromEffect4(context4());
var contextWithChannel = (f2) => flatMap16(context6(), f2);
var flatten12 = (self) => flatMap16(self, identity);
var foldChannel = dual(2, (self, options) => foldCauseChannel(self, {
  onFailure: (cause2) => {
    const either8 = failureOrCause2(cause2);
    switch (either8._tag) {
      case "Left": {
        return options.onFailure(either8.left);
      }
      case "Right": {
        return failCause9(either8.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromInput = (input) => unwrap(input.takeWith(failCause9, (elem) => flatMap16(write(elem), () => fromInput(input)), succeed9));
var fromQueue = (queue) => suspend5(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect4(take6(queue)), flatMap16(match({
  onLeft: match7({
    onFailure: failCause9,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap16(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap16(write(input), () => identityChannel()),
  onFailure: fail11,
  onDone: succeedNow
});
var interruptWhen = dual(2, (self, effect4) => mergeWith2(self, {
  other: fromEffect4(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
var map27 = dual(2, (self, f2) => flatMap16(self, (a) => sync6(() => f2(a))));
var mapEffect4 = dual(2, (self, f2) => flatMap16(self, (z2) => fromEffect4(f2(z2))));
var mapError5 = dual(2, (self, f2) => mapErrorCause3(self, map22(f2)));
var mapErrorCause3 = dual(2, (self, f2) => catchAllCause5(self, (cause2) => failCause9(f2(cause2))));
var mapOut = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (outElem) => flatMap16(write(f2(outElem)), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = dual(2, (self, f2) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f2(outElem)), flatMap16(write), flatMap16(() => reader)),
    onFailure: failCause9,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffectPar = dual(3, (self, f2, n) => unwrapScopedWith((scope5) => gen3(function* () {
  const input = yield* make48();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const errorSignal = yield* make21();
  const withPermits2 = n === Number.POSITIVE_INFINITY ? (_2) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause2) => offer3(queue, failCause8(cause2)),
    onSuccess: match({
      onLeft: (outDone) => zipRight6(interruptible4(withPermits2(n)(_void)), asVoid5(offer3(queue, succeed8(left2(outDone))))),
      onRight: (outElem) => gen3(function* () {
        const deferred = yield* make21();
        const latch = yield* make21();
        yield* offer3(queue, map25(_await(deferred), right2));
        yield* succeed2(latch, void 0).pipe(zipRight6(uninterruptibleMask3((restore) => exit3(restore(_await(errorSignal))).pipe(raceFirst3(exit3(restore(f2(outElem)))), flatMap15(identity))).pipe(tapErrorCause4((cause2) => failCause2(errorSignal, cause2)), intoDeferred2(deferred))), withPermits2(1), forkIn3(scope5));
        yield* _await(latch);
      })
    })
  }), forever3, interruptible4, forkIn3(scope5));
  const consumer = unwrap(matchCause4(flatten11(take6(queue)), {
    onFailure: failCause9,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap16(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll4 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f2) => unwrapScopedWith((scope5) => gen3(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make48();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope5, shutdown4(cancelers));
  const lastDone = yield* make32(none2());
  const errorSignal = yield* make21();
  const withPermits2 = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap15(match({
      onLeft: (done14) => succeed8(some2(done14)),
      onRight: (outElem) => as6(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat2({
      until: (_2) => isSome2(_2)
    }), flatMap15((outDone) => update4(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f2(lastDone2, outDone.value))
    }))), catchAllCause4((cause2) => isInterrupted2(cause2) ? failCause8(cause2) : offer3(queue, failCause8(cause2)).pipe(zipRight6(succeed2(errorSignal, void 0)), asVoid5)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause2) => offer3(queue, failCause8(cause2)).pipe(zipRight6(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits2(concurrencyN)(_void)), {
        onSelfDone: (_2, permitAcquisition) => as6(interrupt7(permitAcquisition), false),
        onOtherDone: (_2, failureAwait) => zipRight6(interrupt7(failureAwait), get12(lastDone).pipe(flatMap15(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f2(lastDone2, outDone))))
        })), as6(false)))
      }),
      onRight: (channel) => match22(mergeStrategy, {
        onBackPressure: () => gen3(function* () {
          const latch = yield* make21();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap15((pull2) => race3(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap15(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight6(raceEffects), withPermits2(1), forkIn3(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen3(function* () {
          const canceler = yield* make21();
          const latch = yield* make21();
          const size23 = yield* size14(cancelers);
          yield* take6(cancelers).pipe(flatMap15((canceler2) => succeed2(canceler2, void 0)), when3(() => size23 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap15((pull2) => exit3(evaluatePull(pull2)).pipe(race3(exit3(interruptible4(_await(errorSignal)))), race3(exit3(interruptible4(_await(canceler)))))), flatMap15(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight6(raceEffects), withPermits2(1), forkIn3(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat2({
    while: (_2) => _2
  }), forkIn3(scope5));
  const consumer = pipe(take6(queue), flatten11, matchCause4({
    onFailure: failCause9,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap16(write(outElem), () => consumer)
    })
  }), unwrap);
  return embedInput(consumer, input);
}));
var mergeMap = dual(3, (self, f2, options) => mergeAll4(options)(mapOut(self, f2)));
var mergeOut = dual(2, (self, n) => mergeAll4({
  concurrency: n
})(mapOut(self, identity)));
var mergeOutWith = dual(3, (self, n, f2) => mergeAllWith({
  concurrency: n
})(mapOut(self, identity), f2));
var mergeWith2 = dual(2, (self, options) => {
  function merge11(scope5) {
    return gen3(function* () {
      const input = yield* make48();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
      function handleSide(exit4, fiber, pull) {
        return (done14, both2, single2) => {
          function onDecision2(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight6(interrupt7(fiber), op.effect)));
            }
            return map25(_await3(fiber), match7({
              onFailure: (cause2) => fromEffect4(op.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done15) => fromEffect4(op.f(succeed3(done15))),
                onRight: (elem) => zipRight7(write(elem), go4(single2(op.f)))
              })
            }));
          }
          return match7(exit4, {
            onFailure: (cause2) => onDecision2(done14(failCause3(cause2))),
            onSuccess: match({
              onLeft: (z2) => onDecision2(done14(succeed3(z2))),
              onRight: (elem) => succeed8(flatMap16(write(elem), () => flatMap16(fromEffect4(forkIn3(interruptible4(pull), scope5)), (leftFiber) => go4(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go4(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight6(interrupt7(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f2) => LeftDone(f2))),
              onOtherDone: (rightExit, lf) => zipRight6(interrupt7(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f2) => RightDone(f2)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap(map25(exit3(pullR), match7({
              onFailure: (cause2) => fromEffect4(state.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done14) => fromEffect4(state.f(succeed3(done14))),
                onRight: (elem) => flatMap16(write(elem), () => go4(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap(map25(exit3(pullL), match7({
              onFailure: (cause2) => fromEffect4(state.f(failCause3(cause2))),
              onSuccess: match({
                onLeft: (done14) => fromEffect4(state.f(succeed3(done14))),
                onRight: (elem) => flatMap16(write(elem), () => go4(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring4(inherit), forkIn3(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring4(inherit), forkIn3(scope5));
        return zipWith11(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap16(go4), embedInput(input));
    });
  }
  return unwrapScopedWith(merge11);
});
var never5 = fromEffect4(never4);
var orDie4 = dual(2, (self, error2) => orDieWith2(self, error2));
var orDieWith2 = dual(2, (self, f2) => catchAll5(self, (e) => failCauseSync3(() => die4(f2(e)))));
var orElse8 = dual(2, (self, that) => catchAll5(self, that));
var pipeToOrFail = dual(2, (self, that) => suspend5(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap16(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause9(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap16(() => writer)),
    onFailure: (cause2) => isDieType2(cause2) && isChannelException(cause2.defect) && equals(cause2.defect, channelException) ? fail11(cause2.defect.error) : failCause9(cause2),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var provideService6 = dual(3, (self, tag3, service3) => {
  return flatMap16(context6(), (context10) => provideContext4(self, add2(context10, tag3, service3)));
});
var provideLayer = dual(2, (self, layer) => unwrapScopedWith((scope5) => map25(buildWithScope2(layer, scope5), (context10) => provideContext4(self, context10))));
var mapInputContext3 = dual(2, (self, f2) => contextWithChannel((context10) => provideContext4(self, f2(context10))));
var provideSomeLayer2 = dual(2, (self, layer) => (
  // @ts-expect-error
  provideLayer(self, merge7(context5(), layer))
));
var repeated = (self) => flatMap16(self, () => repeated(self));
var run2 = (self) => scopedWith2((scope5) => runIn(self, scope5));
var runDrain = (self) => run2(drain(self));
var runScoped = (self) => scopeWith2((scope5) => runIn(self, scope5));
var scoped3 = (effect4) => unwrap(uninterruptibleMask3((restore) => map25(make44(), (scope5) => acquireReleaseOut(tapErrorCause4(restore(extend3(effect4, scope5)), (cause2) => close(scope5, failCause3(cause2))), (_2, exit4) => close(scope5, exit4)))));
var scopedWith3 = (f2) => unwrapScoped3(map25(scope4, (scope5) => flatMap16(fromEffect4(f2(scope5)), write)));
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self) => flatMap15(scope4, (scope5) => toPullIn(self, scope5));
var toPullIn = dual(2, (self, scope5) => zip10(sync4(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap5(([executor, runtime5]) => addFinalizerExit(scope5, (exit4) => {
  const finalizer2 = executor.close(exit4);
  return finalizer2 !== void 0 ? provide2(finalizer2, runtime5) : _void;
})), uninterruptible3, map25(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match7(exec.getDone(), {
        onFailure: failCause8,
        onSuccess: (done14) => succeed8(left2(done14))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap15(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause2) => failCause8(cause2));
    }
  }
};
var toQueue = (queue) => suspend5(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap16(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause2) => fromEffect4(offer3(queue, left2(failCause3(cause2)))),
    onDone: (done14) => fromEffect4(offer3(queue, left2(succeed3(done14))))
  });
};
var unwrap = (channel) => flatten12(fromEffect4(channel));
var unwrapScoped3 = (self) => concatAllWith(scoped3(self), (d, _2) => d, (d, _2) => d);
var unwrapScopedWith = (f2) => concatAllWith(scopedWith3(f2), (d, _2) => d, (d, _2) => d);
var updateService4 = dual(3, (self, tag3, f2) => mapInputContext3(self, (context10) => merge3(context10, make6(tag3, f2(unsafeGet3(context10, tag3))))));
var writeAll = (...outs) => writeChunk(fromIterable2(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk4) => {
  return idx === len ? void_7 : pipe(write(pipe(chunk4, unsafeGet4(idx))), flatMap16(() => writeChunkWriter(idx + 1, len, chunk4)));
};
var zip11 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip6(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip6(exit1, exit22)))
}) : flatMap16(self, (a) => map27(that, (b2) => [a, b2])));
var zipLeft6 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map27(zip11(self, that, {
  concurrent: true
}), (tuple4) => tuple4[0]) : flatMap16(self, (z2) => as7(that, z2)));
var zipRight7 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map27(zip11(self, that, {
  concurrent: true
}), (tuple4) => tuple4[1]) : flatMap16(self, () => that));
var ChannelExceptionTypeId = Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error2) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error2
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _L: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var SinkImpl = class {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = (u) => hasProperty(u, SinkTypeId2);
var suspend6 = (evaluate3) => new SinkImpl(suspend5(() => toChannel(evaluate3())));
var as8 = dual(2, (self, a) => pipe(self, map28(() => a)));
var collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty6())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk4) => {
    const [collected, leftovers] = splitAt2(chunk4, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll3(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed9(appendAll3(acc, collected));
    }
    return flatMap16(write(leftovers), () => succeed9(appendAll3(acc, collected)));
  },
  onFailure: failCause9,
  onDone: () => succeed9(acc)
});
var collectAllWhileWith = dual(2, (self, options) => {
  const refs = pipe(make32(empty6()), zip10(make32(false)));
  const newChannel = pipe(fromEffect4(refs), flatMap16(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap16(() => upstreamMarker)),
      onFailure: fail11,
      onDone: (done14) => pipe(fromEffect4(set7(upstreamDoneRef, true)), as7(done14))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)));
  }));
  return new SinkImpl(newChannel);
});
var collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f2) => {
  return pipe(toChannel(self), doneCollect, foldChannel({
    onFailure: fail11,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? pipe(fromEffect4(set7(leftoversRef, flatten5(leftovers))), flatMap16(() => pipe(fromEffect4(get12(upstreamDoneRef)), flatMap16((upstreamDone) => {
      const accumulatedResult = f2(currentResult, doneValue);
      return upstreamDone ? pipe(write(flatten5(leftovers)), as7(accumulatedResult)) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f2);
    })))) : pipe(write(flatten5(leftovers)), as7(currentResult))
  }));
};
var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map27(([chunks2, z2]) => [z2, flatten5(chunks2)])));
var mapInput8 = dual(2, (self, f2) => pipe(self, mapInputChunks(map7(f2))));
var mapInputEffect3 = dual(2, (self, f2) => mapInputChunksEffect(self, (chunk4) => map25(forEach16(chunk4, (v2) => f2(v2)), unsafeFromArray)));
var mapInputChunks = dual(2, (self, f2) => {
  const loop3 = readWith({
    onInput: (chunk4) => pipe(write(f2(chunk4)), flatMap16(() => loop3)),
    onFailure: fail11,
    onDone: succeed9
  });
  return new SinkImpl(pipe(loop3, pipeTo(toChannel(self))));
});
var mapInputChunksEffect = dual(2, (self, f2) => {
  const loop3 = readWith({
    onInput: (chunk4) => pipe(fromEffect4(f2(chunk4)), flatMap16(write), flatMap16(() => loop3)),
    onFailure: fail11,
    onDone: succeed9
  });
  return new SinkImpl(pipe(loop3, pipeToOrFail(toChannel(self))));
});
var dimap = dual(2, (self, options) => map28(mapInput8(self, options.onInput), options.onDone));
var dimapEffect = dual(2, (self, options) => mapEffect5(mapInputEffect3(self, options.onInput), options.onDone));
var dimapChunks = dual(2, (self, options) => map28(mapInputChunks(self, options.onInput), options.onDone));
var dimapChunksEffect = dual(2, (self, options) => mapEffect5(mapInputChunksEffect(self, options.onInput), options.onDone));
var drain2 = new SinkImpl(drain(identityChannel()));
var ensuring6 = dual(2, (self, finalizer2) => new SinkImpl(pipe(self, toChannel, ensuring5(finalizer2))));
var ensuringWith2 = dual(2, (self, finalizer2) => new SinkImpl(pipe(self, toChannel, ensuringWith(finalizer2))));
var fail12 = (e) => new SinkImpl(fail11(e));
var filterInputEffect = dual(2, (self, f2) => mapInputChunksEffect(self, (chunk4) => map25(filter12(chunk4, f2), unsafeFromArray)));
var findEffect = dual(2, (self, f2) => {
  const newChannel = pipe(fromEffect4(pipe(make32(empty6()), zip10(make32(false)))), flatMap16(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap16(() => upstreamMarker)),
      onFailure: fail11,
      onDone: (done14) => pipe(fromEffect4(set7(upstreamDoneRef, true)), as7(done14))
    });
    const loop3 = foldChannel(collectElements(toChannel(self)), {
      onFailure: fail11,
      onSuccess: ([leftovers, doneValue]) => pipe(fromEffect4(f2(doneValue)), flatMap16((satisfied) => pipe(fromEffect4(set7(leftoversRef, flatten5(leftovers))), zipRight7(pipe(fromEffect4(get12(upstreamDoneRef)), flatMap16((upstreamDone) => {
        if (satisfied) {
          return pipe(write(flatten5(leftovers)), as7(some2(doneValue)));
        }
        if (upstreamDone) {
          return pipe(write(flatten5(leftovers)), as7(none2()));
        }
        return loop3;
      }))))))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(loop3));
  }));
  return new SinkImpl(newChannel);
});
var fold = (s, contFn, f2) => suspend6(() => new SinkImpl(foldReader(s, contFn, f2)));
var foldReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f2, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as7(nextS));
      }
      return foldReader(nextS, contFn, f2);
    },
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk4, contFn, f2, index, length4) => {
  if (index === length4) {
    return [s, empty6()];
  }
  const s1 = f2(s, pipe(chunk4, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk4, contFn, f2, index + 1, length4);
  }
  return [s1, pipe(chunk4, drop3(index + 1))];
};
var foldSink = dual(2, (self, options) => {
  const newChannel = pipe(toChannel(self), collectElements, foldChannel({
    onFailure: (error2) => toChannel(options.onFailure(error2)),
    onSuccess: ([leftovers, z2]) => suspend5(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter5(isNonEmpty2))
      };
      const refReader = pipe(
        sync6(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty6();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap16((chunk4) => writeChunk(chunk4))
      );
      const passthrough3 = identityChannel();
      const continuationSink = pipe(refReader, zipRight7(passthrough3), pipeTo(toChannel(options.onSuccess(z2))));
      return flatMap16(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed9(leftoversRef.ref), flatMap16(writeChunk), zipRight7(writeChunk(newLeftovers)), as7(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f2) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f2)));
var foldChunksReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f2(s, input), contFn, f2),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f2) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f2)));
var foldEffectReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f2)), flatMap16(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f2),
      onSome: (leftover2) => pipe(write(leftover2), as7(nextS))
    })))),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk4, contFn, f2) => foldChunkSplitEffectInternal(s, chunk4, 0, chunk4.length, contFn, f2);
var foldChunkSplitEffectInternal = (s, chunk4, index, length4, contFn, f2) => {
  if (index === length4) {
    return succeed8([s, none2()]);
  }
  return pipe(f2(s, pipe(chunk4, unsafeGet4(index))), flatMap15((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk4, index + 1, length4, contFn, f2) : succeed8([s1, some2(pipe(chunk4, drop3(index + 1)))])));
};
var foldLeftChunks = (s, f2) => foldChunks(s, constTrue, f2);
var flatMap17 = dual(2, (self, f2) => foldSink(self, {
  onFailure: fail12,
  onSuccess: f2
}));
var forEach17 = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach16(input, (v2) => f2(v2), {
      discard: true
    })), flatMap16(() => process2)),
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(f2(input)), flatMap16(() => process2)),
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f2, input, 0, input.length, process2),
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f2, input, index, length4, cont) => {
  if (index === length4) {
    return cont;
  }
  return pipe(fromEffect4(f2(pipe(input, unsafeGet4(index)))), flatMap16((bool) => bool ? forEachWhileReader(f2, input, index + 1, length4, cont) : write(pipe(input, drop3(index)))), catchAll5((error2) => pipe(write(pipe(input, drop3(index))), zipRight7(fail11(error2)))));
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect4) => new SinkImpl(fromEffect4(effect4));
var map28 = dual(2, (self, f2) => {
  return new SinkImpl(pipe(toChannel(self), map27(f2)));
});
var mapEffect5 = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapEffect4(f2))));
var mapError6 = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapError5(f2))));
var mapLeftover = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapOut(map7(f2)))));
var never6 = fromEffect6(never4);
var orElse9 = dual(2, (self, that) => new SinkImpl(pipe(toChannel(self), orElse8(() => toChannel(that())))));
var provideContext5 = dual(2, (self, context10) => new SinkImpl(pipe(toChannel(self), provideContext4(context10))));
var race4 = dual(2, (self, that) => pipe(self, raceBoth(that), map28(merge)));
var raceBoth = dual((args2) => isSink(args2[1]), (self, that, options) => raceWith3(self, {
  other: that,
  onSelfDone: (selfDone) => Done3(map25(selfDone, left2)),
  onOtherDone: (thatDone) => Done3(map25(thatDone, right2)),
  capacity: options?.capacity ?? 16
}));
var raceWith3 = dual(2, (self, options) => {
  function race7(scope5) {
    return gen3(function* () {
      const pubsub = yield* bounded4(options?.capacity ?? 16);
      const subscription1 = yield* extend3(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend3(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft6(fromEffect4(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft6(fromEffect4(shutdown4(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race7);
});
var refineOrDie = dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
var refineOrDieWith = dual(3, (self, pf, f2) => {
  const newChannel = pipe(self, toChannel, catchAll5((error2) => match2(pf(error2), {
    onNone: () => failCauseSync3(() => die4(f2(error2))),
    onSome: fail11
  })));
  return new SinkImpl(newChannel);
});
var splitWhere3 = dual(2, (self, f2) => {
  const newChannel = pipe(fromEffect4(make32(empty6())), flatMap16((ref) => pipe(splitWhereSplitter(false, ref, f2), pipeToOrFail(toChannel(self)), collectElements, flatMap16(([leftovers, z2]) => pipe(fromEffect4(get12(ref)), flatMap16((leftover2) => pipe(write(pipe(leftover2, appendAll3(flatten5(leftovers)))), zipRight7(succeed9(z2)))))))));
  return new SinkImpl(newChannel);
});
var splitWhereSplitter = (written, leftovers, f2) => readWithCause({
  onInput: (input) => {
    if (isEmpty(input)) {
      return splitWhereSplitter(written, leftovers, f2);
    }
    if (written) {
      const index2 = indexWhere(input, f2);
      if (index2 === -1) {
        return zipRight7(write(input), splitWhereSplitter(true, leftovers, f2));
      }
      const [left4, right4] = splitAt2(input, index2);
      return zipRight7(write(left4), fromEffect4(set7(leftovers, right4)));
    }
    const index = indexWhere(input, f2, 1);
    if (index === -1) {
      return zipRight7(write(input), splitWhereSplitter(true, leftovers, f2));
    }
    const [left3, right3] = pipe(input, splitAt2(Math.max(index, 1)));
    return zipRight7(write(left3), fromEffect4(set7(leftovers, right3)));
  },
  onFailure: failCause9,
  onDone: succeed9
});
var indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next5;
  while (result < 0 && (next5 = iterator.next()) && !next5.done) {
    const a = next5.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
var sum5 = foldLeftChunks(0, (acc, chunk4) => acc + reduce4(chunk4, 0, (s, a) => s + a));
var summarized2 = dual(3, (self, summary6, f2) => {
  const newChannel = pipe(fromEffect4(summary6), flatMap16((start5) => pipe(self, toChannel, flatMap16((done14) => pipe(fromEffect4(summary6), map27((end6) => [done14, f2(start5, end6)]))))));
  return new SinkImpl(newChannel);
});
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect6(self)) : self.channel;
var unwrapScopedWith2 = (f2) => new SinkImpl(unwrapScopedWith((scope5) => f2(scope5).pipe(map25((sink) => toChannel(sink)))));
var withDuration = (self) => pipe(self, summarized2(currentTimeMillis2, (start5, end6) => millis(end6 - start5)));
var zip12 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith12(self, that, (z2, z22) => [z2, z22], options));
var zipLeft7 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith12(self, that, (z2, _2) => z2, options));
var zipRight8 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith12(self, that, (_2, z2) => z2, options));
var zipWith12 = dual((args2) => isSink(args2[1]), (self, that, f2, options) => options?.concurrent ? raceWith3(self, {
  other: that,
  onSelfDone: match7({
    onFailure: (cause2) => Done3(failCause8(cause2)),
    onSuccess: (leftZ) => Await(match7({
      onFailure: failCause8,
      onSuccess: (rightZ) => succeed8(f2(leftZ, rightZ))
    }))
  }),
  onOtherDone: match7({
    onFailure: (cause2) => Done3(failCause8(cause2)),
    onSuccess: (rightZ) => Await(match7({
      onFailure: failCause8,
      onSuccess: (leftZ) => succeed8(f2(leftZ, rightZ))
    }))
  })
}) : flatMap17(self, (z2) => map28(that, (z22) => f2(z2, z22))));
var count2 = foldLeftChunks(0, (acc, chunk4) => acc + chunk4.length);
var mkString = suspend6(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_2, elems) => map7(elems, (elem) => {
    strings.push(String(elem));
  })), map28(() => strings.join("")));
});
var timed2 = pipe(withDuration(drain2), map28((tuple4) => tuple4[1]));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MergeDecision.js
var Done4 = Done3;
var Await2 = Await;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/rcRef.js
var TypeId21 = Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance8 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class2 {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId21] = variance8;
  [TypeId14] = TypeId14;
  state = stateEmpty2;
  semaphore = unsafeMakeSemaphore(1);
  constructor(acquire3, context10, scope5, idleTimeToLive) {
    super();
    this.acquire = acquire3;
    this.context = context10;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get15(this);
  }
  get;
  commit() {
    return this.get;
  }
};
var make49 = (options) => withFiberRuntime((fiber) => {
  const context10 = fiber.getFiberRef(currentContext);
  const scope5 = get4(context10, scopeTag);
  const ref = new RcRefImpl(options.acquire, context10, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
  return as3(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_3;
    ref.state = stateClosed;
    return close2;
  }))), ref);
});
var get15 = (self_) => {
  const self = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as3(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake2().pipe(bindTo5("scope"), bind5("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope5)))), map14(({
          scope: scope5,
          value: value6
        }) => {
          const state = {
            _tag: "Acquired",
            value: value6,
            scope: scope5,
            fiber: void 0,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo5("state"), bind5("scope", () => scopeTag), tap2(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_3;
    }
    if (self.idleTimeToLive === void 0) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_3;
    })), ensuring2(sync(() => {
      state.fiber = void 0;
    })), forkIn2(self.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map14(({
    state
  }) => state.value));
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/RcRef.js
var make50 = make49;
var get16 = get15;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork3;
var defaultRuntime2 = defaultRuntime;
var make51 = make45;
var FiberFailureId2 = Symbol.for("effect/Runtime/FiberFailure");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Schedule.js
var driver2 = driver;
var forever4 = forever2;
var spaced2 = spaced;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
var match23 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_LEFT: {
      return options.onLeft();
    }
    case OP_RIGHT: {
      return options.onRight();
    }
    case OP_BOTH: {
      return options.onBoth();
    }
    case OP_EITHER: {
      return options.onEither();
    }
  }
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned = class {
  value;
  constructor(value6) {
    this.value = value6;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/entry.js
var make52 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet8 = (self) => {
  return self.newValue;
};
var unsafeSet = (self, value6) => {
  self.isChanged = true;
  self.newValue = value6;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var copy4 = (self) => ({
  ref: self.ref,
  isNew: self.isNew,
  isChanged: self.isChanged,
  expected: self.expected,
  newValue: self.newValue
});
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var prepareResetJournal = (journal) => {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], copy4(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y2) => x[0] - y2[0]);
  for (const [_2, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone6 = (self) => {
  return self._tag === OP_DONE6;
};
var done8 = (exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol2]() {
      return pipe(hash(STMStateSymbolKey), combine2(hash(OP_DONE6)), combine2(hash(exit4)), cached(this));
    },
    [symbol3](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
};
var interruptedHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_INTERRUPTED)), combine2(hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol2]() {
    return interruptedHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_RUNNING2)), combine2(hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol2]() {
    return runningHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = Symbol.for(TExitSymbolKey);
var variance9 = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess3 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail13 = (error2) => ({
  [TExitTypeId]: variance9,
  _tag: OP_FAIL5,
  error: error2,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_FAIL5)), combine2(hash(error2)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error2, that.error);
  }
});
var die7 = (defect) => ({
  [TExitTypeId]: variance9,
  _tag: OP_DIE3,
  defect,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_DIE3)), combine2(hash(defect)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt9 = (fiberId3) => ({
  [TExitTypeId]: variance9,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_INTERRUPT3)), combine2(hash(fiberId3)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed11 = (value6) => ({
  [TExitTypeId]: variance9,
  _tag: OP_SUCCEED3,
  value: value6,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_SUCCEED3)), combine2(hash(value6)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value6, that.value);
  }
});
var retryHash = pipe(hash(TExitSymbolKey), combine2(hash(OP_RETRY2)), combine2(hash("retry")));
var retry3 = {
  [TExitTypeId]: variance9,
  _tag: OP_RETRY2,
  [symbol2]() {
    return retryHash;
  },
  [symbol3](that) {
    return isExit2(that) && isRetry(that);
  }
};
var void_8 = succeed11(void 0);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
};
var suspend7 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make53 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var STMPrimitive = class {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSTM = (u) => hasProperty(u, STMTypeId2);
var commit2 = (self) => unsafeAtomically(self, constVoid, constVoid);
var unsafeAtomically = (self, onDone2, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler2 = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self, env, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone2(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make53();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k2) => tryCommitAsync(fiberId3, self, txnId, state2, env, scheduler2, priority, k2));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause4((cause2) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone2(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause8(cause2);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause2 = fail7(tExit.error);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause2 = die4(tExit.defect);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause2 = interrupt6(fiberId3);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess3(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause2 = fail7(tExit.error);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause2 = die4(tExit.defect);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause2 = interrupt6(fiberId3);
      return completeTodos(failCause3(cause2), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self, txnId, state, context10, scheduler2, priority, k2) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self, state, context10, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k2);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self, txnId, state, context10, scheduler2, priority, k2));
        break;
      }
    }
  }
};
var completeTodos = (exit4, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit4);
};
var completeTryCommit = (exit4, k2) => {
  k2(exit4);
};
var context7 = () => effect3((_2, __, env) => env);
var contextWithSTM = (f2) => flatMap18(context7(), f2);
var STMDriver = class {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self, journal, fiberId3, r0) {
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_2, __, env) => unsafeGet3(env, current2));
              break;
            }
            case "Left": {
              curr = fail14(current2.left);
              break;
            }
            case "None": {
              curr = fail14(new NoSuchElementException3());
              break;
            }
            case "Right": {
              curr = succeed12(current2.right);
              break;
            }
            case "Some": {
              curr = succeed12(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die7(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail13(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry3;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt9(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env));
                  curr = pipe(current2.effect_instruction_i1, ensuring7(sync8(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value6 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed11(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value6 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed11(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die8(e);
      }
    }
    return exit4;
  }
};
var catchAll6 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var mapInputContext4 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_PROVIDE3);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var die8 = (defect) => dieSync3(() => defect);
var dieMessage3 = (message) => dieSync3(() => new RuntimeException2(message));
var dieSync3 = (evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var effect3 = (f2) => withSTMRuntime((_2) => succeed12(f2(_2.journal, _2.fiberId, _2.getEnv())));
var ensuring7 = dual(2, (self, finalizer2) => matchSTM(self, {
  onFailure: (e) => zipRight9(finalizer2, fail14(e)),
  onSuccess: (a) => zipRight9(finalizer2, succeed12(a))
}));
var fail14 = (error2) => failSync5(() => error2);
var failSync5 = (evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var flatMap18 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var matchSTM = dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map29(right2), catchAll6((e) => pipe(onFailure(e), map29(left2))), flatMap18((either8) => {
  switch (either8._tag) {
    case "Left": {
      return succeed12(either8.left);
    }
    case "Right": {
      return onSuccess(either8.right);
    }
  }
})));
var withSTMRuntime = (f2) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f2;
  return stm;
};
var interrupt10 = withSTMRuntime((_2) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = _2.fiberId;
  return stm;
});
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map29 = dual(2, (self, f2) => pipe(self, flatMap18((a) => sync8(() => f2(a)))));
var orTry = dual(2, (self, that) => {
  const stm = new STMPrimitive(OP_ON_RETRY);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = that;
  return stm;
});
var retry4 = new STMPrimitive(OP_RETRY);
var succeed12 = (value6) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value6;
  return stm;
};
var sync8 = (evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var zip13 = dual(2, (self, that) => pipe(self, zipWith13(that, (a, a1) => [a, a1])));
var zipLeft8 = dual(2, (self, that) => pipe(self, flatMap18((a) => pipe(that, map29(() => a)))));
var zipRight9 = dual(2, (self, that) => pipe(self, flatMap18(() => that)));
var zipWith13 = dual(3, (self, that, f2) => pipe(self, flatMap18((a) => pipe(that, map29((b2) => f2(a, b2))))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/stm.js
var acquireUseRelease3 = dual(3, (acquire3, use, release3) => uninterruptibleMask3((restore) => {
  let state = running3;
  return pipe(restore(unsafeAtomically(acquire3, (exit4) => {
    state = done8(exit4);
  }, () => {
    state = interrupted2;
  })), matchCauseEffect3({
    onFailure: (cause2) => {
      if (isDone6(state) && isSuccess(state.exit)) {
        return pipe(release3(state.exit.value), matchCauseEffect3({
          onFailure: (cause22) => failCause8(parallel4(cause2, cause22)),
          onSuccess: () => failCause8(cause2)
        }));
      }
      return failCause8(cause2);
    },
    onSuccess: (a) => pipe(restore(use(a)), matchCauseEffect3({
      onFailure: (cause2) => pipe(release3(a), matchCauseEffect3({
        onFailure: (cause22) => failCause8(parallel4(cause2, cause22)),
        onSuccess: () => failCause8(cause2)
      })),
      onSuccess: (a2) => pipe(release3(a), as6(a2))
    }))
  }));
}));
var as9 = dual(2, (self, value6) => pipe(self, map29(() => value6)));
var asSome4 = (self) => pipe(self, map29(some2));
var asVoid6 = (self) => pipe(self, map29(constVoid));
var attempt = (evaluate3) => suspend8(() => {
  try {
    return succeed12(evaluate3());
  } catch (defect) {
    return fail14(defect);
  }
});
var bind7 = dual(3, (self, tag3, f2) => flatMap18(self, (k2) => map29(f2(k2), (a) => ({
  ...k2,
  [tag3]: a
}))));
var bindTo7 = dual(2, (self, tag3) => map29(self, (a) => ({
  [tag3]: a
})));
var let_7 = dual(3, (self, tag3, f2) => map29(self, (k2) => ({
  ...k2,
  [tag3]: f2(k2)
})));
var catchSome2 = dual(2, (self, pf) => catchAll6(self, (e) => getOrElse2(pf(e), () => fail14(e))));
var catchTag3 = dual(3, (self, k2, f2) => catchAll6(self, (e) => {
  if ("_tag" in e && e["_tag"] === k2) {
    return f2(e);
  }
  return fail14(e);
}));
var catchTags2 = dual(2, (self, cases) => catchAll6(self, (e) => {
  const keys10 = Object.keys(cases);
  if ("_tag" in e && keys10.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail14(e);
}));
var collect3 = dual(2, (self, pf) => collectSTM(self, (a) => map2(pf(a), succeed12)));
var collectSTM = dual(2, (self, pf) => matchSTM(self, {
  onFailure: fail14,
  onSuccess: (a) => {
    const option6 = pf(a);
    return isSome2(option6) ? option6.value : retry4;
  }
}));
var either5 = (self) => match24(self, {
  onFailure: left2,
  onSuccess: right2
});
var every10 = dual(2, (iterable, predicate) => flatMap18(sync8(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop3 = suspend8(() => {
    const next5 = iterator.next();
    if (next5.done) {
      return succeed12(true);
    }
    return pipe(predicate(next5.value), flatMap18((bool) => bool ? loop3 : succeed12(bool)));
  });
  return loop3;
}));
var exists3 = dual(2, (iterable, predicate) => flatMap18(sync8(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop3 = suspend8(() => {
    const next5 = iterator.next();
    if (next5.done) {
      return succeed12(false);
    }
    return flatMap18(predicate(next5.value), (bool) => bool ? succeed12(bool) : loop3);
  });
  return loop3;
}));
var fiberId2 = effect3((_2, fiberId3) => fiberId3);
var filter13 = dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith13(predicate(curr), (as12, p) => {
  if (p) {
    as12.push(curr);
    return as12;
  }
  return as12;
})), succeed12([])));
var filterNot = dual(2, (iterable, predicate) => filter13(iterable, (a) => negate2(predicate(a))));
var filterOrDie2 = dual(3, (self, predicate, defect) => filterOrElse2(self, predicate, () => dieSync3(defect)));
var filterOrDieMessage2 = dual(3, (self, predicate, message) => filterOrElse2(self, predicate, () => dieMessage3(message)));
var filterOrElse2 = dual(3, (self, predicate, orElse15) => flatMap18(self, (a) => predicate(a) ? succeed12(a) : orElse15(a)));
var filterOrFail3 = dual(3, (self, predicate, orFailWith) => filterOrElse2(self, predicate, (a) => failSync5(() => orFailWith(a))));
var flatten13 = (self) => flatMap18(self, identity);
var flip2 = (self) => matchSTM(self, {
  onFailure: succeed12,
  onSuccess: fail14
});
var flipWith2 = dual(2, (self, f2) => flip2(f2(flip2(self))));
var match24 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => succeed12(onFailure(e)),
  onSuccess: (a) => succeed12(onSuccess(a))
}));
var forEach18 = dual((args2) => isIterable(args2[0]), (iterable, f2, options) => {
  if (options?.discard) {
    return pipe(sync8(() => iterable[Symbol.iterator]()), flatMap18((iterator) => {
      const loop3 = suspend8(() => {
        const next5 = iterator.next();
        if (next5.done) {
          return void_9;
        }
        return pipe(f2(next5.value), flatMap18(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend8(() => fromIterable(iterable).reduce((acc, curr) => zipWith13(acc, f2(curr), (array7, elem) => {
    array7.push(elem);
    return array7;
  }), succeed12([])));
});
var gen4 = (...args2) => suspend8(() => {
  const f2 = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f2(pipe);
  const state = iterator.next();
  const run4 = (state2) => state2.done ? succeed12(state2.value) : flatMap18(yieldWrapGet(state2.value), (val) => run4(iterator.next(val)));
  return run4(state);
});
var if_2 = dual((args2) => typeof args2[0] === "boolean" || isSTM(args2[0]), (self, {
  onFalse,
  onTrue
}) => {
  if (typeof self === "boolean") {
    return self ? onTrue : onFalse;
  }
  return flatMap18(self, (bool) => bool ? onTrue : onFalse);
});
var iterate2 = (initial, options) => iterateLoop(initial, options.while, options.body);
var iterateLoop = (initial, cont, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap18((z2) => iterateLoop(z2, cont, body)));
  }
  return succeed12(initial);
};
var mapAttempt = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => fail14(e),
  onSuccess: (a) => attempt(() => f2(a))
}));
var mapBoth6 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => fail14(onFailure(e)),
  onSuccess: (a) => succeed12(onSuccess(a))
}));
var mapError7 = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => fail14(f2(e)),
  onSuccess: succeed12
}));
var mergeAll5 = dual(3, (iterable, zero3, f2) => suspend8(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith13(curr, f2)), succeed12(zero3))));
var negate2 = (self) => pipe(self, map29((b2) => !b2));
var orDieWith3 = dual(2, (self, f2) => pipe(self, mapError7(f2), catchAll6(die8)));
var orElse10 = dual(2, (self, that) => flatMap18(effect3((journal) => prepareResetJournal(journal)), (reset) => pipe(orTry(self, () => flatMap18(sync8(reset), that)), catchAll6(() => flatMap18(sync8(reset), that)))));
var orElseEither4 = dual(2, (self, that) => orElse10(map29(self, left2), () => map29(that(), right2)));
var orElseFail2 = dual(2, (self, error2) => orElse10(self, () => failSync5(error2)));
var orElseOptional = dual(2, (self, that) => catchAll6(self, match2({
  onNone: that,
  onSome: (e) => fail14(some2(e))
})));
var orElseSucceed3 = dual(2, (self, value6) => orElse10(self, () => sync8(value6)));
var provideContext6 = dual(2, (self, env) => mapInputContext4(self, (_2) => env));
var provideSomeContext2 = dual(2, (self, context10) => mapInputContext4(self, (parent) => merge3(parent, context10)));
var provideService7 = dual(3, (self, tag3, resource) => provideServiceSTM(self, tag3, succeed12(resource)));
var provideServiceSTM = dual(3, (self, tag3, stm) => contextWithSTM((env) => flatMap18(stm, (service3) => provideContext6(self, add2(env, tag3, service3)))));
var reduce17 = dual(3, (iterable, zero3, f2) => suspend8(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, flatMap18((s) => f2(s, curr))), succeed12(zero3))));
var reduceAll = dual(3, (iterable, initial, f2) => suspend8(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith13(curr, f2)), initial)));
var reduceRight5 = dual(3, (iterable, zero3, f2) => suspend8(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, flatMap18((s) => f2(s, curr))), succeed12(zero3))));
var refineOrDie2 = dual(2, (self, pf) => refineOrDieWith2(self, pf, identity));
var refineOrDieWith2 = dual(3, (self, pf, f2) => catchAll6(self, (e) => match2(pf(e), {
  onNone: () => die8(f2(e)),
  onSome: fail14
})));
var reject = dual(2, (self, pf) => rejectSTM(self, (a) => map2(pf(a), fail14)));
var rejectSTM = dual(2, (self, pf) => flatMap18(self, (a) => match2(pf(a), {
  onNone: () => succeed12(a),
  onSome: flatMap18(fail14)
})));
var repeatUntil = dual(2, (self, predicate) => repeatUntilLoop(self, predicate));
var repeatUntilLoop = (self, predicate) => flatMap18(self, (a) => predicate(a) ? succeed12(a) : repeatUntilLoop(self, predicate));
var repeatWhile = dual(2, (self, predicate) => repeatWhileLoop(self, predicate));
var repeatWhileLoop = (self, predicate) => flatMap18(self, (a) => predicate(a) ? repeatWhileLoop(self, predicate) : succeed12(a));
var replicate5 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateSTM = dual(2, (self, n) => all8(replicate5(self, n)));
var replicateSTMDiscard = dual(2, (self, n) => all8(replicate5(self, n), {
  discard: true
}));
var retryUntil = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail14,
  onSuccess: (a) => predicate(a) ? succeed12(a) : retry4
}));
var retryWhile = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail14,
  onSuccess: (a) => !predicate(a) ? succeed12(a) : retry4
}));
var partition8 = dual(2, (elements, f2) => pipe(forEach18(elements, (a) => either5(f2(a))), map29((as12) => partitionMap6(as12, identity))));
var all8 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach18(input, identity, options);
  } else if (options?.discard) {
    return forEach18(Object.values(input), identity, options);
  }
  return map29(forEach18(Object.entries(input), ([_2, e]) => map29(e, (a) => [_2, a])), (values7) => {
    const res = {};
    for (const [k2, v2] of values7) {
      ;
      res[k2] = v2;
    }
    return res;
  });
};
var succeedNone4 = succeed12(none2());
var succeedSome2 = (value6) => succeed12(some2(value6));
var summarized3 = dual(3, (self, summary6, f2) => flatMap18(summary6, (start5) => flatMap18(self, (value6) => map29(summary6, (end6) => [f2(start5, end6), value6]))));
var suspend8 = (evaluate3) => flatten13(sync8(evaluate3));
var tap6 = dual(2, (self, f2) => flatMap18(self, (a) => as9(f2(a), a)));
var tapBoth2 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => pipe(onFailure(e), zipRight9(fail14(e))),
  onSuccess: (a) => pipe(onSuccess(a), as9(a))
}));
var tapError4 = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => zipRight9(f2(e), fail14(e)),
  onSuccess: succeed12
}));
var void_9 = succeed12(void 0);
var unless2 = dual(2, (self, predicate) => suspend8(() => predicate() ? succeedNone4 : asSome4(self)));
var unlessSTM = dual(2, (self, predicate) => flatMap18(predicate, (bool) => bool ? succeedNone4 : asSome4(self)));
var validateAll2 = dual(2, (elements, f2) => flatMap18(partition8(elements, f2), ([errors, values7]) => isNonEmptyArray2(errors) ? fail14(errors) : succeed12(values7)));
var validateFirst2 = dual(2, (elements, f2) => flip2(forEach18(elements, (a) => flip2(f2(a)))));
var when4 = dual(2, (self, predicate) => suspend8(() => predicate() ? asSome4(self) : succeedNone4));
var whenSTM = dual(2, (self, predicate) => flatMap18(predicate, (bool) => bool ? asSome4(self) : succeedNone4));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TRefImpl = class {
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value6) {
    this.versioned = new Versioned(value6);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f2) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f2(unsafeGet8(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make54 = (value6) => effect3((journal) => {
  const ref = new TRefImpl(value6);
  journal.set(ref, make52(ref, true));
  return ref;
});
var get17 = (self) => self.modify((a) => [a, a]);
var set9 = dual(2, (self, value6) => self.modify(() => [void 0, value6]));
var getAndSet4 = dual(2, (self, value6) => self.modify((a) => [a, value6]));
var getAndUpdate3 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome2 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b2) => [a, b2]
})));
var setAndGet3 = dual(2, (self, value6) => self.modify(() => [value6, value6]));
var modify10 = dual(2, (self, f2) => self.modify(f2));
var modifySome2 = dual(3, (self, fallback, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [fallback, a],
  onSome: (b2) => b2
})));
var update6 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet3 = dual(2, (self, f2) => self.modify((a) => {
  const b2 = f2(a);
  return [b2, b2];
}));
var updateSome2 = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b2) => b2
})]));
var updateSomeAndGet2 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b2) => [b2, b2]
})));
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make52(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet9 = dual(2, (self, journal) => unsafeGet8(getOrMakeEntry(self, journal)));
var unsafeSet2 = dual(3, (self, value6, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet(entry, value6);
  return void 0;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = Symbol.for(TDequeueSymbolKey);
var Dropping = {
  _tag: OP_DROPPING_STRATEGY
};
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_2) => _2
};
var TQueueImpl = class {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime5) => {
    const queue = unsafeGet9(this.ref, runtime5.journal);
    if (queue === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed12(queue.length);
  });
  isFull = map29(this.size, (size23) => size23 === this.requestedCapacity);
  isEmpty = map29(this.size, (size23) => size23 === 0);
  shutdown = withSTMRuntime((runtime5) => {
    unsafeSet2(this.ref, void 0, runtime5.journal);
    return void_9;
  });
  isShutdown = effect3((journal) => {
    const queue = unsafeGet9(this.ref, journal);
    return queue === void 0;
  });
  awaitShutdown = flatMap18(this.isShutdown, (isShutdown7) => isShutdown7 ? void_9 : retry4);
  offer(value6) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet9(runtime5.journal));
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value6);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed12(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed12(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed12(true);
          }
          queue.shift();
          queue.push(value6);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed12(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as12 = Array.from(iterable);
      const queue = unsafeGet9(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as12.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as12], runtime5.journal);
        return succeed12(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as12.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed12(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as12.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed12(true);
        }
      }
    });
  }
  peek = withSTMRuntime((runtime5) => {
    const queue = unsafeGet9(this.ref, runtime5.journal);
    if (queue === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    return succeed12(queue[0]);
  });
  peekOption = withSTMRuntime((runtime5) => {
    const queue = unsafeGet9(this.ref, runtime5.journal);
    if (queue === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed12(fromNullable2(queue[0]));
  });
  take = withSTMRuntime((runtime5) => {
    const queue = unsafeGet9(this.ref, runtime5.journal);
    if (queue === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime5.journal);
    return succeed12(dequeued);
  });
  takeAll = withSTMRuntime((runtime5) => {
    const queue = unsafeGet9(this.ref, runtime5.journal);
    if (queue === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    unsafeSet2(this.ref, [], runtime5.journal);
    return succeed12(queue);
  });
  takeUpTo(max11) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet9(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max11);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed12(Array.from(toTake));
    });
  }
};
var offer4 = dual(2, (self, value6) => self.offer(value6));
var offerAll4 = dual(2, (self, iterable) => self.offerAll(iterable));
var seek = dual(2, (self, predicate) => seekLoop(self, predicate));
var seekLoop = (self, predicate) => flatMap18(self.take, (a) => predicate(a) ? succeed12(a) : seekLoop(self, predicate));
var takeBetween3 = dual(3, (self, min9, max11) => suspend8(() => {
  const takeRemainder = (min10, max12, acc) => {
    if (max12 < min10) {
      return succeed12(acc);
    }
    return pipe(self.takeUpTo(max12), flatMap18((taken) => {
      const remaining = min10 - taken.length;
      if (remaining === 1) {
        return pipe(self.take, map29((a) => pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a))));
      }
      if (remaining > 1) {
        return pipe(self.take, flatMap18((a) => takeRemainder(remaining - 1, max12 - taken.length - 1, pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a)))));
      }
      return succeed12(pipe(acc, appendAll3(unsafeFromArray(taken))));
    }));
  };
  return map29(takeRemainder(min9, max11, empty6()), (c) => Array.from(c));
}));
var takeN3 = dual(2, (self, n) => pipe(self, takeBetween3(n, n)));
var takeUpTo3 = dual(2, (self, max11) => self.takeUpTo(max11));
var unbounded6 = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
var makeQueue = (requestedCapacity, strategy) => map29(make54([]), (ref) => new TQueueImpl(ref, requestedCapacity, strategy));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head8, subscribers, tail) => ({
  head: head8,
  subscribers,
  tail
});
var TPubSubImpl = class {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_2) => _2
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = effect3((journal) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
    return currentPublisherTail === void 0;
  });
  awaitShutdown = flatMap18(this.isShutdown, (isShutdown7) => isShutdown7 ? void_9 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime5) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, runtime5.journal);
    if (currentPublisherTail === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed12(unsafeGet9(this.pubsubSize, runtime5.journal));
  });
  isEmpty = map29(this.size, (size23) => size23 === 0);
  isFull = map29(this.size, (size23) => size23 === this.capacity());
  offer(value6) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet9(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed12(true);
      }
      const currentPubSubSize = unsafeGet9(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed12(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed12(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet9(this.publisherHead, runtime5.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet9(currentPublisherHead, runtime5.journal);
              if (node === void 0) {
                return retry4;
              }
              const head8 = node.head;
              const tail = node.tail;
              if (head8 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail, runtime5.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed12(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map29(forEach18(iterable, (a) => this.offer(a)), every2(identity));
  }
  shutdown = effect3((journal) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
    if (currentPublisherTail !== void 0) {
      unsafeSet2(this.publisherTail, void 0, journal);
      const currentSubscribers = unsafeGet9(this.subscribers, journal);
      forEach6(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, void 0, journal);
      });
      unsafeSet2(this.subscribers, empty9(), journal);
    }
  });
};
var TPubSubSubscriptionImpl = class {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = effect3((journal) => {
    const currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
    return currentSubscriberHead === void 0;
  });
  awaitShutdown = flatMap18(this.isShutdown, (isShutdown7) => isShutdown7 ? void_9 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    let loop3 = true;
    let size23 = 0;
    while (loop3) {
      const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
      if (node === void 0) {
        loop3 = false;
      } else {
        const head8 = node.head;
        const tail = node.tail;
        if (head8 !== AbsentValue2) {
          size23 = size23 + 1;
          if (size23 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed12(size23);
  });
  isEmpty = map29(this.size, (size23) => size23 === 0);
  isFull = map29(this.size, (size23) => size23 === this.capacity());
  peek = withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    let value6 = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
      if (node === void 0) {
        return retry4;
      }
      const head8 = node.head;
      const tail = node.tail;
      if (head8 !== AbsentValue2) {
        value6 = head8;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed12(value6);
  });
  peekOption = withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    let value6 = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
      if (node === void 0) {
        value6 = none2();
        loop3 = false;
      } else {
        const head8 = node.head;
        const tail = node.tail;
        if (head8 !== AbsentValue2) {
          value6 = some2(head8);
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed12(value6);
  });
  shutdown = effect3((journal) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
    if (currentSubscriberHead !== void 0) {
      unsafeSet2(this.subscriberHead, void 0, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet9(currentSubscriberHead, journal);
        if (node === void 0) {
          loop3 = false;
        } else {
          const head8 = node.head;
          const tail = node.tail;
          if (head8 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size23 = unsafeGet9(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size23 - 1, journal);
            } else {
              const updatedNode = makeNode2(head8, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet9(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove6(unsafeGet9(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime5.fiberId);
    }
    let value6 = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
      if (node === void 0) {
        return retry4;
      }
      const head8 = node.head;
      const tail = node.tail;
      if (head8 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size23 = unsafeGet9(this.pubsubSize, runtime5.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherHead, tail, runtime5.journal);
          unsafeSet2(this.pubsubSize, size23 - 1, runtime5.journal);
        } else {
          const updatedNode = makeNode2(head8, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime5.journal);
        value6 = head8;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed12(value6);
  });
  takeAll = this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max11) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max11) {
        const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          n = max11;
        } else {
          const head8 = node.head;
          const tail = node.tail;
          if (head8 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size23 = unsafeGet9(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail, runtime5.journal);
              unsafeSet2(this.pubsubSize, size23 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head8, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head8);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed12(builder);
    });
  }
};
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get17(publisherTail), flatMap18((currentPublisherTail) => pipe(all8([make54(currentPublisherTail), get17(subscriberCount), get17(subscribers)]), tap6(([_2, currentSubscriberCount]) => pipe(subscriberCount, set9(currentSubscriberCount + 1))), tap6(([subscriberHead, _2, currentSubscribers]) => pipe(subscribers, set9(pipe(currentSubscribers, add4(subscriberHead))))), map29(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var publish3 = dual(2, (self, value6) => self.offer(value6));
var publishAll2 = dual(2, (self, iterable) => self.offerAll(iterable));
var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TPubSub.js
var publish4 = publish3;
var subscribe4 = subscribe3;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TQueue.js
var TDequeueTypeId2 = TDequeueTypeId;
var offer5 = offer4;
var unbounded8 = unbounded6;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity7) {
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable2(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? void 0;
  }
  put(value6) {
    this.array[this.current] = value6;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable2(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value6, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value6,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var make55 = () => pipe(make21(), flatMap15((deferred) => make32(handoffStateEmpty(deferred))), map25((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer6 = dual(2, (self, value6) => {
  return flatMap15(make21(), (deferred) => flatten11(modify7(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight6(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value6, deferred)], (_2, notifyProducer) => [flatMap15(_await(notifyProducer), () => pipe(self, offer6(value6))), state])))));
});
var take8 = (self) => flatMap15(make21(), (deferred) => flatten11(modify7(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap15(_await(notifyConsumer), () => take8(self)), state], (value6, notifyProducer) => [as6(succeed2(notifyProducer, void 0), value6), handoffStateEmpty(deferred)])))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause2) => ({
  _tag: OP_HALT,
  cause: cause2
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk2 = (chunk4) => new TakeImpl(succeed3(chunk4));
var done10 = (self) => suspend4(() => self.exit);
var end4 = new TakeImpl(fail4(none2()));
var failCause10 = (cause2) => new TakeImpl(failCause3(pipe(cause2, map22(some2))));
var match25 = dual(2, (self, {
  onEnd: onEnd2,
  onFailure,
  onSuccess
}) => match7(self.exit, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: onEnd2,
    onSome: onFailure
  }),
  onSuccess
}));
var matchEffect5 = dual(2, (self, {
  onEnd: onEnd2,
  onFailure,
  onSuccess
}) => matchEffect2(self.exit, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: () => onEnd2,
    onSome: onFailure
  }),
  onSuccess
}));
var map30 = dual(2, (self, f2) => new TakeImpl(pipe(self.exit, map15(map7(f2)))));
var of5 = (value6) => new TakeImpl(succeed3(of2(value6)));
var tap7 = dual(2, (self, f2) => pipe(self.exit, forEachEffect(f2), asVoid5));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail10(none2());
var failCause11 = (cause2) => mapError4(failCause8(cause2), some2);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_2) => _2,
  _E: (_2) => _2,
  _A: (_2) => _2
};
var StreamImpl = class {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var DefaultChunkSize = 4096;
var aggregate = dual(2, (self, sink) => aggregateWithin(self, sink, forever4));
var aggregateWithin = dual(3, (self, sink, schedule2) => filterMap9(aggregateWithinEither(self, sink, schedule2), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = dual(3, (self, sink, schedule2) => {
  const layer = all7([make55(), make32(ScheduleEnd), make32(empty6()), driver2(schedule2), make32(false), make32(false)]);
  return fromEffect7(layer).pipe(flatMap19(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap16(fromEffect4(pipe(handoff, offer6(emit(input)), when3(() => isNonEmpty2(input)))), () => handoffProducer),
      onFailure: (cause2) => fromEffect4(offer6(handoff, halt(cause2))),
      onDone: () => fromEffect4(offer6(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet3(sinkLeftovers, empty6()), flatMap15((leftovers) => {
      if (isNonEmpty2(leftovers)) {
        return pipe(set7(consumed, true), zipRight6(succeed8(pipe(write(leftovers), flatMap16(() => handoffConsumer)))));
      }
      return pipe(take8(handoff), map25((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect4(set7(consumed, true)), zipRight7(write(signal.elements)), zipRight7(fromEffect4(get12(endAfterEmit))), flatMap16((bool) => bool ? void_7 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause9(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get12(consumed), map25((bool) => bool ? fromEffect4(pipe(set7(sinkEndReason, ScheduleEnd), zipRight6(set7(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set7(sinkEndReason, ScheduleEnd), zipRight6(set7(endAfterEmit, true)))), flatMap16(() => handoffConsumer))), unwrap);
            }
            return pipe(set7(sinkEndReason, signal.reason), zipRight6(set7(endAfterEmit, true)), fromEffect4);
          }
        }
      }));
    }), unwrap);
    const timeout4 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set7(consumed, false), zipRight6(set7(endAfterEmit, false)), zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn3(scope5))));
      const handleSide = (leftovers, b2, c) => pipe(set7(sinkLeftovers, flatten5(leftovers)), zipRight6(map25(get12(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all7([get12(consumed), forkSink, pipe(timeout4(some2(b2)), forkIn3(scope5))]), map25(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b2)),
                onSome: (c2) => make7(right2(b2), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap16(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap);
          }
          case OP_UPSTREAM_END: {
            return pipe(get12(consumed), map25((wasConsumed) => wasConsumed ? write(of2(right2(b2))) : void_7), unwrap);
          }
        }
      })), unwrap);
      return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
        onSelfDone: (sinkExit, _2) => pipe(interrupt7(scheduleFiber), zipRight6(pipe(suspend4(() => sinkExit), map25(([leftovers, b2]) => handleSide(leftovers, b2, none2()))))),
        onOtherDone: (scheduleExit, _2) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause2) => match(failureOrCause2(cause2), {
            onLeft: () => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight6(pipe(join3(sinkFiber), map25(([leftovers, b2]) => handleSide(leftovers, b2, none2()))))),
            onRight: (cause3) => pipe(handoff, offer6(halt(cause3)), forkDaemon3, zipRight6(pipe(join3(sinkFiber), map25(([leftovers, b2]) => handleSide(leftovers, b2, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight6(pipe(join3(sinkFiber), map25(([leftovers, b2]) => handleSide(leftovers, b2, some2(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self), handoffProducer).pipe(run2, forkIn3(scope5), zipRight6(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn3(scope5), flatMap15((sinkFiber) => timeout4(none2()).pipe(forkIn3(scope5), map25((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as10 = dual(2, (self, value6) => map31(self, () => value6));
var branchAfter = dual(3, (self, n, f2) => suspend9(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll3(b1)), b2);
      }
      return buffering(pipe(acc, appendAll3(input)));
    },
    onFailure: fail11,
    onDone: () => running4(acc, empty6())
  });
  const running4 = (prefix, leftover2) => pipeTo(zipRight7(write(leftover2), identityChannel()), toChannel2(f2(prefix)));
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty6()))));
}));
var broadcast = dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map25((tuple4) => tuple4.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = dual(2, (self, maximumLag) => map25(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = dual(2, (self, options) => map25(make50({
  acquire: broadcastDynamic(self, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped4(get16(rcRef))));
var broadcastedQueues = dual(3, (self, n, maximumLag) => flatMap15(pubsubFromOptions(maximumLag), (pubsub) => pipe(all7(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap5(() => forkScoped2(runIntoPubSubScoped(self, pubsub))))));
var broadcastedQueuesDynamic = dual(2, (self, maximumLag) => map25(toPubSub2(self, maximumLag), subscribe2));
var buffer2 = dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(unwrapScoped3(map25(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take6(queue2)), flatMap16(match7({
      onFailure: (cause2) => pipe(flipCauseOption2(cause2), match2({
        onNone: () => void_7,
        onSome: failCause9
      })),
      onSuccess: (value6) => flatMap16(write(of2(value6)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue2(self, options);
  return new StreamImpl(unwrapScoped3(map25(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take6(queue2)), flatMap16(match25({
      onEnd: () => void_7,
      onFailure: failCause9,
      onSuccess: (value6) => pipe(write(value6), flatMap16(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = dual(2, (self, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = dual(2, (self, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferDropping = dual(2, (self, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
});
var bufferSliding = dual(2, (self, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
});
var bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map25(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take6(queue2)), flatMap16(match25({
      onEnd: () => void_7,
      onFailure: failCause9,
      onSuccess: (value6) => flatMap16(write(value6), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped6, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take13) => pipe(get12(ref), tap5(_await), zipRight6(make21()), flatMap15((deferred) => pipe(offer3(queue, [take13, deferred]), zipRight6(set7(ref, deferred)), zipRight6(_await(deferred)))), asVoid5, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make21(), flatMap15((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap15((added) => pipe(set7(ref, deferred), when3(() => added))))), asVoid5, fromEffect4, flatMap16(() => producer(queue, ref))),
      onFailure: (error2) => terminate(failCause10(error2)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take6(queue)), flatMap16(([take13, deferred]) => zipRight7(fromEffect4(succeed2(deferred, void 0)), match25(take13, {
      onEnd: () => void_7,
      onFailure: failCause9,
      onSuccess: (value6) => pipe(write(value6), flatMap16(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped6, flatMap15((queue) => pipe(make21(), tap5((start5) => succeed2(start5, void 0)), flatMap15((start5) => pipe(make32(start5), flatMap15((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as6(consumer(queue))))))));
};
var catchAll7 = dual(2, (self, f2) => catchAllCause6(self, (cause2) => match(failureOrCause2(cause2), {
  onLeft: f2,
  onRight: failCause12
})));
var catchAllCause6 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), catchAllCause5((cause2) => toChannel2(f2(cause2))))));
var catchSome3 = dual(2, (self, pf) => pipe(self, catchAll7((error2) => pipe(pf(error2), getOrElse2(() => fail15(error2))))));
var catchSomeCause3 = dual(2, (self, pf) => pipe(self, catchAllCause6((cause2) => pipe(pf(cause2), getOrElse2(() => failCause12(cause2))))));
var catchTag4 = dual(3, (self, k2, f2) => catchAll7(self, (e) => {
  if ("_tag" in e && e["_tag"] === k2) {
    return f2(e);
  }
  return fail15(e);
}));
var catchTags3 = dual(2, (self, cases) => catchAll7(self, (e) => {
  const keys10 = Object.keys(cases);
  if ("_tag" in e && keys10.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail15(e);
}));
var changesWith = dual(2, (self, f2) => {
  const writer = (last6) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce4(input, [last6, empty6()], ([option6, outputs], output) => {
        if (isSome2(option6) && f2(option6.value, output)) {
          return [some2(output), outputs];
        }
        return [some2(output), pipe(outputs, append3(output))];
      });
      return flatMap16(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var changesWithEffect = dual(2, (self, f2) => {
  const writer = (last6) => readWithCause({
    onInput: (input) => pipe(input, reduce16([last6, empty6()], ([option6, outputs], output) => {
      if (isSome2(option6)) {
        return pipe(f2(option6.value, output), map25((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append3(output))]));
      }
      return succeed8([some2(output), pipe(outputs, append3(output))]);
    }), fromEffect4, flatMap16(([newLast, newChunk]) => pipe(write(newChunk), flatMap16(() => writer(newLast))))),
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var chunks = (self) => pipe(self, mapChunks(of2));
var chunksWith = dual(2, (self, f2) => flattenChunks(f2(chunks(self))));
var unsome = (effect4) => catchAll4(asSome3(effect4), (o) => o._tag === "None" ? succeedNone3 : fail10(o.value));
var combine15 = dual(4, (self, that, s, f2) => {
  function producer(handoff, latch) {
    return fromEffect4(take8(latch)).pipe(zipRight7(readWithCause({
      onInput: (input) => flatMap16(fromEffect4(offer6(handoff, succeed3(input))), () => producer(handoff, latch)),
      onFailure: (cause2) => fromEffect4(offer6(handoff, failCause3(pipe(cause2, map22(some2))))),
      onDone: () => flatMap16(fromEffect4(offer6(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make55(), make55(), make55(), make55()]).pipe(tap5(([left3, _2, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn3(scope5))), tap5(([, right3, _2, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn3(scope5))), map25(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight6(take8(left3).pipe(flatMap15(identity))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight6(take8(right3).pipe(flatMap15(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap15(f2(s2, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = dual(4, (self, that, s, f2) => {
  const producer = (handoff, latch) => zipRight7(fromEffect4(take8(latch)), readWithCause({
    onInput: (input) => flatMap16(fromEffect4(pipe(handoff, offer6(chunk2(input)))), () => producer(handoff, latch)),
    onFailure: (cause2) => fromEffect4(offer6(handoff, failCause10(cause2))),
    onDone: () => fromEffect4(offer6(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make55(), make55(), make55(), make55()]).pipe(tap5(([left3, _2, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope5), forkIn3(scope5))), tap5(([_2, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn3(scope5))), map25(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight6(take8(left3).pipe(flatMap15(done10))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight6(take8(right3).pipe(flatMap15(done10))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap15(f2(s2, pullLeft, pullRight), unsome)));
  }))));
});
var concat3 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight7(toChannel2(that)))));
var cross = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _2) => a)));
var crossRight = dual(2, (left3, right3) => flatMap19(left3, () => right3));
var crossWith = dual(3, (left3, right3, f2) => pipe(left3, flatMap19((a) => pipe(right3, map31((b2) => f2(a, b2))))));
var debounce = dual(2, (self, duration3) => unwrapScopedWith3((scope5) => gen3(function* () {
  const handoff = yield* make55();
  function enqueue(last6) {
    return sleep2(duration3).pipe(as6(last6), forkIn3(scope5), map25((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect4(offer6(handoff, emit(of2(elem)))).pipe(flatMap16(() => producer))
    }),
    onFailure: (cause2) => fromEffect4(offer6(handoff, halt(cause2))),
    onDone: () => fromEffect4(offer6(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap(take8(handoff).pipe(map25((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause9(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap(take8(handoff).pipe(forkIn3(scope5), flatMap15((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
          onSelfDone: (leftExit, current2) => match7(leftExit, {
            onFailure: (cause2) => interrupt7(current2).pipe(as6(failCause9(cause2))),
            onSuccess: (chunk4) => interrupt7(current2).pipe(zipRight6(succeed8(write(chunk4).pipe(flatMap16(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match7(rightExit, {
            onFailure: (cause2) => interrupt7(previous2).pipe(as6(failCause9(cause2))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt7(previous2).pipe(zipRight6(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt7(previous2).pipe(as6(failCause9(signal.cause)));
                }
                case OP_END: {
                  return join3(previous2).pipe(map25((chunk4) => write(chunk4).pipe(zipRight7(void_7))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap(join3(state.fiber).pipe(map25((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause9(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope6) => pipeTo(toChannel2(self), producer).pipe(runIn(scope6), forkIn3(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die9 = (defect) => fromEffect7(die5(defect));
var distributedWith = dual(2, (self, options) => pipe(make21(), flatMap15((deferred) => pipe(self, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap15(_await(deferred), (f2) => f2(a))
}), flatMap15((next5) => pipe(all7(map7(range(0, options.size - 1), (id2) => map25(next5, ([key, queue]) => [[key, id2], queue]))), map25(unsafeFromArray), flatMap15((entries3) => {
  const [mappings, queues] = reduceRight2(entries3, [/* @__PURE__ */ new Map(), empty6()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend3(queue))]);
  return pipe(succeed2(deferred, (a) => map25(options.decide(a), (f2) => (key) => f2(mappings.get(key)))), as6(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = dual(4, (self, maximumLag, decide, done14) => pipe(acquireRelease2(make32(/* @__PURE__ */ new Map()), (ref, _2) => pipe(get12(ref), flatMap15((queues) => pipe(queues.values(), forEach16(shutdown4))))), flatMap15((queuesRef) => gen3(function* () {
  const offer8 = (a) => pipe(decide(a), flatMap15((shouldProcess) => pipe(get12(queuesRef), flatMap15((queues) => pipe(queues.entries(), reduce16(empty6(), (acc, [id2, queue]) => {
    if (shouldProcess(id2)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: (cause2) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted2(cause2) ? succeed8(pipe(acc, prepend3(id2))) : failCause8(cause2)
        ),
        onSuccess: () => succeed8(acc)
      }));
    }
    return succeed8(acc);
  }), flatMap15((ids3) => {
    if (isNonEmpty2(ids3)) {
      return update4(queuesRef, (map40) => {
        for (const id2 of ids3) {
          map40.delete(id2);
        }
        return map40;
      });
    }
    return _void;
  }))))), asVoid5);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make32(pipe(bounded5(maximumLag), flatMap15((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map40) => map40.set(id2, queue)), as6([id2, queue]));
  })));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set7(newQueue, pipe(
      // All newly created queues should end immediately
      bounded5(1),
      tap5((queue) => offer3(queue, endTake)),
      flatMap15((queue) => {
        const id2 = newDistributedWithDynamicId();
        return pipe(update4(queuesRef, (map40) => map40.set(id2, queue)), as6(make3(id2, queue)));
      })
    )), zipRight6(pipe(get12(queuesRef), flatMap15((map40) => pipe(fromIterable2(map40.values()), forEach16((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause2) => isInterrupted2(cause2) ? some2(_void) : none2()))))))), zipRight6(done14(endTake)), asVoid5))
  );
  yield* pipe(self, runForEachScoped(offer8), matchCauseEffect3({
    onFailure: (cause2) => finalize(failCause3(pipe(cause2, map22(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten11(get12(newQueue)));
}))));
var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
var drainFork = dual(2, (self, that) => fromEffect7(make21()).pipe(flatMap19((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause4((cause2) => failCause2(backgroundDied, cause2)), forkIn3(scope5))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
var drop5 = dual(2, (self, n) => {
  const loop3 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop3(r));
      const leftover2 = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover2 > 0;
      if (more) {
        return loop3(leftover2);
      }
      return pipe(write(dropped), zipRight7(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(n))));
});
var dropRight3 = dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend9(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap5((elem) => {
          const head8 = queue.head();
          queue.put(elem);
          return head8;
        }));
        return pipe(write(outputs), flatMap16(() => reader));
      },
      onFailure: fail11,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
  });
});
var dropUntil3 = dual(2, (self, predicate) => drop5(dropWhile5(self, (a) => !predicate(a)), 1));
var dropUntilEffect = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map25(unsafeFromArray), map25((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend5(() => loop3);
      }
      return pipe(write(leftover2), zipRight7(identityChannel()));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var dropWhile5 = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const output = dropWhile2(input, predicate);
      if (isEmpty(output)) {
        return suspend5(() => loop3);
      }
      return zipRight7(write(output), identityChannel());
    },
    onFailure: fail11,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
});
var dropWhileEffect = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropWhile4(input, predicate), map25(unsafeFromArray), map25((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend5(() => loop3);
      }
      return zipRight7(write(leftover2), identityChannel());
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
});
var empty37 = new StreamImpl(void_7);
var ensuring8 = dual(2, (self, finalizer2) => new StreamImpl(pipe(toChannel2(self), ensuring5(finalizer2))));
var ensuringWith3 = dual(2, (self, finalizer2) => new StreamImpl(ensuringWith(toChannel2(self), finalizer2)));
var context8 = () => fromEffect7(context4());
var contextWithStream = (f2) => pipe(context8(), flatMap19(f2));
var execute = (effect4) => drain3(fromEffect7(effect4));
var fail15 = (error2) => fromEffectOption(fail10(some2(error2)));
var failSync6 = (evaluate3) => fromEffectOption(failSync3(() => some2(evaluate3())));
var failCause12 = (cause2) => fromEffect7(failCause8(cause2));
var filter14 = dual(2, (self, predicate) => mapChunks(self, filter5(predicate)));
var filterEffect = dual(2, (self, f2) => {
  const loop3 = (iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed9
      });
    } else {
      return pipe(f2(next5.value), map25((bool) => bool ? pipe(write(of2(next5.value)), flatMap16(() => loop3(iterator))) : loop3(iterator)), unwrap);
    }
  };
  return new StreamImpl(suspend5(() => pipe(toChannel2(self), pipeTo(loop3(empty6()[Symbol.iterator]())))));
});
var filterMap9 = dual(2, (self, pf) => mapChunks(self, filterMap5(pf)));
var filterMapEffect = dual(2, (self, pf) => suspend9(() => {
  const loop3 = (iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed9
      });
    } else {
      return pipe(pf(next5.value), match2({
        onNone: () => sync4(() => loop3(iterator)),
        onSome: map25((a2) => flatMap16(write(of2(a2)), () => loop3(iterator)))
      }), unwrap);
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty6()[Symbol.iterator]()))));
}));
var filterMapWhile4 = dual(2, (self, pf) => {
  const loop3 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile3(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap16(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail11,
    onDone: succeed9
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = dual(2, (self, pf) => suspend9(() => {
  const loop3 = (iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed9
      });
    } else {
      return unwrap(match2(pf(next5.value), {
        onNone: () => succeed8(void_7),
        onSome: map25((a2) => flatMap16(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(empty6()[Symbol.iterator]()))));
}));
var find2 = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => match2(findFirst4(input, predicate), {
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var findEffect2 = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(findFirst10(input, predicate), map25(match2({
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    })), unwrap),
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var flatMap19 = dual((args2) => isStream(args2[0]), (self, f2, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f2), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f2));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as12) => pipe(as12, map7((a) => toChannel2(f2(a))), reduce4(void_7, (left3, right3) => pipe(left3, zipRight7(right3)))))), (_2) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), options))));
});
var matchConcurrency = (concurrency, sequential5, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = dual(4, (self, n, bufferSize, f2) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten14 = dual((args2) => isStream(args2[0]), (self, options) => flatMap19(self, identity, options));
var flattenChunks = (self) => {
  const flatten15 = readWithCause({
    onInput: (chunks2) => flatMap16(writeChunk(chunks2), () => flatten15),
    onFailure: failCause9,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten15)));
};
var flattenEffect = dual((args2) => isStream(args2[0]), (self, options) => options?.unordered ? flatMap19(self, (a) => fromEffect7(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = (self) => {
  const processChunk = (chunk4, cont) => {
    const [toEmit, rest] = pipe(chunk4, splitWhere2((exit4) => !isSuccess(exit4)));
    const next5 = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match7({
        onFailure: (cause2) => match2(flipCauseOption2(cause2), {
          onNone: () => void_7,
          onSome: failCause9
        }),
        onSuccess: () => void_7
      })
    }));
    return pipe(write(pipe(toEmit, filterMap5((exit4) => isSuccess(exit4) ? some2(exit4.value) : none2()))), flatMap16(() => next5));
  };
  const process2 = readWithCause({
    onInput: (chunk4) => processChunk(chunk4, process2),
    onFailure: (cause2) => failCause9(cause2),
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
};
var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map31((take13) => take13.exit))));
var forever5 = (self) => new StreamImpl(repeated(toChannel2(self)));
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream2) => {
  if ("channel" in stream2) {
    return stream2.channel;
  } else if (isEffect2(stream2)) {
    return toChannel2(fromEffect7(stream2));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk4) => new StreamImpl(isEmpty(chunk4) ? void_7 : write(chunk4));
var fromEffect7 = (effect4) => pipe(effect4, mapError4(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap(match16(effect4, {
  onFailure: match2({
    onNone: () => void_7,
    onSome: fail11
  }),
  onSuccess: (a) => write(of2(a))
})));
var fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map25(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map25(effect4, ensuring8(shutdown3(pubsub))) : effect4;
  }
  const stream2 = flatMap19(scoped4(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring8(stream2, shutdown3(pubsub)) : stream2;
};
var fromIterable13 = (iterable) => suspend9(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync4(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync4(() => {
      let next5 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next5.done) {
          return void_7;
        }
        return pipe(write(of2(next5.value)), flatMap16(() => loop3(iterator2)));
      }
      builder = [];
      let count5 = 0;
      while (next5.done === false) {
        builder.push(next5.value);
        count5 = count5 + 1;
        if (count5 >= maxChunkSize) {
          break;
        }
        next5 = iterator2.next();
      }
      if (count5 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap16(() => loop3(iterator2)));
      }
      return void_7;
    }), unwrap);
    return new StreamImpl(loop3(iterator));
  }), unwrap2);
};
var fromPull2 = (effect4) => pipe(effect4, map25(repeatEffectChunkOption), unwrapScoped4);
var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause4((cause2) => pipe(isShutdown3(queue), flatMap15((isShutdown7) => isShutdown7 && isInterrupted2(cause2) ? end5() : failCause11(cause2)))), repeatEffectChunkOption, options?.shutdown ? ensuring8(shutdown4(queue)) : identity);
var EOF = Symbol.for("effect/Stream/EOF");
var groupAdjacentBy = dual(2, (self, f2) => {
  const groupAdjacentByChunk = (state, chunk4) => {
    if (isEmpty(chunk4)) {
      return [state, empty6()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty6();
    switch (state._tag) {
      case "Some": {
        const tuple4 = state.value;
        key = tuple4[0];
        let loop3 = true;
        while (loop3 && until < chunk4.length) {
          const input = unsafeGet4(chunk4, until);
          const updatedKey = f2(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple4[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk4).slice(from, until));
            const group4 = appendAll3(previousChunk2, additionalChunk);
            builder.push([key, group4]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple4[1];
        }
        break;
      }
      case "None": {
        key = f2(unsafeGet4(chunk4, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk4.length) {
      const input = unsafeGet4(chunk4, until);
      const updatedKey = f2(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk4).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll3(previousChunk, unsafeFromArray(Array.from(chunk4).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap16(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause2) => match2(state, {
      onNone: () => failCause9(cause2),
      onSome: (output) => flatMap16(write(of2(output)), () => failCause9(cause2))
    }),
    onDone: (done14) => match2(state, {
      onNone: () => succeedNow(done14),
      onSome: (output) => flatMap16(write(of2(output)), () => succeedNow(done14))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
});
var grouped = dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
var groupedWithin = dual(3, (self, chunkSize, duration3) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration3)));
var haltWhen = dual(2, (self, effect4) => {
  const writer = (fiber) => pipe(poll4(fiber), map25(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap16(write(input), () => writer(fiber)),
      onFailure: fail11,
      onDone: () => void_7
    }),
    onSome: match7({
      onFailure: failCause9,
      onSuccess: () => void_7
    })
  })), unwrap);
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn3(scope5), map25((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = dual(2, (self, duration3) => pipe(self, haltWhen(sleep2(duration3))));
var haltWhenDeferred = dual(2, (self, deferred) => {
  const writer = pipe(poll(deferred), map25(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap16(() => writer)),
      onFailure: fail11,
      onDone: () => void_7
    }),
    onSome: (effect4) => unwrap(match16(effect4, {
      onFailure: fail11,
      onSuccess: () => void_7
    }))
  })), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = dual(2, (self, that) => pipe(self, interleaveWith(that, forever5(make57(true, false)))));
var interleaveWith = dual(3, (self, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value6) => flatMap16(fromEffect4(offer6(handoff, of5(value6))), () => producer(handoff)),
    onFailure: (cause2) => fromEffect4(offer6(handoff, failCause10(cause2))),
    onDone: () => fromEffect4(offer6(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make55(), zip10(make55()), tap5(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn3(scope5))), tap5(([_2, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn3(scope5))), map25(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect4(take8(left3)), flatMap16(match25({
            onEnd: () => rightDone ? void_7 : process2(true, rightDone),
            onFailure: failCause9,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap16(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect4(take8(right3)), flatMap16(match25({
            onEnd: () => leftDone ? void_7 : process2(leftDone, true),
            onFailure: failCause9,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap16(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause9,
      onDone: () => void_7
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse3 = dual(2, (self, element2) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend5(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk4) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk4) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element2);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap16(() => writer(flagResult)));
    },
    onFailure: failCause9,
    onDone: () => void_7
  });
  return writer(true);
})))));
var intersperseAffixes = dual(2, (self, {
  end: end6,
  middle,
  start: start5
}) => pipe(make57(start5), concat3(pipe(self, intersperse3(middle))), concat3(make57(end6))));
var interruptAfter = dual(2, (self, duration3) => pipe(self, interruptWhen2(sleep2(duration3))));
var interruptWhen2 = dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
var interruptWhenDeferred2 = dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
var make57 = (...as12) => fromIterable13(as12);
var map31 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOut(map7(f2)))));
var mapAccum4 = dual(3, (self, s, f2) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk4] = mapAccum2(input, s2, f2);
      return flatMap16(write(chunk4), () => accumulator(nextS));
    },
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
});
var mapAccumEffect = dual(3, (self, s, f2) => suspend9(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = (output) => sync4(() => {
        outputs.push(output);
      });
      return pipe(input, reduce16(s2, (s3, a) => pipe(f2(s3, a), flatMap15(([s4, a2]) => pipe(emit2(a2), as6(s4))))), match16({
        onFailure: (error2) => {
          if (outputs.length !== 0) {
            return zipRight7(write(unsafeFromArray(outputs)), fail11(error2));
          }
          return fail11(error2);
        },
        onSuccess: (s3) => flatMap16(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
}));
var mapBoth8 = dual(2, (self, options) => pipe(self, mapError8(options.onFailure), map31(options.onSuccess)));
var mapChunks = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOut(f2))));
var mapChunksEffect = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f2))));
var mapConcat = dual(2, (self, f2) => pipe(self, mapConcatChunk((a) => fromIterable2(f2(a)))));
var mapConcatChunk = dual(2, (self, f2) => pipe(self, mapChunks(flatMap5(f2))));
var mapConcatChunkEffect = dual(2, (self, f2) => pipe(self, mapEffectSequential(f2), mapConcatChunk(identity)));
var mapConcatEffect = dual(2, (self, f2) => pipe(self, mapEffectSequential((a) => pipe(f2(a), map25(fromIterable2))), mapConcatChunk(identity)));
var mapEffectSequential = dual(2, (self, f2) => {
  const loop3 = (iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed9
      });
    } else {
      const value6 = next5.value;
      return unwrap(map25(f2(value6), (a2) => flatMap16(write(of2(a2)), () => loop3(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend5(() => loop3(empty6()[Symbol.iterator]())))));
});
var mapEffectPar = dual(3, (self, n, f2) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f2, n), mapOut(of2))));
var mapError8 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapError5(f2))));
var mapErrorCause4 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapErrorCause3(f2))));
var merge8 = dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll6 = dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten14(fromIterable13(streams), options));
var mergeWithTag = dual(2, (streams, options) => {
  const keys10 = Object.keys(streams);
  const values7 = keys10.map((key) => streams[key].pipe(map31((value6) => ({
    _tag: key,
    value: value6
  }))));
  return mergeAll6(values7, options);
});
var mergeEither = dual(2, (self, that) => mergeWith3(self, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = dual(2, (left3, right3) => pipe(left3, merge8(drain3(right3))));
var mergeRight = dual(2, (left3, right3) => pipe(drain3(left3), merge8(right3)));
var mergeWith3 = dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit4) => terminate || !isSuccess(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5));
  return new StreamImpl(mergeWith2(toChannel2(map31(self, options.onSelf)), {
    other: toChannel2(map31(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var never7 = fromEffect7(never4);
var onEnd = dual(2, (self, effect4) => concat3(self, drain3(fromEffect7(effect4))));
var onError4 = dual(2, (self, cleanup) => pipe(self, catchAllCause6((cause2) => fromEffect7(pipe(cleanup(cause2), zipRight6(failCause8(cause2)))))));
var onDone = dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit4) => isSuccess(exit4) ? cleanup() : _void))));
var onStart = dual(2, (self, effect4) => unwrap2(as6(effect4, self)));
var orDieWith4 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), orDieWith2(f2))));
var orElse11 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse8(() => toChannel2(that())))));
var orElseEither5 = dual(2, (self, that) => pipe(self, map31(left2), orElse11(() => pipe(that(), map31(right2)))));
var orElseFail3 = dual(2, (self, error2) => pipe(self, orElse11(() => failSync6(error2))));
var orElseIfEmpty = dual(2, (self, element2) => pipe(self, orElseIfEmptyChunk(() => of2(element2()))));
var orElseIfEmptyChunk = dual(2, (self, chunk4) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk4())))));
var orElseIfEmptyStream = dual(2, (self, stream2) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend5(() => writer);
      }
      return pipe(write(input), zipRight7(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => suspend5(() => toChannel2(stream2()))
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var orElseSucceed4 = dual(2, (self, value6) => pipe(self, orElse11(() => sync9(value6))));
var peel = dual(2, (self, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make21(), flatMap15((deferred) => pipe(make55(), map25((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error2) => zipRight8(fromEffect6(fail3(deferred, error2)), fail12(error2)),
      onSuccess: ([z2, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap16(fromEffect4(offer6(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause2) => zipRight7(fromEffect4(offer6(handoff, {
            _tag: OP_HALT2,
            cause: cause2
          })), failCause9(cause2)),
          onDone: (_2) => zipRight7(fromEffect4(offer6(handoff, {
            _tag: OP_END2
          })), void_7)
        });
        return fromChannel(pipe(fromEffect4(succeed2(deferred, z2)), zipRight7(fromEffect4(pipe(handoff, offer6({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight7(loop3)));
      }
    });
    const producer = pipe(take8(handoff), map25((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap16(() => producer));
        }
        case OP_HALT2: {
          return failCause9(signal.cause);
        }
        case OP_END2: {
          return void_7;
        }
      }
    }), unwrap);
    return pipe(self, tapErrorCause5((cause2) => failCause2(deferred, cause2)), run3(consumer), forkScoped2, zipRight6(_await(deferred)), map25((z2) => [z2, new StreamImpl(producer)]));
  }))), flatten11);
});
var partition9 = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed8(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed8((n) => n === 0),
    onRight: () => succeed8((n) => n === 1)
  })
}), flatMap15(([queue1, queue2]) => succeed8([filterMap9(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_2) => match(_2, {
  onLeft: some2,
  onRight: none2
})), filterMap9(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var pipeThroughChannelOrFail = dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
var prepend6 = dual(2, (self, values7) => new StreamImpl(zipRight7(write(values7), toChannel2(self))));
var provideContext7 = dual(2, (self, context10) => new StreamImpl(pipe(toChannel2(self), provideContext4(context10))));
var provideSomeContext3 = dual(2, (self, context10) => mapInputContext5(self, merge3(context10)));
var provideLayer2 = dual(2, (self, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map25((env) => pipe(toChannel2(self), provideContext4(env)))))));
var provideService8 = dual(3, (self, tag3, resource) => provideServiceEffect4(self, tag3, succeed8(resource)));
var provideServiceEffect4 = dual(3, (self, tag3, effect4) => provideServiceStream(self, tag3, fromEffect7(effect4)));
var provideServiceStream = dual(3, (self, tag3, stream2) => contextWithStream((env) => flatMap19(stream2, (service3) => pipe(self, provideContext7(add2(env, tag3, service3))))));
var mapInputContext5 = dual(2, (self, f2) => contextWithStream((env) => pipe(self, provideContext7(f2(env)))));
var provideSomeLayer3 = dual(2, (self, layer) => (
  // @ts-expect-error
  // @effect-diagnostics-next-line missingEffectContext:off
  pipe(self, provideLayer2(pipe(context5(), merge7(layer))))
));
var race5 = dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = (...streams) => make21().pipe(map25((halt2) => {
  let winner = null;
  return mergeAll6(streams.map((stream2, index) => stream2.pipe(takeWhile6(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_4);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap15(() => winner === index ? never4 : _void))))), {
    concurrency: streams.length
  });
}), unwrap2);
var rechunk = dual(2, (self, n) => suspend9(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk4) => {
    if (chunk4.length === target && rechunker.isEmpty()) {
      return flatMap16(write(chunk4), () => rechunkProcess(rechunker, target));
    }
    if (chunk4.length > 0) {
      const chunks2 = [];
      let result = void 0;
      let index = 0;
      while (index < chunk4.length) {
        while (index < chunk4.length && result === void 0) {
          result = rechunker.write(pipe(chunk4, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== void 0) {
          chunks2.push(result);
          result = void 0;
        }
      }
      return flatMap16(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
    }
    return suspend5(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause2) => zipRight7(rechunker.emitIfNotEmpty(), failCause9(cause2)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_7;
  }
};
var refineOrDie3 = dual(2, (self, pf) => pipe(self, refineOrDieWith3(pf, identity)));
var refineOrDieWith3 = dual(3, (self, pf, f2) => new StreamImpl(catchAll5(toChannel2(self), (error2) => match2(pf(error2), {
  onNone: () => failCause9(die4(f2(error2))),
  onSome: fail11
}))));
var repeat3 = dual(2, (self, schedule2) => filterMap9(repeatEither(self, schedule2), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map25(effect5, (chunk4) => some2([chunk4, effect5])), catchAll4(match2({
  onNone: () => succeed8(none2()),
  onSome: fail10
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map25(of2)));
var repeatEither = dual(2, (self, schedule2) => repeatWith(self, schedule2, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = dual(2, (self, schedule2) => filterMap9(repeatElementsWith(self, schedule2, {
  onElement: (a) => some2(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = dual(3, (self, schedule2, options) => {
  const driver3 = pipe(driver2(schedule2), map25((driver4) => {
    const feed = (input) => match2(head2(input), {
      onNone: () => loop3,
      onSome: (a) => zipRight7(write(of2(options.onElement(a))), step3(pipe(input, drop3(1)), a))
    });
    const step3 = (input, a) => {
      const advance = pipe(driver4.next(a), as6(pipe(write(of2(options.onElement(a))), flatMap16(() => step3(input, a)))));
      const reset = pipe(driver4.last, orDie2, flatMap15((b2) => pipe(driver4.reset, map25(() => pipe(write(of2(options.onSchedule(b2))), zipRight7(feed(input)))))));
      return pipe(advance, orElse7(() => reset), unwrap);
    };
    const loop3 = readWith({
      onInput: feed,
      onFailure: fail11,
      onDone: () => void_7
    });
    return loop3;
  }), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
});
var repeatWith = dual(3, (self, schedule2, options) => {
  return pipe(driver2(schedule2), map25((driver3) => {
    const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const process2 = pipe(self, provideLastIterationInfo, map31(options.onElement), toChannel2);
    const loop3 = unwrap(match16(driver3.next(void 0), {
      onFailure: () => void_7,
      onSuccess: (output) => flatMap16(process2, () => zipRight7(write(of2(options.onSchedule(output))), loop3))
    }));
    return new StreamImpl(zipRight7(process2, loop3));
  }), unwrap2);
});
var retry5 = dual(2, (self, policy) => driver2(policy).pipe(map25((driver3) => {
  const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  const loop3 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as6(driver3.reset, out)), catchAll5((error2) => driver3.next(error2).pipe(match16({
    onFailure: () => fail11(error2),
    onSuccess: () => loop3
  }), unwrap)));
  return loop3;
}), unwrap, fromChannel2));
var withExecutionPlan2 = dual((args2) => isStream(args2[0]), (self, policy, options) => suspend9(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop3 = suspend9(() => {
    const step3 = policy.steps[i++];
    if (!step3) {
      return fail15(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step3.provide) ? provideSomeContext3(self, step3.provide) : provideSomeLayer3(self, step3.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error2 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend9(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail15(error2);
      });
      nextStream = scheduleDefectRefail2(retry5(nextStream, scheduleFromStep(step3, false)));
    } else {
      const schedule2 = scheduleFromStep(step3, true);
      nextStream = schedule2 ? scheduleDefectRefail2(retry5(nextStream, schedule2)) : nextStream;
    }
    return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk4) => {
      receivedElements = true;
      return chunk4;
    }) : nextStream, (error2) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail15(error2);
      }
      lastError = some2(error2);
      return loop3;
    });
  });
  return loop3;
}));
var scheduleDefectRefail2 = (self) => catchAllCause6(self, (cause2) => failCause12(scheduleDefectRefailCause(cause2)));
var run3 = dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runFold = dual(3, (self, s, f2) => runFoldWhile(self, s, constTrue, f2));
var runFoldEffect = dual(3, (self, s, f2) => runFoldWhileEffect(self, s, constTrue, f2));
var runFoldScoped = dual(3, (self, s, f2) => pipe(self, runFoldWhileScoped(s, constTrue, f2)));
var runFoldScopedEffect = dual(3, (self, s, f2) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f2)));
var runFoldWhile = dual(4, (self, s, cont, f2) => run3(self, fold(s, cont, f2)));
var runFoldWhileEffect = dual(4, (self, s, cont, f2) => run3(self, foldEffect(s, cont, f2)));
var runFoldWhileScoped = dual(4, (self, s, cont, f2) => pipe(self, runScoped2(fold(s, cont, f2))));
var runFoldWhileScopedEffect = dual(4, (self, s, cont, f2) => pipe(self, runScoped2(foldEffect(s, cont, f2))));
var runForEach = dual(2, (self, f2) => run3(self, forEach17(f2)));
var runForEachChunk = dual(2, (self, f2) => run3(self, forEachChunk(f2)));
var runForEachChunkScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEachChunk(f2))));
var runForEachScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEach17(f2))));
var runForEachWhile = dual(2, (self, f2) => run3(self, forEachWhile(f2)));
var runForEachWhileScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEachWhile(f2))));
var runIntoPubSub = dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
var runIntoPubSubScoped = dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
var runIntoQueue = dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped2));
var runIntoQueueElementsScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap16(fromEffect4(offerAll3(queue, map7(input, succeed3))), () => writer),
    onFailure: (cause2) => fromEffect4(offer3(queue, failCause3(map22(cause2, some2)))),
    onDone: () => fromEffect4(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid5);
});
var runIntoQueueScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap16(write(chunk2(input)), () => writer),
    onFailure: (cause2) => write(failCause10(cause2)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take13) => offer3(queue, take13)), drain, runScoped, asVoid5);
});
var runScoped2 = dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
var scan3 = dual(3, (self, s, f2) => pipe(self, scanEffect(s, (s2, a) => succeed8(f2(s2, a)))));
var scanReduce = dual(2, (self, f2) => pipe(self, scanReduceEffect((a2, a) => succeed8(f2(a2, a)))));
var scanReduceEffect = dual(2, (self, f2) => pipe(self, mapAccumEffect(none2(), (option6, a) => {
  switch (option6._tag) {
    case "None": {
      return succeed8([some2(a), a]);
    }
    case "Some": {
      return pipe(f2(option6.value, a), map25((b2) => [some2(b2), b2]));
    }
  }
})));
var schedule = dual(2, (self, schedule2) => filterMap9(scheduleWith(self, schedule2, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = dual(3, (self, schedule2, options) => {
  const loop3 = (driver3, iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (chunk4) => loop3(driver3, chunk4[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeedNow
      });
    }
    return unwrap(matchEffect4(driver3.next(next5.value), {
      onFailure: () => pipe(driver3.last, orDie2, map25((b2) => pipe(write(make7(options.onElement(next5.value), options.onSchedule(b2))), flatMap16(() => loop3(driver3, iterator)))), zipLeft5(driver3.reset)),
      onSuccess: () => succeed8(pipe(write(of2(options.onElement(next5.value))), flatMap16(() => loop3(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect4(driver2(schedule2)), flatMap16((driver3) => pipe(toChannel2(self), pipeTo(loop3(driver3, empty6()[Symbol.iterator]()))))));
});
var scanEffect = dual(3, (self, s, f2) => new StreamImpl(pipe(write(of2(s)), flatMap16(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f2(s2, a), map25((s3) => [s3, s3])))))))));
var scoped4 = (effect4) => new StreamImpl(ensuring5(scoped3(pipe(effect4, map25(of2))), _void));
var scopedWith4 = (f2) => new StreamImpl(scopedWith3((scope5) => f2(scope5).pipe(map25(of2))));
var someOrElse = dual(2, (self, fallback) => pipe(self, map31(getOrElse2(fallback))));
var someOrFail = dual(2, (self, error2) => mapEffectSequential(self, match2({
  onNone: () => failSync3(error2),
  onSome: succeed8
})));
var sliding7 = dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
var slidingSize = dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die9(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend5(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty6() : of2(items);
        return pipe(write(result2), flatMap16(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight2(leftovers));
      const result = isEmpty(lastItems) ? empty6() : of2(lastItems);
      return pipe(write(result), flatMap16(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap16(write(filterMap5(input, (element2, index) => {
        queue.put(element2);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause2) => emitOnStreamEnd(queueSize, failCause9(cause2)),
      onDone: () => emitOnStreamEnd(queueSize, void_7)
    });
    return pipe(toChannel2(self), pipeTo(reader(0)));
  }));
});
var split4 = dual(2, (self, predicate) => {
  const split6 = (leftovers, input) => {
    const [chunk4, remaining] = pipe(leftovers, appendAll3(input), splitWhere2(predicate));
    if (isEmpty(chunk4) || isEmpty(remaining)) {
      return loop3(pipe(chunk4, appendAll3(pipe(remaining, drop3(1)))));
    }
    return pipe(write(of2(chunk4)), flatMap16(() => split6(empty6(), pipe(remaining, drop3(1)))));
  };
  const loop3 = (leftovers) => readWith({
    onInput: (input) => split6(leftovers, input),
    onFailure: fail11,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_7;
      }
      if (isNone2(pipe(leftovers, findFirst4(predicate)))) {
        return zipRight7(write(of2(leftovers)), void_7);
      }
      return zipRight7(split6(empty6(), leftovers), void_7);
    }
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty6()))));
});
var splitOnChunk = dual(2, (self, delimiter) => {
  const next5 = (leftover2, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer3;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce4([pipe(leftover2, getOrElse2(() => empty6())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append3(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer3 === void 0) {
              buffer3 = [];
            }
            buffer3.push(pipe(concatenated, take3(concatenated.length - delimiter.length)));
            return [empty6(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer3 === void 0 ? empty6() : unsafeFromArray(buffer3);
      return flatMap16(write(output), () => next5(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause2) => match2(leftover2, {
      onNone: () => failCause9(cause2),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), failCause9(cause2))
    }),
    onDone: (done14) => match2(leftover2, {
      onNone: () => succeed9(done14),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), succeed9(done14))
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(next5(none2(), 0))));
});
var succeed13 = (value6) => fromChunk(of2(value6));
var sync9 = (evaluate3) => suspend9(() => fromChunk(of2(evaluate3())));
var suspend9 = (stream2) => new StreamImpl(suspend5(() => toChannel2(stream2())));
var take10 = dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die9(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop3 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take3(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover2 = Math.max(0, n2 - taken.length);
      const more = leftover2 > 0;
      if (more) {
        return pipe(write(taken), flatMap16(() => loop3(leftover2)));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed9
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop3(n) : void_7)));
});
var takeRight4 = dual(2, (self, n) => {
  if (n <= 0) {
    return empty37;
  }
  return new StreamImpl(pipe(succeed8(new RingBuffer(n)), map25((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element2 of input) {
          queue.put(element2);
        }
        return reader;
      },
      onFailure: fail11,
      onDone: () => pipe(write(queue.toChunk()), zipRight7(void_7))
    });
    return pipe(toChannel2(self), pipeTo(reader));
  }), unwrap));
});
var takeUntil2 = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3((a) => !predicate(a)));
      const last6 = pipe(input, drop3(taken.length), take3(1));
      if (isEmpty(last6)) {
        return pipe(write(taken), flatMap16(() => loop3));
      }
      return write(pipe(taken, appendAll3(last6)));
    },
    onFailure: fail11,
    onDone: succeed9
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var takeUntilEffect = dual(2, (self, predicate) => {
  const loop3 = (iterator) => {
    const next5 = iterator.next();
    if (next5.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed9
      });
    }
    return pipe(predicate(next5.value), map25((bool) => bool ? write(of2(next5.value)) : pipe(write(of2(next5.value)), flatMap16(() => loop3(iterator)))), unwrap);
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty6()[Symbol.iterator]()))));
});
var takeWhile6 = dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap16(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed9
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var tap8 = dual(2, (self, f2) => mapEffectSequential(self, (a) => as6(f2(a), a)));
var tapBoth3 = dual(2, (self, options) => pipe(self, tapError5(options.onFailure), tap8(options.onSuccess)));
var tapError5 = dual(2, (self, f2) => catchAll7(self, (error2) => fromEffect7(zipRight6(f2(error2), fail10(error2)))));
var tapErrorCause5 = dual(2, (self, f2) => {
  const loop3 = readWithCause({
    onInput: (chunk4) => flatMap16(write(chunk4), () => loop3),
    onFailure: (cause2) => fromEffect4(zipRight6(f2(cause2), failCause8(cause2))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var tapSink = dual(2, (self, sink) => pipe(fromEffect7(all7([bounded5(1), make21()])), flatMap19(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk4) => pipe(fromEffect4(offer3(queue, chunk2(chunk4))), foldCauseChannel({
      onFailure: () => flatMap16(write(chunk4), () => identityChannel()),
      onSuccess: () => flatMap16(write(chunk4), () => loop3)
    })),
    onFailure: (cause2) => pipe(fromEffect4(offer3(queue, failCause10(cause2))), foldCauseChannel({
      onFailure: () => failCause9(cause2),
      onSuccess: () => failCause9(cause2)
    })),
    onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_7,
      onSuccess: () => void_7
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop3), ensuring5(zipRight6(forkDaemon3(offer3(queue, end4)), _await(deferred))))), merge8(execute(pipe(run3(right3, sink), ensuring4(zipRight6(shutdown4(queue), succeed2(deferred, void 0)))))));
})));
var throttle = dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: (chunk4) => succeed8(options.cost(chunk4))
}));
var throttleEffect = dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self, cost, units, duration3, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip10(currentTimeMillis2), map25(([weight, currentTimeMillis4]) => {
      const elapsed2 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration3);
      const sum6 = tokens + cycles * units;
      const max11 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available2 = sum6 < 0 ? max11 : Math.min(sum6, max11);
      if (weight <= available2) {
        return pipe(write(input), flatMap16(() => loop3(available2 - weight, currentTimeMillis4)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap),
    onFailure: failCause9,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map25((currentTimeMillis4) => loop3(units, currentTimeMillis4)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self, costFn, units, duration3, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip10(currentTimeMillis2), map25(([weight, currentTimeMillis4]) => {
      const elapsed2 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration3);
      const sum6 = tokens + cycles * units;
      const max11 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available2 = sum6 < 0 ? max11 : Math.min(sum6, max11);
      const remaining = available2 - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay4 = millis(Math.max(0, waitCycles * toMillis(duration3)));
      if (greaterThan5(delay4, zero2)) {
        return pipe(fromEffect4(sleep2(delay4)), zipRight7(write(input)), flatMap16(() => loop3(remaining, currentTimeMillis4)));
      }
      return flatMap16(write(input), () => loop3(remaining, currentTimeMillis4));
    }), unwrap),
    onFailure: failCause9,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map25((currentTimeMillis4) => loop3(units, currentTimeMillis4)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var timeout3 = dual(2, (self, duration3) => pipe(toPull2(self), map25(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration3
})), fromPull2));
var timeoutFail3 = dual(3, (self, error2, duration3) => pipe(self, timeoutTo2(duration3, failSync6(error2))));
var timeoutFailCause3 = dual(3, (self, cause2, duration3) => pipe(toPull2(self), map25(timeoutFailCause2({
  onTimeout: () => map22(cause2(), some2),
  duration: duration3
})), fromPull2));
var timeoutTo2 = dual(3, (self, duration3, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self, timeoutFailCause3(() => die4(StreamTimeout), duration3), catchSomeCause3((cause2) => isDieType2(cause2) && isRuntimeException2(cause2.defect) && cause2.defect.message !== void 0 && cause2.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
};
var toPubSub2 = dual(2, (self, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap5((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self) => map25(toPull(toChannel2(self)), (pull) => pipe(pull, mapError4(some2), flatMap15(match({
  onLeft: () => fail10(none2()),
  onRight: succeed8
}))));
var toQueue2 = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var toQueueOfElements = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self, queue))));
var toReadableStream = dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
var toReadableStreamEffect = dual((args2) => isStream(args2[0]), (self, options) => map25(runtime4(), (runtime5) => toReadableStreamRuntime(self, runtime5, options)));
var toReadableStreamRuntime = dual((args2) => isStream(args2[0]), (self, runtime5, options) => {
  const runFork4 = runFork3(runtime5);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self, (chunk4) => {
        if (chunk4.length === 0) return _void;
        return latch.whenOpen(sync4(() => {
          latch.unsafeClose();
          for (const item of chunk4) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }));
      }));
      fiber.addObserver((exit4) => {
        try {
          if (exit4._tag === "Failure") {
            controller.error(squash(exit4.cause));
          } else {
            controller.close();
          }
        } catch {
        }
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise(asVoid5(interrupt7(fiber)));
    }
  }, options?.strategy);
});
var transduce = dual(2, (self, sink) => {
  const newChannel = suspend5(() => {
    const leftovers = {
      ref: empty6()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer3 = suspend5(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap16(() => buffer3)),
          onFailure: fail11,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty6();
      return pipe(writeChunk(leftover2), flatMap16(() => buffer3));
    });
    const concatAndGet = (chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll3(leftover2, filter5(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap16(write(input), () => upstreamMarker),
      onFailure: fail11,
      onDone: (done14) => zipRight7(sync6(() => {
        upstreamDone.ref = true;
      }), succeedNow(done14))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap16(([leftover2, z2]) => pipe(succeed9([upstreamDone.ref, concatAndGet(leftover2)]), flatMap16(([done14, newLeftovers]) => {
      const nextChannel = done14 && isEmpty(newLeftovers) ? void_7 : transducer;
      return pipe(write(of2(z2)), flatMap16(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer3), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = dual((args2) => isStream(args2[0]), (self, runtime5) => {
  const runFork4 = runFork3(runtime5);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      let returned = false;
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self, (value6) => latch.whenOpen(sync4(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value6
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit4) => {
              if (returned) return;
              fiber = runFork2(latch.whenOpen(sync4(() => {
                if (exit4._tag === "Failure") {
                  currentReject(squash(exit4.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve, reject2) => {
            currentResolve = resolve;
            currentReject = reject2;
            latch.unsafeOpen();
          });
        },
        return() {
          returned = true;
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return runPromise(as6(interrupt7(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var unfoldChunkEffect = (s, f2) => suspend9(() => {
  const loop3 = (s2) => unwrap(map25(f2(s2), match2({
    onNone: () => void_7,
    onSome: ([chunk4, s3]) => flatMap16(write(chunk4), () => loop3(s3))
  })));
  return new StreamImpl(loop3(s));
});
var unfoldEffect = (s, f2) => unfoldChunkEffect(s, (s2) => pipe(f2(s2), map25(map2(([a, s3]) => [of2(a), s3]))));
var void_10 = succeed13(void 0);
var unwrap2 = (effect4) => flatten14(fromEffect7(effect4));
var unwrapScoped4 = (effect4) => flatten14(scoped4(effect4));
var unwrapScopedWith3 = (f2) => flatten14(scopedWith4((scope5) => f2(scope5)));
var updateService5 = dual(3, (self, tag3, f2) => pipe(self, mapInputContext5((context10) => pipe(context10, add2(tag3, f2(pipe(context10, unsafeGet3(tag3))))))));
var when5 = dual(2, (self, test2) => pipe(self, whenEffect2(sync4(test2))));
var whenCaseEffect = dual(2, (self, pf) => pipe(fromEffect7(self), flatMap19((a) => pipe(pf(a), getOrElse2(() => empty37)))));
var whenEffect2 = dual(2, (self, effect4) => pipe(fromEffect7(effect4), flatMap19((bool) => bool ? self : empty37)));
var zip14 = dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [a, a2])));
var zipFlatten2 = dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [...a, a2])));
var zipAll = dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_2, a2) => a2
}));
var zipAllSortedByKey = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_2, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match16({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed3([map7(leftChunk, ([k2, a]) => [k2, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match16({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed3([map7(rightChunk, ([k2, a2]) => [k2, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error2) => succeed8(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(merge11(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed8(succeed3([pipe(leftOption.value, map7(([k2, a]) => [k2, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed8(succeed3([pipe(rightOption.value, map7(([k2, a2]) => [k2, options.onOther(a2)])), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([pipe(state.rightChunk, map7(([k2, a2]) => [k2, options.onOther(a2)])), DrainRight])),
            onSome: (error2) => succeed8(fail4(some2(error2)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed3(merge11(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map7(state.leftChunk, ([k2, a]) => [k2, options.onSelf(a)]), DrainLeft])),
            onSome: (error2) => succeed8(fail4(some2(error2)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed3(merge11(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge11 = (leftChunk, rightChunk) => {
    const hasNext = (chunk4, index) => index < chunk4.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare2 = options.order(k1, k2);
      if (compare2 === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop3(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop3(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare2 < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipAllWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: (error2) => succeed8(fail4(error2)),
          onSuccess: (leftChunk) => succeed8(succeed3([map7(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: (error2) => succeed8(fail4(error2)),
          onSuccess: (rightChunk) => succeed8(succeed3([map7(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error2) => succeed8(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip17(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed8(succeed3([map7(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed8(succeed3([map7(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map7(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error2) => succeed8(fail4(some2(error2)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip17(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map7(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error2) => succeed8(fail4(some2(error2)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip17(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip17 = (leftChunk, rightChunk, f2) => {
    const [output, either8] = zipChunks(leftChunk, rightChunk, f2);
    switch (either8._tag) {
      case "Left": {
        if (isEmpty(either8.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either8.left)];
      }
      case "Right": {
        if (isEmpty(either8.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either8.right)];
      }
    }
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipLatest = dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestWith = dual(3, (left3, right3, f2) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap15((chunk4) => isEmpty(chunk4) ? pullNonEmpty(pull) : succeed8(chunk4)));
  return pipe(toPull2(left3), map25(pullNonEmpty), zip10(pipe(toPull2(right3), map25(pullNonEmpty))), flatMap15(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith11(join3(rightFiber), (l2, r) => [l2, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith11(join3(leftFiber), (l2, r) => [r, l2, false]))
  })), flatMap19(([l2, r, leftFirst]) => pipe(fromEffect7(make32([unsafeLast(l2), unsafeLast(r)])), flatMap19((latest) => pipe(fromChunk(leftFirst ? pipe(r, map7((a2) => f2(unsafeLast(l2), a2))) : pipe(l2, map7((a) => f2(a, unsafeLast(r))))), concat3(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => modify7(latest, ([_2, rightLatest]) => [pipe(leftChunk, map7((a) => f2(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
    onRight: (rightChunk) => modify7(latest, ([leftLatest, _2]) => [pipe(rightChunk, map7((a2) => f2(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
  })), flatMap19(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft9 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take3(right4.length)), left2(pipe(left4, take3(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop3(left4.length)))];
})));
var zipRight10 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take3(right4.length)))];
  }
  return [pipe(right4, take3(left4.length)), right2(pipe(right4, drop3(left4.length)))];
})));
var zipWith14 = dual(3, (left3, right3, f2) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f2))));
var zipWithChunks = dual(3, (self, that, f2) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error2) => succeed8(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip17(leftOption.value, rightOption.value)));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect4(pullLeft, {
          onFailure: (error2) => succeed8(fail4(error2)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip17(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect4(pullRight, {
          onFailure: (error2) => succeed8(fail4(error2)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip17(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip17 = (leftChunk, rightChunk) => {
    const [output, either8] = f2(leftChunk, rightChunk);
    switch (either8._tag) {
      case "Left": {
        if (isEmpty(either8.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either8.left)];
      }
      case "Right": {
        if (isEmpty(either8.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either8.right)];
      }
    }
  };
  return pipe(self, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self) => pipe(self, mapAccum4(0, (index, a) => [index + 1, [a, index]]));
var zipChunks = (left3, right3, f2) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take3(right3.length), zipWith5(right3, f2)), left2(pipe(left3, drop3(right3.length)))];
  }
  return [pipe(left3, zipWith5(pipe(right3, take3(left3.length)), f2)), right2(pipe(right3, drop3(left3.length)))];
};
var Do6 = succeed13({});
var bind8 = dual((args2) => typeof args2[0] !== "string", (self, tag3, f2, options) => flatMap19(self, (k2) => map31(f2(k2), (a) => ({
  ...k2,
  [tag3]: a
})), options));
var bindTo8 = bindTo(map31);
var let_8 = let_(map31);
var decodeText = dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend9(() => {
  const decoder2 = new TextDecoder(encoding);
  return map31(self, (s) => decoder2.decode(s));
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ConfigError.js
var InvalidData2 = InvalidData;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_2) => _2
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol2]() {
    return pipe(hash(RedactedSymbolKey), combine2(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol3](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make58 = (value6) => {
  const redacted2 = Object.create(proto12);
  redactedRegistry.set(redacted2, value6);
  return redacted2;
};
var value2 = (self) => {
  if (redactedRegistry.has(self)) {
    return redactedRegistry.get(self);
  } else {
    throw new Error("Unable to get redacted value");
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto12,
  [SecretTypeId]: SecretTypeId
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var map32 = dual(2, (self, f2) => mapOrFail(self, (a) => right2(f2(a))));
var mapAttempt2 = dual(2, (self, f2) => mapOrFail(self, (a) => {
  try {
    return right2(f2(a));
  } catch (error2) {
    return left2(InvalidData([], error2 instanceof Error ? error2.message : `${error2}`));
  }
}));
var mapOrFail = dual(2, (self, f2) => {
  const mapOrFail3 = Object.create(proto13);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self;
  mapOrFail3.mapOrFail = f2;
  return mapOrFail3;
});
var nested3 = dual(2, (self, name) => {
  const nested4 = Object.create(proto13);
  nested4._tag = OP_NESTED;
  nested4.name = name;
  nested4.config = self;
  return nested4;
});
var orElse12 = dual(2, (self, that) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend10(that);
  fallback.condition = constTrue;
  return fallback;
});
var orElseIf = dual(2, (self, options) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend10(options.orElse);
  fallback.condition = options.if;
  return fallback;
});
var primitive = (description, parse3) => {
  const primitive2 = Object.create(proto13);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse3;
  return primitive2;
};
var branded = dual(2, (nameOrConfig, constructor) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string5(nameOrConfig);
  return mapOrFail(config2, (a) => constructor.either(a).pipe(mapLeft((brandErrors) => InvalidData([], brandErrors.map((brandError) => brandError.message).join("\n")))));
});
var string5 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested3(config2, name);
};
var succeed14 = (value6) => {
  const constant3 = Object.create(proto13);
  constant3._tag = OP_CONSTANT;
  constant3.value = value6;
  constant3.parse = () => right2(value6);
  return constant3;
};
var suspend10 = (config2) => {
  const lazy = Object.create(proto13);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);
var validate2 = dual(2, (self, {
  message,
  validation
}) => mapOrFail(self, (a) => {
  if (validation(a)) {
    return right2(a);
  }
  return left2(InvalidData([], message));
}));
var withDefault = dual(2, (self, def) => orElseIf(self, {
  orElse: () => succeed14(def),
  if: isMissingDataOnly2
}));
var withDescription = dual(2, (self, description) => {
  const described = Object.create(proto13);
  described._tag = OP_DESCRIBED;
  described.config = self;
  described.description = description;
  return described;
});
var zip15 = dual(2, (self, that) => zipWith15(self, that, (a, b2) => [a, b2]));
var zipWith15 = dual(3, (self, that, f2) => {
  const zipWith16 = Object.create(proto13);
  zipWith16._tag = OP_ZIP_WITH;
  zipWith16.left = self;
  zipWith16.right = that;
  zipWith16.zip = f2;
  return zipWith16;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Config.js
var mapOrFail2 = mapOrFail;
var string6 = string5;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/DateTime.js
var isDateTime2 = isDateTime;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence5 = Equivalence3;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake12 = unsafeMake9;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZonedFromString2 = makeZonedFromString;
var now2 = now;
var setZone2 = setZone;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneMakeNamedEffect2 = zoneMakeNamedEffect;
var zoneMakeLocal2 = zoneMakeLocal;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var toDateUtc2 = toDateUtc;
var toEpochMillis2 = toEpochMillis;
var CurrentTimeZone = class extends Tag2("effect/DateTime/CurrentTimeZone")() {
};
var setZoneCurrent = (self) => map25(CurrentTimeZone, (zone) => setZone2(self, zone));
var withCurrentZone = dual(2, (effect4, zone) => provideService5(effect4, CurrentTimeZone, zone));
var withCurrentZoneOffset = dual(2, (effect4, offset) => provideService5(effect4, CurrentTimeZone, zoneMakeOffset2(offset)));
var withCurrentZoneNamed = dual(2, (effect4, zone) => provideServiceEffect3(effect4, CurrentTimeZone, zoneMakeNamedEffect2(zone)));
var nowInCurrentZone = flatMap15(now2, setZoneCurrent);
var formatIso2 = formatIso;
var formatIsoZoned2 = formatIsoZoned;
var layerCurrentZoneLocal = sync5(CurrentTimeZone, zoneMakeLocal2);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var EncodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = (input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var encoder = new TextEncoder();
var decoder = new TextDecoder();

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length4 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length4; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length4 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length4) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length4 = stripped.length;
  if (length4 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length4}`));
  }
  const index = stripped.indexOf("=");
  if (index !== -1 && (index < length4 - 2 || index === length4 - 2 && stripped[length4 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length4 / 4) - missingOctets);
    for (let i = 0, j2 = 0; i < length4; i += 4, j2 += 3) {
      const buffer3 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j2] = buffer3 >> 16;
      result[j2 + 1] = buffer3 >> 8 & 255;
      result[j2 + 2] = buffer3 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length4 = stripped.length;
  if (length4 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length4}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length4 % 4 === 2 ? `${stripped}==` : length4 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length4 = bytes.length / 2;
    const result = new Uint8Array(length4);
    for (let i = 0; i < length4; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b2 = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b2;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_2) => decoder.decode(_2));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_2) => decoder.decode(_2));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_2) => decoder.decode(_2));
var encodeUriComponent = (str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var decodeUriComponent = (str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var DecodeException2 = DecodeException;
var EncodeException2 = EncodeException;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId22 = TypeId20;
var Proto3 = {
  [TypeId22]: TypeId22,
  get withRequirements() {
    const self = this;
    return contextWith2((context10) => makeProto(self.steps.map((step3) => ({
      ...step3,
      provide: isLayer2(step3.provide) ? provide3(step3.provide, succeedContext2(context10)) : step3.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self = Object.create(Proto3);
  self.steps = steps;
  return self;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberHandle.js
var TypeId23 = Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId23);
var Proto4 = {
  [TypeId23]: TypeId23,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var internalFiberIdId = -1;
var internalFiberId = make15(internalFiberIdId, 0);
var isInternalInterruption = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_2, fiberId3) => has4(ids2(fiberId3), internalFiberIdId),
  sequentialCase: (_2, left3, right3) => left3 || right3,
  parallelCase: (_2, left3, right3) => left3 || right3
});
var unsafeSet3 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self.state.fiber !== void 0) {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
    self.state.fiber = void 0;
  }
  self.state.fiber = fiber;
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = void 0;
    }
    if (isFailure(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set10 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId3) => sync4(() => unsafeSet3(self, fiber, {
  interruptAs: fiberId3,
  onlyIfMissing: options?.onlyIfMissing,
  propagateInterruption: options?.propagateInterruption
}))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberMap.js
var TypeId24 = Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId24);
var Proto5 = {
  [TypeId24]: TypeId24,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var internalFiberIdId2 = -1;
var internalFiberId2 = make15(internalFiberIdId2, 0);
var isInternalInterruption2 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_2, fiberId3) => has4(ids2(fiberId3), internalFiberIdId2),
  sequentialCase: (_2, left3, right3) => left3 || right3,
  parallelCase: (_2, left3, right3) => left3 || right3
});
var unsafeSet4 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
    return;
  }
  const previous2 = get9(self.state.backing, key);
  if (previous2._tag === "Some") {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
  }
  set5(self.state.backing, key, fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current2 = get9(self.state.backing, key);
    if (isSome2(current2) && fiber === current2.value) {
      remove8(self.state.backing, key);
    }
    if (isFailure(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption2(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set11 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => fiberIdWith2((fiberId3) => sync4(() => unsafeSet4(self, key, fiber, {
  ...options,
  interruptAs: fiberId3
}))));
var unsafeGet10 = dual(2, (self, key) => self.state._tag === "Closed" ? none2() : get9(self.state.backing, key));
var get18 = dual(2, (self, key) => suspend4(() => unsafeGet10(self, key)));
var unsafeHas = dual(2, (self, key) => self.state._tag === "Closed" ? false : has6(self.state.backing, key));
var has10 = dual(2, (self, key) => sync4(() => unsafeHas(self, key)));
var remove11 = dual(2, (self, key) => withFiberRuntime2((removeFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  const fiber = get9(self.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine5(removeFiber.id(), internalFiberId2));
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/FiberSet.js
var TypeId25 = Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId25);
var Proto6 = {
  [TypeId25]: TypeId25,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var internalFiberIdId3 = -1;
var internalFiberId3 = make15(internalFiberIdId3, 0);
var isInternalInterruption3 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_2, fiberId3) => has4(ids2(fiberId3), internalFiberIdId3),
  sequentialCase: (_2, left3, right3) => left3 || right3,
  parallelCase: (_2, left3, right3) => left3 || right3
});
var unsafeAdd = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId3));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption3(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var add7 = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId3) => sync4(() => unsafeAdd(self, fiber, {
  ...options,
  interruptAs: fiberId3
}))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _K: (_2) => _2,
  /* c8 ignore next */
  _V: (_2) => _2
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = dual((args2) => isGroupBy(args2[0]), (self, f2, options) => flatMap19(self.grouped, ([key, queue]) => f2(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var filter15 = dual(2, (self, predicate) => make59(pipe(self.grouped, filterEffect((tuple4) => {
  if (predicate(tuple4[0])) {
    return pipe(succeed8(tuple4), as6(true));
  }
  return pipe(shutdown4(tuple4[1]), as6(false));
}))));
var first2 = dual(2, (self, n) => make59(pipe(zipWithIndex(self.grouped), filterEffect((tuple4) => {
  const index = tuple4[1];
  const queue = tuple4[0][1];
  if (index < n) {
    return pipe(succeed8(tuple4), as6(true));
  }
  return pipe(shutdown4(queue), as6(false));
}), map31((tuple4) => tuple4[0]))));
var make59 = (grouped2) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped2
});
var groupBy3 = dual((args2) => isStream(args2[0]), (self, f2, options) => make59(unwrapScoped4(gen3(function* () {
  const decider = yield* make21();
  const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make32(/* @__PURE__ */ new Map());
  const add10 = yield* pipe(mapEffectSequential(self, f2), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value6]) => flatMap15(_await(decider), (f3) => f3(key, value6)), (exit4) => offer3(output, exit4)));
  yield* succeed2(decider, (key, _2) => pipe(get12(ref), map25((map40) => fromNullable2(map40.get(key))), flatMap15(match2({
    onNone: () => flatMap15(add10, ([index, queue]) => zipRight6(update4(ref, (map40) => map40.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map15((tuple4) => of2(tuple4[1])))))])), as6((n) => n === index)))),
    onSome: (index) => succeed8((n) => n === index)
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = dual((args2) => typeof args2[0] !== "function", (self, f2, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self, options.key, {
      bufferSize: options.bufferSize
    }), (_2, s) => mapEffectSequential(s, f2));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self, f2), (n) => options?.unordered ? flatMap19(self, (a) => fromEffect7(f2(a)), {
    concurrency: n
  }) : mapEffectPar(self, n, f2));
});
var bindEffect = dual((args2) => typeof args2[0] !== "string", (self, tag3, f2, options) => mapEffectOptions(self, (k2) => map25(f2(k2), (a) => ({
  ...k2,
  [tag3]: a
})), options));
var mapDequeue = (dequeue, f2) => new MapDequeue(dequeue, f2);
var MapDequeue = class extends Class2 {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_2) => _2
  };
  constructor(dequeue, f2) {
    super();
    this.dequeue = dequeue;
    this.f = f2;
  }
  capacity() {
    return capacity4(this.dequeue);
  }
  get size() {
    return size14(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown3(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown3(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull3(this.dequeue);
  }
  get isEmpty() {
    return isEmpty12(this.dequeue);
  }
  get take() {
    return pipe(take6(this.dequeue), map25((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map25(map7((a) => this.f(a))));
  }
  takeUpTo(max11) {
    return pipe(takeUpTo2(this.dequeue, max11), map25(map7((a) => this.f(a))));
  }
  takeBetween(min9, max11) {
    return pipe(takeBetween2(this.dequeue, min9, max11), map25(map7((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map25(map7((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map25(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = dual((args2) => typeof args2[0] !== "function", (self, f2, options) => {
  const loop3 = (map40, outerQueue) => readWithCause({
    onInput: (input) => flatMap16(fromEffect4(forEach16(groupByIterable(input, f2), ([key, values7]) => {
      const innerQueue = map40.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded5(options?.bufferSize ?? 16), flatMap15((innerQueue2) => pipe(sync4(() => {
          map40.set(key, innerQueue2);
        }), zipRight6(offer3(outerQueue, of5([key, innerQueue2]))), zipRight6(pipe(offer3(innerQueue2, chunk2(values7)), catchSomeCause2((cause2) => isInterruptedOnly2(cause2) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk2(values7)), (cause2) => isInterruptedOnly2(cause2) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map40, outerQueue)),
    onFailure: (cause2) => fromEffect4(offer3(outerQueue, failCause10(cause2))),
    onDone: () => fromEffect4(pipe(forEach16(map40.entries(), ([_2, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause2) => isInterruptedOnly2(cause2) ? some2(_void) : none2())), {
      discard: true
    }), zipRight6(offer3(outerQueue, end4))))
  });
  return make59(unwrapScopedWith3((scope5) => gen3(function* () {
    const map40 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded5();
    yield* addFinalizer2(scope5, shutdown4(queue));
    return yield* toChannel2(self).pipe(pipeTo(loop3(map40, queue)), drain, runIn(scope5), forkIn3(scope5), as6(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = dual(2, (iterable, f2) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map40 = /* @__PURE__ */ new Map();
  let next5;
  while ((next5 = iterator.next()) && !next5.done) {
    const value6 = next5.value;
    const key = f2(value6);
    if (map40.has(key)) {
      const innerBuilder = map40.get(key);
      innerBuilder.push(value6);
    } else {
      const innerBuilder = [value6];
      builder.push([key, innerBuilder]);
      map40.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId2 = Symbol.for("effect/Schema/ParseErrorTypeId");
var ParseError2 = class extends TaggedError2("ParseError") {
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId2] = ParseErrorTypeId2;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError2({
  issue
});
var succeed16 = right2;
var fail17 = left2;
var _try = try_;
var fromOption4 = fromOption2;
var isEither4 = isEither2;
var flatMap20 = dual(2, (self, f2) => {
  return isEither4(self) ? match(self, {
    onLeft: left2,
    onRight: f2
  }) : flatMap15(self, f2);
});
var map33 = dual(2, (self, f2) => {
  return isEither4(self) ? map(self, f2) : map25(self, f2);
});
var mapError9 = dual(2, (self, f2) => {
  return isEither4(self) ? mapLeft(self, f2) : mapError4(self, f2);
});
var mapBoth9 = dual(2, (self, options) => {
  return isEither4(self) ? mapBoth(self, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth5(self, options);
});
var orElse13 = dual(2, (self, f2) => {
  return isEither4(self) ? match(self, {
    onLeft: f2,
    onRight: right2
  }) : catchAll4(self, f2);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options;
  }
  if (options === void 0) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getOption3 = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknownOption = (schema, options) => getOption3(schema.ast, true, options);
var decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknownOption = (schema, options) => getOption3(schema.ast, false, options);
var encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var validateOption = (schema, options) => getOption3(typeAST(schema.ast), true, options);
var validateEither = (schema, options) => getEither(typeAST(schema.ast), true, options);
var validate3 = (schema, options) => getEffect(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var asserts = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
};
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var decodeMemoMap = globalValue(Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = globalValue(Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw = go2(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse13(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined2(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined2(getBatchingAnnotation(ast));
var go2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap20(orElse13(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap20(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform6 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap20(mapError9(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap20(mapError9(transform6(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError9(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse3(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_2, value6]) => value6 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_2, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap15(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail] = rest;
          for (; i < len - tail.length; i++) {
            const te = head8(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap15(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j2 = 0; j2 < tail.length; j2++) {
            i += j2;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j2](input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap15(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy2(es),
              output: copy2(output)
            };
            return flatMap15(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is3) => [goMemo(is3.parameter, isDecoding), goMemo(is3.type, isDecoding), is3.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is3) => is3.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither4(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither4(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap15(either4(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type2 = indexSignature[1];
          const keys10 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys10) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type2(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap15(either4(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys10 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys10.indexOf(name) === -1) {
                keys10.push(name);
              }
            }
            const out = {};
            for (const key of keys10) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy2(es),
              output: Object.assign({}, output)
            };
            return flatMap15(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map40 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map40.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map40.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap15(either4(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy2(es)
            };
            return flatMap15(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get34 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options) => get34()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type2 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type2) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type2]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element2 = ast.elements[i];
        const type2 = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
        if (isLiteral(type2) && !element2.isOptional) {
          out.push([i, type2]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys10 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags2 = getLiterals(member, isDecoding);
    if (tags2.length > 0) {
      candidates.push(member);
      for (let j2 = 0; j2 < tags2.length; j2++) {
        const [key, literal2] = tags2[j2];
        const hash4 = String(literal2.literal);
        keys10[key] = keys10[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys10[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash4)) {
          if (j2 < tags2.length - 1) {
            continue;
          }
          buckets[hash4].push(member);
          keys10[key].literals.push(literal2);
          keys10[key].candidates.push(member);
        } else {
          buckets[hash4] = [member];
          keys10[key].literals.push(literal2);
          keys10[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys10,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess(exit4)) {
      return right2(exit4.value);
    }
    const cause2 = exit4.cause;
    if (isFailType2(cause2)) {
      return left2(cause2.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause2)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b2]) => a > b2 ? 1 : a < b2 ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f2 = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map33(out, f2);
        }
        return out;
      };
  }
};
var makeTree = (value6, forest = []) => ({
  value: value6,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map33(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => TreeFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => TreeFormatter.formatIssueSync(error2.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "" : "") + " " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some2(issue.ast) : none2();
var Either_void = right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap2(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union13 = messageAnnotation(issue);
    if (isString(union13)) {
      return right2({
        message: union13,
        override: false
      });
    }
    if (isEffect2(union13)) {
      return map25(union13, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union13.message)) {
      return right2({
        message: union13.message,
        override: union13.override
      });
    }
    return map25(union13.message, (message) => ({
      message,
      override: union13.override
    }));
  }
}));
var createParseIssueGuard = (tag3) => (issue) => issue._tag === tag3;
var isComposite2 = createParseIssueGuard("Composite");
var isRefinement2 = createParseIssueGuard("Refinement");
var isTransformation2 = createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap20(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap2(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined2);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse2(() => getTitleAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), orElse2(() => getIdentifierAnnotation(ast)), getOrElse2(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map33(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map33(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map33(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map33(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map33(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map33(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map33(forEach16(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map33(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var makeArrayFormatterIssue = (_tag, path, message) => ({
  _tag,
  path,
  message
});
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, void 0, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => ArrayFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => ArrayFormatter.formatIssueSync(error2.issue)
};
var getArrayFormatterIssues = (issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map33(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map33(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path.concat(issue.path));
    case "Composite":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty(issue.issues) ? map33(forEach16(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path)), flatten3) : getArrayFormatterIssues(issue.issues, void 0, path);
      });
    case "Refinement":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path);
      });
    case "Transformation":
      return flatMap20(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path);
      });
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = Symbol.for("effect/Pool");
var poolVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var get19 = (self) => self.get;
var invalidate = dual(2, (self, item) => self.invalidate(item));
var PoolImpl = class extends Class2 {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set();
  available = /* @__PURE__ */ new Set();
  availableLatch = unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set();
  waiters = 0;
  constructor(scope5, acquire3, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope5;
    this.acquire = acquire3;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = acquireUseRelease(scopeMake2(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit, flatMap11((exit4) => {
    const item = {
      exit: exit4,
      finalizer: catchAllCause(scope5.close(exit4), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as3(exit4._tag === "Success" ? this.strategy.onAcquire(item) : zipRight2(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope5, exit4) => exit4._tag === "Failure" ? scope5.close(exit4) : void_3);
  get currentUsage() {
    let count5 = this.waiters;
    for (const item of this.items) {
      count5 += item.refCount;
    }
    return count5;
  }
  get targetSize() {
    if (this.isShuttingDown) return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_3;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap11(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect2(toAcquire, {
      concurrency: toAcquire
    }), zipLeft2(this.availableLatch.open), flatMap11((items) => items.some((_2) => _2.exit._tag === "Failure") ? void_3 : this.resizeLoop));
  });
  resizeSemaphore = unsafeMakeSemaphore(1);
  resize = this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight2(scopeTag), flatMap11((scope5) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self = this;
      return flatMap11(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn2(interruptible2(this.resize), this.scope)), function loop3() {
        if (self.isShuttingDown) {
          return interrupt2;
        } else if (self.available.size > 0) {
          return succeed(unsafeHead(self.available));
        }
        self.availableLatch.unsafeClose();
        return flatMap11(self.availableLatch.await, loop3);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring2(sync(() => this.waiters--)), tap2((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope5.addFinalizer(() => zipRight2(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = flatMap11(suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_2) => _2.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_3;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_3;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight2(poolItem.finalizer, forkIn2(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_3;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      this.isShuttingDown = true;
      const size23 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size23);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft2(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight2(this.semaphore.releaseAll), zipRight2(this.availableLatch.open), zipRight2(semaphore.take(size23)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var reportUnhandledError = (cause2) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause2, unhandledLogLevel);
  }
  return void_3;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/keyedPool.js
var KeyedPoolSymbolKey = "effect/KeyedPool";
var KeyedPoolTypeId = Symbol.for(KeyedPoolSymbolKey);
var KeyedPoolMapValueSymbol = Symbol.for("effect/KeyedPool/MapValue");
var keyedPoolVariance = {
  /* c8 ignore next */
  _K: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var KeyedPoolImpl = class {
  getOrCreatePool;
  activePools;
  [KeyedPoolTypeId] = keyedPoolVariance;
  constructor(getOrCreatePool, activePools) {
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return flatMap11(this.getOrCreatePool(key), get19);
  }
  invalidate(item) {
    return flatMap11(this.activePools, forEachSequentialDiscard((pool) => pool.invalidate(item)));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Complete = class {
  pool;
  _tag = "Complete";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(pool) {
    this.pool = pool;
  }
  [symbol2]() {
    return pipe(string2("effect/KeyedPool/Complete"), combine2(hash(this.pool)), cached(this));
  }
  [symbol3](u) {
    return isComplete(u) && equals(this.pool, u.pool);
  }
};
var isComplete = (u) => isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
var Pending = class {
  deferred;
  _tag = "Pending";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(deferred) {
    this.deferred = deferred;
  }
  [symbol2]() {
    return pipe(string2("effect/KeyedPool/Pending"), combine2(hash(this.deferred)), cached(this));
  }
  [symbol3](u) {
    return isPending(u) && equals(this.deferred, u.deferred);
  }
};
var isPending = (u) => isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
var get20 = dual(2, (self, key) => self.get(key));
var invalidate2 = dual(2, (self, item) => self.invalidate(item));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/rcMap.js
var TypeId26 = Symbol.for("effect/RcMap");
var variance10 = {
  _K: identity,
  _A: identity,
  _E: identity
};
var RcMapImpl = class {
  lookup;
  context;
  scope;
  idleTimeToLive;
  capacity;
  [TypeId26];
  state = {
    _tag: "Open",
    map: empty22()
  };
  semaphore = unsafeMakeSemaphore(1);
  constructor(lookup, context10, scope5, idleTimeToLive, capacity7) {
    this.lookup = lookup;
    this.context = context10;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.capacity = capacity7;
    this[TypeId26] = variance10;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make61 = (options) => withFiberRuntime((fiber) => {
  const context10 = fiber.getFiberRef(currentContext);
  const scope5 = get4(context10, scopeTag);
  const self = new RcMapImpl(options.lookup, context10, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0, Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0));
  return as3(scope5.addFinalizer(() => suspend(() => {
    if (self.state._tag === "Closed") {
      return void_3;
    }
    const map40 = self.state.map;
    self.state = {
      _tag: "Closed"
    };
    return forEachSequentialDiscard(map40, ([, entry]) => scopeClose(entry.scope, exitVoid)).pipe(tap2(() => {
      clear(map40);
    }), self.semaphore.withPermits(1));
  })), self);
});
var get21 = dual(2, (self_, key) => {
  const self = self_;
  return uninterruptibleMask((restore) => getImpl(self, key, restore));
});
var getImpl = fnUntraced(function* (self, key, restore) {
  if (self.state._tag === "Closed") {
    return yield* interrupt2;
  }
  const state = self.state;
  const o = get9(state.map, key);
  let entry;
  if (o._tag === "Some") {
    entry = o.value;
    entry.refCount++;
  } else if (Number.isFinite(self.capacity) && size6(self.state.map) >= self.capacity) {
    return yield* fail2(new ExceededCapacityException(`RcMap attempted to exceed capacity of ${self.capacity}`));
  } else {
    entry = yield* self.semaphore.withPermits(1)(acquire(self, key, restore));
  }
  const scope5 = yield* scopeTag;
  yield* scope5.addFinalizer(() => entry.finalizer);
  return yield* restore(deferredAwait(entry.deferred));
});
var acquire = fnUntraced(function* (self, key, restore) {
  const scope5 = yield* scopeMake2();
  const deferred = yield* deferredMake();
  const acquire3 = self.lookup(key);
  const contextMap = new Map(self.context.unsafeMap);
  yield* restore(mapInputContext(acquire3, (inputContext) => {
    inputContext.unsafeMap.forEach((value6, key2) => {
      contextMap.set(key2, value6);
    });
    contextMap.set(scopeTag.key, scope5);
    return unsafeMake(contextMap);
  })).pipe(exit, flatMap11((exit4) => deferredDone(deferred, exit4)), forkIn2(scope5));
  const entry = {
    deferred,
    scope: scope5,
    finalizer: void 0,
    fiber: void 0,
    expiresAt: 0,
    refCount: 1
  };
  entry.finalizer = release(self, key, entry);
  if (self.state._tag === "Open") {
    set5(self.state.map, key, entry);
  }
  return entry;
});
var release = (self, key, entry) => clockWith3((clock3) => {
  entry.refCount--;
  if (entry.refCount > 0) {
    return void_3;
  } else if (self.state._tag === "Closed" || !has6(self.state.map, key) || self.idleTimeToLive === void 0) {
    if (self.state._tag === "Open") {
      remove8(self.state.map, key);
    }
    return scopeClose(entry.scope, exitVoid);
  }
  if (!isFinite(self.idleTimeToLive)) {
    return void_3;
  }
  entry.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  if (entry.fiber) return void_3;
  return interruptibleMask(function loop3(restore) {
    const now3 = clock3.unsafeCurrentTimeMillis();
    const remaining = entry.expiresAt - now3;
    if (remaining <= 0) {
      if (self.state._tag === "Closed" || entry.refCount > 0) return void_3;
      remove8(self.state.map, key);
      return restore(scopeClose(entry.scope, exitVoid));
    }
    return flatMap11(clock3.sleep(millis(remaining)), () => loop3(restore));
  }).pipe(ensuring2(sync(() => {
    entry.fiber = void 0;
  })), forkIn2(self.scope), tap2((fiber) => {
    entry.fiber = fiber;
  }), self.semaphore.withPermits(1));
});
var invalidate3 = dual(2, fnUntraced(function* (self_, key) {
  const self = self_;
  if (self.state._tag === "Closed") return;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return;
  const entry = o.value;
  remove8(self.state.map, key);
  if (entry.refCount > 0) return;
  yield* scopeClose(entry.scope, exitVoid);
  if (entry.fiber) yield* interruptFiber(entry.fiber);
}));
var has11 = dual(2, (self_, key) => {
  const self = self_;
  return sync(() => {
    if (self.state._tag === "Closed") return false;
    return has6(self.state.map, key);
  });
});
var touch = dual(2, (self_, key) => clockWith3((clock3) => {
  const self = self_;
  if (!self.idleTimeToLive || self.state._tag === "Closed") return void_3;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return void_3;
  o.value.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  return void_3;
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/RcMap.js
var make62 = make61;
var get22 = get21;
var invalidate4 = invalidate3;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/LayerMap.js
var TypeId27 = Symbol.for("effect/LayerMap");
var make63 = fnUntraced2(function* (lookup, options) {
  const context10 = yield* context4();
  const memoMap = context10.unsafeMap.has(CurrentMemoMap2.key) ? get4(context10, CurrentMemoMap2) : yield* makeMemoMap2;
  const rcMap = yield* make62({
    lookup: (key) => scopeWith2((scope5) => diffFiberRefs2(buildWithMemoMap2(lookup(key), memoMap, scope5))).pipe(map25(([patch13, context11]) => ({
      layer: scopedContext2(withFiberRuntime((fiber) => {
        const scope5 = unsafeGet3(fiber.currentContext, Scope);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = patch10(patch13, fiber.id(), oldRefs);
        const revert = diff9(newRefs, oldRefs);
        fiber.setFiberRefs(newRefs);
        return as6(addFinalizerExit(scope5, () => {
          fiber.setFiberRefs(patch10(revert, fiber.id(), fiber.getFiberRefs()));
          return _void;
        }), context11);
      })),
      runtimeEffect: withFiberRuntime2((fiber) => {
        const fiberRefs3 = patch10(patch13, fiber.id(), fiber.getFiberRefs());
        return succeed8(make51({
          context: context11,
          fiberRefs: fiberRefs3,
          runtimeFlags: defaultRuntime2.runtimeFlags
        }));
      })
    }))),
    idleTimeToLive: options?.idleTimeToLive
  });
  if (options?.preloadKeys) {
    for (const key of options.preloadKeys) {
      yield* get22(rcMap, key);
    }
  }
  return identity({
    [TypeId27]: TypeId27,
    rcMap,
    get: (key) => unwrapScoped2(map25(get22(rcMap, key), ({
      layer
    }) => layer)),
    runtime: (key) => flatMap15(get22(rcMap, key), ({
      runtimeEffect
    }) => runtimeEffect),
    invalidate: (key) => invalidate4(rcMap, key)
  });
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/logger-circular.js
var test = dual(2, (self, input) => self.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty32,
  context: empty25(),
  spans: empty11(),
  annotations: empty10(),
  date: /* @__PURE__ */ new Date()
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Logger.js
var replace4 = replaceLogger;
var json2 = replace4(defaultLogger, jsonLogger2);
var logFmt = replace4(defaultLogger, logFmtLogger);
var pretty4 = replace4(defaultLogger, prettyLogger2);
var structured = replace4(defaultLogger, structuredLogger2);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/mailbox.js
var TypeId28 = Symbol.for("effect/Mailbox");
var ReadonlyTypeId = Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty38 = empty6();
var exitEmpty = exitSucceed(empty38);
var exitFalse = exitSucceed(false);
var exitTrue = exitSucceed(true);
var constDone = [empty38, true];
var MailboxImpl = class extends Class2 {
  scheduler;
  capacity;
  strategy;
  [TypeId28] = TypeId28;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = empty6();
  constructor(scheduler2, capacity7, strategy) {
    super();
    this.scheduler = scheduler2;
    this.capacity = capacity7;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll3(fromIterable2(messages)), takeRight2(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll3(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error2) {
    return this.done(exitFail(error2));
  }
  failCause(cause2) {
    return this.done(exitFailCause(cause2));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty38;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = this.done(exitVoid);
  clear = suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty38);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight2(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty38, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else {
        return zipRight2(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException3()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop3(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop3(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = suspend(() => this.unsafeTake() ?? zipRight2(this.awaitTake, this.take));
  await = asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size23 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size23);
  }
  size = sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll3(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty38;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty38;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make64 = (capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend")));
var into = dual(2, (effect4, self) => uninterruptibleMask((restore) => matchCauseEffect(restore(effect4), {
  onFailure: (cause2) => self.failCause(cause2),
  onSuccess: (_2) => self.end
})));
var fromStream = dual((args2) => isStream(args2[0]), (self, options) => tap2(acquireRelease(make64(options), (mailbox) => mailbox.shutdown), (mailbox) => {
  const writer = readWithCause({
    onInput: (input) => flatMap16(mailbox.offerAll(input), () => writer),
    onFailure: (cause2) => mailbox.failCause(cause2),
    onDone: () => mailbox.end
  });
  return scopeWith((scope5) => toChannel2(self).pipe(pipeTo(writer), runIn(scope5), forkIn2(scope5)));
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/managedRuntime.js
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId17]: TypeId17,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/matcher.js
var TypeId29 = Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId29]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId29]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value6) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value6;
  return matcher;
}
var makeWhen = (guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
});
var valueTags = dual(2, (input, fields) => {
  const match28 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match28(input);
});
var discriminator = (field) => (...pattern2) => {
  const f2 = pattern2[pattern2.length - 1];
  const values7 = pattern2.slice(0, -1);
  const pred = values7.length === 1 ? (_2) => _2[field] === values7[0] : (_2) => values7.includes(_2[field]);
  return (self) => self.add(makeWhen(pred, f2));
};
var discriminatorStartsWith = (field) => (pattern2, f2) => {
  const pred = (_2) => typeof _2[field] === "string" && _2[field].startsWith(pattern2);
  return (self) => self.add(makeWhen(pred, f2));
};
var discriminators = (field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self) => self.add(predicate);
};
var discriminatorsExhaustive = (field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
};
var tag = discriminator("_tag");
var tagStartsWith = discriminatorStartsWith("_tag");
var tags = discriminators("_tag");
var tagsExhaustive = discriminatorsExhaustive("_tag");
var either6 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
};
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = (self) => {
  const toEither = either6(self);
  if (isEither2(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Match.js
var SafeRefinementId = Symbol.for("effect/SafeRefinement");
var Fail2 = Symbol.for("effect/Fail");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/metric/polling.js
var MetricPollingSymbolKey = "effect/MetricPolling";
var MetricPollingTypeId = Symbol.for(MetricPollingSymbolKey);
var launch2 = dual(2, (self, schedule2) => pipe(pollAndUpdate(self), zipRight2(value(self.metric)), scheduleForked(schedule2)));
var pollAndUpdate = (self) => flatMap11(self.poll, (value6) => update5(self.metric, value6));
var retry6 = dual(2, (self, policy) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: self.metric,
  poll: retry_Effect(self.poll, policy)
}));
var zip16 = dual(2, (self, that) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: pipe(self.metric, zip9(that.metric)),
  poll: zip5(self.poll, that.poll)
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/MutableHashSet.js
var TypeId30 = Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId30]: TypeId30,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_2]) => _2)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var add8 = dual(2, (self, key) => (set5(self.keyMap, key, true), self));
var has12 = dual(2, (self, key) => has6(self.keyMap, key));
var remove12 = dual(2, (self, key) => (remove8(self.keyMap, key), self));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Ordering.js
var match26 = dual(2, (self, {
  onEqual,
  onGreaterThan,
  onLessThan
}) => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan());
var combine16 = dual(2, (self, that) => self !== 0 ? self : that);
var combineMany3 = dual(2, (self, collection) => {
  let ordering = self;
  if (ordering !== 0) {
    return ordering;
  }
  for (ordering of collection) {
    if (ordering !== 0) {
      return ordering;
    }
  }
  return ordering;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Pretty.js
var getPrettyAnnotation = getAnnotation(PrettyAnnotationId);
var getMatcher = (defaultPretty) => (ast) => match2(getPrettyAnnotation(ast), {
  onNone: () => defaultPretty,
  onSome: (handler) => handler()
});
var toString = getMatcher((a) => String(a));
var stringify2 = getMatcher((a) => JSON.stringify(a));
var formatUnknown2 = getMatcher(formatUnknown);
var match27 = {
  "Declaration": (ast, go4, path) => {
    const annotation = getPrettyAnnotation(ast);
    if (isSome2(annotation)) {
      return annotation.value(...ast.typeParameters.map((tp) => go4(tp, path)));
    }
    throw new Error(getPrettyMissingAnnotationErrorMessage(path, ast));
  },
  "VoidKeyword": getMatcher(() => "void(0)"),
  "NeverKeyword": getMatcher(() => {
    throw new Error(getPrettyNeverErrorMessage);
  }),
  "Literal": getMatcher((literal2) => typeof literal2 === "bigint" ? `${String(literal2)}n` : JSON.stringify(literal2)),
  "SymbolKeyword": toString,
  "UniqueSymbol": toString,
  "TemplateLiteral": stringify2,
  "UndefinedKeyword": toString,
  "UnknownKeyword": formatUnknown2,
  "AnyKeyword": formatUnknown2,
  "ObjectKeyword": formatUnknown2,
  "StringKeyword": stringify2,
  "NumberKeyword": toString,
  "BooleanKeyword": toString,
  "BigIntKeyword": getMatcher((a) => `${String(a)}n`),
  "Enums": stringify2,
  "TupleType": (ast, go4, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const elements = ast.elements.map((e, i) => go4(e.type, path.concat(i)));
    const rest = ast.rest.map((annotatedAST) => go4(annotatedAST.type, path));
    return (input) => {
      const output = [];
      let i = 0;
      for (; i < elements.length; i++) {
        if (input.length < i + 1) {
          if (ast.elements[i].isOptional) {
            continue;
          }
        } else {
          output.push(elements[i](input[i]));
        }
      }
      if (isNonEmptyReadonlyArray(rest)) {
        const [head8, ...tail] = rest;
        for (; i < input.length - tail.length; i++) {
          output.push(head8(input[i]));
        }
        for (let j2 = 0; j2 < tail.length; j2++) {
          i += j2;
          output.push(tail[j2](input[i]));
        }
      }
      return "[" + output.join(", ") + "]";
    };
  },
  "TypeLiteral": (ast, go4, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go4(ps.type, path.concat(ps.name)));
    const indexSignatureTypes = ast.indexSignatures.map((is3) => go4(is3.type, path));
    const expectedKeys = {};
    for (let i = 0; i < propertySignaturesTypes.length; i++) {
      expectedKeys[ast.propertySignatures[i].name] = null;
    }
    return (input) => {
      const output = [];
      for (let i = 0; i < propertySignaturesTypes.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {
          continue;
        }
        output.push(`${formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`);
      }
      if (indexSignatureTypes.length > 0) {
        for (let i = 0; i < indexSignatureTypes.length; i++) {
          const type2 = indexSignatureTypes[i];
          const keys10 = getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);
          for (const key of keys10) {
            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {
              continue;
            }
            output.push(`${formatPropertyKey(key)}: ${type2(input[key])}`);
          }
        }
      }
      return isNonEmptyReadonlyArray(output) ? "{ " + output.join(", ") + " }" : "{}";
    };
  },
  "Union": (ast, go4, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const types = ast.types.map((ast2) => [is({
      ast: ast2
    }), go4(ast2, path)]);
    return (a) => {
      const index = types.findIndex(([is3]) => is3(a));
      if (index === -1) {
        throw new Error(getPrettyNoMatchingSchemaErrorMessage(a, path, ast));
      }
      return types[index][1](a);
    };
  },
  "Suspend": (ast, go4, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => {
        const get34 = memoizeThunk(() => go4(ast.f(), path));
        return (a) => get34()(a);
      },
      onSome: (handler) => handler()
    });
  },
  "Refinement": (ast, go4, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go4(ast.from, path),
      onSome: (handler) => handler()
    });
  },
  "Transformation": (ast, go4, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go4(ast.to, path),
      onSome: (handler) => handler()
    });
  }
};
var compile = getCompiler(match27);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/PrimaryKey.js
var symbol4 = Symbol.for("effect/PrimaryKey");

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/rateLimiter.js
var currentCost = globalValue(Symbol.for("effect/RateLimiter/currentCost"), () => unsafeMake10(1));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Redacted.js
var isRedacted2 = isRedacted;
var make70 = make58;
var value4 = value2;
var getEquivalence7 = (isEquivalent) => make((x, y2) => isEquivalent(value4(x), value4(y2)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto14 = {
  ...CommitPrototype,
  commit() {
    return get23(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var get23 = (self) => map14(get11(self.ref), (tuple4) => tuple4[1]);
var set12 = dual(2, (self, acquire3) => flatten7(modifyEffect(self.ref, ([oldScope, value6]) => uninterruptible(scopeClose(oldScope, exitVoid).pipe(zipRight2(scopeMake2()), flatMap11((newScope) => exit(scopeExtend(acquire3, newScope)).pipe(flatMap11((exit4) => exitMatch(exit4, {
  onFailure: (cause2) => scopeClose(newScope, exitVoid).pipe(as3([failCause(cause2), [oldScope, value6]])),
  onSuccess: (value7) => succeed([void_3, [newScope, value7]])
})))))))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/reloadable.js
var ReloadableSymbolKey = "effect/Reloadable";
var ReloadableTypeId = Symbol.for(ReloadableSymbolKey);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/dataSource.js
var make71 = (runAll) => new RequestResolverImpl((requests) => runAll(requests.map((_2) => _2.map((_3) => _3.request))));
var around = dual(3, (self, before2, after3) => new RequestResolverImpl((requests) => acquireUseRelease(before2, () => self.runAll(requests), after3), make7("Around", self, before2, after3)));
var aroundRequests = dual(3, (self, before2, after3) => new RequestResolverImpl((requests) => {
  const flatRequests = requests.flatMap((chunk4) => chunk4.map((entry) => entry.request));
  return acquireUseRelease(before2(flatRequests), () => self.runAll(requests), (a2) => after3(flatRequests, a2));
}, make7("AroundRequests", self, before2, after3)));
var batchN = dual(2, (self, n) => new RequestResolverImpl((requests) => {
  return n < 1 ? die2(new IllegalArgumentException2("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(map7(reduce3(requests, empty6(), (acc, chunk4) => appendAll3(acc, chunksOf3(unsafeFromArray(chunk4), n))), (chunk4) => Array.from(chunk4))));
}, make7("BatchN", self, n)));
var mapInputContext6 = dual(2, (self, f2) => new RequestResolverImpl((requests) => mapInputContext(self.runAll(requests), (context10) => f2(context10)), make7("MapInputContext", self, f2)));
var eitherWith2 = dual(3, (self, that, f2) => new RequestResolverImpl((batch) => forEachSequential(batch, (requests) => {
  const [as12, bs] = pipe(requests, partitionMap3(f2));
  return zipWithOptions(self.runAll(Array.of(as12)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
}), make7("EitherWith", self, that, f2)));
var never8 = make71(() => never4).identified("Never");
var provideContext8 = dual(2, (self, context10) => mapInputContext6(self, (_2) => context10).identified("ProvideContext", self, context10));
var race6 = dual(2, (self, that) => new RequestResolverImpl((requests) => race3(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto15 = {
  ...CommitPrototype,
  commit() {
    return get25(this);
  },
  [ResourceTypeId]: resourceVariance
};
var get25 = (self) => flatMap11(get23(self.scopedRef), identity);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/STM.js
var as11 = as9;
var flatMap21 = flatMap18;
var gen5 = gen4;
var map34 = map29;
var retry7 = retry4;
var succeed19 = succeed12;
var zipLeft10 = zipLeft8;
var Do7 = succeed19({});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either2,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map35,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set13,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError3,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId31,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between7,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose5,
  declare: () => declare,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend4,
  failureSchema: () => failureSchema,
  filter: () => filter16,
  filterEffect: () => filterEffect2,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan9,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo7,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head7,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf2,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length3,
  lessThan: () => lessThan13,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo7,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make72,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString3,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit4,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split5,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend11,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag2,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate4,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Struct.js
var pick4 = dual((args2) => isObject(args2[0]), (s, ...keys10) => {
  const out = {};
  for (const k2 of keys10) {
    if (k2 in s) {
      out[k2] = s[k2];
    }
  }
  return out;
});
var omit3 = dual((args2) => isObject(args2[0]), (s, ...keys10) => {
  const out = {
    ...s
  };
  for (const k2 of keys10) {
    delete out[k2];
  }
  return out;
});
var evolve = dual(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k2 in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k2)) {
      out[k2] = t[k2](obj[k2]);
    }
  }
  return out;
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Schema.js
var TypeId31 = Symbol.for("effect/Schema");
function make72(ast) {
  return class SchemaClass {
    [TypeId31] = variance11;
    static ast = ast;
    static annotations(annotations3) {
      return make72(mergeSchemaAnnotations(this.ast, annotations3));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId31] = variance11;
  };
}
var variance11 = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _I: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var makeStandardResult = (exit4) => isSuccess(exit4) ? exit4.value : makeStandardFailureResult(pretty2(exit4.cause));
var makeStandardFailureResult = (message) => ({
  issues: [{
    message
  }]
});
var makeStandardFailureFromParseIssue = (issue) => map25(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
}));
var standardSchemaV1 = (schema, overrideOptions) => {
  const decodeUnknown4 = decodeUnknown2(schema, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make72(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value6) {
        const scheduler2 = new SyncScheduler();
        const fiber = runFork2(matchEffect4(decodeUnknown4(value6, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: (value7) => succeed8({
            value: value7
          })
        }), {
          scheduler: scheduler2
        });
        scheduler2.flush();
        const exit4 = fiber.unsafePoll();
        if (exit4) {
          return makeStandardResult(exit4);
        }
        return new Promise((resolve) => {
          fiber.addObserver((exit5) => {
            resolve(makeStandardResult(exit5));
          });
        });
      }
    };
  };
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations3) => {
  if (!annotations3) {
    return {};
  }
  const out = {
    ...annotations3
  };
  for (const key in builtInAnnotations) {
    if (key in annotations3) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations3[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations3) => annotations(ast, toASTAnnotations(annotations3));
function asSchema(schema) {
  return schema;
}
var format6 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make72(encodedAST(schema.ast));
var encodedBoundSchema = (schema) => make72(encodedBoundAST(schema.ast));
var typeSchema = (schema) => make72(typeAST(schema.ast));
var encodeUnknown2 = (schema, options) => {
  const encodeUnknown3 = encodeUnknown(schema, options);
  return (u, overrideOptions) => mapError9(encodeUnknown3(u, overrideOptions), parseError);
};
var encodeUnknownEither2 = (schema, options) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
};
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var encode4 = encodeUnknown2;
var encodeEither = encodeUnknownEither2;
var encodePromise = encodeUnknownPromise;
var decodeUnknown3 = (schema, options) => {
  const decodeUnknown4 = decodeUnknown2(schema, options);
  return (u, overrideOptions) => mapError9(decodeUnknown4(u, overrideOptions), parseError);
};
var decodeUnknownEither2 = (schema, options) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
};
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown3(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var decode5 = decodeUnknown3;
var decodeEither = decodeUnknownEither2;
var decodePromise = decodeUnknownPromise;
var validate4 = (schema, options) => {
  const validate5 = validate3(schema, options);
  return (u, overrideOptions) => mapError9(validate5(u, overrideOptions), parseError);
};
var validateEither2 = (schema, options) => {
  const validateEither3 = validateEither(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
};
var validatePromise = (schema, options) => {
  const parser = validate4(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var isSchema = (u) => hasProperty(u, TypeId31) && isObject(u[TypeId31]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make72(ast) {
    static annotations(annotations3) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var pickLiteral = (...literals) => (_schema) => Literal2(...literals);
var UniqueSymbolFromSelf = (symbol5) => make72(new UniqueSymbol(symbol5));
var getDefaultEnumsAST = (enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make72(ast) {
  static annotations(annotations3) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations3));
  }
  static enums = {
    ...enums
  };
};
var Enums2 = (enums) => makeEnumsClass(enums);
var TemplateLiteral2 = (...[head8, ...tail]) => {
  const spans = [];
  let h2 = "";
  let ts = tail;
  if (isSchema(head8)) {
    if (isLiteral(head8.ast)) {
      h2 = String(head8.ast.literal);
    } else {
      ts = [head8, ...ts];
    }
  } else {
    h2 = String(head8);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next5 = ts[i + 1];
        if (isSchema(next5)) {
          if (isLiteral(next5.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next5.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next5)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make72(new TemplateLiteral(h2, spans));
  } else {
    return make72(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h2), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal2 = ast.literal;
      if (!isString(literal2)) {
        const s = String(literal2);
        return transform2(Literal2(s), schema, {
          strict: true,
          decode: () => literal2,
          encode: () => s
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose5(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make72(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose5(Union2(...members), schema) : schema;
    }
  }
}
var TemplateLiteralParser = (...params) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal2(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element2 = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element2) {
      elements.push(element2);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format6(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _2, ast) => {
      const match28 = re.exec(i);
      return match28 ? succeed16(match28.slice(1, params.length + 1)) : fail17(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: (tuple4) => succeed16(tuple4.join(""))
  }) {
    static params = params.slice();
  };
};
var declareConstructor = (typeParameters, options, annotations3) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make72)), (...typeParameters2) => options.encode(...typeParameters2.map(make72)), toASTAnnotations(annotations3)));
var declarePrimitive = (is3, annotations3) => {
  const decodeUnknown4 = () => (input, _2, ast) => is3(input) ? succeed16(input) : fail17(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations3)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make72(ast) {
    static annotations(annotations3) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations4 = arguments[2];
    return declareConstructor(typeParameters, options, annotations4);
  }
  const is3 = arguments[0];
  const annotations3 = arguments[1];
  return declarePrimitive(is3, annotations3);
};
var BrandSchemaId = Symbol.for("effect/SchemaId/Brand");
var fromBrand = (constructor, annotations3) => (self) => {
  const out = makeBrandClass(self, new Refinement(self.ast, function predicate(a, _2, ast) {
    const either8 = constructor.either(a);
    return isLeft2(either8) ? some2(new Type2(ast, a, either8.left.map((v2) => v2.message).join(", "))) : none2();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations3
  })));
  return out;
};
var InstanceOfSchemaId = Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf2 = (constructor, annotations3) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations3
});
var Undefined = class extends make72(undefinedKeyword) {
};
var Void = class extends make72(voidKeyword) {
};
var Null = class extends make72($null) {
};
var Never = class extends make72(neverKeyword) {
};
var Unknown = class extends make72(unknownKeyword) {
};
var Any = class extends make72(anyKeyword) {
};
var BigIntFromSelf = class extends make72(bigIntKeyword) {
};
var SymbolFromSelf = class extends make72(symbolKeyword) {
};
var String$ = class extends make72(stringKeyword) {
};
var Number$ = class extends make72(numberKeyword) {
};
var Boolean$ = class extends make72(booleanKeyword) {
};
var Object$ = class extends make72(objectKeyword) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m2) => m2.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make72(ast) {
    static annotations(annotations3) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var NullOr = (self) => Union2(self, Null);
var UndefinedOr = (self) => Union2(self, Undefined);
var NullishOr = (self) => Union2(self, Null, Undefined);
var keyof2 = (self) => make72(keyof(self.ast));
var element = (self) => new ElementImpl(new OptionalType(self.ast, false), self);
var optionalElement = (self) => new ElementImpl(new OptionalType(self.ast, true), self);
var ElementImpl = class _ElementImpl {
  ast;
  from;
  [TypeId31];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations3) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations3)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make72(ast) {
    static annotations(annotations3) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function makeArrayClass(value6, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value6], ast) {
    static annotations(annotations3) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  };
}
var Array$ = (value6) => makeArrayClass(value6);
function makeNonEmptyArrayClass(value6, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value6], [value6], ast) {
    static annotations(annotations3) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  };
}
var NonEmptyArray = (value6) => makeNonEmptyArrayClass(value6);
function ArrayEnsure(value6) {
  return transform2(Union2(value6, Array$(value6)), Array$(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => ensure(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
function NonEmptyArrayEnsure(value6) {
  return transform2(Union2(value6, NonEmptyArray(value6)), NonEmptyArray(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => isNonEmptyReadonlyArray(i) ? i : of(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
};
var FromPropertySignature = class extends OptionalType {
  isReadonly;
  fromKey;
  constructor(type2, isOptional, isReadonly, annotations3, fromKey2) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey2;
  }
};
var ToPropertySignature = class extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
var PropertySignatureTransformation2 = class {
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode6, encode5) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations3) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations3
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations3
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class _PropertySignatureImpl {
  ast;
  [TypeId31];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations3) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)));
  }
  toString() {
    return String(this.ast);
  }
};
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations3) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o, defaultValue) => match2(o, {
  onNone: () => some2(defaultValue()),
  onSome: (value6) => some2(value6 === void 0 ? defaultValue() : value6)
});
var pruneUndefined2 = (ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
  const pruned = pruneUndefined2(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
});
var withDecodingDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = dual(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some2(options.decode(o)), flatMap2(options.encode)));
var requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap2(options.decode), (o) => some2(options.encode(o))));
var optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options.decode, options.encode));
var optionalPropertySignatureAST = (self, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse2(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self));
      if (isNullable2) {
        return optionalToRequired(NullOr(self), to, {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self, to, {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self), typeSchema(self), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self));
      if (isNullable2) {
        return optionalToRequired(NullishOr(self), to, {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self), to, {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, void 0);
      }
    }
  }
};
var optional = (self) => {
  const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
var optionalWith = dual((args2) => isSchema(args2[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
var preserveMissingMessageAnnotation = pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys = Reflect.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type2, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type2), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type2, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is3) => {
          issFrom.push(is3);
          issTo.push(new IndexSignature(is3.parameter, typeAST(is3.type), is3.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is3) => iss.push(is3));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys = Reflect.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make72(ast) {
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys10) {
      return Struct(pick4(fields, ...keys10));
    }
    static omit(...keys10) {
      return Struct(omit3(fields, ...keys10));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag2 = (tag3) => Literal2(tag3).pipe(propertySignature, withConstructorDefault(() => tag3));
var TaggedStruct = (value6, fields) => Struct({
  _tag: tag2(value6),
  ...fields
});
function makeRecordClass(key, value6, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value6
  }], ast) {
    static annotations(annotations3) {
      return makeRecordClass(key, value6, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static key = key;
    static value = value6;
  };
}
var Record = (options) => makeRecordClass(options.key, options.value);
var pick5 = (...keys10) => (self) => make72(pick(self.ast, keys10));
var omit4 = (...keys10) => (self) => make72(omit(self.ast, keys10));
var pluck = dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
  const value6 = make72(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform2(schema.pipe(pick5(key)), value6, {
    strict: true,
    decode: (i) => i[key],
    encode: (a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from, ast) {
  return class BrandClass extends make72(ast) {
    static annotations(annotations3) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
    static from = from;
  };
}
var brand = (brand2, annotations3) => (self) => {
  const annotation = match2(getBrandAnnotation(self.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations3
  }));
  return makeBrandClass(self, ast);
};
var partial2 = (self) => make72(partial(self.ast));
var partialWith = dual((args2) => isSchema(args2[0]), (self, options) => make72(partial(self.ast, options)));
var required2 = (self) => make72(required(self.ast));
var mutable2 = (schema) => make72(mutable(schema.ast));
var intersectTypeLiterals = (x, y2, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y2)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y2.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type2
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type2, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y2.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y2, path));
};
var preserveRefinementAnnotations = omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y2, path) => Union.make(intersectUnionMembers([x], [y2], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap4(xs, (x) => flatMap4(ys, (y2) => {
  switch (y2._tag) {
    case "Literal": {
      if (isString(y2.literal) && isStringKeyword(x) || isNumber(y2.literal) && isNumberKeyword(x) || isBoolean(y2.literal) && isBooleanKeyword(x)) {
        return [y2];
      }
      break;
    }
    case "StringKeyword": {
      if (y2 === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y2], path));
        }
      } else if (x === stringKeyword) {
        return [y2];
      }
      break;
    }
    case "NumberKeyword": {
      if (y2 === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y2], path));
        }
      } else if (x === numberKeyword) {
        return [y2];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y2 === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y2], path));
        }
      } else if (x === booleanKeyword) {
        return [y2];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y2.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y2.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y2, intersectUnionMembers(getTypes(x), getTypes(y2.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y2], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y2, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y2], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y2, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y2, path);
          const to = intersectTypeLiterals(x.to, typeAST(y2), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map33(transformation.decode(fromA, options, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options, ast, toA) => map33(transformation.encode(toI, options, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y2.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y2.from, path), intersectTypeLiterals(x.to, y2.to, path), new TypeLiteralTransformation(y2.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y2], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y2, path));
}));
var extend4 = dual(2, (self, that) => make72(extendAST(self.ast, that.ast, [])));
var compose5 = dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose3(from.ast, to.ast)));
var suspend11 = (f2) => make72(new Suspend(() => f2().ast));
var RefineSchemaId = Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter18, ast) {
  return class RefineClass extends make72(ast) {
    static annotations(annotations3) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter18;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap4(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter16(predicate, annotations3) {
  return (self) => {
    function filter18(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter18, toASTAnnotations(annotations3));
    return makeRefineClass(self, filter18, ast);
  };
}
var filterEffect2 = dual(2, (self, f2) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => flatMap20(f2(i, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => succeed16(i),
    onSome: fail17
  })),
  encode: (a) => succeed16(a)
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make72(ast) {
    static annotations(annotations3) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
var transform2 = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed16(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed16(options.encode(toI, toA))
}));
function transformLiteral(from, to) {
  return transform2(Literal2(from), Literal2(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
var attachPropertySignature = dual((args2) => isSchema(args2[0]), (schema, key, value6, annotations3) => {
  const ast = extend4(typeSchema(schema), Struct({
    [key]: isSymbol(value6) ? UniqueSymbolFromSelf(value6) : Literal2(value6)
  })).ast;
  return make72(new Transformation(schema.ast, annotations3 ? mergeSchemaAnnotations(ast, annotations3) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some2(value6), () => none2())])));
});
var annotations2 = dual(2, (self, annotations3) => self.annotations(annotations3));
var rename2 = dual(2, (self, mapping) => make72(rename(self.ast, mapping)));
var TrimmedSchemaId = Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations3) => (self) => self.pipe(filter16((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations3
}));
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = (maxLength2, annotations3) => (self) => self.pipe(filter16((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations3
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength2, annotations3) => (self) => self.pipe(filter16((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations3
}));
var LengthSchemaId2 = LengthSchemaId;
var length3 = (length4, annotations3) => (self) => {
  const minLength2 = isObject(length4) ? Math.max(0, Math.floor(length4.min)) : Math.max(0, Math.floor(length4));
  const maxLength2 = isObject(length4) ? Math.max(minLength2, Math.floor(length4.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self.pipe(filter16((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations3
    }));
  }
  return self.pipe(filter16((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations3
  }));
};
var PatternSchemaId = Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations3) => (self) => {
  const source = regex.source;
  return self.pipe(filter16((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations3
  }));
};
var StartsWithSchemaId = Symbol.for("effect/SchemaId/StartsWith");
var startsWith = (startsWith2, annotations3) => (self) => {
  const formatted = JSON.stringify(startsWith2);
  return self.pipe(filter16((a) => a.startsWith(startsWith2), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith2
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith2}`
    },
    ...annotations3
  }));
};
var EndsWithSchemaId = Symbol.for("effect/SchemaId/EndsWith");
var endsWith = (endsWith2, annotations3) => (self) => {
  const formatted = JSON.stringify(endsWith2);
  return self.pipe(filter16((a) => a.endsWith(endsWith2), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith2
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith2}$`
    },
    ...annotations3
  }));
};
var IncludesSchemaId = Symbol.for("effect/SchemaId/Includes");
var includes = (searchString, annotations3) => (self) => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter16((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations3
  }));
};
var LowercasedSchemaId = Symbol.for("effect/SchemaId/Lowercased");
var lowercased = (annotations3) => (self) => self.pipe(filter16((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations3
}));
var Lowercased = class extends String$.pipe(lowercased({
  identifier: "Lowercased"
})) {
};
var UppercasedSchemaId = Symbol.for("effect/SchemaId/Uppercased");
var uppercased = (annotations3) => (self) => self.pipe(filter16((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations3
}));
var Uppercased = class extends String$.pipe(uppercased({
  identifier: "Uppercased"
})) {
};
var CapitalizedSchemaId = Symbol.for("effect/SchemaId/Capitalized");
var capitalized = (annotations3) => (self) => self.pipe(filter16((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations3
}));
var Capitalized = class extends String$.pipe(capitalized({
  identifier: "Capitalized"
})) {
};
var UncapitalizedSchemaId = Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = (annotations3) => (self) => self.pipe(filter16((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations3
}));
var Uncapitalized = class extends String$.pipe(uncapitalized({
  identifier: "Uncapitalized"
})) {
};
var Char = class extends String$.pipe(length3(1, {
  identifier: "Char"
})) {
};
var nonEmptyString3 = (annotations3) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations3
});
var Lowercase = class extends transform2(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i) => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
}) {
};
var Uppercase = class extends transform2(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i) => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
}) {
};
var Capitalize = class extends transform2(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i) => capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
}) {
};
var Uncapitalize = class extends transform2(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i) => uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
}) {
};
var Trimmed = class extends String$.pipe(trimmed({
  identifier: "Trimmed"
})) {
};
var NonEmptyTrimmedString = class extends Trimmed.pipe(nonEmptyString3({
  identifier: "NonEmptyTrimmedString"
})) {
};
var Trim = class extends transform2(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i) => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
}) {
};
var split5 = (separator) => transform2(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i) => i.split(separator),
  encode: (a) => a.join(separator)
});
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _2, ast) => _try({
    try: () => JSON.parse(i, options?.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _2, ast) => _try({
    try: () => JSON.stringify(a, options?.replacer, options?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose5(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
var NonEmptyString = class extends String$.pipe(nonEmptyString3({
  identifier: "NonEmptyString"
})) {
};
var UUIDSchemaId = Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends String$.pipe(pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
})) {
};
var ULIDSchemaId = Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends String$.pipe(pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
})) {
};
var URLFromSelf = class extends instanceOf2(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url2) => url2.toString()
}) {
};
var URL$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _2, ast) => _try({
    try: () => new URL(i),
    catch: (e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed16(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url2) => url2.toString()
}) {
};
var FiniteSchemaId2 = FiniteSchemaId;
var finite = (annotations3) => (self) => self.pipe(filter16(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {},
  ...annotations3
}));
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan9 = (exclusiveMinimum, annotations3) => (self) => self.pipe(filter16((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations3
}));
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo7 = (minimum, annotations3) => (self) => self.pipe(filter16((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations3
}));
var MultipleOfSchemaId = Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = (divisor, annotations3) => (self) => {
  const positiveDivisor = Math.abs(divisor);
  return self.pipe(filter16((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations3
  }));
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations3) => (self) => self.pipe(filter16((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
}));
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan13 = (exclusiveMaximum, annotations3) => (self) => self.pipe(filter16((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations3
}));
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo7 = (maximum, annotations3) => (self) => self.pipe(filter16((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations3
}));
var BetweenSchemaId2 = BetweenSchemaId;
var between7 = (minimum, maximum, annotations3) => (self) => self.pipe(filter16((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations3
}));
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = (annotations3) => (self) => self.pipe(filter16((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations3
}));
var positive = (annotations3) => greaterThan9(0, {
  title: "positive",
  ...annotations3
});
var negative = (annotations3) => lessThan13(0, {
  title: "negative",
  ...annotations3
});
var nonPositive = (annotations3) => lessThanOrEqualTo7(0, {
  title: "nonPositive",
  ...annotations3
});
var nonNegative = (annotations3) => greaterThanOrEqualTo7(0, {
  title: "nonNegative",
  ...annotations3
});
var clamp8 = (minimum, maximum) => (self) => {
  return transform2(self, typeSchema(self).pipe(between7(minimum, maximum)), {
    strict: false,
    decode: (i) => clamp3(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _2, ast) => fromOption4(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed16(String(a))
  });
}
var NumberFromString = class extends parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
}) {
};
var Finite = class extends Number$.pipe(finite({
  identifier: "Finite"
})) {
};
var Int = class extends Number$.pipe(int({
  identifier: "Int"
})) {
};
var NonNaN = class extends Number$.pipe(nonNaN({
  identifier: "NonNaN"
})) {
};
var Positive = class extends Number$.pipe(positive({
  identifier: "Positive"
})) {
};
var Negative = class extends Number$.pipe(negative({
  identifier: "Negative"
})) {
};
var NonPositive = class extends Number$.pipe(nonPositive({
  identifier: "NonPositive"
})) {
};
var NonNegative = class extends Number$.pipe(nonNegative({
  identifier: "NonNegative"
})) {
};
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends Number$.pipe(finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
})) {
};
var Not = class extends transform2(Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i) => not(i),
  encode: (a) => not(a)
}) {
};
var encodeSymbol2 = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail17(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed16(key);
};
var decodeSymbol = (s) => succeed16(Symbol.for(s));
var Symbol$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i) => decodeSymbol(i),
  encode: (a, _2, ast) => encodeSymbol2(a, ast)
}).annotations({
  identifier: "Symbol"
}) {
};
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = (min9, annotations3) => (self) => self.pipe(filter16((a) => a > min9, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min9
  },
  title: `greaterThanBigInt(${min9})`,
  description: min9 === 0n ? "a positive bigint" : `a bigint greater than ${min9}n`,
  ...annotations3
}));
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = (min9, annotations3) => (self) => self.pipe(filter16((a) => a >= min9, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min9
  },
  title: `greaterThanOrEqualToBigInt(${min9})`,
  description: min9 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min9}n`,
  ...annotations3
}));
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = (max11, annotations3) => (self) => self.pipe(filter16((a) => a < max11, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max11
  },
  title: `lessThanBigInt(${max11})`,
  description: max11 === 0n ? "a negative bigint" : `a bigint less than ${max11}n`,
  ...annotations3
}));
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = (max11, annotations3) => (self) => self.pipe(filter16((a) => a <= max11, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max11
  },
  title: `lessThanOrEqualToBigInt(${max11})`,
  description: max11 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max11}n`,
  ...annotations3
}));
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = (min9, max11, annotations3) => (self) => self.pipe(filter16((a) => a >= min9 && a <= max11, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min9,
    max: max11
  },
  title: `betweenBigInt(${min9}, ${max11})`,
  description: `a bigint between ${min9}n and ${max11}n`,
  ...annotations3
}));
var positiveBigInt = (annotations3) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations3
});
var negativeBigInt = (annotations3) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations3
});
var nonNegativeBigInt = (annotations3) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations3
});
var nonPositiveBigInt = (annotations3) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations3
});
var clampBigInt = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp5(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var BigInt$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _2, ast) => fromOption4(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed16(String(a))
}).annotations({
  identifier: "BigInt"
}) {
};
var PositiveBigIntFromSelf = BigIntFromSelf.pipe(positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = BigInt$.pipe(positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = BigIntFromSelf.pipe(negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = BigInt$.pipe(negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = BigIntFromSelf.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = BigInt$.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = BigIntFromSelf.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = BigInt$.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _2, ast) => fromOption4(fromNumber(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _2, ast) => fromOption4(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
}) {
};
var redactedArbitrary = (value6) => (fc) => value6(fc).map(make70);
var toComposite = (eff, onSuccess, ast, actual) => mapBoth9(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown4) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown4(value4(u), options), make70, ast, u) : fail17(new Type2(ast, u));
var RedactedFromSelf = (value6) => declare([value6], {
  decode: (value7) => redactedParse(decodeUnknown2(value7)),
  encode: (value7) => redactedParse(encodeUnknown(value7))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence7
});
function Redacted(value6) {
  return transform2(value6, RedactedFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => make70(i),
    encode: (a) => value4(a)
  });
}
var DurationFromSelf = class extends declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_2) => nanos(_2)), fc.maxSafeNat().map((_2) => millis(_2))),
  equivalence: () => Equivalence2
}) {
};
var DurationFromNanos = class extends transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter16((duration3) => isFinite(duration3), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i) => succeed16(nanos(i)),
  encode: (a, _2, ast) => match2(toNanos(a), {
    onNone: () => fail17(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed16(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
}) {
};
var NonNegativeInt = NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends transform2(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i) => millis(i),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
}) {
};
var DurationValueMillis = TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = TaggedStruct("Infinity", {});
var durationValueInfinity = DurationValueInfinity.make({});
var DurationValue = Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = (u) => typeof u === "object";
var Duration = class extends transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
}) {
};
var clampDuration = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp6(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationSchemaId = Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = (max11, annotations3) => (self) => self.pipe(filter16((a) => lessThan5(a, max11), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max11
  },
  title: `lessThanDuration(${max11})`,
  description: `a Duration less than ${decode(max11)}`,
  ...annotations3
}));
var LessThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max11, annotations3) => (self) => self.pipe(filter16((a) => lessThanOrEqualTo5(a, max11), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max11
  },
  title: `lessThanOrEqualToDuration(${max11})`,
  description: `a Duration less than or equal to ${decode(max11)}`,
  ...annotations3
}));
var GreaterThanDurationSchemaId = Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = (min9, annotations3) => (self) => self.pipe(filter16((a) => greaterThan5(a, min9), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min9
  },
  title: `greaterThanDuration(${min9})`,
  description: `a Duration greater than ${decode(min9)}`,
  ...annotations3
}));
var GreaterThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min9, annotations3) => (self) => self.pipe(filter16((a) => greaterThanOrEqualTo5(a, min9), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min9
  },
  title: `greaterThanOrEqualToDuration(${min9})`,
  description: `a Duration greater than or equal to ${decode(min9)}`,
  ...annotations3
}));
var BetweenDurationSchemaId = Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations3) => (self) => self.pipe(filter16((a) => between5(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations3
}));
var Uint8ArrayFromSelf = class extends declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence3(equals)
}) {
};
var Uint8 = class extends Number$.pipe(between7(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
})) {
};
var Uint8Array$ = class extends transform2(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i) => Uint8Array.from(i),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
}) {
};
var makeUint8ArrayTransformation = (id2, decode6, encode5) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _2, ast) => mapLeft(decode6(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed16(encode5(a))
}).annotations({
  identifier: id2
});
var Uint8ArrayFromBase64 = makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = (id2, decode6, encode5) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id2}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _2, ast) => mapLeft(decode6(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed16(encode5(a))
}).annotations({
  identifier: `StringFrom${id2}`
});
var StringFromBase64 = makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _2, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a, _2, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = (n, annotations3) => (self) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter16((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = (n, annotations3) => (self) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter16((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = (n, annotations3) => (self) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self.pipe(filter16((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var getNumberIndexedAccess2 = (self) => make72(getNumberIndexedAccess(self.ast));
function head7(self) {
  return transform2(self, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self))), {
    strict: false,
    decode: (i) => head(i),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of
    })
  });
}
function headNonEmpty3(self) {
  return transform2(self, getNumberIndexedAccess2(typeSchema(self)), {
    strict: false,
    decode: (i) => headNonEmpty(i),
    encode: (a) => of(a)
  });
}
var headOrElse = dual((args2) => isSchema(args2[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess2(typeSchema(self)), {
  strict: true,
  decode: (i, _2, ast) => i.length > 0 ? succeed16(i[0]) : fallback ? succeed16(fallback()) : fail17(new Type2(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed16(of(a))
}));
var ValidDateSchemaId = Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations3) => (self) => self.pipe(filter16((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations3
}));
var LessThanDateSchemaId = Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = (max11, annotations3) => (self) => self.pipe(filter16((a) => a < max11, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max11
  },
  title: `lessThanDate(${formatDate(max11)})`,
  description: `a date before ${formatDate(max11)}`,
  ...annotations3
}));
var LessThanOrEqualToDateSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = (max11, annotations3) => (self) => self.pipe(filter16((a) => a <= max11, {
  schemaId: LessThanOrEqualToDateSchemaId,
  [LessThanOrEqualToDateSchemaId]: {
    max: max11
  },
  title: `lessThanOrEqualToDate(${formatDate(max11)})`,
  description: `a date before or equal to ${formatDate(max11)}`,
  ...annotations3
}));
var GreaterThanDateSchemaId = Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = (min9, annotations3) => (self) => self.pipe(filter16((a) => a > min9, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min9
  },
  title: `greaterThanDate(${formatDate(min9)})`,
  description: `a date after ${formatDate(min9)}`,
  ...annotations3
}));
var GreaterThanOrEqualToDateSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = (min9, annotations3) => (self) => self.pipe(filter16((a) => a >= min9, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min9
  },
  title: `greaterThanOrEqualToDate(${formatDate(min9)})`,
  description: `a date after or equal to ${formatDate(min9)}`,
  ...annotations3
}));
var BetweenDateSchemaId = Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = (min9, max11, annotations3) => (self) => self.pipe(filter16((a) => a <= max11 && a >= min9, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max11,
    min: min9
  },
  title: `betweenDate(${formatDate(min9)}, ${formatDate(max11)})`,
  description: `a date between ${formatDate(min9)} and ${formatDate(max11)}`,
  ...annotations3
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date3) => `new Date(${JSON.stringify(date3)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
}) {
};
var ValidDateFromSelf = class extends DateFromSelf.pipe(validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})) {
};
var DateFromString = class extends transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
}) {
};
var Date$ = class extends DateFromString.pipe(validDate({
  identifier: "Date"
})) {
};
var DateFromNumber = class extends transform2(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {
};
var DateTimeUtcFromSelf = class extends declare((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date3) => unsafeFromDate2(date3)),
  equivalence: () => Equivalence5
}) {
};
var decodeDateTimeUtc = (input, ast) => _try({
  try: () => unsafeMake12(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
});
var DateTimeUtcFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _2, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed16(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
}) {
};
var DateTimeUtcFromDate = class extends transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _2, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed16(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
}) {
};
var DateTimeUtc = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _2, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed16(formatIso2(a))
}).annotations({
  identifier: "DateTimeUtc"
}) {
};
var timeZoneOffsetArbitrary = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2);
var TimeZoneOffsetFromSelf = class extends declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
}) {
};
var TimeZoneOffset = class extends transform2(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i) => zoneMakeOffset2(i),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
}) {
};
var timeZoneNamedArbitrary = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);
var TimeZoneNamedFromSelf = class extends declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
}) {
};
var TimeZoneNamed = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _2, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i),
    catch: () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed16(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
}) {
};
var TimeZoneFromSelf = class extends Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {
};
var TimeZone = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _2, ast) => match2(zoneFromString2(i), {
    onNone: () => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: succeed16
  }),
  encode: (a) => succeed16(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
}) {
};
var timeZoneArbitrary = (fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
var DateTimeZonedFromSelf = class extends declare((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence5
}) {
};
var DateTimeZoned = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _2, ast) => match2(makeZonedFromString2(i), {
    onNone: () => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: succeed16
  }),
  encode: (a) => succeed16(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
}) {
};
var OptionNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value6) => Struct({
  _tag: Literal2("Some"),
  value: value6
}).annotations({
  description: `SomeEncoded<${format6(value6)}>`
});
var optionEncoded = (value6) => Union2(OptionNoneEncoded, optionSomeEncoded(value6)).annotations({
  description: `OptionEncoded<${format6(value6)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary = (value6, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value6(fc)
})).map(optionDecode);
var optionPretty = (value6) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value6(a)})`
});
var optionParse = (decodeUnknown4) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed16(none2()) : toComposite(decodeUnknown4(u.value, options), some2, ast, u) : fail17(new Type2(ast, u));
var OptionFromSelf_ = (value6) => {
  return declare([value6], {
    decode: (value7) => optionParse(decodeUnknown2(value7)),
    encode: (value7) => optionParse(encodeUnknown(value7))
  }, {
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var OptionFromSelf = (value6) => {
  return OptionFromSelf_(value6).annotations({
    description: `Option<${format6(value6)}>`
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value6) => ({
  _tag: "Some",
  value: value6
});
function Option(value6) {
  const value_ = asSchema(value6);
  const out = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i) => optionDecode(i),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
function OptionFromNullOr(value6) {
  return transform2(NullOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrNull2(a)
  });
}
function OptionFromNullishOr(value6, onNoneEncoding) {
  return transform2(NullishOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: onNoneEncoding === null ? (a) => getOrNull2(a) : (a) => getOrUndefined2(a)
  });
}
function OptionFromUndefinedOr(value6) {
  return transform2(UndefinedOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrUndefined2(a)
  });
}
var OptionFromNonEmptyTrimmedString = class extends transform2(String$, OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => filter(some2(i.trim()), isNonEmpty6),
  encode: (a) => getOrElse2(a, () => "")
}) {
};
var rightEncoded = (right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
});
var eitherEncoded = (right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u)
}) : fail17(new Type2(ast, u));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either2 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform2(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i) => eitherDecode(i),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform2(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  });
  const fromLeft = transform2(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  });
  const out = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i) => i._tag === "Left" ? left2(i.left) : right2(i.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var mapArbitrary = (key, value6, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value6(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => new Map(as12));
  };
};
var readonlyMapPretty = (key, value6) => (map40) => `new Map([${Array.from(map40.entries()).map(([k2, v2]) => `[${key(k2)}, ${value6(v2)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value6) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b2) => arrayEquivalence(Array.from(a.entries()), Array.from(b2.entries())));
};
var readonlyMapParse = (decodeUnknown4) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown4(Array.from(u.entries()), options), (as12) => new Map(as12), ast, u) : fail17(new Type2(ast, u));
var mapFromSelf_ = (key, value6, description) => declare([key, value6], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `ReadonlyMap<${format6(key)}, ${format6(value6)}>`);
var MapFromSelf = ({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `Map<${format6(key)}, ${format6(value6)}>`);
function ReadonlyMap({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
function map35({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
var ReadonlyMapFromRecord = ({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var MapFromRecord = ({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var setArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => new Set(as12));
};
var readonlySetPretty = (item) => (set19) => `new Set([${Array.from(set19.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b2) => arrayEquivalence(Array.from(a.values()), Array.from(b2.values())));
};
var readonlySetParse = (decodeUnknown4) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown4(Array.from(u.values()), options), (as12) => new Set(as12), ast, u) : fail17(new Type2(ast, u));
var setFromSelf_ = (value6, description) => declare([value6], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value6) => setFromSelf_(value6, `ReadonlySet<${format6(value6)}>`);
var SetFromSelf = (value6) => setFromSelf_(value6, `Set<${format6(value6)}>`);
function ReadonlySet(value6) {
  return transform2(Array$(value6), ReadonlySetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
function set13(value6) {
  return transform2(Array$(value6), SetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
var bigDecimalPretty = () => (val) => `BigDecimal(${format2(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value6, scale2]) => make4(value6, scale2));
var BigDecimalFromSelf = class extends declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence
}) {
};
var BigDecimal = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _2, ast) => fromString(i).pipe(match2({
    onNone: () => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: (val) => succeed16(normalize(val))
  })),
  encode: (a) => succeed16(format2(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
}) {
};
var BigDecimalFromNumber = class extends transform2(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i) => unsafeFromNumber(i),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
}) {
};
var GreaterThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min9, annotations3) => (self) => {
  const formatted = format2(min9);
  return self.pipe(filter16((a) => greaterThan3(a, min9), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min9
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations3
  }));
};
var GreaterThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min9, annotations3) => (self) => {
  const formatted = format2(min9);
  return self.pipe(filter16((a) => greaterThanOrEqualTo3(a, min9), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min9
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations3
  }));
};
var LessThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = (max11, annotations3) => (self) => {
  const formatted = format2(max11);
  return self.pipe(filter16((a) => lessThan3(a, max11), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max11
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations3
  }));
};
var LessThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max11, annotations3) => (self) => {
  const formatted = format2(max11);
  return self.pipe(filter16((a) => lessThanOrEqualTo3(a, max11), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max11
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations3
  }));
};
var PositiveBigDecimalSchemaId = Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = (annotations3) => (self) => self.pipe(filter16((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations3
}));
var PositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations3) => (self) => self.pipe(filter16((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations3
}));
var NonNegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = (annotations3) => (self) => self.pipe(filter16((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations3
}));
var NegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations3) => (self) => self.pipe(filter16((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations3
}));
var NonPositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations3) => (self) => {
  const formattedMinimum = format2(minimum);
  const formattedMaximum = format2(maximum);
  return self.pipe(filter16((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations3
  }));
};
var clampBigDecimal = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp4(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable2);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) ? isEmpty(u) ? succeed16(empty6()) : toComposite(decodeUnknown4(toReadonlyArray(u), options), fromIterable2, ast, u) : fail17(new Type2(ast, u));
var ChunkFromSelf = (value6) => {
  return declare([value6], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format6(value6)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence4
  });
};
function Chunk(value6) {
  return transform2(Array$(value6), ChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => i.length === 0 ? empty6() : fromIterable2(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var nonEmptyChunkArbitrary = (item) => (fc) => array4(item(fc), {
  minLength: 1
}).map((as12) => unsafeFromNonEmptyArray(as12));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) && isNonEmpty2(u) ? toComposite(decodeUnknown4(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail17(new Type2(ast, u));
var NonEmptyChunkFromSelf = (value6) => {
  return declare([value6], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format6(value6)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence4
  });
};
function NonEmptyChunk(value6) {
  return transform2(NonEmptyArray(value6), NonEmptyChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => unsafeFromNonEmptyArray(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var decodeData = (a) => Array.isArray(a) ? array5(a) : struct2(a);
var dataArbitrary = (item) => (fc) => item(fc).map(decodeData);
var dataPretty = (item) => (d) => `Data(${item(d)})`;
var dataParse = (decodeUnknown4) => (u, options, ast) => isEqual(u) ? toComposite(decodeUnknown4(u, options), decodeData, ast, u) : fail17(new Type2(ast, u));
var DataFromSelf = (value6) => {
  return declare([value6], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format6(value6)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
var Data = (value6) => {
  return transform2(value6, DataFromSelf(typeSchema(value6)), {
    strict: false,
    decode: (i) => decodeData(i),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class6 = (identifier2) => (fieldsOr, annotations3) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class4,
  annotations: annotations3
});
var getClassTag = (tag3) => withConstructorDefault(propertySignature(Literal2(tag3)), () => tag3);
var TaggedClass2 = (identifier2) => (tag3, fieldsOr, annotations3) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations3
  }) {
    static _tag = tag3;
  };
};
var TaggedError3 = (identifier2) => (tag3, fieldsOr, annotations3) => {
  class Base4 extends Error4 {
  }
  ;
  Base4.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base4,
    annotations: annotations3,
    disableToString: true
  }) {
    static _tag = tag3;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b2) => {
  const out = {
    ...a
  };
  for (const key of Reflect.ownKeys(b2)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b2[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var astCache = globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations3) => {
  if (annotations3 === void 0) {
    return [];
  } else if (Array.isArray(annotations3)) {
    return annotations3;
  } else {
    return [annotations3];
  }
};
var makeClass = ({
  Base: Base4,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base4 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId31] = variance11;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _2, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed16(input) : fail17(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed16(input) : map33(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty5) => (self) => `${identifier2}(${pretty5(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make72(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend4(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations4) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = Struct({
  _tag: Literal2("Composite"),
  left: suspend11(() => FiberIdEncoded),
  right: suspend11(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId3) => {
  switch (fiberId3._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
  }
};
var FiberIdFromSelf = class extends declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
var FiberId = class extends transform2(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i) => fiberIdDecode(i),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
}) {
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = Struct({
  _tag: Literal2("Empty")
});
var causeFailEncoded = (error2) => Struct({
  _tag: Literal2("Fail"),
  error: error2
});
var CauseInterruptEncoded = Struct({
  _tag: Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error2, defect) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const suspended3 = suspend11(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error2)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error2, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error2(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error2) => (cause2) => {
  const f2 = (cause3) => {
    switch (cause3._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error2(cause3.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause3)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause3.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f2(cause3.left)}, ${f2(cause3.right)})`;
      case "Parallel":
        return `Cause.parallel(${f2(cause3.left)}, ${f2(cause3.right)})`;
    }
  };
  return f2(cause2);
};
var causeParse = (decodeUnknown4) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options), causeDecode, ast, u) : fail17(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error2
}) => {
  return declare([error2, defect], {
    decode: (error3, defect2) => causeParse(decodeUnknown2(causeEncoded(error3, defect2))),
    encode: (error3, defect2) => causeParse(encodeUnknown(causeEncoded(error3, defect2)))
  }, {
    title: `Cause<${error2.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return empty32;
    case "Fail":
      return fail7(cause2.error);
    case "Die":
      return die4(cause2.defect);
    case "Interrupt":
      return interrupt6(fiberIdDecode(cause2.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause2.left), causeDecode(cause2.right));
    case "Parallel":
      return parallel4(causeDecode(cause2.left), causeDecode(cause2.right));
  }
}
function causeEncode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause2.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause2.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause2.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
  }
}
var Cause = ({
  defect,
  error: error2
}) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};
var Defect = class extends transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err2 = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err2.name = i.name;
      }
      err2.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err2;
    }
    return prettyErrorMessage(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
}) {
};
var exitFailureEncoded = (error2, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error2, defect)
});
var exitSuccessEncoded = (value6) => Struct({
  _tag: Literal2("Success"),
  value: value6
});
var exitEncoded = (value6, error2, defect) => {
  return Union2(exitFailureEncoded(error2, defect), exitSuccessEncoded(value6)).annotations({
    title: `ExitEncoded<${format6(value6)}, ${format6(error2)}, ${format6(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause3(causeDecode(input.cause));
    case "Success":
      return succeed3(input.value);
  }
};
var exitArbitrary = (value6, error2, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error2, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value6(fc)
})).map(exitDecode);
var exitPretty = (value6, error2) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty(error2)(exit4.cause)})` : `Exit.succeed(${value6(exit4.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match7(u, {
  onFailure: (cause2) => toComposite(decodeUnknownCause(cause2, options), failCause3, ast, u),
  onSuccess: (value6) => toComposite(decodeUnknownValue(value6, options), succeed3, ast, u)
}) : fail17(new Type2(ast, u));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};
var hashSetArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable5);
};
var hashSetPretty = (item) => (set19) => `HashSet(${Array.from(set19).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b2) => arrayEquivalence(Array.from(a), Array.from(b2)));
};
var hashSetParse = (decodeUnknown4) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable5, ast, u) : fail17(new Type2(ast, u));
var HashSetFromSelf = (value6) => {
  return declare([value6], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format6(value6)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
function HashSet(value6) {
  return transform2(Array$(value6), HashSetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromIterable5(i),
    encode: (a) => Array.from(a)
  });
}
var hashMapArbitrary = (key, value6, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value6(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashMapPretty = (key, value6) => (map40) => `HashMap([${Array.from(map40).map(([k2, v2]) => `[${key(k2)}, ${value6(v2)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value6) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b2) => arrayEquivalence(Array.from(a), Array.from(b2)));
};
var hashMapParse = (decodeUnknown4) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable6, ast, u) : fail17(new Type2(ast, u));
var HashMapFromSelf = ({
  key,
  value: value6
}) => {
  return declare([key, value6], {
    decode: (key2, value7) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value7)))),
    encode: (key2, value7) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value7))))
  }, {
    description: `HashMap<${format6(key)}, ${format6(value6)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value6
}) => {
  return transform2(Array$(Tuple(key, value6)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => fromIterable6(i),
    encode: (a) => Array.from(a)
  });
};
var listArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var listPretty = (item) => (set19) => `List(${Array.from(set19).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b2) => arrayEquivalence(Array.from(a), Array.from(b2)));
};
var listParse = (decodeUnknown4) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable7, ast, u) : fail17(new Type2(ast, u));
var ListFromSelf = (value6) => {
  return declare([value6], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format6(value6)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
function List(value6) {
  return transform2(Array$(value6), ListFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromIterable7(i),
    encode: (a) => Array.from(a)
  });
}
var sortedSetArbitrary = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => fromIterable11(as12, ord));
};
var sortedSetPretty = (item) => (set19) => `new SortedSet([${Array.from(values3(set19)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown4, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown4(Array.from(values3(u)), options), (as12) => fromIterable11(as12, ord), ast, u) : fail17(new Type2(ast, u));
var SortedSetFromSelf = (value6, ordA, ordI) => {
  return declare([value6], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format6(value6)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence6()
  });
};
function SortedSet(value6, ordA) {
  const to = typeSchema(asSchema(value6));
  return transform2(Array$(value6), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (i) => fromIterable11(i, ordA),
    encode: (a) => Array.from(values3(a))
  });
}
var BooleanFromUnknown = class extends transform2(Unknown, Boolean$, {
  strict: true,
  decode: (i) => isTruthy(i),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
}) {
};
var BooleanFromString = class extends transform2(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i) => i === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
}) {
};
var Config = (name, schema) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema);
  return string6(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error2) => InvalidData2([], TreeFormatter.formatIssueSync(error2))))));
};
var symbolSerializable = Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = (serializable) => serializable;
var serializableSchema = (self) => self[symbolSerializable];
var serialize = (self) => encodeUnknown2(self[symbolSerializable])(self);
var deserialize = dual(2, (self, value6) => decodeUnknown3(self[symbolSerializable])(value6));
var symbolWithResult = Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = (withExit) => withExit;
var failureSchema = (self) => self[symbolWithResult].failure;
var successSchema = (self) => self[symbolWithResult].success;
var exitSchemaCache = globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = (self) => {
  const proto16 = Object.getPrototypeOf(self);
  if (!(symbolWithResult in proto16)) {
    return Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto16);
  if (schema === void 0) {
    schema = Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
    exitSchemaCache.set(proto16, schema);
  }
  return schema;
};
var serializeFailure = dual(2, (self, value6) => encode4(self[symbolWithResult].failure)(value6));
var deserializeFailure = dual(2, (self, value6) => decodeUnknown3(self[symbolWithResult].failure)(value6));
var serializeSuccess = dual(2, (self, value6) => encode4(self[symbolWithResult].success)(value6));
var deserializeSuccess = dual(2, (self, value6) => decodeUnknown3(self[symbolWithResult].success)(value6));
var serializeExit = dual(2, (self, value6) => encode4(exitSchema(self))(value6));
var deserializeExit = dual(2, (self, value6) => decodeUnknown3(exitSchema(self))(value6));
var asSerializableWithResult = (procedure) => procedure;
var TaggedRequest = (identifier2) => (tag3, options, annotations3) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag3)
  }, options.payload);
  return class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag3,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations3
  }) {
    static _tag = tag3;
    static success = options.success;
    static failure = options.failure;
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  };
};
var equivalence2 = (schema) => go3(schema.ast, []);
var getEquivalenceAnnotation = getAnnotation(EquivalenceAnnotationId);
var go3 = (ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go3(tp, path)));
      case "Refinement":
        return hook.value(go3(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go3(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go3(ast.from, path);
    case "Suspend": {
      const get34 = memoizeThunk(() => go3(ast.f(), path));
      return (a, b2) => get34()(a, b2);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i) => go3(element2.type, path.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go3(annotatedAST.type, path));
      return make((a, b2) => {
        if (!Array.isArray(a) || !Array.isArray(b2)) {
          return false;
        }
        const len = a.length;
        if (len !== b2.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b2[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail] = rest;
          for (; i < len - tail.length; i++) {
            if (!head8(a[i], b2[i])) {
              return false;
            }
          }
          for (let j2 = 0; j2 < tail.length; j2++) {
            i += j2;
            if (!tail[j2](a[i], b2[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go3(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is3) => go3(is3.type, path));
      return make((a, b2) => {
        if (!isRecord(a) || !isRecord(b2)) {
          return false;
        }
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b2, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b2[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is3 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is3.parameter);
          const isSymbol2 = isSymbolKeyword(encodedParameter);
          if (isSymbol2) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b2);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b2);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
          for (let j2 = 0; j2 < aKeys.length; j2++) {
            const key = aKeys[j2];
            if (!Object.prototype.hasOwnProperty.call(b2, key) || !indexSignatures[i](a[key], b2[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const len = ownKeys.length;
      return make((a, b2) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal2 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                candidates = candidates.concat(buckets[literal2]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go3(ast2, path), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is3] = tuples[i];
          if (is3(a) && is3(b2)) {
            if (equivalence3(a, b2)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
};
var SymbolStruct = TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i) => decodeSymbol(i.key),
  encode: (a, _2, ast) => map33(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  }))
});
var PropertyKey$ = class extends Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
}) {
};
var ArrayFormatterIssue = class extends Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
}) {
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/scopedCache.js
var makeCacheState2 = (map40, keys10, accesses, updating, hits, misses) => ({
  map: map40,
  keys: keys10,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState2 = () => makeCacheState2(empty22(), makeKeySet(), unbounded(), make13(false), 0, 0);
var complete3 = (key, exit4, ownerCount, entryStats, timeToLive) => struct2({
  _tag: "Complete",
  key,
  exit: exit4,
  ownerCount,
  entryStats,
  timeToLive
});
var pending3 = (key, scoped6) => struct2({
  _tag: "Pending",
  key,
  scoped: scoped6
});
var refreshing2 = (scoped6, complete4) => struct2({
  _tag: "Refreshing",
  scoped: scoped6,
  complete: complete4
});
var toScoped = (self) => matchEffect2(self.exit, {
  onFailure: (cause2) => failCause(cause2),
  onSuccess: ([value6]) => acquireRelease(as3(sync(() => incrementAndGet(self.ownerCount)), value6), () => releaseOwner(self))
});
var releaseOwner = (self) => matchEffect2(self.exit, {
  onFailure: () => void_3,
  onSuccess: ([, finalizer2]) => flatMap11(sync(() => decrementAndGet(self.ownerCount)), (numOwner) => when(finalizer2(void_4), () => numOwner === 0))
});
var ScopedCacheSymbolKey = "effect/ScopedCache";
var ScopedCacheTypeId = Symbol.for(ScopedCacheSymbolKey);
var scopedCacheVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Error: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var ScopedCacheImpl = class {
  capacity;
  scopedLookup;
  clock;
  timeToLive;
  context;
  [ScopedCacheTypeId] = scopedCacheVariance;
  cacheState;
  constructor(capacity7, scopedLookup, clock3, timeToLive, context10) {
    this.capacity = capacity7;
    this.scopedLookup = scopedLookup;
    this.clock = clock3;
    this.timeToLive = timeToLive;
    this.context = context10;
    this.cacheState = initialCacheState2();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size6(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value6) => flatten7(this.resolveMapValue(value6))
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value6) => flatten7(this.resolveMapValue(value6, true))
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const value6 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value6 === void 0) {
        return none2();
      }
      switch (value6._tag) {
        case "Complete": {
          return some2(makeEntryStats(value6.entryStats.loadedMillis));
        }
        case "Pending": {
          return none2();
        }
        case "Refreshing": {
          return some2(makeEntryStats(value6.complete.entryStats.loadedMillis));
        }
      }
    });
  }
  get(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap11((lookupValue) => suspend(() => {
      let k2 = void 0;
      let value6 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value6 === void 0) {
        k2 = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value6 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(k2, lookupValue));
        }
      }
      if (value6 === void 0) {
        this.trackMiss();
        return zipRight2(this.ensureMapSizeNotExceeded(k2), lookupValue);
      }
      return map14(this.resolveMapValue(value6), flatMap11(match2({
        onNone: () => {
          const val = value6;
          const current2 = getOrUndefined2(get9(this.cacheState.map, key));
          if (equals(current2, value6)) {
            remove8(this.cacheState.map, key);
          }
          return pipe(this.ensureMapSizeNotExceeded(val.key), zipRight2(releaseOwner(val)), zipRight2(this.get(key)));
        },
        onSome: succeed
      })));
    })), flatten7);
  }
  invalidate(key) {
    return suspend(() => {
      if (has6(this.cacheState.map, key)) {
        const mapValue = getOrUndefined2(get9(this.cacheState.map, key));
        remove8(this.cacheState.map, key);
        switch (mapValue._tag) {
          case "Complete": {
            return releaseOwner(mapValue);
          }
          case "Pending": {
            return void_3;
          }
          case "Refreshing": {
            return releaseOwner(mapValue.complete);
          }
        }
      }
      return void_3;
    });
  }
  get invalidateAll() {
    return forEachConcurrentDiscard(fromIterable5(Array.from(this.cacheState.map).map(([key]) => key)), (key) => this.invalidate(key), false, false);
  }
  refresh(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap11((scoped6) => {
      let value6 = getOrUndefined2(get9(this.cacheState.map, key));
      let newKey = void 0;
      if (value6 === void 0) {
        newKey = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value6 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(newKey, scoped6));
        }
      }
      let finalScoped;
      if (value6 === void 0) {
        finalScoped = zipRight2(this.ensureMapSizeNotExceeded(newKey), scoped6);
      } else {
        switch (value6._tag) {
          case "Complete": {
            if (this.hasExpired(value6.timeToLive)) {
              finalScoped = succeed(this.get(key));
            } else {
              const current2 = getOrUndefined2(get9(this.cacheState.map, key));
              if (equals(current2, value6)) {
                const mapValue = refreshing2(scoped6, value6);
                set5(this.cacheState.map, key, mapValue);
                finalScoped = scoped6;
              } else {
                finalScoped = succeed(this.get(key));
              }
            }
            break;
          }
          case "Pending": {
            finalScoped = value6.scoped;
            break;
          }
          case "Refreshing": {
            finalScoped = value6.scoped;
            break;
          }
        }
      }
      return flatMap11(finalScoped, (s) => scopedEffect(asVoid2(s)));
    }));
  }
  get size() {
    return sync(() => size6(this.cacheState.map));
  }
  resolveMapValue(value6, ignorePending = false) {
    switch (value6._tag) {
      case "Complete": {
        this.trackHit();
        if (this.hasExpired(value6.timeToLive)) {
          return succeed(succeedNone);
        }
        return as3(this.ensureMapSizeNotExceeded(value6.key), asSome(toScoped(value6)));
      }
      case "Pending": {
        this.trackHit();
        if (ignorePending) {
          return succeed(succeedNone);
        }
        return zipRight2(this.ensureMapSizeNotExceeded(value6.key), map14(value6.scoped, asSome));
      }
      case "Refreshing": {
        this.trackHit();
        if (this.hasExpired(value6.complete.timeToLive)) {
          if (ignorePending) {
            return succeed(succeedNone);
          }
          return zipRight2(this.ensureMapSizeNotExceeded(value6.complete.key), map14(value6.scoped, asSome));
        }
        return as3(this.ensureMapSizeNotExceeded(value6.complete.key), asSome(toScoped(value6.complete)));
      }
    }
  }
  lookupValueOf(key) {
    return pipe(onInterrupt(flatMap11(make44(), (scope5) => pipe(this.scopedLookup(key), provideContext(pipe(this.context, add2(Scope, scope5))), exit, map14((exit4) => [exit4, (exit5) => close(scope5, exit5)]))), () => sync(() => remove8(this.cacheState.map, key))), flatMap11(([exit4, release3]) => {
      const now3 = this.clock.unsafeCurrentTimeMillis();
      const expiredAt = now3 + toMillis(this.timeToLive(exit4));
      switch (exit4._tag) {
        case "Success": {
          const exitWithFinalizer = succeed3([exit4.value, release3]);
          const completedResult = complete3(makeMapKey(key), exitWithFinalizer, make13(1), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return sync(() => flatten7(as3(this.cleanMapValue(previousValue), toScoped(completedResult))));
        }
        case "Failure": {
          const completedResult = complete3(makeMapKey(key), exit4, make13(0), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return zipRight2(release3(exit4), sync(() => flatten7(as3(this.cleanMapValue(previousValue), toScoped(completedResult)))));
        }
      }
    }), memoize, flatten7);
  }
  hasExpired(timeToLive) {
    return this.clock.unsafeCurrentTimeMillis() > timeToLive;
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    const cleanedKeys = [];
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size23 = size6(this.cacheState.map);
      loop3 = size23 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 === void 0) {
          loop3 = false;
        } else {
          if (has6(this.cacheState.map, key2.current)) {
            const removed = getOrUndefined2(get9(this.cacheState.map, key2.current));
            remove8(this.cacheState.map, key2.current);
            size23 = size23 - 1;
            cleanedKeys.push(removed);
            loop3 = size23 > this.capacity;
          }
        }
      }
      set3(this.cacheState.updating, false);
    }
    return cleanedKeys;
  }
  cleanMapValue(mapValue) {
    if (mapValue === void 0) {
      return void_3;
    }
    switch (mapValue._tag) {
      case "Complete": {
        return releaseOwner(mapValue);
      }
      case "Pending": {
        return void_3;
      }
      case "Refreshing": {
        return releaseOwner(mapValue.complete);
      }
    }
  }
  ensureMapSizeNotExceeded(key) {
    return forEachConcurrentDiscard(this.trackAccess(key), (cleanedMapValue) => this.cleanMapValue(cleanedMapValue), false, false);
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/SortedMap.js
var TypeId32 = Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId32]: {
    _K: (_2) => _2,
    _V: (_2) => _2
  },
  [symbol2]() {
    return pipe(hash(this.tree), combine2(hash("effect/SortedMap")), cached(this));
  },
  [symbol3](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl4 = (tree) => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
var isSortedMap = (u) => hasProperty(u, TypeId32);
var empty39 = (ord) => makeImpl4(empty29(ord));
var fromIterable16 = dual(2, (iterable, ord) => makeImpl4(fromIterable10(iterable, ord)));
var get26 = dual(2, (self, key) => findFirst9(self.tree, key));
var getOrder3 = (self) => getOrder2(self.tree);
var has13 = dual(2, (self, key) => isSome2(get26(self, key)));
var map36 = dual(2, (self, f2) => reduce18(self, empty39(getOrder2(self.tree)), (acc, v2, k2) => set14(acc, k2, f2(v2, k2))));
var reduce18 = dual(3, (self, zero3, f2) => reduce14(self.tree, zero3, f2));
var remove13 = dual(2, (self, key) => makeImpl4(removeFirst2(self.tree, key)));
var set14 = dual(3, (self, key, value6) => has8(self.tree, key) ? makeImpl4(insert2(removeFirst2(self.tree, key), key, value6)) : makeImpl4(insert2(self.tree, key, value6)));
var partition10 = dual(2, (self, predicate) => {
  const ord = getOrder2(self.tree);
  let right3 = empty39(ord);
  let left3 = empty39(ord);
  for (const value6 of self) {
    if (predicate(value6[0])) {
      right3 = set14(right3, value6[0], value6[1]);
    } else {
      left3 = set14(left3, value6[0], value6[1]);
    }
  }
  return [left3, right3];
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Stream.js
var StreamTypeId3 = StreamTypeId2;
var toChannel4 = toChannel2;
var map37 = map31;
var mapEffect6 = mapEffectOptions;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Streamable.js
var streamVariance2 = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var Class7 = class {
  /**
   * @since 2.0.0
   */
  [StreamTypeId3] = streamVariance2;
  /**
   * @since 2.0.0
   */
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * @internal
   */
  get channel() {
    return toChannel4(this.toStream());
  }
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Subscribable.js
var TypeId33 = Symbol.for("effect/Subscribable");
var Proto7 = {
  [TypeId14]: TypeId14,
  [TypeId33]: TypeId33,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make76 = (options) => Object.assign(Object.create(Proto7), options);
var map38 = dual(2, (self, f2) => make76({
  get: map25(self.get, f2),
  changes: map37(self.changes, f2)
}));
var mapEffect7 = dual(2, (self, f2) => make76({
  get: flatMap15(self.get, f2),
  changes: mapEffect6(self.changes, f2)
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/SynchronizedRef.js
var SynchronizedRefTypeId = SynchronizedTypeId;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var SubscriptionRefImpl = class extends Class2 {
  ref;
  pubsub;
  semaphore;
  [TypeId14] = TypeId14;
  [TypeId33] = TypeId33;
  [RefTypeId2] = refVariance;
  [SynchronizedRefTypeId] = synchronizedVariance;
  [SubscriptionRefTypeId] = subscriptionRefVariance;
  constructor(ref, pubsub, semaphore) {
    super();
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = get12(this.ref);
  }
  commit() {
    return this.get;
  }
  get;
  get changes() {
    return pipe(get12(this.ref), flatMap15((a) => map25(fromPubSub(this.pubsub, {
      scoped: true
    }), (s) => concat3(make57(a), s))), this.semaphore.withPermits(1), unwrapScoped4);
  }
  modify(f2) {
    return this.modifyEffect((a) => succeed8(f2(a)));
  }
  modifyEffect(f2) {
    return pipe(get12(this.ref), flatMap15(f2), flatMap15(([b2, a]) => pipe(set7(this.ref, a), as6(b2), zipLeft5(publish2(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
var modify11 = dual(2, (self, f2) => self.modify(f2));
var modifyEffect2 = dual(2, (self, f2) => self.modifyEffect(f2));
var set15 = dual(2, (self, value6) => pipe(set7(self.ref, value6), zipLeft5(publish2(self.pubsub, value6)), self.semaphore.withPermits(1)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/Supervisor.js
var SupervisorTypeId2 = SupervisorTypeId;
var AbstractSupervisor = class {
  /**
   * @since 2.0.0
   */
  onStart(_context, _effect, _parent, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEnd(_value, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEffect(_fiber, _effect) {
  }
  /**
   * @since 2.0.0
   */
  onSuspend(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  onResume(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  map(f2) {
    return new ProxySupervisor(this, map14(this.value, f2));
  }
  /**
   * @since 2.0.0
   */
  zip(right3) {
    return new Zip(this, right3);
  }
  /**
   * @since 2.0.0
   */
  onRun(execution, _fiber) {
    return execution();
  }
  /**
   * @since 2.0.0
   */
  [SupervisorTypeId2] = supervisorVariance;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tArray.js
var TArraySymbolKey = "effect/TArray";
var TArrayTypeId = Symbol.for(TArraySymbolKey);
var tArrayVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TArrayImpl = class {
  chunk;
  [TArrayTypeId] = tArrayVariance;
  constructor(chunk4) {
    this.chunk = chunk4;
  }
};
var collectFirst = dual(2, (self, pf) => collectFirstSTM(self, (a) => pipe(pf(a), map2(succeed12))));
var collectFirstSTM = dual(2, (self, pf) => withSTMRuntime((runtime5) => {
  let index = 0;
  let result = none2();
  while (isNone2(result) && index < self.chunk.length) {
    const element2 = pipe(self.chunk[index], unsafeGet9(runtime5.journal));
    const option6 = pf(element2);
    if (isSome2(option6)) {
      result = option6;
    }
    index = index + 1;
  }
  return pipe(result, match2({
    onNone: () => succeedNone4,
    onSome: map29(some2)
  }));
}));
var contains5 = dual(2, (self, value6) => some14(self, (a) => equals(a)(value6)));
var count4 = dual(2, (self, predicate) => reduce19(self, 0, (n, a) => predicate(a) ? n + 1 : n));
var countSTM = dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => map29(predicate(a), (bool) => bool ? n + 1 : n)));
var every12 = dual(2, (self, predicate) => negate2(some14(self, (a) => !predicate(a))));
var everySTM = dual(2, (self, predicate) => map29(countSTM(self, predicate), (count5) => count5 === self.chunk.length));
var findFirst11 = dual(2, (self, predicate) => collectFirst(self, (a) => predicate(a) ? some2(a) : none2()));
var findFirstIndex2 = dual(2, (self, value6) => findFirstIndexFrom(self, value6, 0));
var findFirstIndexFrom = dual(3, (self, value6, from) => findFirstIndexWhereFrom(self, (a) => equals(a)(value6), from));
var findFirstIndexWhere = dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
var findFirstIndexWhereFrom = dual(3, (self, predicate, from) => {
  if (from < 0) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element2 = unsafeGet9(self.chunk[index], journal);
      found = predicate(element2);
      index = index + 1;
    }
    if (found) {
      return some2(index - 1);
    }
    return none2();
  });
});
var findFirstIndexWhereSTM = dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
var findFirstIndexWhereFromSTM = dual(3, (self, predicate, from) => {
  const forIndex = (index) => index < self.chunk.length ? pipe(get17(self.chunk[index]), flatMap18(predicate), flatMap18((bool) => bool ? succeed12(some2(index)) : forIndex(index + 1))) : succeedNone4;
  return from < 0 ? succeedNone4 : forIndex(from);
});
var findFirstSTM = dual(2, (self, predicate) => {
  const init = [none2(), 0];
  const cont = (state) => isNone2(state[0]) && state[1] < self.chunk.length - 1;
  return map29(iterate2(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get17(self.chunk[index]), flatMap18((value6) => map29(predicate(value6), (bool) => [bool ? some2(value6) : none2(), index + 1])));
    }
  }), (state) => state[0]);
});
var findLast3 = dual(2, (self, predicate) => effect3((journal) => {
  let index = self.chunk.length - 1;
  let result = none2();
  while (isNone2(result) && index >= 0) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    if (predicate(element2)) {
      result = some2(element2);
    }
    index = index - 1;
  }
  return result;
}));
var findLastIndex2 = dual(2, (self, value6) => findLastIndexFrom(self, value6, self.chunk.length - 1));
var findLastIndexFrom = dual(3, (self, value6, end6) => {
  if (end6 >= self.chunk.length) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index = end6;
    let found = false;
    while (!found && index >= 0) {
      const element2 = unsafeGet9(self.chunk[index], journal);
      found = equals(element2)(value6);
      index = index - 1;
    }
    if (found) {
      return some2(index + 1);
    }
    return none2();
  });
});
var findLastSTM = dual(2, (self, predicate) => {
  const init = [none2(), self.chunk.length - 1];
  const cont = (state) => isNone2(state[0]) && state[1] >= 0;
  return map29(iterate2(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get17(self.chunk[index]), flatMap18((value6) => map29(predicate(value6), (bool) => [bool ? some2(value6) : none2(), index - 1])));
    }
  }), (state) => state[0]);
});
var forEach19 = dual(2, (self, f2) => reduceSTM(self, void 0, (_2, a) => f2(a)));
var fromIterable17 = (iterable) => map29(forEach18(iterable, make54), (chunk4) => new TArrayImpl(chunk4));
var get28 = dual(2, (self, index) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage3("Index out of bounds");
  }
  return get17(self.chunk[index]);
});
var maxOption = dual(2, (self, order) => {
  const greaterThan10 = greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan10(acc)(curr) ? curr : acc);
});
var minOption = dual(2, (self, order) => {
  const lessThan14 = lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan14(acc)(curr) ? curr : acc);
});
var reduce19 = dual(3, (self, zero3, f2) => effect3((journal) => {
  let index = 0;
  let result = zero3;
  while (index < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    result = f2(result, element2);
    index = index + 1;
  }
  return result;
}));
var reduceOption = dual(2, (self, f2) => effect3((journal) => {
  let index = 0;
  let result = void 0;
  while (index < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    result = result === void 0 ? element2 : f2(result, element2);
    index = index + 1;
  }
  return fromNullable2(result);
}));
var reduceOptionSTM = dual(2, (self, f2) => reduceSTM(self, none2(), (acc, curr) => isSome2(acc) ? map29(f2(acc.value, curr), some2) : succeedSome2(curr)));
var reduceSTM = dual(3, (self, zero3, f2) => flatMap18(toArray4(self), reduce17(zero3, f2)));
var some14 = dual(2, (self, predicate) => map29(findFirst11(self, predicate), isSome2));
var someSTM = dual(2, (self, predicate) => map29(countSTM(self, predicate), (n) => n > 0));
var toArray4 = (self) => forEach18(self.chunk, get17);
var transform3 = dual(2, (self, f2) => effect3((journal) => {
  let index = 0;
  while (index < self.chunk.length) {
    const ref = self.chunk[index];
    unsafeSet2(ref, f2(unsafeGet9(ref, journal)), journal);
    index = index + 1;
  }
  return void 0;
}));
var transformSTM = dual(2, (self, f2) => flatMap18(forEach18(self.chunk, (ref) => flatMap18(get17(ref), f2)), (chunk4) => effect3((journal) => {
  const iterator = chunk4[Symbol.iterator]();
  let index = 0;
  let next5;
  while ((next5 = iterator.next()) && !next5.done) {
    unsafeSet2(self.chunk[index], next5.value, journal);
    index = index + 1;
  }
  return void 0;
})));
var update7 = dual(3, (self, index, f2) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage3("Index out of bounds");
  }
  return update6(self.chunk[index], f2);
});
var updateSTM = dual(3, (self, index, f2) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage3("Index out of bounds");
  }
  return pipe(get17(self.chunk[index]), flatMap18(f2), flatMap18((updated) => set9(self.chunk[index], updated)));
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tDeferred.js
var TDeferredSymbolKey = "effect/TDeferred";
var TDeferredTypeId = Symbol.for(TDeferredSymbolKey);
var tDeferredVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2
};
var TDeferredImpl = class {
  ref;
  [TDeferredTypeId] = tDeferredVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var done11 = dual(2, (self, either8) => flatMap18(get17(self.ref), match2({
  onNone: () => zipRight9(set9(self.ref, some2(either8)), succeed12(true)),
  onSome: () => succeed12(false)
})));
var fail18 = dual(2, (self, error2) => done11(self, left2(error2)));
var succeed21 = dual(2, (self, value6) => done11(self, right2(value6)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tMap.js
var TMapSymbolKey = "effect/TMap";
var TMapTypeId = Symbol.for(TMapSymbolKey);
var tMapVariance = {
  /* c8 ignore next */
  _K: (_2) => _2,
  /* c8 ignore next */
  _V: (_2) => _2
};
var TMapImpl = class {
  tBuckets;
  tSize;
  [TMapTypeId] = tMapVariance;
  constructor(tBuckets, tSize) {
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
};
var isTMap = (u) => hasProperty(u, TMapTypeId);
var LoadFactor = 0.75;
var hash3 = (key) => {
  const h2 = hash(key);
  return h2 ^ h2 >>> 16;
};
var indexOf = (k2, capacity7) => hash3(k2) & capacity7 - 1;
var find3 = dual(2, (self, pf) => findSTM(self, (key, value6) => {
  const option6 = pf(key, value6);
  if (isSome2(option6)) {
    return succeed12(option6.value);
  }
  return fail14(none2());
}));
var findSTM = dual(2, (self, f2) => reduceSTM2(self, none2(), (acc, value6, key) => isNone2(acc) ? matchSTM(f2(key, value6), {
  onFailure: match2({
    onNone: () => succeedNone4,
    onSome: fail14
  }),
  onSuccess: succeedSome2
}) : succeed19(acc)));
var findAll2 = dual(2, (self, pf) => findAllSTM(self, (key, value6) => {
  const option6 = pf(key, value6);
  if (isSome2(option6)) {
    return succeed12(option6.value);
  }
  return fail14(none2());
}));
var findAllSTM = dual(2, (self, pf) => map29(reduceSTM2(self, empty6(), (acc, value6, key) => matchSTM(pf(key, value6), {
  onFailure: match2({
    onNone: () => succeed12(acc),
    onSome: fail14
  }),
  onSuccess: (a) => succeed12(append3(acc, a))
})), (a) => Array.from(a)));
var forEach20 = dual(2, (self, f2) => reduceSTM2(self, void 0, (_2, value6, key) => asVoid6(f2(key, value6))));
var get29 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index], journal);
  return pipe(findFirst4(bucket, (entry) => equals(entry[0])(key)), map2((entry) => entry[1]));
}));
var getOrElse6 = dual(3, (self, key, fallback) => map29(get29(self, key), getOrElse2(fallback)));
var has14 = dual(2, (self, key) => map29(get29(self, key), isSome2));
var merge10 = dual(4, (self, key, value6, f2) => flatMap18(get29(self, key), match2({
  onNone: () => as9(set16(self, key, value6), value6),
  onSome: (v0) => {
    const v1 = f2(v0, value6);
    return as9(set16(self, key, v1), v1);
  }
})));
var reduce20 = dual(3, (self, zero3, f2) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  let result = zero3;
  let index = 0;
  while (index < buckets.chunk.length) {
    const bucket = buckets.chunk[index];
    const items = unsafeGet9(bucket, journal);
    result = reduce4(items, result, (acc, entry) => f2(acc, entry[1], entry[0]));
    index = index + 1;
  }
  return result;
}));
var reduceSTM2 = dual(3, (self, zero3, f2) => flatMap18(toReadonlyArray2(self), reduce17(zero3, (acc, entry) => f2(acc, entry[1], entry[0]))));
var remove14 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index], journal);
  const [toRemove, toRetain] = partition3(bucket, (entry) => equals(entry[1], key));
  if (isNonEmpty2(toRemove)) {
    const currentSize = unsafeGet9(self.tSize, journal);
    unsafeSet2(buckets.chunk[index], toRetain, journal);
    unsafeSet2(self.tSize, currentSize - 1, journal);
  }
}));
var removeAll = dual(2, (self, keys10) => effect3((journal) => {
  const iterator = keys10[Symbol.iterator]();
  let next5;
  while ((next5 = iterator.next()) && !next5.done) {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const index = indexOf(next5.value, buckets.chunk.length);
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const [toRemove, toRetain] = partition3(bucket, (entry) => equals(next5.value)(entry[0]));
    if (isNonEmpty2(toRemove)) {
      const currentSize = unsafeGet9(self.tSize, journal);
      unsafeSet2(buckets.chunk[index], toRetain, journal);
      unsafeSet2(self.tSize, currentSize - 1, journal);
    }
  }
}));
var removeIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => effect3((journal) => {
  const discard2 = options?.discard === true;
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity7 = buckets.chunk.length;
  const removed = [];
  let index = 0;
  let newSize = 0;
  while (index < capacity7) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const iterator = bucket[Symbol.iterator]();
    let next5;
    let newBucket = empty6();
    while ((next5 = iterator.next()) && !next5.done) {
      const [k2, v2] = next5.value;
      if (!predicate(k2, v2)) {
        newBucket = prepend3(newBucket, next5.value);
        newSize = newSize + 1;
      } else {
        if (!discard2) {
          removed.push([k2, v2]);
        }
      }
    }
    unsafeSet2(buckets.chunk[index], newBucket, journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (!discard2) {
    return removed;
  }
}));
var retainIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => removeIf(self, (key, value6) => !predicate(key, value6), options));
var set16 = dual(3, (self, key, value6) => {
  const resize = (journal, buckets) => {
    const capacity7 = buckets.chunk.length;
    const newCapacity = capacity7 << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => empty6());
    let index = 0;
    while (index < capacity7) {
      const pairs = unsafeGet9(buckets.chunk[index], journal);
      const iterator = pairs[Symbol.iterator]();
      let next5;
      while ((next5 = iterator.next()) && !next5.done) {
        const newIndex2 = indexOf(next5.value[0], newCapacity);
        newBuckets[newIndex2] = prepend3(newBuckets[newIndex2], next5.value);
      }
      index = index + 1;
    }
    const newIndex = indexOf(key, newCapacity);
    newBuckets[newIndex] = prepend3(newBuckets[newIndex], [key, value6]);
    const newArray = [];
    index = 0;
    while (index < newCapacity) {
      newArray[index] = new TRefImpl(newBuckets[index]);
      index = index + 1;
    }
    const newTArray = new TArrayImpl(newArray);
    unsafeSet2(self.tBuckets, newTArray, journal);
  };
  return effect3((journal) => {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const capacity7 = buckets.chunk.length;
    const index = indexOf(key, capacity7);
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const shouldUpdate = some6(bucket, (entry) => equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = map7(bucket, (entry) => equals(key)(entry[0]) ? [key, value6] : entry);
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    } else {
      const newSize = unsafeGet9(self.tSize, journal) + 1;
      unsafeSet2(self.tSize, newSize, journal);
      if (capacity7 * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = prepend3(bucket, [key, value6]);
        unsafeSet2(buckets.chunk[index], newBucket, journal);
      }
    }
  });
});
var setIfAbsent = dual(3, (self, key, value6) => flatMap18(get29(self, key), match2({
  onNone: () => set16(self, key, value6),
  onSome: () => void_9
})));
var takeFirst = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity7 = buckets.chunk.length;
  const size23 = unsafeGet9(self.tSize, journal);
  let result = none2();
  let index = 0;
  while (index < capacity7 && isNone2(result)) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const recreate = some6(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty6();
      let next5;
      while ((next5 = iterator.next()) && !next5.done && isNone2(result)) {
        const option6 = pf(next5.value[0], next5.value[1]);
        if (isSome2(option6) && isNone2(result)) {
          result = option6;
        } else {
          newBucket = prepend3(newBucket, next5.value);
        }
      }
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    }
    index = index + 1;
  }
  if (isSome2(result)) {
    unsafeSet2(self.tSize, size23 - 1, journal);
  }
  return result;
}), collect3((option6) => isSome2(option6) ? some2(option6.value) : none2())));
var takeFirstSTM = dual(2, (self, pf) => pipe(findSTM(self, (key, value6) => map29(pf(key, value6), (a) => [key, a])), collect3((option6) => isSome2(option6) ? some2(option6.value) : none2()), flatMap18((entry) => as9(remove14(self, entry[0]), entry[1]))));
var takeSome = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity7 = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index = 0;
  while (index < capacity7) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const recreate = some6(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty6();
      let next5;
      while ((next5 = iterator.next()) && !next5.done) {
        const option6 = pf(next5.value[0], next5.value[1]);
        if (isSome2(option6)) {
          builder.push(option6.value);
        } else {
          newBucket = prepend3(newBucket, next5.value);
          newSize = newSize + 1;
        }
      }
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return some2(builder);
  }
  return none2();
}), collect3((option6) => isSome2(option6) ? some2(option6.value) : none2())));
var takeSomeSTM = dual(2, (self, pf) => pipe(findAllSTM(self, (key, value6) => map29(pf(key, value6), (a) => [key, a])), map29((chunk4) => isNonEmptyArray2(chunk4) ? some2(chunk4) : none2()), collect3((option6) => isSome2(option6) ? some2(option6.value) : none2()), flatMap18((entries3) => as9(removeAll(self, entries3.map((entry) => entry[0])), map6(entries3, (entry) => entry[1])))));
var toReadonlyArray2 = (self) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity7 = buckets.chunk.length;
  const builder = [];
  let index = 0;
  while (index < capacity7) {
    const bucket = buckets.chunk[index];
    for (const entry of unsafeGet9(bucket, journal)) {
      builder.push(entry);
    }
    index = index + 1;
  }
  return builder;
});
var transform4 = dual(2, (self, f2) => effect3((journal) => {
  const buckets = pipe(self.tBuckets, unsafeGet9(journal));
  const capacity7 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity7
  }, () => empty6());
  let newSize = 0;
  let index = 0;
  while (index < capacity7) {
    const bucket = buckets.chunk[index];
    const pairs = unsafeGet9(bucket, journal);
    const iterator = pairs[Symbol.iterator]();
    let next5;
    while ((next5 = iterator.next()) && !next5.done) {
      const newPair = f2(next5.value[0], next5.value[1]);
      const index2 = indexOf(newPair[0], capacity7);
      const newBucket = newBuckets[index2];
      if (!some6(newBucket, (entry) => equals(entry[0], newPair[0]))) {
        newBuckets[index2] = prepend3(newBucket, newPair);
        newSize = newSize + 1;
      }
    }
    index = index + 1;
  }
  index = 0;
  while (index < capacity7) {
    unsafeSet2(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}));
var transformSTM2 = dual(2, (self, f2) => pipe(flatMap18(toReadonlyArray2(self), forEach18((entry) => f2(entry[0], entry[1]))), flatMap18((newData) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity7 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity7
  }, () => empty6());
  const iterator = newData[Symbol.iterator]();
  let newSize = 0;
  let next5;
  while ((next5 = iterator.next()) && !next5.done) {
    const index2 = indexOf(next5.value[0], capacity7);
    const newBucket = newBuckets[index2];
    if (!some6(newBucket, (entry) => equals(entry[0])(next5.value[0]))) {
      newBuckets[index2] = prepend3(newBucket, next5.value);
      newSize = newSize + 1;
    }
  }
  let index = 0;
  while (index < capacity7) {
    unsafeSet2(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}))));
var transformValues = dual(2, (self, f2) => transform4(self, (key, value6) => [key, f2(value6)]));
var transformValuesSTM = dual(2, (self, f2) => transformSTM2(self, (key, value6) => map29(f2(value6), (value7) => [key, value7])));
var updateWith2 = dual(3, (self, key, f2) => flatMap18(get29(self, key), (option6) => match2(f2(option6), {
  onNone: () => as9(remove14(self, key), none2()),
  onSome: (value6) => as9(set16(self, key, value6), some2(value6))
})));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var TPriorityQueueSymbolKey = "effect/TPriorityQueue";
var TPriorityQueueTypeId = Symbol.for(TPriorityQueueSymbolKey);
var tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TPriorityQueueImpl = class {
  ref;
  [TPriorityQueueTypeId] = tPriorityQueueVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var offer7 = dual(2, (self, value6) => update6(self.ref, (map40) => set14(map40, value6, match2(get26(map40, value6), {
  onNone: () => of(value6),
  onSome: prepend2(value6)
}))));
var offerAll5 = dual(2, (self, values7) => update6(self.ref, (map40) => fromIterable(values7).reduce((map41, value6) => set14(map41, value6, match2(get26(map41, value6), {
  onNone: () => of(value6),
  onSome: prepend2(value6)
})), map40)));
var removeIf2 = dual(2, (self, predicate) => retainIf2(self, (a) => !predicate(a)));
var retainIf2 = dual(2, (self, predicate) => update6(self.ref, (map40) => reduce18(map40, empty39(getOrder3(map40)), (map41, value6, key) => {
  const filtered = filter4(value6, predicate);
  return filtered.length > 0 ? set14(map41, key, filtered) : remove13(map41, key);
})));
var takeUpTo4 = dual(2, (self, n) => modify10(self.ref, (map40) => {
  const builder = [];
  const iterator = map40[Symbol.iterator]();
  let updated = map40;
  let index = 0;
  let next5;
  while ((next5 = iterator.next()) && !next5.done && index < n) {
    const [key, value6] = next5.value;
    const [left3, right3] = pipe(value6, splitAt(n - index));
    for (const value7 of left3) {
      builder.push(value7);
    }
    if (right3.length > 0) {
      updated = set14(updated, key, right3);
    } else {
      updated = remove13(updated, key);
    }
    index = index + left3.length;
  }
  return [builder, updated];
}));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tRandom.js
var TRandomSymbolKey = "effect/TRandom";
var TRandomTypeId = Symbol.for(TRandomSymbolKey);
var randomInteger = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
var randomIntegerBetween = (low, high) => {
  return (state) => {
    const prng = new PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
var randomNumber = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
var withState = (state, f2) => {
  return pipe(state, modify10(f2));
};
var shuffleWith2 = (iterable, nextIntBounded) => {
  const swap3 = (buffer3, index1, index2) => pipe(buffer3, get28(index1), flatMap18((tmp) => pipe(buffer3, updateSTM(index1, () => pipe(buffer3, get28(index2))), zipRight9(pipe(buffer3, update7(index2, () => tmp))))));
  return pipe(fromIterable17(iterable), flatMap18((buffer3) => {
    const array7 = [];
    for (let i = array7.length; i >= 2; i = i - 1) {
      array7.push(i);
    }
    return pipe(array7, forEach18((n) => pipe(nextIntBounded(n), flatMap18((k2) => swap3(buffer3, n - 1, k2))), {
      discard: true
    }), zipRight9(toArray4(buffer3)));
  }));
};
var Tag3 = GenericTag("effect/TRandom");
var TRandomImpl = class {
  state;
  [TRandomTypeId] = TRandomTypeId;
  constructor(state) {
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = flatMap18(this.next, (n) => succeed12(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  next;
  nextBoolean;
  nextInt;
  nextRange(min9, max11) {
    return flatMap18(this.next, (n) => succeed12((max11 - min9) * n + min9));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
var live = effect(Tag3, pipe(make54(new PCGRandom(Math.random() * 4294967296 >>> 0).getState()), map29((seed) => new TRandomImpl(seed)), commit2));
var next4 = flatMap18(Tag3, (random3) => random3.next);
var nextBoolean2 = flatMap18(Tag3, (random3) => random3.nextBoolean);
var nextInt2 = flatMap18(Tag3, (random3) => random3.nextInt);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var TReentrantLockSymbolKey = "effect/TReentrantLock";
var TReentrantLockTypeId = Symbol.for(TReentrantLockSymbolKey);
var WriteLockTypeId = Symbol.for("effect/TReentrantLock/WriteLock");
var ReadLockTypeId = Symbol.for("effect/TReentrantLock/ReadLock");
var TReentranLockImpl = class {
  state;
  [TReentrantLockTypeId] = TReentrantLockTypeId;
  constructor(state) {
    this.state = state;
  }
};
var ReadLock = class {
  readers;
  [ReadLockTypeId] = ReadLockTypeId;
  constructor(readers) {
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId3) {
    return getOrElse2(get8(this.readers, fiberId3), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
};
var WriteLock = class {
  readLocks;
  writeLocks;
  fiberId;
  [WriteLockTypeId] = WriteLockTypeId;
  constructor(readLocks2, writeLocks2, fiberId3) {
    this.readLocks = readLocks2;
    this.writeLocks = writeLocks2;
    this.fiberId = fiberId3;
  }
  readLocksHeld(fiberId3) {
    return equals(fiberId3)(this.fiberId) ? this.readLocks : 0;
  }
  writeLocksHeld(fiberId3) {
    return equals(fiberId3)(this.fiberId) ? this.writeLocks : 0;
  }
};
var isReadLock = (lock2) => {
  return ReadLockTypeId in lock2;
};
var isWriteLock = (lock2) => {
  return WriteLockTypeId in lock2;
};
var emptyReadLock = new ReadLock(empty10());
var makeReadLock = (fiberId3, count5) => {
  if (count5 <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(make16([fiberId3, count5]));
};
var noOtherHolder = (readLock2, fiberId3) => {
  return isEmpty3(readLock2.readers) || size4(readLock2.readers) === 1 && has5(readLock2.readers, fiberId3);
};
var adjustReadLock = (readLock2, fiberId3, adjustment) => {
  const total = readLock2.readLocksHeld(fiberId3);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(remove7(readLock2.readers, fiberId3));
  }
  return new ReadLock(set4(readLock2.readers, fiberId3, newTotal));
};
var adjustRead = (self, delta) => withSTMRuntime((runtime5) => {
  const lock2 = unsafeGet9(self.state, runtime5.journal);
  if (isReadLock(lock2)) {
    const result = adjustReadLock(lock2, runtime5.fiberId, delta);
    unsafeSet2(self.state, result, runtime5.journal);
    return succeed12(result.readLocksHeld(runtime5.fiberId));
  }
  if (isWriteLock(lock2) && equals(runtime5.fiberId)(lock2.fiberId)) {
    const newTotal = lock2.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${threadName2(runtime5.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    unsafeSet2(self.state, new WriteLock(newTotal, lock2.writeLocks, runtime5.fiberId), runtime5.journal);
    return succeed12(newTotal);
  }
  return retry4;
});
var acquireRead = (self) => adjustRead(self, 1);
var acquireWrite = (self) => withSTMRuntime((runtime5) => {
  const lock2 = unsafeGet9(self.state, runtime5.journal);
  if (isReadLock(lock2) && noOtherHolder(lock2, runtime5.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock2.readLocksHeld(runtime5.fiberId), 1, runtime5.fiberId), runtime5.journal);
    return succeed12(1);
  }
  if (isWriteLock(lock2) && equals(runtime5.fiberId)(lock2.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock2.readLocks, lock2.writeLocks + 1, runtime5.fiberId), runtime5.journal);
    return succeed12(lock2.writeLocks + 1);
  }
  return retry4;
});
var make82 = map29(make54(emptyReadLock), (readLock2) => new TReentranLockImpl(readLock2));
var releaseRead = (self) => adjustRead(self, -1);
var releaseWrite = (self) => withSTMRuntime((runtime5) => {
  const lock2 = unsafeGet9(self.state, runtime5.journal);
  if (isWriteLock(lock2) && lock2.writeLocks === 1 && equals(runtime5.fiberId)(lock2.fiberId)) {
    const result = makeReadLock(lock2.fiberId, lock2.readLocks);
    unsafeSet2(self.state, result, runtime5.journal);
    return succeed12(result.writeLocksHeld(runtime5.fiberId));
  }
  if (isWriteLock(lock2) && equals(runtime5.fiberId)(lock2.fiberId)) {
    const result = new WriteLock(lock2.readLocks, lock2.writeLocks - 1, runtime5.fiberId);
    unsafeSet2(self.state, result, runtime5.journal);
    return succeed12(result.writeLocksHeld(runtime5.fiberId));
  }
  throw new Error(`Defect: Fiber ${threadName2(runtime5.fiberId)} releasing write lock it does not hold`);
});
var withLock = dual(2, (effect4, self) => withWriteLock(effect4, self));
var withReadLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight6(restore(commit2(acquireRead(self))), ensuring4(effect4, commit2(releaseRead(self))))));
var withWriteLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight6(restore(commit2(acquireWrite(self))), ensuring4(effect4, commit2(releaseWrite(self))))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TRef.js
var TRefTypeId2 = TRefTypeId;
var get30 = get17;
var set17 = set9;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var TSemaphoreSymbolKey = "effect/TSemaphore";
var TSemaphoreTypeId = Symbol.for(TSemaphoreSymbolKey);
var TSemaphoreImpl = class {
  permits;
  [TSemaphoreTypeId] = TSemaphoreTypeId;
  constructor(permits) {
    this.permits = permits;
  }
};
var acquireN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value6 = unsafeGet9(self.permits, driver3.journal);
  if (value6 < n) {
    return retry7;
  } else {
    return succeed19(unsafeSet2(self.permits, value6 - n, driver3.journal));
  }
}));
var releaseN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current2 = unsafeGet9(self.permits, driver3.journal);
  return succeed19(unsafeSet2(self.permits, current2 + n, driver3.journal));
}));
var withPermit = dual(2, (self, semaphore) => withPermits(self, semaphore, 1));
var withPermits = dual(3, (self, semaphore, permits) => uninterruptibleMask3((restore) => zipRight6(restore(commit2(acquireN(permits)(semaphore))), ensuring4(self, commit2(releaseN(permits)(semaphore))))));
var withPermitsScoped = dual(2, (self, permits) => acquireReleaseInterruptible2(commit2(acquireN(self, permits)), () => commit2(releaseN(self, permits))));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tSet.js
var TSetSymbolKey = "effect/TSet";
var TSetTypeId = Symbol.for(TSetSymbolKey);
var tSetVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TSetImpl = class {
  tMap;
  [TSetTypeId] = tSetVariance;
  constructor(tMap) {
    this.tMap = tMap;
  }
};
var isTSet = (u) => hasProperty(u, TSetTypeId);
var add9 = dual(2, (self, value6) => set16(self.tMap, value6, void 0));
var difference7 = dual(2, (self, other) => flatMap18(toHashSet(other), (values7) => removeIf3(self, (value6) => has4(values7, value6), {
  discard: true
})));
var forEach21 = dual(2, (self, f2) => reduceSTM3(self, void 0, (_2, value6) => f2(value6)));
var has15 = dual(2, (self, value6) => has14(self.tMap, value6));
var intersection7 = dual(2, (self, other) => flatMap18(toHashSet(other), (values7) => pipe(self, retainIf3((value6) => pipe(values7, has4(value6)), {
  discard: true
}))));
var reduce21 = dual(3, (self, zero3, f2) => reduce20(self.tMap, zero3, (acc, _2, key) => f2(acc, key)));
var reduceSTM3 = dual(3, (self, zero3, f2) => reduceSTM2(self.tMap, zero3, (acc, _2, key) => f2(acc, key)));
var remove15 = dual(2, (self, value6) => remove14(self.tMap, value6));
var removeAll2 = dual(2, (self, iterable) => removeAll(self.tMap, iterable));
var removeIf3 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => options?.discard === true ? removeIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(removeIf(self.tMap, (key) => predicate(key)), map29(map6((entry) => entry[0]))));
var retainIf3 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => options?.discard === true ? retainIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(retainIf(self.tMap, (key) => predicate(key)), map29(map6((entry) => entry[0]))));
var takeFirst2 = dual(2, (self, pf) => takeFirst(self.tMap, (key) => pf(key)));
var takeFirstSTM2 = dual(2, (self, pf) => takeFirstSTM(self.tMap, (key) => pf(key)));
var takeSome2 = dual(2, (self, pf) => takeSome(self.tMap, (key) => pf(key)));
var takeSomeSTM2 = dual(2, (self, pf) => takeSomeSTM(self.tMap, (key) => pf(key)));
var toHashSet = (self) => reduce21(self, empty9(), (acc, value6) => pipe(acc, add4(value6)));
var transform5 = dual(2, (self, f2) => transform4(self.tMap, (key, value6) => [f2(key), value6]));
var transformSTM3 = dual(2, (self, f2) => transformSTM2(self.tMap, (key, value6) => map29(f2(key), (a) => [a, value6])));
var union12 = dual(2, (self, other) => forEach21(other, (value6) => add9(self, value6)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/stm/tSubscriptionRef.js
var TSubscriptionRefSymbolKey = "effect/TSubscriptionRef";
var TSubscriptionRefTypeId = Symbol.for(TSubscriptionRefSymbolKey);
var TSubscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TDequeueMerge = class {
  first;
  second;
  [TDequeueTypeId2] = tDequeueVariance;
  constructor(first4, second) {
    this.first = first4;
    this.second = second;
  }
  peek = gen5(this, function* () {
    const first4 = yield* this.peekOption;
    if (first4._tag === "Some") {
      return first4.value;
    }
    return yield* retry7;
  });
  peekOption = gen5(this, function* () {
    const first4 = yield* this.first.peekOption;
    if (first4._tag === "Some") {
      return first4;
    }
    const second = yield* this.second.peekOption;
    if (second._tag === "Some") {
      return second;
    }
    return none2();
  });
  take = gen5(this, function* () {
    if (!(yield* this.first.isEmpty)) {
      return yield* this.first.take;
    }
    if (!(yield* this.second.isEmpty)) {
      return yield* this.second.take;
    }
    return yield* retry7;
  });
  takeAll = gen5(this, function* () {
    return [...yield* this.first.takeAll, ...yield* this.second.takeAll];
  });
  takeUpTo(max11) {
    return gen5(this, function* () {
      const first4 = yield* this.first.takeUpTo(max11);
      if (first4.length >= max11) {
        return first4;
      }
      return [...first4, ...yield* this.second.takeUpTo(max11 - first4.length)];
    });
  }
  capacity() {
    return this.first.capacity() + this.second.capacity();
  }
  size = gen5(this, function* () {
    return (yield* this.first.size) + (yield* this.second.size);
  });
  isFull = gen5(this, function* () {
    return (yield* this.first.isFull) && (yield* this.second.isFull);
  });
  isEmpty = gen5(this, function* () {
    return (yield* this.first.isEmpty) && (yield* this.second.isEmpty);
  });
  shutdown = gen5(this, function* () {
    yield* this.first.shutdown;
    yield* this.second.shutdown;
  });
  isShutdown = gen5(this, function* () {
    return (yield* this.first.isShutdown) && (yield* this.second.isShutdown);
  });
  awaitShutdown = gen5(this, function* () {
    yield* this.first.awaitShutdown;
    yield* this.second.awaitShutdown;
  });
};
var TSubscriptionRefImpl = class {
  ref;
  pubsub;
  [TSubscriptionRefTypeId] = TSubscriptionRefVariance;
  [TRefTypeId2] = tRefVariance;
  constructor(ref, pubsub) {
    this.ref = ref;
    this.pubsub = pubsub;
  }
  get todos() {
    return this.ref.todos;
  }
  get versioned() {
    return this.ref.versioned;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return gen5(this, function* () {
      const first4 = yield* unbounded8();
      yield* offer5(first4, yield* get30(this.ref));
      return new TDequeueMerge(first4, yield* subscribe4(this.pubsub));
    });
  }
  modify(f2) {
    return pipe(get30(this.ref), map34(f2), flatMap21(([b2, a]) => pipe(set17(this.ref, a), as11(b2), zipLeft10(publish4(this.pubsub, a)))));
  }
};
var set18 = dual(2, (self, value6) => self.modify(() => [void 0, value6]));
var getAndSet5 = dual(2, (self, value6) => self.modify((a) => [a, value6]));
var getAndUpdate5 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome4 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b2) => [a, b2]
})));
var setAndGet5 = dual(2, (self, value6) => self.modify(() => [value6, value6]));
var modify12 = dual(2, (self, f2) => self.modify(f2));
var modifySome4 = dual(3, (self, fallback, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [fallback, a],
  onSome: (b2) => b2
})));
var update8 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet5 = dual(2, (self, f2) => self.modify((a) => {
  const b2 = f2(a);
  return [b2, b2];
}));
var updateSome4 = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b2) => b2
})]));
var updateSomeAndGet4 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b2) => [b2, b2]
})));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotationSymbolKey = "effect/TestAnnotation";
var TestAnnotationTypeId = Symbol.for(TestAnnotationSymbolKey);
var TestAnnotationImpl = class {
  identifier;
  initial;
  combine;
  [TestAnnotationTypeId] = {
    _A: (_2) => _2
  };
  constructor(identifier2, initial, combine18) {
    this.identifier = identifier2;
    this.initial = initial;
    this.combine = combine18;
  }
  [symbol2]() {
    return pipe(hash(TestAnnotationSymbolKey), combine2(hash(this.identifier)), cached(this));
  }
  [symbol3](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
};
var isTestAnnotation = (u) => hasProperty(u, TestAnnotationTypeId);
var make88 = (identifier2, initial, combine18) => {
  return new TestAnnotationImpl(identifier2, initial, combine18);
};
var compose6 = (left3, right3) => {
  if (isLeft2(left3) && isLeft2(right3)) {
    return left2(left3.left + right3.left);
  }
  if (isRight2(left3) && isRight2(right3)) {
    return right2(pipe(left3.right, appendAll3(right3.right)));
  }
  if (isRight2(left3) && isLeft2(right3)) {
    return right3;
  }
  if (isLeft2(left3) && isRight2(right3)) {
    return right3;
  }
  throw new Error(getBugErrorMessage("TestAnnotation.compose"));
};
var fibers = make88("fibers", left2(0), compose6);
var ignored = make88("ignored", 0, (a, b2) => a + b2);
var repeated2 = make88("repeated", 0, (a, b2) => a + b2);
var retried = make88("retried", 0, (a, b2) => a + b2);
var tagged4 = make88("tagged", empty9(), (a, b2) => pipe(a, union6(b2)));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMapTypeId = Symbol.for("effect/TestAnnotationMap");
var TestAnnotationMapImpl = class {
  map;
  [TestAnnotationMapTypeId] = TestAnnotationMapTypeId;
  constructor(map40) {
    this.map = map40;
  }
};
var empty44 = () => new TestAnnotationMapImpl(empty10());
var make89 = (map40) => {
  return new TestAnnotationMapImpl(map40);
};
var overwrite = dual(3, (self, key, value6) => make89(set4(self.map, key, value6)));
var update9 = dual(3, (self, key, f2) => {
  let value6 = key.initial;
  if (has5(self.map, key)) {
    value6 = unsafeGet6(self.map, key);
  }
  return overwrite(self, key, f2(value6));
});
var get32 = dual(2, (self, key) => {
  if (has5(self.map, key)) {
    return unsafeGet6(self.map, key);
  }
  return key.initial;
});
var annotate = dual(3, (self, key, value6) => update9(self, key, (_2) => key.combine(_2, value6)));
var combine17 = dual(2, (self, that) => {
  let result = self.map;
  for (const entry of that.map) {
    if (has5(result, entry[0])) {
      const value6 = get8(result, entry[0]);
      result = set4(result, entry[0], entry[0].combine(value6, entry[1]));
    } else {
      result = set4(result, entry[0], entry[1]);
    }
  }
  return make89(result);
});

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotationsTypeId = Symbol.for("effect/TestAnnotations");
var AnnotationsImpl = class {
  ref;
  [TestAnnotationsTypeId] = TestAnnotationsTypeId;
  constructor(ref) {
    this.ref = ref;
  }
  get(key) {
    return map14(get12(this.ref), get32(key));
  }
  annotate(key, value6) {
    return update4(this.ref, annotate(key, value6));
  }
  get supervisedFibers() {
    return descriptorWith((descriptor2) => flatMap11(this.get(fibers), (either8) => {
      switch (either8._tag) {
        case "Left": {
          return succeed(empty30(Order6));
        }
        case "Right": {
          return pipe(either8.right, forEachSequential((ref) => sync(() => get7(ref))), map14(reduce3(empty30(Order6), (a, b2) => union7(a, b2))), map14(filter10((fiber) => !equals(fiber.id(), descriptor2.id))));
        }
      }
    }));
  }
};
var TestAnnotations = GenericTag("effect/Annotations");
var make90 = (ref) => new AnnotationsImpl(ref);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START = "Start";
var OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
var OP_SUSPENDED_WARNING_DATA_DONE = "Done";
var start3 = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
var pending4 = (fiber) => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
var done12 = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
var isStart = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
var isPending2 = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START = "Start";
var OP_WARNING_DATA_PENDING = "Pending";
var OP_WARNING_DATA_DONE = "Done";
var start4 = {
  _tag: OP_WARNING_DATA_START
};
var pending5 = (fiber) => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
var done13 = {
  _tag: OP_WARNING_DATA_DONE
};
var isStart2 = (self) => {
  return self._tag === OP_WARNING_DATA_START;
};
var isPending3 = (self) => {
  return self._tag === OP_WARNING_DATA_PENDING;
};

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestLive.js
var TestLiveTypeId = Symbol.for("effect/TestLive");
var TestLive = GenericTag("effect/TestLive");
var LiveImpl = class {
  services;
  [TestLiveTypeId] = TestLiveTypeId;
  constructor(services) {
    this.services = services;
  }
  provide(effect4) {
    return fiberRefLocallyWith(currentServices, merge3(this.services))(effect4);
  }
};
var make91 = (services) => new LiveImpl(services);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestClock.js
var makeData = (instant, sleeps) => ({
  instant,
  sleeps
});
var TestClock = GenericTag("effect/TestClock");
var warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
var TestClockImpl = class {
  clockState;
  live;
  annotations;
  warningState;
  suspendedWarningState;
  [ClockTypeId] = ClockTypeId;
  constructor(clockState, live5, annotations3, warningState, suspendedWarningState) {
    this.clockState = clockState;
    this.live = live5;
    this.annotations = annotations3;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = map14(get11(this.clockState), (data) => data.instant);
    this.currentTimeNanos = map14(get11(this.clockState), (data) => BigInt(data.instant * 1e6));
  }
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis() {
    return unsafeGet7(this.clockState).instant;
  }
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos() {
    return BigInt(unsafeGet7(this.clockState).instant * 1e6);
  }
  /**
   * Returns the current clock time in milliseconds.
   */
  currentTimeMillis;
  /**
   * Returns the current clock time in nanoseconds.
   */
  currentTimeNanos;
  /**
   * Saves the `TestClock`'s current state in an effect which, when run, will
   * restore the `TestClock` state to the saved state.
   */
  get save() {
    return map14(get11(this.clockState), (data) => set6(this.clockState, data));
  }
  /**
   * Sets the current clock time to the specified instant. Any effects that
   * were scheduled to occur on or before the new time will be run in order.
   */
  setTime(instant) {
    return zipRight2(this.warningDone(), this.run(() => instant));
  }
  /**
   * Semantically blocks the current fiber until the clock time is equal to or
   * greater than the specified duration. Once the clock time is adjusted to
   * on or after the duration, the fiber will automatically be resumed.
   */
  sleep(durationInput) {
    const duration3 = decode(durationInput);
    return flatMap11(deferredMake(), (deferred) => pipe(modify6(this.clockState, (data) => {
      const end6 = data.instant + toMillis(duration3);
      if (end6 > data.instant) {
        return [true, makeData(data.instant, pipe(data.sleeps, prepend3([end6, deferred])))];
      }
      return [false, data];
    }), flatMap11((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight2(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid2))));
  }
  /**
   * Returns a list of the times at which all queued effects are scheduled to
   * resume.
   */
  get sleeps() {
    return map14(get11(this.clockState), (data) => map7(data.sleeps, (_2) => _2[0]));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjust(durationInput) {
    const duration3 = decode(durationInput);
    return zipRight2(this.warningDone(), this.run((n) => n + toMillis(duration3)));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjustWith(durationInput) {
    const duration3 = decode(durationInput);
    return (effect4) => zipLeftOptions(effect4, this.adjust(duration3), {
      concurrent: true
    });
  }
  /**
   * Returns a set of all fibers in this test.
   */
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
   * Captures a "snapshot" of the identifier and status of all fibers in this
   * test other than the current fiber. Fails with the `void` value if any of
   * these fibers are not done or suspended. Note that because we cannot
   * synchronize on the status of multiple fibers at the same time this
   * snapshot may not be fully consistent.
   */
  freeze() {
    return flatMap11(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce12(empty10(), (map40, fiber) => pipe(fiber.status, flatMap11((status2) => {
      if (isDone3(status2)) {
        return succeed(set4(map40, fiber.id(), status2));
      }
      if (isSuspended2(status2)) {
        return succeed(set4(map40, fiber.id(), status2));
      }
      return fail2(void 0);
    })))));
  }
  /**
   * Forks a fiber that will display a warning message if a test is using time
   * but is not advancing the `TestClock`.
   */
  warningStart() {
    return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some2(pipe(this.live.provide(pipe(logWarning(warning), delay2(seconds(5)))), interruptible2, fork, map14((fiber) => pending5(fiber)))) : none2());
  }
  /**
   * Cancels the warning message that is displayed if a test is using time but
   * is not advancing the `TestClock`.
   */
  warningDone() {
    return updateSomeEffect(this.warningState, (warningData) => {
      if (isStart2(warningData)) {
        return some2(succeed(done13));
      }
      if (isPending3(warningData)) {
        return some2(pipe(interruptFiber(warningData.fiber), as3(done13)));
      }
      return none2();
    });
  }
  yieldTimer = async_((resume2) => {
    const timer2 = setTimeout(() => {
      resume2(void_3);
    }, 0);
    return sync(() => clearTimeout(timer2));
  });
  /**
   * Returns whether all descendants of this fiber are done or suspended.
   */
  suspended() {
    return pipe(this.freeze(), zip5(pipe(this.yieldTimer, zipRight2(this.freeze()))), flatMap11(([first4, last6]) => equals(first4, last6) ? succeed(first4) : fail2(void 0)));
  }
  /**
   * Polls until all descendants of this fiber are done or suspended.
   */
  awaitSuspended() {
    return pipe(this.suspendedWarningStart(), zipRight2(pipe(this.suspended(), zipWith6(pipe(this.yieldTimer, zipRight2(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight2(this.suspendedWarningDone()));
  }
  /**
   * Forks a fiber that will display a warning message if a test is advancing
   * the `TestClock` but a fiber is not suspending.
   */
  suspendedWarningStart() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isStart(suspendedWarningData)) {
        return some2(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight2(set6(this.suspendedWarningState, done12)), delay2(seconds(5)))), interruptible2, fork, map14((fiber) => pending4(fiber))));
      }
      return none2();
    });
  }
  /**
   * Cancels the warning message that is displayed if a test is advancing the
   * `TestClock` but a fiber is not suspending.
   */
  suspendedWarningDone() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isPending2(suspendedWarningData)) {
        return some2(pipe(interruptFiber(suspendedWarningData.fiber), as3(start3)));
      }
      return none2();
    });
  }
  /**
   * Runs all effects scheduled to occur on or before the specified instant,
   * which may depend on the current time, in order.
   */
  run(f2) {
    return pipe(this.awaitSuspended(), zipRight2(pipe(modify6(this.clockState, (data) => {
      const end6 = f2(data.instant);
      const sorted = pipe(data.sleeps, sort2(pipe(Order, mapInput3((_2) => _2[0]))));
      if (isNonEmpty2(sorted)) {
        const [instant, deferred] = headNonEmpty2(sorted);
        if (instant <= end6) {
          return [some2([end6, deferred]), makeData(instant, tailNonEmpty2(sorted))];
        }
      }
      return [none2(), makeData(end6, data.sleeps)];
    }), flatMap11((option6) => {
      switch (option6._tag) {
        case "None": {
          return void_3;
        }
        case "Some": {
          const [end6, deferred] = option6.value;
          return pipe(deferredSucceed(deferred, void 0), zipRight2(yieldNow()), zipRight2(this.run(() => end6)));
        }
      }
    }))));
  }
};
var live2 = (data) => scoped(TestClock, gen2(function* ($) {
  const live5 = yield* $(TestLive);
  const annotations3 = yield* $(TestAnnotations);
  const clockState = yield* $(sync(() => unsafeMake6(data)));
  const warningState = yield* $(makeSynchronized(start4));
  const suspendedWarningState = yield* $(makeSynchronized(start3));
  const testClock = new TestClockImpl(clockState, live5, annotations3, warningState, suspendedWarningState);
  yield* $(withClockScoped(testClock));
  yield* $(addFinalizer(() => zipRight2(testClock.warningDone(), testClock.suspendedWarningDone())));
  return testClock;
}));
var defaultTestClock = live2(makeData((/* @__PURE__ */ new Date(0)).getTime(), empty6()));
var adjustWith = dual(2, (effect4, durationInput) => {
  const duration3 = decode(durationInput);
  return testClockWith((testClock) => testClock.adjustWith(duration3)(effect4));
});
var testClockWith = (f2) => fiberRefGetWith(currentServices, (services) => f2(pipe(services, get4(clockTag))));
var currentTimeMillis3 = testClockWith((testClock) => testClock.currentTimeMillis);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestConfig.js
var TestConfig = GenericTag("effect/TestConfig");
var make92 = (params) => params;

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestSized.js
var TestSizedTypeId = Symbol.for("effect/TestSized");
var TestSized = GenericTag("effect/TestSized");
var SizedImpl = class {
  fiberRef;
  [TestSizedTypeId] = TestSizedTypeId;
  constructor(fiberRef) {
    this.fiberRef = fiberRef;
  }
  get size() {
    return fiberRefGet(this.fiberRef);
  }
  withSize(size23) {
    return (effect4) => fiberRefLocally(this.fiberRef, size23)(effect4);
  }
};
var make93 = (size23) => new SizedImpl(fiberRefUnsafeMake(size23));
var fromFiberRef = (fiberRef) => new SizedImpl(fiberRef);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestServices.js
var liveServices2 = pipe(make6(TestAnnotations, make90(unsafeMake6(empty44()))), add2(TestLive, make91(liveServices)), add2(TestSized, make93(100)), add2(TestConfig, make92({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var currentServices2 = fiberRefUnsafeMakeContext(liveServices2);
var withAnnotations = dual(2, (effect4, annotations3) => fiberRefLocallyWith(currentServices2, add2(TestAnnotations, annotations3))(effect4));
var withAnnotationsScoped = (annotations3) => fiberRefLocallyScopedWith(currentServices2, add2(TestAnnotations, annotations3));
var annotationsLayer = () => scoped(TestAnnotations, pipe(sync(() => unsafeMake6(empty44())), map14(make90), tap2(withAnnotationsScoped)));
var liveWith = (f2) => fiberRefGetWith(currentServices2, (services) => f2(get4(services, TestLive)));
var live3 = liveWith(succeed);
var withLive = dual(2, (effect4, live5) => fiberRefLocallyWith(currentServices2, add2(TestLive, live5))(effect4));
var withLiveScoped = (live5) => fiberRefLocallyScopedWith(currentServices2, add2(TestLive, live5));
var liveLayer = () => scoped(TestLive, pipe(context2(), map14(make91), tap2(withLiveScoped)));
var provideLive = (effect4) => liveWith((live5) => live5.provide(effect4));
var provideWithLive = dual(2, (self, f2) => fiberRefGetWith(currentServices, (services) => provideLive(f2(fiberRefLocally(currentServices, services)(self)))));
var sizedWith = (f2) => fiberRefGetWith(currentServices2, (services) => f2(get4(services, TestSized)));
var sized = sizedWith(succeed);
var withSized = dual(2, (effect4, sized2) => fiberRefLocallyWith(currentServices2, add2(TestSized, sized2))(effect4));
var withSizedScoped = (sized2) => fiberRefLocallyScopedWith(currentServices2, add2(TestSized, sized2));
var sizedLayer = (size23) => scoped(TestSized, pipe(fiberRefMake(size23), map14(fromFiberRef), tap2(withSizedScoped)));
var size21 = sizedWith((sized2) => sized2.size);
var withSize = dual(2, (effect4, size23) => sizedWith((sized2) => sized2.withSize(size23)(effect4)));
var testConfigWith = (f2) => fiberRefGetWith(currentServices2, (services) => f2(get4(services, TestConfig)));
var testConfig = testConfigWith(succeed);
var withTestConfig = dual(2, (effect4, config2) => fiberRefLocallyWith(currentServices2, add2(TestConfig, config2))(effect4));
var withTestConfigScoped = (config2) => fiberRefLocallyScopedWith(currentServices2, add2(TestConfig, config2));
var testConfigLayer = (params) => scoped(TestConfig, suspend4(() => {
  const testConfig2 = make92(params);
  return pipe(withTestConfigScoped(testConfig2), as3(testConfig2));
}));
var repeats = testConfigWith((config2) => succeed(config2.repeats));
var retries = testConfigWith((config2) => succeed(config2.retries));
var samples = testConfigWith((config2) => succeed(config2.samples));
var shrinks = testConfigWith((config2) => succeed(config2.shrinks));

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/TestContext.js
var live4 = pipe(annotationsLayer(), merge5(liveLayer()), merge5(sizedLayer(100)), merge5(pipe(defaultTestClock, provideMerge(merge5(liveLayer(), annotationsLayer())))), merge5(testConfigLayer({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var LiveContext = syncContext(() => liveServices);
var TestContext = provideMerge(live4, LiveContext);

// node_modules/.pnpm/effect@3.17.13/node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = Symbol.for(TrieSymbolKey);
var trieVariance = {
  /* c8 ignore next */
  _Value: (_2) => _2
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k2, v2) => [k2, v2], () => true);
  },
  [symbol2]() {
    let hash4 = hash(TrieSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isTrie(that)) {
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl5 = (root) => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = root?.count ?? 0;
  return trie;
};
var TrieIterator = class _TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f2, filter18) {
    this.trie = trie;
    this.f = f2;
    this.filter = filter18;
    const root = trie._root !== void 0 ? trie._root : void 0;
    if (root !== void 0) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value6 = node.value;
        if (value6 !== void 0) {
          const key = keyString + node.key;
          if (this.filter(key, value6)) {
            return {
              done: false,
              value: this.f(key, value6)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: void 0
    };
  }
  addToStack(node, keyString) {
    if (node.right !== void 0) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== void 0) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== void 0) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new _TrieIterator(this.trie, this.f, this.filter);
  }
};
var isTrie = (u) => hasProperty(u, TrieTypeId);
var empty45 = () => makeImpl5(void 0);
var insert3 = dual(3, (self, key, value6) => {
  if (key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let n = self._root ?? {
    key: key[0],
    count: 0
  };
  const count5 = n.count + 1;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    nStack.push(n);
    if (c > n.key) {
      dStack.push(1);
      if (n.right === void 0) {
        n = {
          key: c,
          count: count5
        };
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      dStack.push(-1);
      if (n.left === void 0) {
        n = {
          key: c,
          count: count5
        };
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        n.value = value6;
      } else if (n.mid === void 0) {
        dStack.push(0);
        n = {
          key: key[cIndex + 1],
          count: count5
        };
      } else {
        dStack.push(0);
        n = n.mid;
      }
      cIndex += 1;
    }
  }
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: nStack[s + 1],
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nStack[s + 1]
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: nStack[s + 1],
        right: n2.right
      };
    }
  }
  nStack[0].count = count5;
  return makeImpl5(nStack[0]);
});
var reduce22 = dual(3, (self, zero3, f2) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f2(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var map39 = dual(2, (self, f2) => reduce22(self, empty45(), (trie, value6, key) => insert3(trie, key, f2(value6, key))));
var filter17 = dual(2, (self, f2) => reduce22(self, empty45(), (trie, value6, key) => f2(value6, key) ? insert3(trie, key, value6) : trie));
var filterMap10 = dual(2, (self, f2) => reduce22(self, empty45(), (trie, value6, key) => {
  const option6 = f2(value6, key);
  return isSome2(option6) ? insert3(trie, key, option6.value) : trie;
}));
var forEach22 = dual(2, (self, f2) => reduce22(self, void 0, (_2, value6, key) => f2(value6, key)));
var keysWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key) => key, (key) => key.startsWith(prefix)));
var valuesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (_2, value6) => value6, (key) => key.startsWith(prefix)));
var entriesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key, value6) => [key, value6], (key) => key.startsWith(prefix)));
var toEntriesWithPrefix = dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));
var get33 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return none2();
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return none2();
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        return fromNullable2(n.value);
      } else {
        if (n.mid === void 0) {
          return none2();
        } else {
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  return none2();
});
var has16 = dual(2, (self, key) => isSome2(get33(self, key)));
var unsafeGet11 = dual(2, (self, key) => {
  const element2 = get33(self, key);
  if (isNone2(element2)) {
    throw new Error("Expected trie to contain key");
  }
  return element2.value;
});
var remove16 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const count5 = n.count - 1;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const removeNode = nStack[nStack.length - 1];
  nStack[nStack.length - 1] = {
    key: removeNode.key,
    count: count5,
    left: removeNode.left,
    mid: removeNode.mid,
    right: removeNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    const nc = child.left === void 0 && child.mid === void 0 && child.right === void 0 ? void 0 : child;
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: nc,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nc
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: nc,
        right: n2.right
      };
    }
  }
  nStack[0].count = count5;
  return makeImpl5(nStack[0]);
});
var removeMany2 = dual(2, (self, keys10) => {
  let trie = self;
  for (const key of keys10) {
    trie = remove16(key)(trie);
  }
  return trie;
});
var insertMany = dual(2, (self, iter) => {
  let trie = self;
  for (const [key, value6] of iter) {
    trie = insert3(key, value6)(trie);
  }
  return trie;
});
var modify13 = dual(3, (self, key, f2) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const updateNode = nStack[nStack.length - 1];
  if (updateNode.value === void 0) {
    return self;
  }
  nStack[nStack.length - 1] = {
    key: updateNode.key,
    count: updateNode.count,
    value: f2(updateNode.value),
    // Update
    left: updateNode.left,
    mid: updateNode.mid,
    right: updateNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: child,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: child
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: child,
        right: n2.right
      };
    }
  }
  return makeImpl5(nStack[0]);
});
var longestPrefixOf = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let longestPrefixNode = void 0;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (n.value !== void 0) {
      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];
    }
    if (c > n.key) {
      if (n.right === void 0) {
        break;
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        break;
      } else {
        n = n.left;
      }
    } else {
      if (n.mid === void 0) {
        break;
      } else {
        n = n.mid;
        cIndex += 1;
      }
    }
  }
  return fromNullable2(longestPrefixNode);
});

// node_modules/.pnpm/@dojoengine+grpc@1.7.2/node_modules/@dojoengine/grpc/dist/index.js
var Empty$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Empty", []);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Empty = new Empty$Type();
var EnumOption$Type = class extends MessageType {
  constructor() {
    super("types.EnumOption", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EnumOption = new EnumOption$Type();
var Enum$Type = class extends MessageType {
  constructor() {
    super("types.Enum", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "option",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "options", kind: "message", repeat: 2, T: () => EnumOption }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.option = 0;
    message.options = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* uint32 option */
        2:
          message.option = reader.uint32();
          break;
        case /* repeated types.EnumOption options */
        3:
          message.options.push(EnumOption.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.option !== 0)
      writer.tag(2, WireType.Varint).uint32(message.option);
    for (let i = 0; i < message.options.length; i++)
      EnumOption.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Enum = new Enum$Type();
var Primitive$Type = class extends MessageType {
  constructor() {
    super("types.Primitive", [
      {
        no: 1,
        name: "i8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "i16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "i32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "i64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "i128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "u8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "u16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "u32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 9,
        name: "u64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "u128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 11,
        name: "u256",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 12,
        name: "bool",
        kind: "scalar",
        oneof: "primitive_type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "felt252",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 14,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 15,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 16,
        name: "eth_address",
        kind: "scalar",
        localName: "eth_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.primitive_type = { oneofKind: void 0 };
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 i8 */
        1:
          message.primitive_type = {
            oneofKind: "i8",
            i8: reader.int32()
          };
          break;
        case /* int32 i16 */
        2:
          message.primitive_type = {
            oneofKind: "i16",
            i16: reader.int32()
          };
          break;
        case /* int32 i32 */
        3:
          message.primitive_type = {
            oneofKind: "i32",
            i32: reader.int32()
          };
          break;
        case /* int64 i64 */
        4:
          message.primitive_type = {
            oneofKind: "i64",
            i64: reader.int64().toBigInt()
          };
          break;
        case /* bytes i128 */
        5:
          message.primitive_type = {
            oneofKind: "i128",
            i128: reader.bytes()
          };
          break;
        case /* uint32 u8 */
        6:
          message.primitive_type = {
            oneofKind: "u8",
            u8: reader.uint32()
          };
          break;
        case /* uint32 u16 */
        7:
          message.primitive_type = {
            oneofKind: "u16",
            u16: reader.uint32()
          };
          break;
        case /* uint32 u32 */
        8:
          message.primitive_type = {
            oneofKind: "u32",
            u32: reader.uint32()
          };
          break;
        case /* uint64 u64 */
        9:
          message.primitive_type = {
            oneofKind: "u64",
            u64: reader.uint64().toBigInt()
          };
          break;
        case /* bytes u128 */
        10:
          message.primitive_type = {
            oneofKind: "u128",
            u128: reader.bytes()
          };
          break;
        case /* bytes u256 */
        11:
          message.primitive_type = {
            oneofKind: "u256",
            u256: reader.bytes()
          };
          break;
        case /* bool bool */
        12:
          message.primitive_type = {
            oneofKind: "bool",
            bool: reader.bool()
          };
          break;
        case /* bytes felt252 */
        13:
          message.primitive_type = {
            oneofKind: "felt252",
            felt252: reader.bytes()
          };
          break;
        case /* bytes class_hash */
        14:
          message.primitive_type = {
            oneofKind: "class_hash",
            class_hash: reader.bytes()
          };
          break;
        case /* bytes contract_address */
        15:
          message.primitive_type = {
            oneofKind: "contract_address",
            contract_address: reader.bytes()
          };
          break;
        case /* bytes eth_address */
        16:
          message.primitive_type = {
            oneofKind: "eth_address",
            eth_address: reader.bytes()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.primitive_type.oneofKind === "i8")
      writer.tag(1, WireType.Varint).int32(message.primitive_type.i8);
    if (message.primitive_type.oneofKind === "i16")
      writer.tag(2, WireType.Varint).int32(message.primitive_type.i16);
    if (message.primitive_type.oneofKind === "i32")
      writer.tag(3, WireType.Varint).int32(message.primitive_type.i32);
    if (message.primitive_type.oneofKind === "i64")
      writer.tag(4, WireType.Varint).int64(message.primitive_type.i64);
    if (message.primitive_type.oneofKind === "i128")
      writer.tag(5, WireType.LengthDelimited).bytes(message.primitive_type.i128);
    if (message.primitive_type.oneofKind === "u8")
      writer.tag(6, WireType.Varint).uint32(message.primitive_type.u8);
    if (message.primitive_type.oneofKind === "u16")
      writer.tag(7, WireType.Varint).uint32(message.primitive_type.u16);
    if (message.primitive_type.oneofKind === "u32")
      writer.tag(8, WireType.Varint).uint32(message.primitive_type.u32);
    if (message.primitive_type.oneofKind === "u64")
      writer.tag(9, WireType.Varint).uint64(message.primitive_type.u64);
    if (message.primitive_type.oneofKind === "u128")
      writer.tag(10, WireType.LengthDelimited).bytes(message.primitive_type.u128);
    if (message.primitive_type.oneofKind === "u256")
      writer.tag(11, WireType.LengthDelimited).bytes(message.primitive_type.u256);
    if (message.primitive_type.oneofKind === "bool")
      writer.tag(12, WireType.Varint).bool(message.primitive_type.bool);
    if (message.primitive_type.oneofKind === "felt252")
      writer.tag(13, WireType.LengthDelimited).bytes(message.primitive_type.felt252);
    if (message.primitive_type.oneofKind === "class_hash")
      writer.tag(14, WireType.LengthDelimited).bytes(message.primitive_type.class_hash);
    if (message.primitive_type.oneofKind === "contract_address")
      writer.tag(15, WireType.LengthDelimited).bytes(message.primitive_type.contract_address);
    if (message.primitive_type.oneofKind === "eth_address")
      writer.tag(16, WireType.LengthDelimited).bytes(message.primitive_type.eth_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Primitive = new Primitive$Type();
var Struct$Type = class extends MessageType {
  constructor() {
    super("types.Struct", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "children", kind: "message", repeat: 2, T: () => Member }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.children = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* repeated types.Member children */
        2:
          message.children.push(Member.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    for (let i = 0; i < message.children.length; i++)
      Member.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Struct2 = new Struct$Type();
var Array$$Type = class extends MessageType {
  constructor() {
    super("types.Array", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Array$2 = new Array$$Type();
var FixedSizeArray$Type = class extends MessageType {
  constructor() {
    super("types.FixedSizeArray", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    message.size = 0;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint32 size */
        2:
          message.size = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.size !== 0)
      writer.tag(2, WireType.Varint).uint32(message.size);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var FixedSizeArray = new FixedSizeArray$Type();
var Ty$Type = class extends MessageType {
  constructor() {
    super("types.Ty", [
      { no: 2, name: "primitive", kind: "message", oneof: "ty_type", T: () => Primitive },
      { no: 3, name: "enum", kind: "message", oneof: "ty_type", T: () => Enum },
      { no: 4, name: "struct", kind: "message", oneof: "ty_type", T: () => Struct2 },
      { no: 5, name: "tuple", kind: "message", oneof: "ty_type", T: () => Array$2 },
      { no: 6, name: "array", kind: "message", oneof: "ty_type", T: () => Array$2 },
      {
        no: 7,
        name: "bytearray",
        kind: "scalar",
        oneof: "ty_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "fixed_size_array", kind: "message", localName: "fixed_size_array", oneof: "ty_type", T: () => FixedSizeArray }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ty_type = { oneofKind: void 0 };
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        2:
          message.ty_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.primitive)
          };
          break;
        case /* types.Enum enum */
        3:
          message.ty_type = {
            oneofKind: "enum",
            enum: Enum.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.enum)
          };
          break;
        case /* types.Struct struct */
        4:
          message.ty_type = {
            oneofKind: "struct",
            struct: Struct2.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.struct)
          };
          break;
        case /* types.Array tuple */
        5:
          message.ty_type = {
            oneofKind: "tuple",
            tuple: Array$2.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.tuple)
          };
          break;
        case /* types.Array array */
        6:
          message.ty_type = {
            oneofKind: "array",
            array: Array$2.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.array)
          };
          break;
        case /* string bytearray */
        7:
          message.ty_type = {
            oneofKind: "bytearray",
            bytearray: reader.string()
          };
          break;
        case /* types.FixedSizeArray fixed_size_array */
        8:
          message.ty_type = {
            oneofKind: "fixed_size_array",
            fixed_size_array: FixedSizeArray.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.fixed_size_array)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ty_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.ty_type.primitive, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "enum")
      Enum.internalBinaryWrite(message.ty_type.enum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "struct")
      Struct2.internalBinaryWrite(message.ty_type.struct, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "tuple")
      Array$2.internalBinaryWrite(message.ty_type.tuple, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "array")
      Array$2.internalBinaryWrite(message.ty_type.array, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "bytearray")
      writer.tag(7, WireType.LengthDelimited).string(message.ty_type.bytearray);
    if (message.ty_type.oneofKind === "fixed_size_array")
      FixedSizeArray.internalBinaryWrite(message.ty_type.fixed_size_array, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Ty = new Ty$Type();
var Member$Type = class extends MessageType {
  constructor() {
    super("types.Member", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty },
      {
        no: 3,
        name: "key",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.key = false;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        case /* bool key */
        3:
          message.key = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.key !== false)
      writer.tag(3, WireType.Varint).bool(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Member = new Member$Type();
var PatternMatching = ((PatternMatching2) => {
  PatternMatching2[PatternMatching2["FixedLen"] = 0] = "FixedLen";
  PatternMatching2[PatternMatching2["VariableLen"] = 1] = "VariableLen";
  return PatternMatching2;
})(PatternMatching || {});
var LogicalOperator = ((LogicalOperator2) => {
  LogicalOperator2[LogicalOperator2["AND"] = 0] = "AND";
  LogicalOperator2[LogicalOperator2["OR"] = 1] = "OR";
  return LogicalOperator2;
})(LogicalOperator || {});
var ComparisonOperator = ((ComparisonOperator2) => {
  ComparisonOperator2[ComparisonOperator2["EQ"] = 0] = "EQ";
  ComparisonOperator2[ComparisonOperator2["NEQ"] = 1] = "NEQ";
  ComparisonOperator2[ComparisonOperator2["GT"] = 2] = "GT";
  ComparisonOperator2[ComparisonOperator2["GTE"] = 3] = "GTE";
  ComparisonOperator2[ComparisonOperator2["LT"] = 4] = "LT";
  ComparisonOperator2[ComparisonOperator2["LTE"] = 5] = "LTE";
  ComparisonOperator2[ComparisonOperator2["IN"] = 6] = "IN";
  ComparisonOperator2[ComparisonOperator2["NOT_IN"] = 7] = "NOT_IN";
  ComparisonOperator2[ComparisonOperator2["CONTAINS"] = 8] = "CONTAINS";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ALL"] = 9] = "CONTAINS_ALL";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ANY"] = 10] = "CONTAINS_ANY";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_EQ"] = 11] = "ARRAY_LENGTH_EQ";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_GT"] = 12] = "ARRAY_LENGTH_GT";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_LT"] = 13] = "ARRAY_LENGTH_LT";
  return ComparisonOperator2;
})(ComparisonOperator || {});
var OrderDirection = ((OrderDirection2) => {
  OrderDirection2[OrderDirection2["ASC"] = 0] = "ASC";
  OrderDirection2[OrderDirection2["DESC"] = 1] = "DESC";
  return OrderDirection2;
})(OrderDirection || {});
var PaginationDirection = ((PaginationDirection2) => {
  PaginationDirection2[PaginationDirection2["FORWARD"] = 0] = "FORWARD";
  PaginationDirection2[PaginationDirection2["BACKWARD"] = 1] = "BACKWARD";
  return PaginationDirection2;
})(PaginationDirection || {});
var CallType = ((CallType2) => {
  CallType2[CallType2["EXECUTE"] = 0] = "EXECUTE";
  CallType2[CallType2["EXECUTE_FROM_OUTSIDE"] = 1] = "EXECUTE_FROM_OUTSIDE";
  return CallType2;
})(CallType || {});
var ContractType = ((ContractType3) => {
  ContractType3[ContractType3["WORLD"] = 0] = "WORLD";
  ContractType3[ContractType3["ERC20"] = 1] = "ERC20";
  ContractType3[ContractType3["ERC721"] = 2] = "ERC721";
  ContractType3[ContractType3["ERC1155"] = 3] = "ERC1155";
  ContractType3[ContractType3["UDC"] = 4] = "UDC";
  ContractType3[ContractType3["OTHER"] = 5] = "OTHER";
  return ContractType3;
})(ContractType || {});
var World$Type = class extends MessageType {
  constructor() {
    super("types.World", [
      {
        no: 1,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Model }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_address = "";
    message.models = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string world_address */
        1:
          message.world_address = reader.string();
          break;
        case /* repeated types.Model models */
        2:
          message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.world_address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.world_address);
    for (let i = 0; i < message.models.length; i++)
      Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var World = new World$Type();
var Model$Type = class extends MessageType {
  constructor() {
    super("types.Model", [
      {
        no: 1,
        name: "selector",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "packed_size",
        kind: "scalar",
        localName: "packed_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "unpacked_size",
        kind: "scalar",
        localName: "unpacked_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "layout",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "schema",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 9,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 10,
        name: "use_legacy_store",
        kind: "scalar",
        localName: "use_legacy_store",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.selector = new Uint8Array(0);
    message.namespace = "";
    message.name = "";
    message.packed_size = 0;
    message.unpacked_size = 0;
    message.class_hash = new Uint8Array(0);
    message.layout = new Uint8Array(0);
    message.schema = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    message.use_legacy_store = false;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes selector */
        1:
          message.selector = reader.bytes();
          break;
        case /* string namespace */
        2:
          message.namespace = reader.string();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* uint32 packed_size */
        4:
          message.packed_size = reader.uint32();
          break;
        case /* uint32 unpacked_size */
        5:
          message.unpacked_size = reader.uint32();
          break;
        case /* bytes class_hash */
        6:
          message.class_hash = reader.bytes();
          break;
        case /* bytes layout */
        7:
          message.layout = reader.bytes();
          break;
        case /* bytes schema */
        8:
          message.schema = reader.bytes();
          break;
        case /* bytes contract_address */
        9:
          message.contract_address = reader.bytes();
          break;
        case /* bool use_legacy_store */
        10:
          message.use_legacy_store = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.selector.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.selector);
    if (message.namespace !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.namespace);
    if (message.name !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.name);
    if (message.packed_size !== 0)
      writer.tag(4, WireType.Varint).uint32(message.packed_size);
    if (message.unpacked_size !== 0)
      writer.tag(5, WireType.Varint).uint32(message.unpacked_size);
    if (message.class_hash.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.class_hash);
    if (message.layout.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.layout);
    if (message.schema.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.schema);
    if (message.contract_address.length)
      writer.tag(9, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.use_legacy_store !== false)
      writer.tag(10, WireType.Varint).bool(message.use_legacy_store);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Model = new Model$Type();
var Entity$Type = class extends MessageType {
  constructor() {
    super("types.Entity", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Struct2 },
      {
        no: 3,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "executed_at",
        kind: "scalar",
        localName: "executed_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = new Uint8Array(0);
    message.models = [];
    message.created_at = 0n;
    message.updated_at = 0n;
    message.executed_at = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hashed_keys */
        1:
          message.hashed_keys = reader.bytes();
          break;
        case /* repeated types.Struct models */
        2:
          message.models.push(Struct2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 created_at */
        3:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        4:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 executed_at */
        5:
          message.executed_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hashed_keys.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      Struct2.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.created_at !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.updated_at);
    if (message.executed_at !== 0n)
      writer.tag(5, WireType.Varint).uint64(message.executed_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Entity = new Entity$Type();
var Event$Type = class extends MessageType {
  constructor() {
    super("types.Event", [
      {
        no: 1,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.data = [];
    message.transaction_hash = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        1:
          message.keys.push(reader.bytes());
          break;
        case /* repeated bytes data */
        2:
          message.data.push(reader.bytes());
          break;
        case /* bytes transaction_hash */
        3:
          message.transaction_hash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.keys[i]);
    for (let i = 0; i < message.data.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data[i]);
    if (message.transaction_hash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.transaction_hash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Event = new Event$Type();
var Query$Type = class extends MessageType {
  constructor() {
    super("types.Query", [
      { no: 1, name: "clause", kind: "message", T: () => Clause },
      {
        no: 2,
        name: "no_hashed_keys",
        kind: "scalar",
        localName: "no_hashed_keys",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination },
      {
        no: 5,
        name: "historical",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.no_hashed_keys = false;
    message.models = [];
    message.historical = false;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        case /* bool no_hashed_keys */
        2:
          message.no_hashed_keys = reader.bool();
          break;
        case /* repeated string models */
        3:
          message.models.push(reader.string());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        case /* bool historical */
        5:
          message.historical = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.no_hashed_keys !== false)
      writer.tag(2, WireType.Varint).bool(message.no_hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.models[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.historical !== false)
      writer.tag(5, WireType.Varint).bool(message.historical);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Query = new Query$Type();
var EventQuery$Type = class extends MessageType {
  constructor() {
    super("types.EventQuery", [
      { no: 1, name: "keys", kind: "message", T: () => KeysClause },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.KeysClause keys */
        1:
          message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.keys)
      KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EventQuery = new EventQuery$Type();
var Clause$Type = class extends MessageType {
  constructor() {
    super("types.Clause", [
      { no: 1, name: "hashed_keys", kind: "message", localName: "hashed_keys", oneof: "clause_type", T: () => HashedKeysClause },
      { no: 2, name: "keys", kind: "message", oneof: "clause_type", T: () => KeysClause },
      { no: 3, name: "member", kind: "message", oneof: "clause_type", T: () => MemberClause },
      { no: 4, name: "composite", kind: "message", oneof: "clause_type", T: () => CompositeClause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.clause_type = { oneofKind: void 0 };
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.HashedKeysClause hashed_keys */
        1:
          message.clause_type = {
            oneofKind: "hashed_keys",
            hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.hashed_keys)
          };
          break;
        case /* types.KeysClause keys */
        2:
          message.clause_type = {
            oneofKind: "keys",
            keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.keys)
          };
          break;
        case /* types.MemberClause member */
        3:
          message.clause_type = {
            oneofKind: "member",
            member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.member)
          };
          break;
        case /* types.CompositeClause composite */
        4:
          message.clause_type = {
            oneofKind: "composite",
            composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.composite)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause_type.oneofKind === "hashed_keys")
      HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "keys")
      KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "member")
      MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "composite")
      CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Clause = new Clause$Type();
var KeysClause$Type = class extends MessageType {
  constructor() {
    super("types.KeysClause", [
      {
        no: 2,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "pattern_matching", kind: "enum", localName: "pattern_matching", T: () => ["types.PatternMatching", PatternMatching] },
      {
        no: 4,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.pattern_matching = 0;
    message.models = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        2:
          message.keys.push(reader.bytes());
          break;
        case /* types.PatternMatching pattern_matching */
        3:
          message.pattern_matching = reader.int32();
          break;
        case /* repeated string models */
        4:
          message.models.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.keys[i]);
    if (message.pattern_matching !== 0)
      writer.tag(3, WireType.Varint).int32(message.pattern_matching);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var KeysClause = new KeysClause$Type();
var HashedKeysClause$Type = class extends MessageType {
  constructor() {
    super("types.HashedKeysClause", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes hashed_keys */
        1:
          message.hashed_keys.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.hashed_keys.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var HashedKeysClause = new HashedKeysClause$Type();
var MemberValue$Type = class extends MessageType {
  constructor() {
    super("types.MemberValue", [
      { no: 1, name: "primitive", kind: "message", oneof: "value_type", T: () => Primitive },
      {
        no: 2,
        name: "string",
        kind: "scalar",
        oneof: "value_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "list", kind: "message", oneof: "value_type", T: () => MemberValueList }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value_type = { oneofKind: void 0 };
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        1:
          message.value_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.value_type.primitive)
          };
          break;
        case /* string string */
        2:
          message.value_type = {
            oneofKind: "string",
            string: reader.string()
          };
          break;
        case /* types.MemberValueList list */
        3:
          message.value_type = {
            oneofKind: "list",
            list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, message.value_type.list)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.value_type.oneofKind === "string")
      writer.tag(2, WireType.LengthDelimited).string(message.value_type.string);
    if (message.value_type.oneofKind === "list")
      MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValue = new MemberValue$Type();
var MemberValueList$Type = class extends MessageType {
  constructor() {
    super("types.MemberValueList", [
      { no: 1, name: "values", kind: "message", repeat: 2, T: () => MemberValue }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.values = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.MemberValue values */
        1:
          message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.values.length; i++)
      MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValueList = new MemberValueList$Type();
var MemberClause$Type = class extends MessageType {
  constructor() {
    super("types.MemberClause", [
      {
        no: 2,
        name: "model",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "member",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "operator", kind: "enum", T: () => ["types.ComparisonOperator", ComparisonOperator] },
      { no: 5, name: "value", kind: "message", T: () => MemberValue }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.model = "";
    message.member = "";
    message.operator = 0;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string model */
        2:
          message.model = reader.string();
          break;
        case /* string member */
        3:
          message.member = reader.string();
          break;
        case /* types.ComparisonOperator operator */
        4:
          message.operator = reader.int32();
          break;
        case /* types.MemberValue value */
        5:
          message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.model !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.model);
    if (message.member !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.member);
    if (message.operator !== 0)
      writer.tag(4, WireType.Varint).int32(message.operator);
    if (message.value)
      MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberClause = new MemberClause$Type();
var CompositeClause$Type = class extends MessageType {
  constructor() {
    super("types.CompositeClause", [
      { no: 3, name: "operator", kind: "enum", T: () => ["types.LogicalOperator", LogicalOperator] },
      { no: 4, name: "clauses", kind: "message", repeat: 2, T: () => Clause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operator = 0;
    message.clauses = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.LogicalOperator operator */
        3:
          message.operator = reader.int32();
          break;
        case /* repeated types.Clause clauses */
        4:
          message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.operator !== 0)
      writer.tag(3, WireType.Varint).int32(message.operator);
    for (let i = 0; i < message.clauses.length; i++)
      Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var CompositeClause = new CompositeClause$Type();
var Token$Type = class extends MessageType {
  constructor() {
    super("types.Token", [
      {
        no: 1,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "total_supply",
        kind: "scalar",
        localName: "total_supply",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.metadata = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes token_id */
        1:
          message.token_id = reader.bytes();
          break;
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* bytes metadata */
        6:
          message.metadata = reader.bytes();
          break;
        case /* optional bytes total_supply */
        7:
          message.total_supply = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.token_id !== void 0)
      writer.tag(1, WireType.LengthDelimited).bytes(message.token_id);
    if (message.contract_address.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.name !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType.Varint).uint32(message.decimals);
    if (message.metadata.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.metadata);
    if (message.total_supply !== void 0)
      writer.tag(7, WireType.LengthDelimited).bytes(message.total_supply);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Token = new Token$Type();
var TokenContract$Type = class extends MessageType {
  constructor() {
    super("types.TokenContract", [
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.count = 0;
    message.metadata = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* uint32 count */
        6:
          message.count = reader.uint32();
          break;
        case /* bytes metadata */
        7:
          message.metadata = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.name !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType.Varint).uint32(message.decimals);
    if (message.count !== 0)
      writer.tag(6, WireType.Varint).uint32(message.count);
    if (message.metadata.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.metadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenContract = new TokenContract$Type();
var TokenBalance$Type = class extends MessageType {
  constructor() {
    super("types.TokenBalance", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        localName: "account_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balance = new Uint8Array(0);
    message.account_address = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes balance */
        1:
          message.balance = reader.bytes();
          break;
        case /* bytes account_address */
        2:
          message.account_address = reader.bytes();
          break;
        case /* bytes contract_address */
        3:
          message.contract_address = reader.bytes();
          break;
        case /* optional bytes token_id */
        4:
          message.token_id = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.balance);
    if (message.account_address.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.account_address);
    if (message.contract_address.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.token_id !== void 0)
      writer.tag(4, WireType.LengthDelimited).bytes(message.token_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalance = new TokenBalance$Type();
var OrderBy$Type = class extends MessageType {
  constructor() {
    super("types.OrderBy", [
      {
        no: 1,
        name: "field",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "direction", kind: "enum", T: () => ["types.OrderDirection", OrderDirection] }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = "";
    message.direction = 0;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string field */
        1:
          message.field = reader.string();
          break;
        case /* types.OrderDirection direction */
        2:
          message.direction = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.field !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.field);
    if (message.direction !== 0)
      writer.tag(2, WireType.Varint).int32(message.direction);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var OrderBy = new OrderBy$Type();
var Controller$Type = class extends MessageType {
  constructor() {
    super("types.Controller", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "deployed_at_timestamp",
        kind: "scalar",
        localName: "deployed_at_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = new Uint8Array(0);
    message.username = "";
    message.deployed_at_timestamp = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address */
        1:
          message.address = reader.bytes();
          break;
        case /* string username */
        2:
          message.username = reader.string();
          break;
        case /* uint64 deployed_at_timestamp */
        3:
          message.deployed_at_timestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.address);
    if (message.username !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.username);
    if (message.deployed_at_timestamp !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.deployed_at_timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Controller = new Controller$Type();
var Pagination$Type = class extends MessageType {
  constructor() {
    super("types.Pagination", [
      {
        no: 1,
        name: "cursor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "direction", kind: "enum", T: () => ["types.PaginationDirection", PaginationDirection] },
      { no: 4, name: "order_by", kind: "message", localName: "order_by", repeat: 2, T: () => OrderBy }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cursor = "";
    message.limit = 0;
    message.direction = 0;
    message.order_by = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cursor */
        1:
          message.cursor = reader.string();
          break;
        case /* uint32 limit */
        2:
          message.limit = reader.uint32();
          break;
        case /* types.PaginationDirection direction */
        3:
          message.direction = reader.int32();
          break;
        case /* repeated types.OrderBy order_by */
        4:
          message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cursor);
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).uint32(message.limit);
    if (message.direction !== 0)
      writer.tag(3, WireType.Varint).int32(message.direction);
    for (let i = 0; i < message.order_by.length; i++)
      OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Pagination = new Pagination$Type();
var ControllerQuery$Type = class extends MessageType {
  constructor() {
    super("types.ControllerQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "usernames",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.usernames = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string usernames */
        2:
          message.usernames.push(reader.string());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.usernames.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.usernames[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ControllerQuery = new ControllerQuery$Type();
var TokenQuery$Type = class extends MessageType {
  constructor() {
    super("types.TokenQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenQuery = new TokenQuery$Type();
var TokenBalanceQuery$Type = class extends MessageType {
  constructor() {
    super("types.TokenBalanceQuery", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalanceQuery = new TokenBalanceQuery$Type();
var TransactionCall$Type = class extends MessageType {
  constructor() {
    super("types.TransactionCall", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "entrypoint",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "call_type", kind: "enum", localName: "call_type", T: () => ["types.CallType", CallType] },
      {
        no: 5,
        name: "caller_address",
        kind: "scalar",
        localName: "caller_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.entrypoint = "";
    message.calldata = [];
    message.call_type = 0;
    message.caller_address = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* string entrypoint */
        2:
          message.entrypoint = reader.string();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* types.CallType call_type */
        4:
          message.call_type = reader.int32();
          break;
        case /* bytes caller_address */
        5:
          message.caller_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.entrypoint !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.entrypoint);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
    if (message.call_type !== 0)
      writer.tag(4, WireType.Varint).int32(message.call_type);
    if (message.caller_address.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.caller_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionCall = new TransactionCall$Type();
var Transaction$Type = class extends MessageType {
  constructor() {
    super("types.Transaction", [
      {
        no: 1,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "sender_address",
        kind: "scalar",
        localName: "sender_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "max_fee",
        kind: "scalar",
        localName: "max_fee",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "nonce",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "block_number",
        kind: "scalar",
        localName: "block_number",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "transaction_type",
        kind: "scalar",
        localName: "transaction_type",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "block_timestamp",
        kind: "scalar",
        localName: "block_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 10, name: "calls", kind: "message", repeat: 2, T: () => TransactionCall },
      {
        no: 11,
        name: "unique_models",
        kind: "scalar",
        localName: "unique_models",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hash = new Uint8Array(0);
    message.sender_address = new Uint8Array(0);
    message.calldata = [];
    message.max_fee = new Uint8Array(0);
    message.signature = [];
    message.nonce = new Uint8Array(0);
    message.block_number = 0n;
    message.transaction_type = "";
    message.block_timestamp = 0n;
    message.calls = [];
    message.unique_models = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes transaction_hash */
        1:
          message.transaction_hash = reader.bytes();
          break;
        case /* bytes sender_address */
        2:
          message.sender_address = reader.bytes();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* bytes max_fee */
        4:
          message.max_fee = reader.bytes();
          break;
        case /* repeated bytes signature */
        5:
          message.signature.push(reader.bytes());
          break;
        case /* bytes nonce */
        6:
          message.nonce = reader.bytes();
          break;
        case /* uint64 block_number */
        7:
          message.block_number = reader.uint64().toBigInt();
          break;
        case /* string transaction_type */
        8:
          message.transaction_type = reader.string();
          break;
        case /* uint64 block_timestamp */
        9:
          message.block_timestamp = reader.uint64().toBigInt();
          break;
        case /* repeated types.TransactionCall calls */
        10:
          message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated bytes unique_models */
        11:
          message.unique_models.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction_hash.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hash);
    if (message.sender_address.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.sender_address);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
    if (message.max_fee.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.max_fee);
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(5, WireType.LengthDelimited).bytes(message.signature[i]);
    if (message.nonce.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.nonce);
    if (message.block_number !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.block_number);
    if (message.transaction_type !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.transaction_type);
    if (message.block_timestamp !== 0n)
      writer.tag(9, WireType.Varint).uint64(message.block_timestamp);
    for (let i = 0; i < message.calls.length; i++)
      TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.unique_models.length; i++)
      writer.tag(11, WireType.LengthDelimited).bytes(message.unique_models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Transaction = new Transaction$Type();
var TransactionFilter$Type = class extends MessageType {
  constructor() {
    super("types.TransactionFilter", [
      {
        no: 1,
        name: "transaction_hashes",
        kind: "scalar",
        localName: "transaction_hashes",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "entrypoints",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "model_selectors",
        kind: "scalar",
        localName: "model_selectors",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "from_block",
        kind: "scalar",
        localName: "from_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "to_block",
        kind: "scalar",
        localName: "to_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hashes = [];
    message.caller_addresses = [];
    message.contract_addresses = [];
    message.entrypoints = [];
    message.model_selectors = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes transaction_hashes */
        1:
          message.transaction_hashes.push(reader.bytes());
          break;
        case /* repeated bytes caller_addresses */
        2:
          message.caller_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        3:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string entrypoints */
        4:
          message.entrypoints.push(reader.string());
          break;
        case /* repeated bytes model_selectors */
        5:
          message.model_selectors.push(reader.bytes());
          break;
        case /* optional uint64 from_block */
        6:
          message.from_block = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_block */
        7:
          message.to_block = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transaction_hashes.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hashes[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.entrypoints.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.entrypoints[i]);
    for (let i = 0; i < message.model_selectors.length; i++)
      writer.tag(5, WireType.LengthDelimited).bytes(message.model_selectors[i]);
    if (message.from_block !== void 0)
      writer.tag(6, WireType.Varint).uint64(message.from_block);
    if (message.to_block !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.to_block);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionFilter = new TransactionFilter$Type();
var TransactionQuery$Type = class extends MessageType {
  constructor() {
    super("types.TransactionQuery", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionQuery = new TransactionQuery$Type();
var Contract$Type = class extends MessageType {
  constructor() {
    super("types.Contract", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
      {
        no: 3,
        name: "head",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "tps",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_block_timestamp",
        kind: "scalar",
        localName: "last_block_timestamp",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "last_pending_block_tx",
        kind: "scalar",
        localName: "last_pending_block_tx",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.contract_type = 0;
    message.updated_at = 0n;
    message.created_at = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* types.ContractType contract_type */
        2:
          message.contract_type = reader.int32();
          break;
        case /* optional uint64 head */
        3:
          message.head = reader.uint64().toBigInt();
          break;
        case /* optional uint64 tps */
        4:
          message.tps = reader.uint64().toBigInt();
          break;
        case /* optional uint64 last_block_timestamp */
        5:
          message.last_block_timestamp = reader.uint64().toBigInt();
          break;
        case /* optional bytes last_pending_block_tx */
        6:
          message.last_pending_block_tx = reader.bytes();
          break;
        case /* uint64 updated_at */
        7:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 created_at */
        8:
          message.created_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
    if (message.contract_type !== 0)
      writer.tag(2, WireType.Varint).int32(message.contract_type);
    if (message.head !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.head);
    if (message.tps !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.tps);
    if (message.last_block_timestamp !== void 0)
      writer.tag(5, WireType.Varint).uint64(message.last_block_timestamp);
    if (message.last_pending_block_tx !== void 0)
      writer.tag(6, WireType.LengthDelimited).bytes(message.last_pending_block_tx);
    if (message.updated_at !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.updated_at);
    if (message.created_at !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.created_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Contract = new Contract$Type();
var ContractQuery$Type = class extends MessageType {
  constructor() {
    super("types.ContractQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1, T: () => ["types.ContractType", ContractType] }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.contract_types = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated types.ContractType contract_types */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contract_types.push(reader.int32());
          else
            message.contract_types.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    if (message.contract_types.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.contract_types.length; i++)
        writer.int32(message.contract_types[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ContractQuery = new ContractQuery$Type();
var SubscribeTransactionsRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTransactionsRequest", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();
var SubscribeTransactionsResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTransactionsResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => Transaction }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Transaction transaction */
        1:
          message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();
var RetrieveControllersRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveControllersRequest", [
      { no: 1, name: "query", kind: "message", T: () => ControllerQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ControllerQuery query */
        1:
          message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersRequest = new RetrieveControllersRequest$Type();
var RetrieveControllersResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveControllersResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "controllers", kind: "message", repeat: 2, T: () => Controller }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.controllers = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Controller controllers */
        2:
          message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.controllers.length; i++)
      Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersResponse = new RetrieveControllersResponse$Type();
var RetrieveContractsRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsRequest = new RetrieveContractsRequest$Type();
var RetrieveContractsResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveContractsResponse", [
      { no: 1, name: "contracts", kind: "message", repeat: 2, T: () => Contract }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contracts = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Contract contracts */
        1:
          message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contracts.length; i++)
      Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsResponse = new RetrieveContractsResponse$Type();
var UpdateTokenBalancesSubscriptionRequest$Type = class extends MessageType {
  constructor() {
    super("world.UpdateTokenBalancesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.account_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes account_addresses */
        3:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        4:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();
var SubscribeTokenBalancesResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTokenBalancesResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "balance", kind: "message", T: () => TokenBalance }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.TokenBalance balance */
        2:
          message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    if (message.balance)
      TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();
var RetrieveTokensRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokensRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenQuery query */
        1:
          message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensRequest = new RetrieveTokensRequest$Type();
var SubscribeTokensRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTokensRequest", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensRequest = new SubscribeTokensRequest$Type();
var RetrieveTokensResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokensResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tokens", kind: "message", repeat: 2, T: () => Token }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.tokens = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Token tokens */
        2:
          message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.tokens.length; i++)
      Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensResponse = new RetrieveTokensResponse$Type();
var SubscribeTokensResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTokensResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "token", kind: "message", T: () => Token }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Token token */
        2:
          message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    if (message.token)
      Token.internalBinaryWrite(message.token, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensResponse = new SubscribeTokensResponse$Type();
var UpdateTokenSubscriptionRequest$Type = class extends MessageType {
  constructor() {
    super("world.UpdateTokenSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();
var RetrieveTokenBalancesRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokenBalancesRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenBalanceQuery query */
        1:
          message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();
var SubscribeTokenBalancesRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeTokenBalancesRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();
var RetrieveTokenBalancesResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokenBalancesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balances", kind: "message", repeat: 2, T: () => TokenBalance }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.balances = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenBalance balances */
        2:
          message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.balances.length; i++)
      TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();
var RetrieveTransactionsRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTransactionsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TransactionQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionQuery query */
        1:
          message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();
var RetrieveTransactionsResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTransactionsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transactions", kind: "message", repeat: 2, T: () => Transaction }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.transactions = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Transaction transactions */
        2:
          message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.transactions.length; i++)
      Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();
var RetrieveTokenContractsRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokenContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenBalanceQuery query */
        1:
          message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();
var RetrieveTokenContractsResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveTokenContractsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tokens", kind: "message", repeat: 2, T: () => TokenContract }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.tokens = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenContract tokens */
        2:
          message.tokens.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.tokens.length; i++)
      TokenContract.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();
var SubscribeContractsRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsRequest = new SubscribeContractsRequest$Type();
var SubscribeContractsResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeContractsResponse", [
      { no: 1, name: "contract", kind: "message", T: () => Contract }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Contract contract */
        1:
          message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract)
      Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsResponse = new SubscribeContractsResponse$Type();
var WorldMetadataRequest$Type = class extends MessageType {
  constructor() {
    super("world.WorldMetadataRequest", []);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldMetadataRequest = new WorldMetadataRequest$Type();
var WorldMetadataResponse$Type = class extends MessageType {
  constructor() {
    super("world.WorldMetadataResponse", [
      { no: 1, name: "world", kind: "message", T: () => World }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.World world */
        1:
          message.world = World.internalBinaryRead(reader, reader.uint32(), options, message.world);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.world)
      World.internalBinaryWrite(message.world, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldMetadataResponse = new WorldMetadataResponse$Type();
var SubscribeEntitiesRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeEntitiesRequest", [
      { no: 1, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
var SubscribeEventMessagesRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeEventMessagesRequest", [
      { no: 1, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventMessagesRequest = new SubscribeEventMessagesRequest$Type();
var UpdateEntitiesSubscriptionRequest$Type = class extends MessageType {
  constructor() {
    super("world.UpdateEntitiesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Clause clause */
        2:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();
var UpdateEventMessagesSubscriptionRequest$Type = class extends MessageType {
  constructor() {
    super("world.UpdateEventMessagesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Clause clause */
        2:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.subscription_id);
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateEventMessagesSubscriptionRequest = new UpdateEventMessagesSubscriptionRequest$Type();
var SubscribeEntityResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeEntityResponse", [
      { no: 1, name: "entity", kind: "message", T: () => Entity },
      {
        no: 2,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Entity entity */
        1:
          message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
          break;
        case /* uint64 subscription_id */
        2:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.entity)
      Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.subscription_id !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.subscription_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntityResponse = new SubscribeEntityResponse$Type();
var RetrieveEntitiesRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveEntitiesRequest", [
      { no: 1, name: "query", kind: "message", T: () => Query }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Query query */
        1:
          message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
var RetrieveEventMessagesRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveEventMessagesRequest", [
      { no: 1, name: "query", kind: "message", T: () => Query }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Query query */
        1:
          message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventMessagesRequest = new RetrieveEventMessagesRequest$Type();
var RetrieveEntitiesResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveEntitiesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "entities", kind: "message", repeat: 2, T: () => Entity }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.entities = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Entity entities */
        2:
          message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.entities.length; i++)
      Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
var RetrieveEventsRequest$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveEventsRequest", [
      { no: 1, name: "query", kind: "message", T: () => EventQuery }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.EventQuery query */
        1:
          message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsRequest = new RetrieveEventsRequest$Type();
var RetrieveEventsResponse$Type = class extends MessageType {
  constructor() {
    super("world.RetrieveEventsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "events", kind: "message", repeat: 2, T: () => Event }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.events = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Event events */
        2:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsResponse = new RetrieveEventsResponse$Type();
var SubscribeEventsRequest$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeEventsRequest", [
      { no: 1, name: "keys", kind: "message", repeat: 2, T: () => KeysClause }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.KeysClause keys */
        1:
          message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsRequest = new SubscribeEventsRequest$Type();
var SubscribeEventsResponse$Type = class extends MessageType {
  constructor() {
    super("world.SubscribeEventsResponse", [
      { no: 1, name: "event", kind: "message", T: () => Event }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Event event */
        1:
          message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.event)
      Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsResponse = new SubscribeEventsResponse$Type();
var PublishMessageRequest$Type = class extends MessageType {
  constructor() {
    super("world.PublishMessageRequest", [
      {
        no: 1,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signature = [];
    message.message = "";
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes signature */
        1:
          message.signature.push(reader.bytes());
          break;
        case /* string message */
        2:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.signature[i]);
    if (message.message !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageRequest = new PublishMessageRequest$Type();
var PublishMessageResponse$Type = class extends MessageType {
  constructor() {
    super("world.PublishMessageResponse", [
      {
        no: 1,
        name: "entity_id",
        kind: "scalar",
        localName: "entity_id",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.entity_id = new Uint8Array(0);
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes entity_id */
        1:
          message.entity_id = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.entity_id.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.entity_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageResponse = new PublishMessageResponse$Type();
var PublishMessageBatchRequest$Type = class extends MessageType {
  constructor() {
    super("world.PublishMessageBatchRequest", [
      { no: 1, name: "messages", kind: "message", repeat: 2, T: () => PublishMessageRequest }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messages = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageRequest messages */
        1:
          message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.messages.length; i++)
      PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
var PublishMessageBatchResponse$Type = class extends MessageType {
  constructor() {
    super("world.PublishMessageBatchResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 2, T: () => PublishMessageResponse }
    ]);
  }
  create(value6) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.responses = [];
    if (value6 !== void 0)
      reflectionMergePartial(this, message, value6);
    return message;
  }
  internalBinaryRead(reader, length4, options, target) {
    let message = target ?? this.create(), end6 = reader.pos + length4;
    while (reader.pos < end6) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageResponse responses */
        1:
          message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.responses.length; i++)
      PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();
var World2 = new ServiceType("world.World", [
  { name: "SubscribeContracts", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },
  { name: "WorldMetadata", options: {}, I: WorldMetadataRequest, O: WorldMetadataResponse },
  { name: "SubscribeEntities", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEntitiesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
  { name: "RetrieveEntities", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
  { name: "SubscribeEventMessages", serverStreaming: true, options: {}, I: SubscribeEventMessagesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEventMessagesSubscription", options: {}, I: UpdateEventMessagesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokenBalances", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },
  { name: "UpdateTokenBalancesSubscription", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokens", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },
  { name: "UpdateTokensSubscription", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },
  { name: "RetrieveEventMessages", options: {}, I: RetrieveEventMessagesRequest, O: RetrieveEntitiesResponse },
  { name: "RetrieveEvents", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },
  { name: "SubscribeEvents", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },
  { name: "RetrieveTokens", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },
  { name: "RetrieveTokenBalances", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },
  { name: "RetrieveTransactions", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },
  { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },
  { name: "RetrieveControllers", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },
  { name: "RetrieveContracts", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },
  { name: "RetrieveTokenContracts", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },
  { name: "PublishMessage", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },
  { name: "PublishMessageBatch", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse }
]);
var WorldClient = class {
  constructor(_transport) {
    this._transport = _transport;
  }
  typeName = World2.typeName;
  methods = World2.methods;
  options = World2.options;
  /**
   * Subscribes to updates about contracts. Like the head block number, tps, etc.
   *
   * @generated from protobuf rpc: SubscribeContracts
   */
  subscribeContracts(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieves metadata about the World including all the registered components and systems.
   *
   * @generated from protobuf rpc: WorldMetadata
   */
  worldMetadata(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEntities
   */
  subscribeEntities(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEntitiesSubscription
   */
  updateEntitiesSubscription(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEntities
   */
  retrieveEntities(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEventMessages
   */
  subscribeEventMessages(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEventMessagesSubscription
   */
  updateEventMessagesSubscription(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token balance updates.
   *
   * @generated from protobuf rpc: SubscribeTokenBalances
   */
  subscribeTokenBalances(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token balance subscription
   *
   * @generated from protobuf rpc: UpdateTokenBalancesSubscription
   */
  updateTokenBalancesSubscription(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token updates.
   *
   * @generated from protobuf rpc: SubscribeTokens
   */
  subscribeTokens(input, options) {
    const method = this.methods[9], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token subscription
   *
   * @generated from protobuf rpc: UpdateTokensSubscription
   */
  updateTokensSubscription(input, options) {
    const method = this.methods[10], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEventMessages
   */
  retrieveEventMessages(input, options) {
    const method = this.methods[11], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve events
   *
   * @generated from protobuf rpc: RetrieveEvents
   */
  retrieveEvents(input, options) {
    const method = this.methods[12], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to events
   *
   * @generated from protobuf rpc: SubscribeEvents
   */
  subscribeEvents(input, options) {
    const method = this.methods[13], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve tokens
   *
   * @generated from protobuf rpc: RetrieveTokens
   */
  retrieveTokens(input, options) {
    const method = this.methods[14], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve token balances
   *
   * @generated from protobuf rpc: RetrieveTokenBalances
   */
  retrieveTokenBalances(input, options) {
    const method = this.methods[15], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve transactions
   *
   * @generated from protobuf rpc: RetrieveTransactions
   */
  retrieveTransactions(input, options) {
    const method = this.methods[16], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to transactions
   *
   * @generated from protobuf rpc: SubscribeTransactions
   */
  subscribeTransactions(input, options) {
    const method = this.methods[17], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve controllers
   *
   * @generated from protobuf rpc: RetrieveControllers
   */
  retrieveControllers(input, options) {
    const method = this.methods[18], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve contracts
   *
   * @generated from protobuf rpc: RetrieveContracts
   */
  retrieveContracts(input, options) {
    const method = this.methods[19], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve tokens contracts
   *
   * @generated from protobuf rpc: RetrieveTokenContracts
   */
  retrieveTokenContracts(input, options) {
    const method = this.methods[20], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a torii offchain message
   *
   * @generated from protobuf rpc: PublishMessage
   */
  publishMessage(input, options) {
    const method = this.methods[21], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a set of torii offchain messages
   *
   * @generated from protobuf rpc: PublishMessageBatch
   */
  publishMessageBatch(input, options) {
    const method = this.methods[22], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
};
var DojoGrpcClient = class {
  transport;
  worldClient;
  constructor(config2) {
    this.transport = new GrpcWebFetchTransport({
      baseUrl: config2.url,
      format: "binary"
    });
    this.worldClient = new WorldClient(this.transport);
  }
  destroy() {
  }
};
function hexToBuffer(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function mapOrderDirection(direction) {
  switch (direction) {
    case "Asc":
      return 0;
    case "Desc":
      return 1;
    default:
      return 0;
  }
}
function mapPaginationDirection(direction) {
  switch (direction) {
    case "Forward":
      return 0;
    case "Backward":
      return 1;
    default:
      return 0;
  }
}
function mapOrderBy(orderBy) {
  return {
    field: orderBy.field,
    direction: mapOrderDirection(orderBy.direction)
  };
}
function mapPagination(pagination) {
  return {
    limit: pagination.limit || 0,
    cursor: pagination.cursor || "",
    direction: mapPaginationDirection(pagination.direction),
    order_by: pagination.order_by.map(mapOrderBy)
  };
}
function mapPatternMatching(pattern2) {
  switch (pattern2) {
    case "FixedLen":
      return 0;
    case "VariableLen":
      return 1;
    default:
      return 0;
  }
}
function mapComparisonOperator(op) {
  switch (op) {
    case "Eq":
      return 0;
    case "Neq":
      return 1;
    case "Gt":
      return 2;
    case "Gte":
      return 3;
    case "Lt":
      return 4;
    case "Lte":
      return 5;
    case "In":
      return 6;
    case "NotIn":
      return 7;
    default:
      return 0;
  }
}
function mapLogicalOperator(op) {
  switch (op) {
    case "And":
      return 0;
    case "Or":
      return 1;
    default:
      return 0;
  }
}
function mapMemberValue(value6) {
  if (typeof value6 === "string") {
    return { value_type: { oneofKind: "string", string: value6 } };
  } else if (Array.isArray(value6)) {
    return {
      value_type: {
        oneofKind: "list",
        list: { values: value6.map(mapMemberValue) }
      }
    };
  } else if (value6 && typeof value6 === "object" && "Primitive" in value6) {
    return {
      value_type: {
        oneofKind: "primitive",
        primitive: value6.Primitive
      }
    };
  }
  return {
    value_type: { oneofKind: "string", string: String(value6) }
  };
}
function mapClause(clause) {
  if ("HashedKeys" in clause) {
    const hashedKeysClause = {
      hashed_keys: clause.HashedKeys.map(hexToBuffer)
    };
    return {
      clause_type: {
        oneofKind: "hashed_keys",
        hashed_keys: hashedKeysClause
      }
    };
  } else if ("Keys" in clause) {
    const keysClause = {
      keys: clause.Keys.keys.map(
        (k2) => k2 ? hexToBuffer(k2) : new Uint8Array()
      ),
      pattern_matching: mapPatternMatching(clause.Keys.pattern_matching),
      models: clause.Keys.models
    };
    return {
      clause_type: { oneofKind: "keys", keys: keysClause }
    };
  } else if ("Member" in clause) {
    const memberClause = {
      model: clause.Member.model,
      member: clause.Member.member,
      operator: mapComparisonOperator(clause.Member.operator),
      value: mapMemberValue(clause.Member.value)
    };
    return {
      clause_type: { oneofKind: "member", member: memberClause }
    };
  } else if ("Composite" in clause) {
    const compositeClause = {
      operator: mapLogicalOperator(clause.Composite.operator),
      clauses: clause.Composite.clauses.map(mapClause)
    };
    return {
      clause_type: {
        oneofKind: "composite",
        composite: compositeClause
      }
    };
  }
  throw new Error("Unknown clause type");
}
function mapQuery(query) {
  return {
    pagination: mapPagination(query.pagination),
    clause: query.clause ? mapClause(query.clause) : void 0,
    no_hashed_keys: query.no_hashed_keys,
    models: query.models,
    historical: query.historical
  };
}
function mapControllerQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    usernames: query.usernames,
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenBalanceQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    account_addresses: query.account_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTransactionFilter(filter18) {
  return {
    transaction_hashes: filter18.transaction_hashes.map(hexToBuffer),
    caller_addresses: filter18.caller_addresses.map(hexToBuffer),
    contract_addresses: filter18.contract_addresses.map(hexToBuffer),
    entrypoints: filter18.entrypoints,
    model_selectors: filter18.model_selectors.map(hexToBuffer),
    from_block: filter18.from_block ? BigInt(filter18.from_block) : void 0,
    to_block: filter18.to_block ? BigInt(filter18.to_block) : void 0
  };
}
function mapTransactionQuery(query) {
  return {
    filter: query.filter ? mapTransactionFilter(query.filter) : void 0,
    pagination: mapPagination(query.pagination)
  };
}
function createRetrieveEntitiesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveEventMessagesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveTokensRequest(query) {
  return {
    query: mapTokenQuery(query)
  };
}
function createRetrieveTokenBalancesRequest(query) {
  return {
    query: mapTokenBalanceQuery(query)
  };
}
function createRetrieveTokenContractsRequest(query) {
  return {
    query: mapTokenBalanceQuery(query)
  };
}
function createRetrieveControllersRequest(query) {
  return {
    query: mapControllerQuery(query)
  };
}
function createRetrieveTransactionsRequest(query) {
  return {
    query: mapTransactionQuery(query)
  };
}
function createRetrieveEventsRequest(query) {
  return {
    query: {
      keys: query.keys ? {
        keys: query.keys.keys.map(
          (k2) => k2 ? hexToBuffer(k2) : new Uint8Array()
        ),
        pattern_matching: query.keys.pattern_matching === "FixedLen" ? 0 : 1,
        models: query.keys.models || []
      } : void 0,
      pagination: query.pagination ? mapPagination(query.pagination) : void 0
    }
  };
}
function createRetrieveContractsRequest(query) {
  return {
    query: {
      contract_addresses: query.contract_addresses?.map(hexToBuffer) || [],
      contract_types: query.contract_types || []
    }
  };
}
var textDecoder = void 0;
function bufferToHex(buffer3) {
  return "0x" + Array.from(buffer3).map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
function hexToBuffer2(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function mapCallType(callType) {
  switch (callType) {
    case 0:
      return "Execute";
    case 1:
      return "ExecuteFromOutside";
    default:
      return "Execute";
  }
}
function mapTransactionCall(call) {
  return {
    contract_address: bufferToHex(call.contract_address),
    entrypoint: call.entrypoint,
    calldata: call.calldata.map(bufferToHex),
    call_type: mapCallType(call.call_type),
    caller_address: bufferToHex(call.caller_address)
  };
}
function mapTransaction(tx) {
  return {
    transaction_hash: bufferToHex(tx.transaction_hash),
    sender_address: bufferToHex(tx.sender_address),
    calldata: tx.calldata.map(bufferToHex),
    max_fee: bufferToHex(tx.max_fee),
    signature: tx.signature.map(bufferToHex),
    nonce: bufferToHex(tx.nonce),
    block_number: Number(tx.block_number),
    transaction_type: tx.transaction_type,
    block_timestamp: Number(tx.block_timestamp),
    calls: tx.calls.map(mapTransactionCall),
    unique_models: tx.unique_models.map(bufferToHex)
  };
}
function mapTransactionsResponse(response) {
  return {
    items: response.transactions.map(mapTransaction),
    next_cursor: response.next_cursor || void 0
  };
}
function mapController(controller) {
  return {
    address: bufferToHex(controller.address),
    username: controller.username,
    deployed_at_timestamp: Number(controller.deployed_at_timestamp)
  };
}
function mapControllersResponse(response) {
  return {
    items: response.controllers.map(mapController),
    next_cursor: response.next_cursor || void 0
  };
}
function uint8ArrayToString(input) {
  if (textDecoder) {
    return textDecoder.decode(input);
  }
  textDecoder = new TextDecoder();
  return textDecoder.decode(input);
}
function parseJsonMetadata(input) {
  try {
    return JSON.parse(uint8ArrayToString(input));
  } catch (_err) {
    return uint8ArrayToString(input);
  }
}
function mapToken(token) {
  return {
    contract_address: bufferToHex(token.contract_address),
    token_id: token.token_id ? bufferToHex(token.token_id) : void 0,
    name: token.name,
    symbol: token.symbol,
    decimals: token.decimals,
    metadata: parseJsonMetadata(token.metadata)
  };
}
function mapTokensResponse(response) {
  return {
    items: response.tokens.map(mapToken),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenBalance(balance) {
  return {
    balance: bufferToHex(balance.balance),
    account_address: bufferToHex(balance.account_address),
    contract_address: bufferToHex(balance.contract_address),
    token_id: balance.token_id ? bufferToHex(balance.token_id) : void 0
  };
}
function mapTokenBalancesResponse(response) {
  return {
    items: response.balances.map(mapTokenBalance),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenContract(collection) {
  return {
    contract_address: bufferToHex(collection.contract_address),
    name: collection.name,
    symbol: collection.symbol,
    decimals: collection.decimals,
    count: collection.count,
    metadata: parseJsonMetadata(collection.metadata)
  };
}
function mapTokenContractsResponse(response) {
  return {
    items: response.tokens.map(mapTokenContract),
    next_cursor: response.next_cursor || void 0
  };
}
function mapPrimitive(primitive2) {
  if (!primitive2.primitive_type) return null;
  switch (primitive2.primitive_type.oneofKind) {
    case "i8":
      return primitive2.primitive_type.i8;
    case "i16":
      return primitive2.primitive_type.i16;
    case "i32":
      return primitive2.primitive_type.i32;
    case "i64":
      return Number(primitive2.primitive_type.i64);
    case "i128":
      return bufferToHex(primitive2.primitive_type.i128);
    case "u8":
      return primitive2.primitive_type.u8;
    case "u16":
      return primitive2.primitive_type.u16;
    case "u32":
      return primitive2.primitive_type.u32;
    case "u64":
      return Number(primitive2.primitive_type.u64);
    case "u128":
      return bufferToHex(primitive2.primitive_type.u128);
    case "u256":
      return bufferToHex(primitive2.primitive_type.u256);
    case "bool":
      return primitive2.primitive_type.bool;
    case "felt252":
      return bufferToHex(primitive2.primitive_type.felt252);
    case "class_hash":
      return bufferToHex(primitive2.primitive_type.class_hash);
    case "contract_address":
      return bufferToHex(primitive2.primitive_type.contract_address);
    case "eth_address":
      return bufferToHex(primitive2.primitive_type.eth_address);
    default:
      return null;
  }
}
function getPrimitiveTypeName(primitive2) {
  if (!primitive2.primitive_type) return "";
  return primitive2.primitive_type.oneofKind || "";
}
function mapTy(ty, isKey = false) {
  if (!ty.ty_type) {
    return {
      type: "primitive",
      type_name: "",
      value: null,
      key: isKey
    };
  }
  switch (ty.ty_type.oneofKind) {
    case "primitive": {
      return {
        type: "primitive",
        type_name: getPrimitiveTypeName(ty.ty_type.primitive),
        value: mapPrimitive(ty.ty_type.primitive),
        key: isKey
      };
    }
    case "struct": {
      const struct5 = ty.ty_type.struct;
      const structValue = {};
      for (const member of struct5.children) {
        if (member.ty) {
          structValue[member.name] = mapTy(member.ty, member.key);
        }
      }
      return {
        type: "struct",
        type_name: struct5.name,
        value: structValue,
        key: isKey
      };
    }
    case "enum": {
      const enumType = ty.ty_type.enum;
      const selectedOption = enumType.options[enumType.option];
      return {
        type: "enum",
        type_name: enumType.name,
        value: selectedOption && selectedOption.ty ? {
          option: selectedOption.name,
          value: mapTy(selectedOption.ty)
        } : null,
        key: isKey
      };
    }
    case "array": {
      const array7 = ty.ty_type.array;
      return {
        type: "array",
        type_name: "array",
        value: array7.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "tuple": {
      const tuple4 = ty.ty_type.tuple;
      return {
        type: "tuple",
        type_name: "tuple",
        value: tuple4.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "bytearray": {
      return {
        type: "bytearray",
        type_name: "bytearray",
        value: ty.ty_type.bytearray,
        key: isKey
      };
    }
    default:
      return {
        type: "primitive",
        type_name: "",
        value: null,
        key: isKey
      };
  }
}
function mapModel(model) {
  const mappedModel = {};
  if (model && Array.isArray(model)) {
    for (const member of model) {
      if (member.ty) {
        mappedModel[member.name] = mapTy(member.ty, member.key);
      }
    }
  }
  return mappedModel;
}
function mapEntity(entity) {
  const models = {};
  for (const model of entity.models) {
    models[model.name] = mapModel(model.children);
  }
  return {
    hashed_keys: bufferToHex(entity.hashed_keys),
    models
  };
}
function mapEntitiesResponse(response) {
  return {
    items: response.entities.map(mapEntity),
    next_cursor: response.next_cursor || void 0
  };
}
function mapIndexerUpdate(update10) {
  return {
    head: Number(update10.head),
    tps: Number(update10.tps),
    last_block_timestamp: Number(update10.last_block_timestamp),
    contract_address: bufferToHex(update10.contract_address)
  };
}
function mapMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(hexToBuffer2)
  };
}
function mapEvent(event) {
  return {
    keys: event.keys.map(bufferToHex),
    data: event.data.map(bufferToHex),
    transaction_hash: bufferToHex(event.transaction_hash)
  };
}
function mapEventsResponse(response) {
  return {
    items: response.events.map(mapEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function mapContract(contract) {
  return {
    contract_address: bufferToHex(contract.contract_address),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? bufferToHex(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function mapContractsResponse(response) {
  return {
    items: response.contracts.map(mapContract)
  };
}
function mapWorldMetadataResponse(response) {
  if (!response.world) {
    return null;
  }
  return {
    world_address: bufferToHex(response.world.world_address),
    models: response.world.models.map((model) => ({
      selector: bufferToHex(model.selector),
      namespace: model.namespace,
      name: model.name,
      packed_size: model.packed_size,
      unpacked_size: model.unpacked_size,
      class_hash: bufferToHex(model.class_hash),
      layout: bufferToHex(model.layout),
      schema: bufferToHex(model.schema),
      contract_address: bufferToHex(model.contract_address),
      use_legacy_store: model.use_legacy_store
    }))
  };
}
var HexString = Schema_exports.String.pipe(
  Schema_exports.pattern(/^0x[0-9a-fA-F]*$/, {
    message: () => "Invalid hex string format"
  })
);
var BufferToHex = Schema_exports.transform(
  Schema_exports.Uint8ArrayFromSelf,
  HexString,
  {
    decode: (buffer3) => {
      return "0x" + Array.from(buffer3).map((b2) => b2.toString(16).padStart(2, "0")).join("");
    },
    encode: (hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    }
  }
);
var OptionalBufferToHex = Schema_exports.optional(BufferToHex);
var BufferArrayToHexArray = Schema_exports.transform(
  Schema_exports.Array(Schema_exports.Uint8ArrayFromSelf),
  Schema_exports.Array(HexString),
  {
    decode: (buffers) => buffers.map(
      (buffer3) => "0x" + Array.from(buffer3).map((b2) => b2.toString(16).padStart(2, "0")).join("")
    ),
    encode: (hexStrings) => hexStrings.map((hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    })
  }
);
var BigIntToNumber = Schema_exports.transform(
  Schema_exports.BigIntFromSelf,
  Schema_exports.Number,
  {
    decode: (bigint3) => Number(bigint3),
    encode: (number5) => BigInt(number5)
  }
);
var OptionalString = Schema_exports.optional(Schema_exports.String);
var OptionalNumber = Schema_exports.optional(Schema_exports.Number);
var textDecoder2 = void 0;
var Uint8ArrayToString = Schema_exports.transform(
  Schema_exports.Uint8ArrayFromSelf,
  Schema_exports.String,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      return textDecoder2.decode(input);
    },
    encode: (str) => new TextEncoder().encode(str)
  }
);
var JsonMetadata = Schema_exports.transform(
  Schema_exports.Uint8ArrayFromSelf,
  Schema_exports.Unknown,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      const str = textDecoder2.decode(input);
      try {
        return JSON.parse(str);
      } catch (_err) {
        return str;
      }
    },
    encode: (value6) => {
      const str = typeof value6 === "string" ? value6 : JSON.stringify(value6);
      return new TextEncoder().encode(str);
    }
  }
);
var CallTypeSchema = Schema_exports.transform(
  Schema_exports.Enums({
    EXECUTE: 0,
    EXECUTE_FROM_OUTSIDE: 1
  }),
  Schema_exports.Literal("Execute", "ExecuteFromOutside"),
  {
    decode: (grpcCallType) => {
      switch (grpcCallType) {
        case 0:
          return "Execute";
        case 1:
          return "ExecuteFromOutside";
        default:
          return "Execute";
      }
    },
    encode: (toriiCallType) => {
      switch (toriiCallType) {
        case "Execute":
          return 0;
        case "ExecuteFromOutside":
          return 1;
        default:
          return 0;
      }
    }
  }
);
var TransactionCallSchema = Schema_exports.transform(
  Schema_exports.Struct({
    contract_address: Schema_exports.Uint8ArrayFromSelf,
    entrypoint: Schema_exports.String,
    calldata: Schema_exports.Array(Schema_exports.Uint8ArrayFromSelf),
    call_type: Schema_exports.Enums({
      EXECUTE: 0,
      EXECUTE_FROM_OUTSIDE: 1
    }),
    caller_address: Schema_exports.Uint8ArrayFromSelf
  }),
  Schema_exports.Struct({
    contract_address: BufferToHex,
    entrypoint: Schema_exports.String,
    calldata: BufferArrayToHexArray,
    call_type: CallTypeSchema,
    caller_address: BufferToHex
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      entrypoint: grpc.entrypoint,
      calldata: grpc.calldata,
      call_type: grpc.call_type,
      caller_address: grpc.caller_address
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      entrypoint: torii.entrypoint,
      calldata: torii.calldata,
      call_type: torii.call_type,
      caller_address: torii.caller_address
    })
  }
);
var TransactionSchema = Schema_exports.transform(
  Schema_exports.Struct({
    transaction_hash: Schema_exports.Uint8ArrayFromSelf,
    sender_address: Schema_exports.Uint8ArrayFromSelf,
    calldata: Schema_exports.Array(Schema_exports.Uint8ArrayFromSelf),
    max_fee: Schema_exports.Uint8ArrayFromSelf,
    signature: Schema_exports.Array(Schema_exports.Uint8ArrayFromSelf),
    nonce: Schema_exports.Uint8ArrayFromSelf,
    block_number: Schema_exports.BigIntFromSelf,
    block_timestamp: Schema_exports.BigIntFromSelf,
    transaction_type: Schema_exports.String,
    calls: Schema_exports.Array(TransactionCallSchema),
    unique_models: Schema_exports.Array(Schema_exports.Uint8ArrayFromSelf)
  }),
  Schema_exports.Struct({
    transaction_hash: BufferToHex,
    sender_address: BufferToHex,
    calldata: BufferArrayToHexArray,
    max_fee: BufferToHex,
    signature: BufferArrayToHexArray,
    nonce: BufferToHex,
    block_number: BigIntToNumber,
    block_timestamp: BigIntToNumber,
    transaction_type: Schema_exports.String,
    calls: Schema_exports.Array(TransactionCallSchema),
    unique_models: BufferArrayToHexArray
  }),
  {
    decode: (grpc) => ({
      transaction_hash: grpc.transaction_hash,
      sender_address: grpc.sender_address,
      calldata: grpc.calldata,
      max_fee: grpc.max_fee,
      signature: grpc.signature,
      nonce: grpc.nonce,
      block_number: grpc.block_number,
      block_timestamp: grpc.block_timestamp,
      transaction_type: grpc.transaction_type,
      calls: grpc.calls,
      unique_models: grpc.unique_models
    }),
    encode: (torii) => ({
      transaction_hash: torii.transaction_hash,
      sender_address: torii.sender_address,
      calldata: torii.calldata,
      max_fee: torii.max_fee,
      signature: torii.signature,
      nonce: torii.nonce,
      block_number: BigInt(torii.block_number),
      block_timestamp: BigInt(torii.block_timestamp),
      transaction_type: torii.transaction_type,
      calls: torii.calls,
      unique_models: torii.unique_models
    })
  }
);
var ControllerSchema = Schema_exports.transform(
  Schema_exports.Struct({
    address: Schema_exports.Uint8ArrayFromSelf,
    username: Schema_exports.String,
    deployed_at_timestamp: Schema_exports.BigIntFromSelf
  }),
  Schema_exports.Struct({
    address: BufferToHex,
    username: Schema_exports.String,
    deployed_at_timestamp: BigIntToNumber
  }),
  {
    decode: (grpc) => ({
      address: grpc.address,
      username: grpc.username,
      deployed_at_timestamp: grpc.deployed_at_timestamp
    }),
    encode: (torii) => ({
      address: torii.address,
      username: torii.username,
      deployed_at_timestamp: BigInt(torii.deployed_at_timestamp)
    })
  }
);
var TokenSchema = Schema_exports.transform(
  Schema_exports.Struct({
    contract_address: Schema_exports.Uint8ArrayFromSelf,
    token_id: Schema_exports.optional(Schema_exports.Uint8ArrayFromSelf),
    name: Schema_exports.String,
    symbol: Schema_exports.String,
    decimals: Schema_exports.Number,
    metadata: Schema_exports.Uint8ArrayFromSelf
  }),
  Schema_exports.Struct({
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex,
    name: Schema_exports.String,
    symbol: Schema_exports.String,
    decimals: Schema_exports.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      token_id: grpc.token_id,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      token_id: torii.token_id,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      metadata: torii.metadata
    })
  }
);
var TokenBalanceSchema = Schema_exports.transform(
  Schema_exports.Struct({
    balance: Schema_exports.Uint8ArrayFromSelf,
    account_address: Schema_exports.Uint8ArrayFromSelf,
    contract_address: Schema_exports.Uint8ArrayFromSelf,
    token_id: Schema_exports.optional(Schema_exports.Uint8ArrayFromSelf)
  }),
  Schema_exports.Struct({
    balance: BufferToHex,
    account_address: BufferToHex,
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex
  }),
  {
    decode: (grpc) => ({
      balance: grpc.balance,
      account_address: grpc.account_address,
      contract_address: grpc.contract_address,
      token_id: grpc.token_id
    }),
    encode: (torii) => ({
      balance: torii.balance,
      account_address: torii.account_address,
      contract_address: torii.contract_address,
      token_id: torii.token_id
    })
  }
);
var TokenContractSchema = Schema_exports.transform(
  Schema_exports.Struct({
    contract_address: Schema_exports.Uint8ArrayFromSelf,
    name: Schema_exports.String,
    symbol: Schema_exports.String,
    decimals: Schema_exports.Number,
    count: Schema_exports.BigIntFromSelf,
    metadata: Schema_exports.Uint8ArrayFromSelf
  }),
  Schema_exports.Struct({
    contract_address: BufferToHex,
    name: Schema_exports.String,
    symbol: Schema_exports.String,
    decimals: Schema_exports.Number,
    count: Schema_exports.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      count: grpc.count,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      count: BigInt(torii.count),
      metadata: torii.metadata
    })
  }
);
var TransactionsResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    transactions: Schema_exports.Array(TransactionSchema),
    next_cursor: OptionalString
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(TransactionSchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.transactions,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      transactions: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var ControllersResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    controllers: Schema_exports.Array(ControllerSchema),
    next_cursor: OptionalString
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(ControllerSchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.controllers,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      controllers: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokensResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    tokens: Schema_exports.Array(TokenSchema),
    next_cursor: OptionalString
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(TokenSchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenBalancesResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    balances: Schema_exports.Array(TokenBalanceSchema),
    next_cursor: OptionalString
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(TokenBalanceSchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.balances,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      balances: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenContractsResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    tokens: Schema_exports.Array(TokenContractSchema),
    next_cursor: OptionalString
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(TokenContractSchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var PrimitiveSchema = Schema_exports.transform(
  Schema_exports.Struct({
    primitive_type: Schema_exports.Union(
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("i8"),
        i8: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("i16"),
        i16: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("i32"),
        i32: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("i64"),
        i64: Schema_exports.BigIntFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("i128"),
        i128: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u8"),
        u8: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u16"),
        u16: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u32"),
        u32: Schema_exports.Number
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u64"),
        u64: Schema_exports.BigIntFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u128"),
        u128: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("u256"),
        u256: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("bool"),
        bool: Schema_exports.Boolean
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("felt252"),
        felt252: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("class_hash"),
        class_hash: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("contract_address"),
        contract_address: Schema_exports.Uint8ArrayFromSelf
      }),
      Schema_exports.Struct({
        oneofKind: Schema_exports.Literal("eth_address"),
        eth_address: Schema_exports.Uint8ArrayFromSelf
      })
    ).pipe(Schema_exports.optional)
  }),
  Schema_exports.Unknown,
  {
    decode: (primitive2) => {
      if (!primitive2.primitive_type) return null;
      switch (primitive2.primitive_type.oneofKind) {
        case "i8":
          return primitive2.primitive_type.i8;
        case "i16":
          return primitive2.primitive_type.i16;
        case "i32":
          return primitive2.primitive_type.i32;
        case "i64":
          return Number(primitive2.primitive_type.i64);
        case "i128":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.i128
          );
        case "u8":
          return primitive2.primitive_type.u8;
        case "u16":
          return primitive2.primitive_type.u16;
        case "u32":
          return primitive2.primitive_type.u32;
        case "u64":
          return Number(primitive2.primitive_type.u64);
        case "u128":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.u128
          );
        case "u256":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.u256
          );
        case "bool":
          return primitive2.primitive_type.bool;
        case "felt252":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.felt252
          );
        case "class_hash":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.class_hash
          );
        case "contract_address":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.contract_address
          );
        case "eth_address":
          return BufferToHex.pipe(Schema_exports.decodeSync)(
            primitive2.primitive_type.eth_address
          );
        default:
          return null;
      }
    },
    encode: (value6) => {
      throw new Error("Encoding not implemented for PrimitiveSchema");
    }
  }
);
var TySchema = Schema_exports.suspend(
  () => Schema_exports.transform(
    Schema_exports.Struct({
      ty_type: Schema_exports.Union(
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("primitive"),
          primitive: PrimitiveSchema
        }),
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("struct"),
          struct: Schema_exports.Struct({
            name: Schema_exports.String,
            children: Schema_exports.Array(MemberSchema)
          })
        }),
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("enum"),
          enum: Schema_exports.Struct({
            name: Schema_exports.String,
            option: Schema_exports.Number,
            options: Schema_exports.Array(MemberSchema)
          })
        }),
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("array"),
          array: Schema_exports.Struct({
            children: Schema_exports.Array(TySchema)
          })
        }),
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("tuple"),
          tuple: Schema_exports.Struct({
            children: Schema_exports.Array(TySchema)
          })
        }),
        Schema_exports.Struct({
          oneofKind: Schema_exports.Literal("bytearray"),
          bytearray: Schema_exports.String
        })
      ).pipe(Schema_exports.optional)
    }),
    Schema_exports.Struct({
      type: Schema_exports.String,
      type_name: Schema_exports.String,
      value: Schema_exports.Unknown,
      key: Schema_exports.Boolean
    }),
    {
      decode: (ty, isKey = false) => {
        if (!ty.ty_type) {
          return {
            type: "primitive",
            type_name: "",
            value: null,
            key: isKey
          };
        }
        switch (ty.ty_type.oneofKind) {
          case "primitive": {
            const primitiveValue = PrimitiveSchema.pipe(
              Schema_exports.decodeSync
            )(ty.ty_type.primitive);
            return {
              type: "primitive",
              type_name: ty.ty_type.primitive.primitive_type?.oneofKind || "",
              value: primitiveValue,
              key: isKey
            };
          }
          case "struct": {
            const struct5 = ty.ty_type.struct;
            const structValue = {};
            for (const member of struct5.children) {
              if (member.ty) {
                structValue[member.name] = TySchema.pipe(
                  Schema_exports.decodeSync
                )(member.ty);
              }
            }
            return {
              type: "struct",
              type_name: struct5.name,
              value: structValue,
              key: isKey
            };
          }
          case "enum": {
            const enumType = ty.ty_type.enum;
            const selectedOption = enumType.options[enumType.option];
            return {
              type: "enum",
              type_name: enumType.name,
              value: selectedOption && selectedOption.ty ? {
                option: selectedOption.name,
                value: TySchema.pipe(
                  Schema_exports.decodeSync
                )(selectedOption.ty)
              } : null,
              key: isKey
            };
          }
          case "array": {
            const array7 = ty.ty_type.array;
            return {
              type: "array",
              type_name: "array",
              value: array7.children.map(
                (child) => TySchema.pipe(Schema_exports.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "tuple": {
            const tuple4 = ty.ty_type.tuple;
            return {
              type: "tuple",
              type_name: "tuple",
              value: tuple4.children.map(
                (child) => TySchema.pipe(Schema_exports.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "bytearray": {
            return {
              type: "bytearray",
              type_name: "bytearray",
              value: ty.ty_type.bytearray,
              key: isKey
            };
          }
          default:
            return {
              type: "primitive",
              type_name: "",
              value: null,
              key: isKey
            };
        }
      },
      encode: (torii) => {
        throw new Error("Encoding not implemented for TySchema");
      }
    }
  )
);
var MemberSchema = Schema_exports.suspend(
  () => Schema_exports.Struct({
    name: Schema_exports.String,
    ty: Schema_exports.optional(TySchema),
    key: Schema_exports.Boolean
  })
);
var ModelSchema = Schema_exports.transform(
  Schema_exports.Array(MemberSchema),
  Schema_exports.Record({ key: Schema_exports.String, value: TySchema }),
  {
    decode: (members) => {
      const model = {};
      if (members && Array.isArray(members)) {
        for (const member of members) {
          if (member.ty) {
            const ty = TySchema.pipe(Schema_exports.decodeSync)(member.ty);
            model[member.name] = { ...ty, key: member.key };
          }
        }
      }
      return model;
    },
    encode: (model) => {
      throw new Error("Encoding not implemented for ModelSchema");
    }
  }
);
var EntitySchema = Schema_exports.transform(
  Schema_exports.Struct({
    hashed_keys: Schema_exports.Uint8ArrayFromSelf,
    models: Schema_exports.Array(
      Schema_exports.Struct({
        name: Schema_exports.String,
        children: Schema_exports.Array(MemberSchema)
      })
    )
  }),
  Schema_exports.Struct({
    hashed_keys: BufferToHex,
    models: Schema_exports.Record({ key: Schema_exports.String, value: ModelSchema })
  }),
  {
    decode: (grpc) => {
      const models = {};
      for (const model of grpc.models) {
        models[model.name] = ModelSchema.pipe(Schema_exports.decodeSync)(
          model.children
        );
      }
      return {
        hashed_keys: BufferToHex.pipe(Schema_exports.decodeSync)(
          grpc.hashed_keys
        ),
        models
      };
    },
    encode: (torii) => {
      throw new Error("Encoding not implemented for EntitySchema");
    }
  }
);
var EntitiesResponseSchema = Schema_exports.transform(
  Schema_exports.Struct({
    entities: Schema_exports.Array(EntitySchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  Schema_exports.Struct({
    items: Schema_exports.Array(EntitySchema),
    next_cursor: Schema_exports.optional(Schema_exports.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.entities,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      entities: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
function transformTransaction(tx) {
  return Schema_exports.decodeSync(TransactionSchema)(tx);
}
function transformTransactionsResponse(response) {
  return Schema_exports.decodeSync(TransactionsResponseSchema)(response);
}
function transformControllersResponse(response) {
  return Schema_exports.decodeSync(ControllersResponseSchema)(response);
}
function transformToken(token) {
  return Schema_exports.decodeSync(TokenSchema)(token);
}
function transformTokensResponse(response) {
  return Schema_exports.decodeSync(TokensResponseSchema)(response);
}
function transformTokenBalance(balance) {
  return Schema_exports.decodeSync(TokenBalanceSchema)(balance);
}
function transformTokenBalancesResponse(response) {
  return Schema_exports.decodeSync(TokenBalancesResponseSchema)(response);
}
function transformTokenContractsResponse(response) {
  return Schema_exports.decodeSync(TokenContractsResponseSchema)(response);
}
function transformEntity(entity) {
  return Schema_exports.decodeSync(EntitySchema)(entity);
}
function transformEntitiesResponse(response) {
  return Schema_exports.decodeSync(EntitiesResponseSchema)(response);
}
function transformIndexerUpdate(update10) {
  return {
    head: Number(update10.head),
    tps: Number(update10.tps),
    last_block_timestamp: Number(update10.last_block_timestamp),
    contract_address: Schema_exports.decodeSync(BufferToHex)(
      update10.contract_address
    )
  };
}
function transformMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(
      (sig) => Schema_exports.encodeSync(BufferToHex)(sig)
    )
  };
}
function transformEvent(event) {
  return {
    keys: event.keys.map(
      (key) => Schema_exports.decodeSync(BufferToHex)(key)
    ),
    data: event.data.map(
      (d) => Schema_exports.decodeSync(BufferToHex)(d)
    ),
    transaction_hash: Schema_exports.decodeSync(BufferToHex)(
      event.transaction_hash
    )
  };
}
function transformEventsResponse(response) {
  return {
    items: response.events.map(transformEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function transformContract(contract) {
  return {
    contract_address: Schema_exports.decodeSync(BufferToHex)(
      contract.contract_address
    ),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? Schema_exports.decodeSync(BufferToHex)(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function transformContractsResponse(response) {
  return {
    items: response.contracts.map(transformContract)
  };
}
function transformWorldMetadataResponse(response) {
  if (!response.world) {
    return null;
  }
  return {
    world_address: Schema_exports.decodeSync(BufferToHex)(
      response.world.world_address
    ),
    models: response.world.models.map((model) => ({
      selector: Schema_exports.decodeSync(BufferToHex)(model.selector),
      namespace: model.namespace,
      name: model.name,
      packed_size: model.packed_size,
      unpacked_size: model.unpacked_size,
      class_hash: Schema_exports.decodeSync(BufferToHex)(model.class_hash),
      layout: Schema_exports.decodeSync(BufferToHex)(model.layout),
      schema: Schema_exports.decodeSync(BufferToHex)(model.schema),
      contract_address: Schema_exports.decodeSync(BufferToHex)(
        model.contract_address
      ),
      use_legacy_store: model.use_legacy_store
    }))
  };
}
function hexToBuffer3(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function bufferToHex2(buffer3) {
  return "0x" + Array.from(buffer3).map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
var Subscription = class {
  _subscription;
  constructor(subscription) {
    this._subscription = subscription;
  }
  cancel() {
    this._subscription.cancel();
  }
  free() {
    this._subscription.cancel();
  }
  get id() {
    return this._subscription.id;
  }
};
var ToriiGrpcClient = class {
  client;
  nextSubscriptionId = 1n;
  subscriptions = /* @__PURE__ */ new Map();
  useEffectSchema;
  mappers;
  constructor(config2) {
    this.client = new DojoGrpcClient({
      url: config2.toriiUrl
    });
    this.useEffectSchema = config2.useEffectSchema ?? false;
    this.mappers = this.useEffectSchema ? {
      entitiesResponse: transformEntitiesResponse,
      controllersResponse: transformControllersResponse,
      tokensResponse: transformTokensResponse,
      tokenBalancesResponse: transformTokenBalancesResponse,
      tokenContractsResponse: transformTokenContractsResponse,
      transactionsResponse: transformTransactionsResponse,
      indexerUpdate: transformIndexerUpdate,
      message: transformMessage,
      transaction: transformTransaction,
      entity: transformEntity,
      token: transformToken,
      tokenBalance: transformTokenBalance,
      eventsResponse: transformEventsResponse,
      contractsResponse: transformContractsResponse,
      worldMetadataResponse: transformWorldMetadataResponse,
      event: transformEvent,
      contract: transformContract
    } : {
      entitiesResponse: mapEntitiesResponse,
      controllersResponse: mapControllersResponse,
      tokensResponse: mapTokensResponse,
      tokenBalancesResponse: mapTokenBalancesResponse,
      tokenContractsResponse: mapTokenContractsResponse,
      transactionsResponse: mapTransactionsResponse,
      indexerUpdate: mapIndexerUpdate,
      message: mapMessage,
      transaction: mapTransaction,
      entity: mapEntity,
      token: mapToken,
      tokenBalance: mapTokenBalance,
      eventsResponse: mapEventsResponse,
      contractsResponse: mapContractsResponse,
      worldMetadataResponse: mapWorldMetadataResponse,
      event: mapEvent,
      contract: mapContract
    };
  }
  createStreamSubscription(options) {
    const subscriptionId = this.nextSubscriptionId++;
    const stream2 = options.createStream();
    const subscription = {
      id: subscriptionId,
      stream: stream2,
      cancel: () => {
        this.subscriptions.delete(subscriptionId);
      }
    };
    this.subscriptions.set(subscriptionId, subscription);
    stream2.responses.onMessage(options.onMessage);
    if (options.onError) {
      stream2.responses.onError(options.onError);
    } else {
      stream2.responses.onError((error2) => {
        console.error(
          `Stream error (subscription ${subscriptionId}):`,
          error2
        );
      });
    }
    if (options.onComplete) {
      stream2.responses.onComplete(options.onComplete);
    } else {
      stream2.responses.onComplete(() => {
        this.subscriptions.delete(subscriptionId);
      });
    }
    return new Subscription(subscription);
  }
  async getControllers(query) {
    const request2 = createRetrieveControllersRequest(query);
    const response = await this.client.worldClient.retrieveControllers(request2).response;
    return this.mappers.controllersResponse(response);
  }
  async getTransactions(query) {
    const request2 = createRetrieveTransactionsRequest(query);
    const response = await this.client.worldClient.retrieveTransactions(request2).response;
    return this.mappers.transactionsResponse(response);
  }
  async getTokens(query) {
    const request2 = createRetrieveTokensRequest(query);
    const response = await this.client.worldClient.retrieveTokens(request2).response;
    return this.mappers.tokensResponse(response);
  }
  async getTokenBalances(query) {
    const request2 = createRetrieveTokenBalancesRequest(query);
    const response = await this.client.worldClient.retrieveTokenBalances(request2).response;
    return this.mappers.tokenBalancesResponse(response);
  }
  async getTokenContracts(query) {
    const request2 = createRetrieveTokenContractsRequest(query);
    const response = await this.client.worldClient.retrieveTokenContracts(request2).response;
    return this.mappers.tokenContractsResponse(response);
  }
  async getEntities(query) {
    const request2 = createRetrieveEntitiesRequest(query);
    const response = await this.client.worldClient.retrieveEntities(request2).response;
    return this.mappers.entitiesResponse(response);
  }
  async getAllEntities(limit, cursor) {
    const query = {
      pagination: {
        limit,
        cursor: cursor || void 0,
        direction: "Forward",
        order_by: []
      },
      clause: void 0,
      no_hashed_keys: true,
      models: [],
      historical: false
    };
    return this.getEntities(query);
  }
  async getEventMessages(query) {
    const request2 = createRetrieveEventMessagesRequest(query);
    const response = await this.client.worldClient.retrieveEventMessages(request2).response;
    return this.mappers.entitiesResponse(response);
  }
  async onTransaction(filter18, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTransactions({
        filter: filter18 ? mapTransactionFilter(filter18) : void 0
      }),
      onMessage: (response) => {
        if (response.transaction) {
          callback(this.mappers.transaction(response.transaction));
        }
      }
    });
  }
  async onTokenUpdated(contract_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokens({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.token) {
          callback(this.mappers.token(response.token));
        }
      }
    });
  }
  async onEntityUpdated(clause, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEntities({
        clause: clause ? mapClause(clause) : void 0
      }),
      onMessage: (response) => {
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateEntitySubscription(subscription, clause) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEntitiesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0
    }).response;
  }
  async onEventMessageUpdated(clause, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEventMessages({
        clause: clause ? mapClause(clause) : void 0
      }),
      onMessage: (response) => {
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateEventMessageSubscription(subscription, clause) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEventMessagesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0
    }).response;
  }
  async onStarknetEvent(clauses, callback) {
    const grpcClauses = clauses.map((clause) => ({
      keys: clause.keys.map(
        (k2) => k2 ? hexToBuffer3(k2) : new Uint8Array()
      ),
      pattern_matching: clause.pattern_matching === "FixedLen" ? 0 : 1,
      models: clause.models
    }));
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEvents({
        keys: grpcClauses
      }),
      onMessage: (response) => {
        if (response.event) {
          const hexConverter = this.useEffectSchema ? (buffer3) => Schema_exports.decodeSync(BufferToHex)(buffer3) : bufferToHex2;
          callback({
            keys: response.event.keys.map(hexConverter),
            data: response.event.data.map(hexConverter),
            transaction_hash: hexConverter(
              response.event.transaction_hash
            )
          });
        }
      }
    });
  }
  async onTokenBalanceUpdated(contract_addresses, account_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokenBalances({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        account_addresses: account_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.balance) {
          callback(
            this.mappers.tokenBalance(response.balance),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateTokenBalanceSubscription(subscription, contract_addresses, account_addresses, token_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokenBalancesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contract_addresses.map(hexToBuffer3),
      account_addresses: account_addresses.map(hexToBuffer3),
      token_ids: token_ids.map(hexToBuffer3)
    }).response;
  }
  async publishMessage(message) {
    const request2 = this.mappers.message(message);
    const response = await this.client.worldClient.publishMessage(request2).response;
    return this.useEffectSchema ? Schema_exports.decodeSync(BufferToHex)(response.entity_id) : bufferToHex2(response.entity_id);
  }
  async publishMessageBatch(messages) {
    const request2 = {
      messages: messages.map(this.mappers.message)
    };
    const response = await this.client.worldClient.publishMessageBatch(request2).response;
    const hexConverter = this.useEffectSchema ? (buffer3) => Schema_exports.decodeSync(BufferToHex)(buffer3) : bufferToHex2;
    return response.responses.map((r) => hexConverter(r.entity_id));
  }
  async getWorldMetadata() {
    const response = await this.client.worldClient.worldMetadata({}).response;
    return this.mappers.worldMetadataResponse(response);
  }
  async getEvents(query) {
    const request2 = createRetrieveEventsRequest(query);
    const response = await this.client.worldClient.retrieveEvents(request2).response;
    return this.mappers.eventsResponse(response);
  }
  async getContracts(query) {
    const request2 = createRetrieveContractsRequest(query || {});
    const response = await this.client.worldClient.retrieveContracts(request2).response;
    return this.mappers.contractsResponse(response);
  }
  async updateTokensSubscription(subscription, contractAddresses, tokenIds) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokensSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contractAddresses?.map(hexToBuffer3) || [],
      token_ids: tokenIds?.map(hexToBuffer3) || []
    }).response;
  }
  async onContractsUpdated(query, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeContracts({
        query: {
          contract_addresses: query.contract_addresses?.map(hexToBuffer3) || [],
          contract_types: query.contract_types || []
        }
      }),
      onMessage: (response) => {
        if (response.contract) {
          callback(this.mappers.contract(response.contract));
        }
      }
    });
  }
  findSubscription(subscription) {
    return this.subscriptions.get(subscription.id);
  }
  destroy() {
    for (const [_2, subscription] of this.subscriptions) {
      subscription.cancel();
    }
    this.subscriptions.clear();
    this.client.destroy();
  }
};

// node_modules/.pnpm/@dojoengine+sdk@1.7.2_@tanstack+react-query@5.86.0_react@18.3.1__@types+react-dom@18.3._4809cdb42fd73c9f09f3fee080481e5d/node_modules/@dojoengine/sdk/dist/web/chunk-T6XYST2Q.js
function v(t, e) {
  if (Object.hasOwn(t, "type") && Object.hasOwn(t, "value")) return { Primitive: { [t.type]: t.value } };
  if (typeof t == "number") return { Primitive: { U32: t } };
  if (typeof t == "boolean") return { Primitive: { Bool: t } };
  if (typeof t == "bigint") return { Primitive: { Felt252: e(t.toString()) } };
  if (typeof t == "string") return { String: t };
  if (Array.isArray(t)) return { List: t.map((r) => v(r, e)) };
  throw new Error(`Unsupported primitive type: ${typeof t}`);
}
function ht(t, e, r = "VariableLen") {
  return new h().keys(t, e, r);
}
function ft(t) {
  return new h().hashed_keys(t);
}
function bt(t, e, r, s) {
  return new h().where(t, e, r, s);
}
function kt(t) {
  return new h().compose().and(t);
}
function Tt(t) {
  return new h().compose().or(t);
}
var h = class {
  clause;
  constructor() {
    this.clause = {};
  }
  keys(t, e, r = "VariableLen") {
    return this.clause = { Keys: { keys: e.length === 0 ? [void 0] : e, pattern_matching: r, models: t } }, this;
  }
  hashed_keys(t) {
    let e = t.map((r, s) => {
      try {
        return `0x${BigInt(r).toString(16)}`;
      } catch {
        throw new Error(`Invalid key value at index ${s}: ${r}. Expected a valid BigNumberish value.`);
      }
    });
    return this.clause = { HashedKeys: e }, this;
  }
  where(t, e, r, s) {
    let n = Array.isArray(s) ? { List: s.map((c) => v(c, shortString_exports.encodeShortString)) } : v(s, shortString_exports.encodeShortString);
    return this.clause = { Member: { model: t, member: e, operator: r, value: n } }, this;
  }
  compose() {
    return new z();
  }
  build() {
    if (Object.keys(this.clause).length === 0) throw new Error("You cannot build an empty Clause");
    return this.clause;
  }
};
var z = class {
  orClauses = [];
  andClauses = [];
  or(t) {
    return this.orClauses = t.map((e) => e.build()), this;
  }
  and(t) {
    return this.andClauses = t.map((e) => e.build()), this;
  }
  build() {
    if (this.orClauses.length === 0 && this.andClauses.length === 0) throw new Error("ComposeClause is empty. Add .or([clause]) or .and([clause])");
    if (this.orClauses && this.andClauses.length === 0) return { Composite: { operator: "Or", clauses: this.orClauses } };
    if (this.andClauses && this.orClauses.length === 0) return { Composite: { operator: "And", clauses: this.andClauses } };
    if (this.andClauses && this.orClauses) return { Composite: { operator: "And", clauses: [...this.andClauses, { Composite: { operator: "Or", clauses: this.orClauses } }] } };
    throw new Error("CompositeClause is not properly build");
  }
};
var wt = "No signer configured in sdk.init()";
var Ct = "No identity configured in sdk.init()";
var P = "Account is undefined";
var W = "Clause has not been defined yet. Use `.withClause()` to do so";
function G(t, e, r, s, n) {
  return { types: { StarknetDomain: [{ name: "name", type: "shortstring" }, { name: "version", type: "shortstring" }, { name: "chainId", type: "shortstring" }, { name: "revision", type: "shortstring" }], ...n, [t]: s !== void 0 ? s : Object.keys(e).map((c) => ({ name: c, type: typeof e[c] == "bigint" || typeof e[c] == "number" ? "felt" : "string" })) }, primaryType: t, domain: r, message: e };
}
function D(t) {
  return t instanceof CairoOption;
}
function X(t, e) {
  return e instanceof CairoOption && e.isSome() ? new CairoOption(CairoOptionVariant.Some, e.unwrap()) : t instanceof CairoOption ? t.isSome() ? new CairoOption(CairoOptionVariant.Some, t.unwrap()) : new CairoOption(CairoOptionVariant.None) : t;
}
function T(t) {
  return t instanceof CairoCustomEnum;
}
function Z(t, e) {
  if (!T(t) || !T(e)) return t;
  let r = e.activeVariant(), s = e.unwrap();
  if (r && s !== void 0) {
    let u = {};
    for (let i in t.variant) u[i] = void 0;
    return u[r] = s, new CairoCustomEnum(u);
  }
  let n = t.activeVariant(), c = t.unwrap();
  if (n && c !== void 0) {
    let u = {};
    for (let i in t.variant) u[i] = void 0;
    return u[n] = c, new CairoCustomEnum(u);
  }
  return t;
}
function tt(t, e) {
  if (D(t) && D(e)) return X(t, e);
  if (T(t) && T(e)) return Z(t, e);
  let r = { ...t };
  for (let s in e) Object.hasOwn(e, s) && (e[s] !== null && typeof e[s] == "object" && !Array.isArray(e[s]) && s in t && typeof t[s] == "object" && !Array.isArray(t[s]) ? r[s] = tt(t[s], e[s]) : r[s] = e[s]);
  return r;
}
function vt(t, e, r) {
  let [s, n] = e.split("-");
  for (let c of r) if (c.entityId === t) return c.models?.[s]?.[n];
}
function At(t, e) {
  let [r, s] = t.split("-");
  for (let n of e) return n.models?.[r]?.[s];
}
var _ = { limit: 1e3, cursor: void 0, direction: "Forward", order_by: [] };
var f = class q {
  constructor(e, r, s) {
    this.limit = e, this.cursor = r, this.direction = s, this.items = [], s || (this.direction = "Forward");
  }
  items;
  static fromQuery(e, r) {
    let s = e.getPagination();
    return new q(s.limit ?? 1e3, r, s.direction);
  }
  withItems(e) {
    return this.items = e, this;
  }
  getItems() {
    return this.items;
  }
  getNextQuery(e) {
    let r = e.withLimit(this.limit);
    return this.cursor && r.withCursor(this.cursor), r.getPagination().direction !== this.direction && r.withDirection(this.direction), r;
  }
  getPreviousQuery(e) {
    let r = e.withLimit(this.limit);
    return this.cursor && r.withCursor(this.cursor), r.getPagination().direction === this.direction && r.withDirection(et(this.direction)), r;
  }
};
function et(t) {
  return t === "Forward" ? "Backward" : "Forward";
}
function y(t, e) {
  let r = [];
  for (let s of t) {
    let n = addAddressPadding(s.hashed_keys), c = s.models, u = { entityId: n, models: {} };
    for (let i in s.models) {
      let [a, o] = i.split("-");
      if (!a || !o) {
        e?.logging && console.warn(`Invalid modelName format: ${i}`);
        continue;
      }
      u.models[a] || (u.models[a] = {}), u.models[a][o] = N(c[i]);
    }
    r.push(u), e?.logging && console.log("Parsed entity:", u);
  }
  return e?.logging && console.log("Parsed result:", r), Object.values(r);
}
function w(t) {
  switch (t.type) {
    case "primitive":
      return nt(t);
    case "struct":
      return N(t.value);
    case "enum":
      return t.value.option === "Some" ? new CairoOption(CairoOptionVariant.Some, w(t.value.value)) : t.value.option === "None" ? new CairoOption(CairoOptionVariant.None) : it(t);
    case "tuple":
    case "array":
      return t.value.map(w);
    default:
      return t.value;
  }
}
function it(t) {
  return t.value.value.type === "tuple" ? t.value.option : new CairoCustomEnum({ [t.value.option]: w(t.value.value) });
}
function nt(t) {
  switch (t.type_name) {
    case "u64":
    case "i64":
      return Number(t.value);
    case "u128":
    case "i128":
      return BigInt(t.value);
    case "u256":
      return BigInt(t.value);
    case "u8":
    case "u16":
    case "u32":
    case "i8":
    case "i16":
    case "i32":
    case "bool":
    case "ContractAddress":
    case "ClassHash":
    case "felt252":
    case "EthAddress":
    default:
      return t.value;
  }
}
function N(t) {
  let e = t instanceof Map ? Array.from(t.entries()) : Object.entries(t);
  return Object.fromEntries(e.map(([r, s]) => [r, w(s)]));
}
function B(t) {
  return (e) => {
    try {
      if (t) {
        let r = y([e]);
        t({ data: r, error: void 0 });
      }
    } catch (r) {
      t && t({ data: void 0, error: r instanceof Error ? r : new Error(String(r)) });
    }
  };
}
function m(t, e) {
  return (r) => {
    if (r !== e) try {
      t({ data: r, error: void 0 });
    } catch (s) {
      t({ data: void 0, error: s });
    }
  };
}
var b = { balance: "0x0000000000000000000000000000000000000000000000000000000000000000", account_address: "0x0", contract_address: "0x0", token_id: "0x0000000000000000000000000000000000000000000000000000000000000000" };
function l(t) {
  return t.contractAddresses && (t.contractAddresses = t.contractAddresses.map((e) => addAddressPadding(e))), t.accountAddresses && (t.accountAddresses = t.accountAddresses.map((e) => addAddressPadding(e))), { contractAddresses: t.contractAddresses ?? [], accountAddresses: t.accountAddresses ?? [], attributesFilter: t.attributesFilter ?? [], contractTypes: t.contractTypes ?? [], tokenIds: t.tokenIds ?? [], pagination: t.pagination ?? _ };
}
function at4(t) {
  return t.map((e) => ({ trait_name: e.name, trait_value: e.value }));
}
async function E(t, e) {
  let { contractAddresses: r, tokenIds: s, pagination: n, attributesFilter: c } = l(e);
  return await t.getTokens({ contract_addresses: r, token_ids: s, attribute_filters: at4(c), pagination: n });
}
async function K(t, e) {
  let { contractAddresses: r, contractTypes: s, pagination: n } = l(e);
  return await t.getTokenContracts({ contract_addresses: r, contract_types: s, pagination: n });
}
async function I(t, e) {
  let { contractAddresses: r, accountAddresses: s, tokenIds: n, pagination: c } = l(e);
  return await t.getTokenBalances({ contract_addresses: r, account_addresses: s, token_ids: n, pagination: c });
}
async function Bt(t, e) {
  let { contractAddresses: r, accountAddresses: s, tokenIds: n } = l(e);
  return await t.onTokenBalanceUpdated(r ?? [], s ?? [], n ?? [], m(e.callback, b));
}
async function Q(t, e) {
  let { subscription: r, contractAddresses: s, accountAddresses: n, tokenIds: c } = e;
  return await t.updateTokenBalanceSubscription(r, s ?? [], n ?? [], c ?? []);
}
async function j(t, e) {
  let { contractAddresses: r, accountAddresses: s, tokenIds: n, callback: c } = e, u = await I(t, { contractAddresses: r ?? [], accountAddresses: s ?? [], tokenIds: n ?? [] }), i = await t.onTokenBalanceUpdated(r ?? [], s ?? [], n ?? [], m(c, b));
  return [u, i];
}
var k = { contract_address: "0x0", token_id: "0x0000000000000000000000000000000000000000000000000000000000000000", name: "", symbol: "", decimals: 0, metadata: "", total_supply: "" };
async function Et(t, e) {
  let { contractAddresses: r, tokenIds: s, callback: n } = l(e);
  return await t.onTokenUpdated(r ?? [], s ?? [], m(n, k));
}
async function F(t, e) {
  let { contractAddresses: r, tokenIds: s, callback: n } = e, c = await E(t, { contractAddresses: r ?? [], tokenIds: s ?? [] }), u = await t.onTokenUpdated(r ?? [], s ?? [], m(n, k));
  return [c, u];
}
var L = () => ({ pagination: { limit: 100, cursor: void 0, direction: "Forward", order_by: [] }, clause: void 0, no_hashed_keys: true, models: [], historical: false });
var ut = class V {
  query;
  constructor(e) {
    this.query = { ...L(), ...e };
  }
  withLimit(e) {
    return this.query.pagination.limit = e, this;
  }
  withOffset() {
    return this;
  }
  withCursor(e) {
    return this.query.pagination.cursor = e, this;
  }
  withDirection(e) {
    return this.query.pagination.direction = e, this;
  }
  withClause(e) {
    return this.query.clause = e, this;
  }
  includeHashedKeys() {
    return this.query.no_hashed_keys = false, this;
  }
  addOrderBy(e, r) {
    return this.query.pagination.order_by.push({ field: e, direction: r }), this;
  }
  withOrderBy(e) {
    return this.query.pagination.order_by = e, this;
  }
  addEntityModel(e) {
    return this.query.models.push(e), this;
  }
  withEntityModels(e) {
    return this.query.models = e, this;
  }
  build() {
    return this.query;
  }
  static withPagination(e, r, s) {
    return new V().withLimit(r).withCursor(e).withDirection(s);
  }
  getClause() {
    return this.query.clause ? ok(this.query.clause) : err(W);
  }
  getPagination() {
    return this.query.pagination;
  }
  isHistorical() {
    return this.query.historical;
  }
};
var Mt = class extends ut {
  constructor(t) {
    super({ ...L(), ...t, historical: true });
  }
};
function H({ client: t, config: e, sendMessage: r, sendMessageBatch: s, grpcClient: n }) {
  let c = n ?? t;
  if (!c) throw new Error("Either client or grpcClient must be provided");
  let u = n ?? new ToriiGrpcClient({ toriiUrl: e.client.toriiUrl ?? "http://localhost:8080", worldAddress: e.client.worldAddress });
  return { client: t, subscribeEntityQuery: async ({ query: i, callback: a }) => {
    let o = i.build(), d = await c.getEntities(o), p = y(d.items);
    return [f.fromQuery(i, d.next_cursor).withItems(p), await c.onEntityUpdated(o.clause, B(a))];
  }, subscribeEventQuery: async ({ query: i, callback: a }) => {
    let o = i.build(), d = await u.getEventMessages(o), p = y(d.items);
    return [f.fromQuery(i, d.next_cursor).withItems(p), await u.onEventMessageUpdated(o.clause, B(a))];
  }, subscribeTokenBalance: async (i) => {
    if (n) {
      let { contractAddresses: a, accountAddresses: o, tokenIds: d, pagination: p } = l(i), C = await n.getTokenBalances({ contract_addresses: a, account_addresses: o, token_ids: d, pagination: p }), Y = await n.onTokenBalanceUpdated(a ?? [], o ?? [], d ?? [], m(i.callback, b));
      return [C, Y];
    }
    return await j(t, i);
  }, getEntities: async ({ query: i }) => {
    let a = i.build(), o = await c.getEntities(a);
    return f.fromQuery(i, o.next_cursor).withItems(y(o.items));
  }, getEventMessages: async ({ query: i }) => {
    let a = i.build(), o = await c.getEventMessages(a);
    return f.fromQuery(i, o.next_cursor).withItems(y(o.items));
  }, generateTypedData: (i, a, o, d) => G(i, a, e.domain, o, d), sendMessage: r, sendMessageBatch: s, sendSignedMessageBatch: async (i) => {
    try {
      return ok(await c.publishMessageBatch(i));
    } catch (a) {
      throw console.error("Failed to send signed message batch:", a), a;
    }
  }, getTokens: async (i) => {
    if (n) {
      let { contractAddresses: a, tokenIds: o, pagination: d } = l(i);
      return await n.getTokens({ contract_addresses: a, token_ids: o, pagination: d });
    }
    return await E(t, i);
  }, getTokenContracts: async (i) => {
    if (n) {
      let { contractAddresses: a, contractTypes: o, pagination: d } = l(i);
      return await n.getTokenContracts({ contract_addresses: a, contract_types: o, pagination: d });
    }
    return await K(t, i);
  }, getTokenBalances: async (i) => {
    if (n) {
      let { contractAddresses: a, accountAddresses: o, tokenIds: d, pagination: p } = l(i);
      return await n.getTokenBalances({ contract_addresses: a, account_addresses: o, token_ids: d, pagination: p });
    }
    return await I(t, i);
  }, onTokenBalanceUpdated: async (i) => {
    let { contractAddresses: a, accountAddresses: o, tokenIds: d } = l(i);
    return await u.onTokenBalanceUpdated(a ?? [], o ?? [], d ?? [], m(i.callback, b));
  }, onTokenUpdated: async (i) => {
    let { contractAddresses: a, tokenIds: o } = l(i);
    return await u.onTokenUpdated(a ?? [], o ?? [], m(i.callback, k));
  }, updateTokenBalanceSubscription: async (i) => {
    if (n) {
      let { contractAddresses: a, accountAddresses: o, tokenIds: d } = l(i);
      return await n.updateTokenBalanceSubscription(i.subscription, a ?? [], o ?? [], d ?? []);
    }
    return await Q(t, i);
  }, updateEntitySubscription: async (i, a) => await c.updateEntitySubscription(i, a), updateEventMessageSubscription: async (i, a, o) => await u.updateEventMessageSubscription(i, a), getControllers: async (i, a, o = _) => await c.getControllers({ contract_addresses: i, usernames: a, pagination: o }), subscribeToken: async (i) => {
    if (n) {
      let { contractAddresses: a, tokenIds: o, pagination: d } = l(i), p = await n.getTokens({ contract_addresses: a, token_ids: o, pagination: d }), C = await n.onTokenUpdated(a ?? [], o ?? [], m(i.callback, k));
      return [p, C];
    }
    return await F(t, i);
  } };
}
function mt(t) {
  return new ToriiGrpcClient({ toriiUrl: t.toriiUrl ?? "http://localhost:8080", worldAddress: t.worldAddress });
}
async function Vt(t) {
  return await new ToriiClient(t);
}
var gt = { toriiUrl: "http://localhost:8080" };
async function Ht(t) {
  let e;
  if (!t.grpcClient) {
    let n = { ...gt, ...t.client };
    e = await new ToriiClient(n);
  }
  return H({ client: e, config: t, sendMessage: async (n, c) => {
    if (!c) return err(P);
    try {
      let u = await c.signMessage(n), i = JSON.stringify(n), a = t.grpcClient || e;
      return ok(await a.publishMessage({ message: i, signature: Array.isArray(u) ? u : [u.r.toString(), u.s.toString()] }));
    } catch (u) {
      throw console.error("Failed to send message:", u), u;
    }
  }, sendMessageBatch: async (n, c) => {
    if (!c) return err(P);
    try {
      let u = [];
      for (let a of n) {
        let o = await c.signMessage(a), d = JSON.stringify(a);
        u.push({ message: d, signature: Array.isArray(o) ? o : [o.r.toString(), o.s.toString()] });
      }
      let i = t.grpcClient || e;
      return ok(await i.publishMessageBatch(u));
    } catch (u) {
      throw console.error("Failed to send message batch:", u), u;
    }
  }, grpcClient: t.grpcClient });
}
export {
  kt as AndComposeClause,
  h as ClauseBuilder,
  ft as HashedKeysClause,
  Mt as HistoricalToriiQueryBuilder,
  ht as KeysClause,
  bt as MemberClause,
  P as NO_ACCOUNT,
  Ct as NO_IDENTITY,
  wt as NO_SIGNER,
  Tt as OrComposeClause,
  f as Pagination,
  ut as ToriiQueryBuilder,
  W as UNDEFINED_CLAUSE,
  v as convertToPrimitive,
  Vt as createClient,
  tt as deepMerge,
  gt as defaultClientConfig,
  k as defaultToken,
  b as defaultTokenBalance,
  _ as defaultToriiPagination,
  G as generateTypedData,
  At as getModel,
  vt as getModelByEntityId,
  I as getTokenBalances,
  K as getTokenContracts,
  E as getTokens,
  Ht as init,
  mt as initGrpc,
  T as isCairoCustomEnum,
  D as isCairoOption,
  Z as mergeCairoCustomEnum,
  X as mergeCairoOption,
  Bt as onTokenBalanceUpdated,
  Et as onTokenUpdated,
  y as parseEntities,
  l as parseTokenRequest,
  m as safeCallback,
  B as subscribeQueryModelCallback,
  F as subscribeToken,
  j as subscribeTokenBalance,
  Q as updateTokenBalanceSubscription
};
//# sourceMappingURL=@dojoengine_sdk.js.map
