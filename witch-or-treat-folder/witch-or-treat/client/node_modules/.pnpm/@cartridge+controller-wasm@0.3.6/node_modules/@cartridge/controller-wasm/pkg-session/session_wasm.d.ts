/* tslint:disable */
/* eslint-disable */
/**
 * Subscribes to the creation of a session for a given controller, session_key_guid and cartridge api url.
 * The goal of this function is to know from any place when the register session flow has been completed, and to
 * get the authorization.
 */
export function subscribeCreateSession(session_key_guid: JsFelt, cartridge_api_url: string): Promise<JsSubscribeSessionResult>;
export function signerToGuid(signer: Signer): JsFelt;
export enum ErrorCode {
  StarknetFailedToReceiveTransaction = 1,
  StarknetContractNotFound = 20,
  StarknetBlockNotFound = 24,
  StarknetInvalidTransactionIndex = 27,
  StarknetClassHashNotFound = 28,
  StarknetTransactionHashNotFound = 29,
  StarknetPageSizeTooBig = 31,
  StarknetNoBlocks = 32,
  StarknetInvalidContinuationToken = 33,
  StarknetTooManyKeysInFilter = 34,
  StarknetContractError = 40,
  StarknetTransactionExecutionError = 41,
  StarknetClassAlreadyDeclared = 51,
  StarknetInvalidTransactionNonce = 52,
  StarknetInsufficientMaxFee = 53,
  StarknetInsufficientAccountBalance = 54,
  StarknetValidationFailure = 55,
  StarknetCompilationFailed = 56,
  StarknetContractClassSizeIsTooLarge = 57,
  StarknetNonAccount = 58,
  StarknetDuplicateTx = 59,
  StarknetCompiledClassHashMismatch = 60,
  StarknetUnsupportedTxVersion = 61,
  StarknetUnsupportedContractClassVersion = 62,
  StarknetUnexpectedError = 63,
  StarknetNoTraceAvailable = 10,
  StarknetReplacementTransactionUnderpriced = 64,
  StarknetFeeBelowMinimum = 65,
  SignError = 101,
  StorageError = 102,
  AccountFactoryError = 103,
  PaymasterExecutionTimeNotReached = 104,
  PaymasterExecutionTimePassed = 105,
  PaymasterInvalidCaller = 106,
  PaymasterRateLimitExceeded = 107,
  PaymasterNotSupported = 108,
  PaymasterHttp = 109,
  PaymasterExcecution = 110,
  PaymasterSerialization = 111,
  CartridgeControllerNotDeployed = 112,
  InsufficientBalance = 113,
  OriginError = 114,
  EncodingError = 115,
  SerdeWasmBindgenError = 116,
  CairoSerdeError = 117,
  CairoShortStringToFeltError = 118,
  DeviceCreateCredential = 119,
  DeviceGetAssertion = 120,
  DeviceBadAssertion = 121,
  DeviceChannel = 122,
  DeviceOrigin = 123,
  AccountSigning = 124,
  AccountProvider = 125,
  AccountClassHashCalculation = 126,
  AccountFeeOutOfRange = 128,
  ProviderRateLimited = 129,
  ProviderArrayLengthMismatch = 130,
  ProviderOther = 131,
  SessionAlreadyRegistered = 132,
  UrlParseError = 133,
  Base64DecodeError = 134,
  CoseError = 135,
  PolicyChainIdMismatch = 136,
  InvalidOwner = 137,
  GasPriceTooHigh = 138,
  TransactionTimeout = 139,
  ConversionError = 140,
  InvalidChainId = 141,
}
export interface JsCall {
    contractAddress: JsFelt;
    entrypoint: string;
    calldata: JsFelt[];
}

export type JsPriceUnit = "WEI" | "FRI";

export interface JsEstimateFeeDetails {
    nonce: JsFelt;
}

export interface JsFeeEstimate {
    l1_gas_consumed: number;
    l1_gas_price: number;
    l2_gas_consumed: number;
    l2_gas_price: number;
    l1_data_gas_consumed: number;
    l1_data_gas_price: number;
    overall_fee: number;
}

/**
 * JavaScript-friendly OutsideExecution V3 structure
 */
export interface JsOutsideExecutionV3 {
    caller: JsFelt;
    execute_after: number;
    execute_before: number;
    calls: JsCall[];
    nonce: [JsFelt, JsFelt];
}

/**
 * Result type for signExecuteFromOutside containing both the OutsideExecution and signature
 */
export interface JsSignedOutsideExecution {
    outside_execution: JsOutsideExecutionV3;
    signature: JsFelt[];
}

export interface Owner {
    signer?: Signer;
    account?: JsFelt;
}

export interface CallPolicy {
    target: JsFelt;
    method: JsFelt;
    authorized?: boolean;
}

export interface TypedDataPolicy {
    scope_hash: JsFelt;
    authorized?: boolean;
}

export type Policy = CallPolicy | TypedDataPolicy;

export type JsRegister = RegisterInput;

export type JsRegisterResponse = ResponseData;

export interface WebauthnSigner {
    rpId: string;
    credentialId: string;
    publicKey: string;
}

export interface StarknetSigner {
    privateKey: JsFelt;
}

export interface Eip191Signer {
    address: string;
}

export interface Signer {
    webauthns?: WebauthnSigner[];
    webauthn?: WebauthnSigner;
    starknet?: StarknetSigner;
    eip191?: Eip191Signer;
}

export type JsAddSignerInput = SignerInput;

export type JsRemoveSignerInput = SignerInput;

export type JsFelt = Felt;

export type Felts = JsFelt[];

export type JsFeeSource = "PAYMASTER" | "CREDITS";

export type JsSubscribeSessionResult = SubscribeCreateSessionSubscribeCreateSession;

export type JsRevokableSession = RevokableSession;

export interface AuthorizedSession {
    session: Session;
    authorization: JsFelt[] | null;
    isRegistered: boolean;
    expiresAt: number;
    allowedPoliciesRoot: JsFelt;
    metadataHash: JsFelt;
    sessionKeyGuid: JsFelt;
    guardianKeyGuid: JsFelt;
}

export interface Session {
    policies: Policy[];
    expiresAt: number;
    metadataHash: JsFelt;
    sessionKeyGuid: JsFelt;
    guardianKeyGuid: JsFelt;
}

export interface Credentials {
    authorization: JsFelt[];
    privateKey: JsFelt;
}

export class CartridgeSessionAccount {
  private constructor();
  free(): void;
  static new(rpc_url: string, signer: JsFelt, address: JsFelt, chain_id: JsFelt, session_authorization: JsFelt[], session: Session): CartridgeSessionAccount;
  static newAsRegistered(rpc_url: string, signer: JsFelt, address: JsFelt, owner_guid: JsFelt, chain_id: JsFelt, session: Session): CartridgeSessionAccount;
  sign(hash: JsFelt, calls: JsCall[]): Promise<Felts>;
  execute(calls: JsCall[]): Promise<any>;
  executeFromOutside(calls: JsCall[]): Promise<any>;
}
export class JsControllerError {
  private constructor();
  free(): void;
  code: ErrorCode;
  message: string;
  get data(): string | undefined;
  set data(value: string | null | undefined);
}
