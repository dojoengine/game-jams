import{useAccount as B}from"@starknet-react/core";import{jsx as S}from"react/jsx-runtime";function F(e,o=()=>S("div",{children:"Please connect your wallet"})){return r=>{let{account:n,address:s}=B();if(!s)return o?S(o,{}):null;let t={...r,account:n,address:s};return S(e,{...t})}}import{getEntityIdFromKeys as G}from"@dojoengine/utils";import{useContext as $,useMemo as O}from"react";import{DojoProvider as N}from"@dojoengine/core";import{createContext as v,useContext as Q}from"react";import{useContext as T}from"react";import{create as H}from"zustand";import{createDojoStoreFactory as I}from"@dojoengine/state/zustand";function k(){return I(H)}function Y(e,o){let[r,n]=o.split("-"),{useDojoStore:s}=T(u);return s(i=>i.entities[e.toString()]?.models?.[r]?.[n])}function Z(e,o){let[r,n]=o.split("-"),{useDojoStore:s}=T(u);return s(i=>{let a=i.historical_entities[e.toString()];return a?a.filter(c=>c.models[r][n]!==void 0):[]})}function ee(e){let[o,r]=e.split("-"),{useDojoStore:n}=T(u);return n(t=>t.getEntitiesByModel(o,r).map(i=>({[i.entityId]:i.models?.[o]?.[r]})))}import{jsx as A}from"react/jsx-runtime";var u=v(void 0);function se({dojoConfig:e,sdk:o,clientFn:r,children:n}){if(Q(u))throw new Error("DojoProvider can only be used once");let t=new N(e.manifest,e.rpcUrl);return A(u.Provider,{value:{config:e,client:r(t),sdk:o,provider:t,useDojoStore:k()},children:n})}import{useCallback as R,useEffect as w,useRef as b}from"react";function m(e,o){if(e===o)return!0;if(e===null||o===null||typeof e!="object"||typeof o!="object")return!1;if(Array.isArray(e)&&Array.isArray(o)){if(e.length!==o.length)return!1;for(let s=0;s<e.length;s++)if(!m(e[s],o[s]))return!1;return!0}if(e instanceof Date&&o instanceof Date)return e.getTime()===o.getTime();if(e instanceof RegExp&&o instanceof RegExp)return e.toString()===o.toString();let r=Object.keys(e),n=Object.keys(o);return r.length!==n.length?!1:r.every(s=>Object.hasOwn(o,s)&&m(e[s],o[s]))}function g(e){return new Promise(o=>setTimeout(o,e))}function l(e){return function(r){let n=b(null),s=b(null),t=b(!1),i=R(async()=>{for(;t.current;)await g(50);if(t.current=!0,n.current)return await e.updateSubscriptionMethod(n.current,e.queryToHashedKeysMethod(s.current,e.historical),e.historical),null;let[a,c]=await e.subscribeMethod({query:s.current,callback:({data:f,error:h})=>{f&&e.processUpdateData(f),h&&(console.error(`${e.getErrorPrefix()} - error subscribing with query: `,r.toString()),console.error(h))},historical:e.historical});return e.processInitialData(a.getItems()),c},[r]);w(()=>(m(r,s.current)||(s.current=r,i().then(a=>{a!==null&&(n.current=a)}).catch(a=>{console.error(`${e.getErrorPrefix()} - error fetching data for query: `,JSON.stringify(r)),console.error(a)}).finally(()=>{t.current=!1})),()=>{n.current}),[r,i])}}function ye(e){let{sdk:o,useDojoStore:r}=p(),n=r(t=>t);l({subscribeMethod:t=>o.subscribeEntityQuery(t),updateSubscriptionMethod:(t,i)=>o.updateEntitySubscription(t,i),queryToHashedKeysMethod:t=>t.getClause()._unsafeUnwrap(),processInitialData:t=>{n.mergeEntities(t)},processUpdateData:t=>{if(t){let a=t.filter(c=>Number.parseInt(c.entityId,16)!==0)[0];a&&n.updateEntity(a)}},getErrorPrefix:()=>"Dojo.js - useEntityQuery",historical:!1})(e)}function fe(e){if(!e.isHistorical())throw new Error("Query must be  HistoricalToriiQueryBuilder");let{sdk:o,useDojoStore:r}=p(),n=r(t=>t);l({subscribeMethod:t=>o.subscribeEntityQuery(t),updateSubscriptionMethod:(t,i)=>o.updateEntitySubscription(t,i),queryToHashedKeysMethod:t=>t.getClause()._unsafeUnwrap(),processInitialData:t=>{n.setHistoricalEntities(t)},processUpdateData:t=>{if(t){let a=t.filter(c=>Number.parseInt(c.entityId,16)!==0)[0];a&&n.updateHistoricalEntity(a)}},getErrorPrefix:()=>"Dojo.js - useHistoricalEntityQuery",historical:!0})(e)}import{useState as U}from"react";function xe(e){let{sdk:o,useDojoStore:r}=p(),n=r(t=>t);l({subscribeMethod:t=>o.subscribeEventQuery(t),updateSubscriptionMethod:(t,i)=>o.updateEventMessageSubscription(t,i,!1),queryToHashedKeysMethod:t=>t.getClause()._unsafeUnwrap(),processInitialData:t=>{n.mergeEntities(t)},processUpdateData:t=>{if(t){let a=t.filter(c=>Number.parseInt(c.entityId,16)!==0)[0];a&&n.updateEntity(a)}},getErrorPrefix:()=>"Dojo.js - useEventQuery",historical:!1})(e)}function ke(e){let{sdk:o}=p(),[r,n]=U([]);return l({subscribeMethod:t=>o.subscribeEventQuery(t),updateSubscriptionMethod:(t,i)=>o.updateEventMessageSubscription(t,i,!0),queryToHashedKeysMethod:t=>t.getClause()._unsafeUnwrap(),processInitialData:t=>{n(t)},processUpdateData:t=>{if(t){let i=t.filter(a=>Number.parseInt(a.entityId,16)!==0);n(a=>[...i,...a])}},getErrorPrefix:()=>"Dojo.js - useHistoricalEventsQuery",historical:!0})(e),r}import{useCallback as D,useEffect as K,useRef as E,useState as j}from"react";function Ce(e){let{sdk:o}=p(),[r,n]=j([]),s=E(null),[t,i]=j([]),a=E(null),c=D(async()=>{let d=await o.getTokens({contractAddresses:e.contractAddresses??[],tokenIds:e.tokenIds??[]});n(d.items)},[o,e]),f=D(async()=>{let[d,y]=await o.subscribeTokenBalance({contractAddresses:e.contractAddresses??[],accountAddresses:e.accountAddresses??[],tokenIds:e.tokenIds??[],callback:({data:M,error:x})=>{if(x){console.error(x);return}i(P=>_(P,M))}});a.current=y,i(d.items)},[o,e]);K(()=>{m(e,s.current)||(s.current=e,c(),f())},[e]);function h(d){return t.find(y=>y.contract_address===d.contract_address)}function C(d,y){return Number.parseInt(y?.balance??"0",16)*10**-d.decimals}return{tokens:r,balances:t,getBalance:h,toDecimal:C}}function _(e,o){if(BigInt(o.account_address)===0n&&BigInt(o.contract_address)===0n)return e;let r=e.findIndex(n=>n.token_id===o.token_id&&n.contract_address===o.contract_address);return r===-1?[...e,o]:e.map((n,s)=>s===r?o:n)}function p(){return $(u)}function Ie(...e){return O(()=>e.length>0?G(e.map(r=>BigInt(r))):BigInt(0),[e])}export{u as DojoContext,se as DojoSdkProvider,F as WithAccount,k as createDojoStore,p as useDojoSDK,Ie as useEntityId,ye as useEntityQuery,xe as useEventQuery,fe as useHistoricalEntityQuery,ke as useHistoricalEventsQuery,Z as useHistoricalModel,Y as useModel,ee as useModels,Ce as useTokens};
//# sourceMappingURL=react.js.map