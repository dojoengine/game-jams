{"version":3,"sources":["../src/global/constants.ts","../src/types/api/index.ts","../src/types/api/jsonrpc.ts","../src/types/api/rpc.ts","../src/utils/encode.ts","../src/global/config.ts","../src/global/logger.type.ts","../src/global/logger.ts","../src/channel/rpc_0_8_1.ts","../src/types/lib/contract/index.ts","../src/provider/types/spec.type.ts","../src/types/calldata.ts","../src/contract/types/index.type.ts","../src/types/outsideExecution.ts","../src/utils/json.ts","../src/utils/batch/index.ts","../src/utils/assert.ts","../src/utils/num.ts","../src/utils/typed.ts","../src/utils/hash/selector.ts","../src/utils/shortString.ts","../src/utils/calldata/byteArray.ts","../src/utils/calldata/cairo.ts","../src/utils/helpers.ts","../src/utils/cairoDataTypes/felt.ts","../src/utils/cairoDataTypes/uint256.ts","../src/utils/cairoDataTypes/uint512.ts","../src/utils/calldata/enum/CairoCustomEnum.ts","../src/utils/calldata/enum/CairoOption.ts","../src/utils/calldata/enum/CairoResult.ts","../src/utils/calldata/formatter.ts","../src/utils/calldata/parser/interface.ts","../src/utils/cairoDataTypes/bytes31.ts","../src/utils/errors/rpc.ts","../src/utils/errors/index.ts","../src/utils/connect/buffer.ts","../src/utils/cairoDataTypes/uint32.ts","../src/utils/cairoDataTypes/byteArray.ts","../src/utils/cairoDataTypes/uint8.ts","../src/utils/cairoDataTypes/uint16.ts","../src/utils/cairoDataTypes/uint64.ts","../src/utils/cairoDataTypes/uint96.ts","../src/utils/cairoDataTypes/uint128.ts","../src/utils/cairoDataTypes/int8.ts","../src/utils/cairoDataTypes/int16.ts","../src/utils/cairoDataTypes/int32.ts","../src/utils/cairoDataTypes/int64.ts","../src/utils/cairoDataTypes/int128.ts","../src/utils/calldata/parser/parsingStrategy.ts","../src/utils/calldata/parser/parser-0-1.1.0.ts","../src/utils/calldata/parser/parser-2.0.0.ts","../src/utils/calldata/parser/index.ts","../src/utils/calldata/tuple.ts","../src/utils/cairoDataTypes/fixedArray.ts","../src/utils/calldata/propertyOrder.ts","../src/utils/calldata/requestParser.ts","../src/utils/calldata/responseParser.ts","../src/utils/calldata/validate.ts","../src/utils/calldata/index.ts","../src/utils/hash/index.ts","../src/utils/hash/transactionHash/v3.ts","../src/utils/hash/transactionHash/v2.ts","../src/utils/ec.ts","../src/utils/hash/transactionHash/index.ts","../src/utils/hash/classHash.ts","../src/utils/stark/index.ts","../src/utils/contract.ts","../src/utils/eth.ts","../src/utils/connect/fetch.ts","../src/utils/provider.ts","../src/utils/resolve.ts","../src/utils/transaction/index.ts","../src/utils/transaction/getCompiledCalldata.ts","../src/utils/transaction/transaction.ts","../src/channel/rpc_0_9_0.ts","../src/utils/eventEmitter.ts","../src/utils/connect/ws.ts","../src/channel/ws/subscription.ts","../src/channel/ws/ws_0_9.ts","../src/utils/responseParser/rpc.ts","../src/provider/modules/tip.ts","../src/utils/transactionReceipt/transactionReceipt.ts","../src/utils/typedData.ts","../src/utils/merkle.ts","../src/provider/modules/verifyMessageInStarknet.ts","../src/provider/modules/getGasPrices.ts","../src/provider/rpc.ts","../src/provider/extensions/default.ts","../src/utils/starknetId.ts","../src/provider/extensions/starknetId.ts","../src/provider/extensions/brotherId.ts","../src/provider/interface.ts","../src/provider/index.ts","../src/signer/interface.ts","../src/signer/default.ts","../src/signer/ethSigner.ts","../src/utils/uint256.ts","../src/signer/ledgerSigner111.ts","../src/utils/address.ts","../src/signer/ledgerSigner221.ts","../src/signer/ledgerSigner231.ts","../src/utils/outsideExecution.ts","../src/utils/src5.ts","../src/utils/paymaster.ts","../src/paymaster/rpc.ts","../src/paymaster/interface.ts","../src/paymaster/index.ts","../src/deployer/default.ts","../src/deployer/interface.ts","../src/deployer/index.ts","../src/account/default.ts","../src/account/interface.ts","../src/wallet/connect.ts","../src/wallet/account.ts","../src/utils/events/index.ts","../src/contract/default.ts","../src/contract/interface.ts","../src/utils/responseParser/interface.ts","../src/utils/units.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport type { ResourceBoundsOverhead } from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { ValuesType } from '../types/helpers/valuesType';\nimport type { LogLevel } from './logger.type';\nimport type { TipType } from '../provider/modules/tip';\n\nexport { IS_BROWSER } from '../utils/encode';\n\n/**\n * Cairo Felt support storing max 31 character\n */\nexport const TEXT_TO_FELT_MAX_LEN = 31;\nexport const ZERO = 0n;\nexport const MASK_250 = 2n ** 250n - 1n; // 2 ** 250 - 1\nexport const MASK_31 = 2n ** 31n - 1n; // 2 ** 31 - 1\nexport const API_VERSION = ZERO;\nexport const PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\n\n// based on: https://github.com/starkware-libs/cairo-lang/blob/v0.12.3/src/starkware/starknet/common/storage.cairo#L3\nexport const MAX_STORAGE_ITEM_SIZE = 256n;\nexport const ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\n\nconst range = (min: bigint, max: bigint) => ({ min, max }) as const;\n\nexport const RANGE_FELT = range(ZERO, PRIME - 1n);\n\n// Unsigned integer ranges\nexport const RANGE_U8 = range(ZERO, 2n ** 8n - 1n);\nexport const RANGE_U16 = range(ZERO, 2n ** 16n - 1n);\nexport const RANGE_U32 = range(ZERO, 2n ** 32n - 1n);\nexport const RANGE_U64 = range(ZERO, 2n ** 64n - 1n);\nexport const RANGE_U96 = range(ZERO, 2n ** 96n - 1n);\nexport const RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\n\n// Signed integer ranges\nexport const RANGE_I8 = range(-(2n ** 7n), 2n ** 7n - 1n);\nexport const RANGE_I16 = range(-(2n ** 15n), 2n ** 15n - 1n);\nexport const RANGE_I32 = range(-(2n ** 31n), 2n ** 31n - 1n);\nexport const RANGE_I64 = range(-(2n ** 63n), 2n ** 63n - 1n);\nexport const RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\n\nexport const LegacyUDC = {\n  ADDRESS: '0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf',\n  ENTRYPOINT: 'deployContract',\n} as const;\n\nexport const UDC = {\n  ADDRESS: '0x02ceed65a4bd731034c01113685c831b01c15d7d432f71afb1cf1634b53a2125',\n  ENTRYPOINT: 'deploy_contract',\n} as const;\n\nexport const OutsideExecutionCallerAny = '0x414e595f43414c4c4552'; // encodeShortString('ANY_CALLER')\nexport const SNIP9_V1_INTERFACE_ID =\n  '0x68cfd18b92d1907b8ba3cc324900277f5a3622099431ea85dd8089255e4181';\nexport const SNIP9_V2_INTERFACE_ID =\n  '0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872';\n\n// Ledger signer\n// 0x80\nexport const HARDENING_BYTE = 128;\n// 0x80000000\nexport const HARDENING_4BYTES = 2147483648n;\n\n// NOTE: the enum alias exports are made so both the 'const' and 'type' are reachable in the published '.d.ts' file,\n// otherwise the last export hides the preceding export with the same name in this file\nconst _BaseUrl = {\n  SN_MAIN: 'https://alpha-mainnet.starknet.io',\n  SN_SEPOLIA: 'https://alpha-sepolia.starknet.io',\n} as const;\ntype _BaseUrl = ValuesType<typeof _BaseUrl>;\nexport { _BaseUrl as BaseUrl };\n\nconst _NetworkName = {\n  SN_MAIN: 'SN_MAIN',\n  SN_SEPOLIA: 'SN_SEPOLIA',\n} as const;\ntype _NetworkName = ValuesType<typeof _NetworkName>;\nexport { _NetworkName as NetworkName };\n\nconst _StarknetChainId = {\n  SN_MAIN: '0x534e5f4d41494e', // encodeShortString('SN_MAIN'),\n  SN_SEPOLIA: '0x534e5f5345504f4c4941', // encodeShortString('SN_SEPOLIA')\n} as const;\ntype _StarknetChainId = ValuesType<typeof _StarknetChainId>;\nexport { _StarknetChainId as StarknetChainId };\n\nconst _TransactionHashPrefix = {\n  DECLARE: '0x6465636c617265', // encodeShortString('declare'),\n  DEPLOY: '0x6465706c6f79', // encodeShortString('deploy'),\n  DEPLOY_ACCOUNT: '0x6465706c6f795f6163636f756e74', // encodeShortString('deploy_account'),\n  INVOKE: '0x696e766f6b65', // encodeShortString('invoke'),\n  L1_HANDLER: '0x6c315f68616e646c6572', // encodeShortString('l1_handler'),\n} as const;\ntype _TransactionHashPrefix = ValuesType<typeof _TransactionHashPrefix>;\nexport { _TransactionHashPrefix as TransactionHashPrefix };\n\n/**\n * dot format rpc versions\n */\nconst _SupportedRpcVersion = {\n  '0.8.1': '0.8.1',\n  '0.9.0': '0.9.0',\n  v0_8_1: '0.8.1',\n  v0_9_0: '0.9.0',\n} as const;\ntype _SupportedRpcVersion = ValuesType<typeof _SupportedRpcVersion>;\nexport { _SupportedRpcVersion as SupportedRpcVersion };\n\nexport type SupportedTransactionVersion = typeof ETransactionVersion.V3;\nexport type SupportedCairoVersion = '1';\n\n// Default initial global config\nexport const DEFAULT_GLOBAL_CONFIG: {\n  logLevel: LogLevel;\n  rpcVersion: _SupportedRpcVersion;\n  transactionVersion: SupportedTransactionVersion;\n  resourceBoundsOverhead: ResourceBoundsOverhead;\n  defaultTipType: TipType;\n  fetch: any;\n  websocket: any;\n  buffer: any;\n} = {\n  rpcVersion: '0.9.0',\n  transactionVersion: ETransactionVersion.V3, // Starknet 0.14.0 only V3 transactions\n  logLevel: 'INFO',\n  resourceBoundsOverhead: {\n    l1_gas: {\n      max_amount: 50,\n      max_price_per_unit: 50,\n    },\n    l1_data_gas: {\n      max_amount: 50,\n      max_price_per_unit: 50,\n    },\n    l2_gas: {\n      max_amount: 50,\n      max_price_per_unit: 50,\n    },\n  },\n  defaultTipType: 'recommendedTip',\n  fetch: undefined,\n  websocket: undefined,\n  buffer: undefined,\n};\n\nexport const RPC_DEFAULT_NODES = {\n  SN_MAIN: [`https://starknet-mainnet.public.blastapi.io/rpc/`],\n  SN_SEPOLIA: [`https://starknet-sepolia.public.blastapi.io/rpc/`],\n} as const;\n\nexport const PAYMASTER_RPC_NODES = {\n  SN_MAIN: [`https://starknet.paymaster.avnu.fi`],\n  SN_SEPOLIA: [`https://sepolia.paymaster.avnu.fi`],\n} as const;\n\n// Default system messages\nexport const SYSTEM_MESSAGES = {\n  legacyTxWarningMessage:\n    'You are using a deprecated transaction version (V0,V1,V2)!\\nUpdate to the latest V3 transactions!',\n  legacyTxRPC08Message:\n    'RPC 0.8+ do not support legacy transactions, use RPC 0.8+ v3 transactions!',\n  SWOldV3: 'RPC 0.7 V3 tx (improper resource bounds) not supported in RPC 0.8+',\n  channelVersionMismatch:\n    'Channel specification version is not compatible with the connected node Specification Version',\n  unsupportedSpecVersion:\n    'The connected node specification version is not supported by this library',\n  maxFeeInV3: 'maxFee is not supported in V3 transactions, use resourceBounds instead',\n  declareNonSierra: 'Declaring non Sierra (Cairo0)contract using RPC 0.8+',\n  unsupportedMethodForRpcVersion: 'Unsupported method for RPC version',\n  txEvictedFromMempool: 'Transaction TTL, evicted from the mempool, try to increase the tip',\n  consensusFailed: 'Consensus failed to finalize the block proposal',\n  txFailsBlockBuildingValidation: 'Transaction fails block building validation',\n};\n","export * as JRPC from './jsonrpc';\n\nexport * as RPCSPEC08 from '@starknet-io/starknet-types-08';\nexport * as RPCSPEC09 from '@starknet-io/starknet-types-09';\nexport { PAYMASTER_API } from '@starknet-io/starknet-types-08';\n\n// Default export\n// alias for \"export * from '@starknet-io/starknet-types-09';\" which is done within ./rpc.ts\n// the extra level avoids a rollup issue that injects namespace merger JS code into the published .d.ts file\n//\n// eslint-disable-next-line\nexport * from './rpc';\n","export type RequestBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n  method: string;\n  params?: {};\n};\n\nexport type ResponseBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n} & (SuccessResponseBody | ErrorResponseBody);\n\nexport type SuccessResponseBody = {\n  result: unknown;\n};\n\nexport type ErrorResponseBody = {\n  error: Error;\n};\n\nexport type Error = {\n  code: number;\n  message: string;\n  data?: unknown;\n};\n\nexport type WebSocketEvent = Omit<RequestBody, 'id'> & { params: {} };\n","// see explanation in ./index.ts\nexport * from '@starknet-io/starknet-types-09';\n","import { base64 } from '@scure/base';\n\nexport const IS_BROWSER = typeof window !== 'undefined';\n\nconst STRING_ZERO = '0';\n\n/**\n * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts\n * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers\n */\n\n/**\n * Convert array buffer to string\n *\n * *[internal usage]*\n *\n * @param {ArrayBuffer} array The ArrayBuffer to convert to string.\n * @returns {string} The converted string.\n *\n * @example\n * ```typescript\n * const buffer = new ArrayBuffer(5);\n * const view = new Uint8Array(buffer);\n * [72, 101, 108, 108, 111].forEach((x, idx) => view[idx] = x);\n * const result = encode.arrayBufferToString(buffer);\n * // result = \"Hello\"\n * ```\n */\nexport function arrayBufferToString(array: ArrayBuffer): string {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), '');\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * *[internal usage]*\n *\n * @param {string} str The UTF-8 string to convert.\n * @returns {Uint8Array} The encoded Uint8Array.\n *\n * @example\n * ```typescript\n * const myString = 'Hi';\n * const result = encode.utf8ToArray(myString);\n * // result = Uint8Array(2) [ 72, 105 ]\n * ```\n */\nexport function utf8ToUint8Array(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * @deprecated use utf8ToUint8Array instead\n */\nexport const utf8ToArray = utf8ToUint8Array;\n\n/**\n * Convert utf8-string to bigint\n *\n * @param str The UTF-8 string to convert.\n * @returns The converted bigint.\n */\nexport function utf8ToBigInt(str: string): bigint {\n  return uint8ArrayToBigInt(utf8ToUint8Array(str));\n}\n\n/**\n * Convert string to array buffer (browser and node compatible)\n *\n * @param {string} a The Base64 encoded string to convert.\n * @returns {Uint8Array} The decoded Uint8Array.\n *\n * @example\n * ```typescript\n * const base64String = 'SGVsbG8='; // 'Hello' in Base64\n * const result = encode.atobUniversal(base64String);\n * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]\n * ```\n */\nexport function atobUniversal(a: string): Uint8Array {\n  return base64.decode(a);\n}\n\n/**\n * Convert array buffer to string (browser and node compatible)\n *\n * @param {ArrayBuffer} b The Array buffer.\n * @returns {string} The Base64 encoded string.\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.btoaUniversal(buffer);\n * // result = \"SGVsbG8=\"\n * ```\n */\nexport function btoaUniversal(b: ArrayBuffer): string {\n  return base64.encode(new Uint8Array(b));\n}\n\n/**\n * Convert array buffer to hex-string\n *\n * @param {Uint8Array} buffer The encoded Uint8Array.\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.buf2hex(buffer);\n * // result = \"48656c6c6f\"\n * ```\n */\nexport function buf2hex(buffer: Uint8Array): string {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Remove hex prefix '0x' from hex-string\n * @param hex hex-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const hexStringWithPrefix = '0x48656c6c6f';\n * const result = encode.removeHexPrefix(hexStringWithPrefix);\n * // result: \"48656c6c6f\"\n * ```\n */\nexport function removeHexPrefix(hex: string): string {\n  return hex.replace(/^0x/i, '');\n}\n\n/**\n * Add hex prefix '0x' to base16-string\n * @param hex base16-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const plainHexString = '48656c6c6f';\n * const result = encode.addHexPrefix(plainHexString);\n * // result: \"0x48656c6c6f\"\n * ```\n */\nexport function addHexPrefix(hex: string): string {\n  return `0x${removeHexPrefix(hex)}`;\n}\n\n/**\n * Prepend or append to string\n *\n * *[internal usage]*\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied either to the left or the right of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {boolean} left Set to true to add padding to the left, false to add it to the right.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = 'hello';\n * const result = padString(myString, 10, true);\n * // result = '00000hello'\n * ```\n */\nfunction padString(\n  str: string,\n  length: number,\n  left: boolean,\n  padding: string = STRING_ZERO\n): string {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\n\n/**\n * Prepend string (default with '0')\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied only to the left of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n * @example\n * ```typescript\n * const myString = '1A3F';\n * const result = encode.padLeft(myString, 10);\n * // result: '0000001A3F'\n * ```\n */\nexport function padLeft(str: string, length: number, padding: string = STRING_ZERO): string {\n  return padString(str, length, true, padding);\n}\n\n/**\n * Calculate byte length of string\n *\n * *[no internal usage]*\n *\n * Calculates the byte length of a string based on a specified byte size.\n * The function rounds up the byte count to the nearest multiple of the specified byte size.\n *\n * @param {string} str The string whose byte length is to be calculated.\n * @param {number} [byteSize='8'] The size of the byte block to round up to. Defaults to 8.\n * @returns {number} The calculated byte length, rounded to the nearest multiple of byteSize.\n *\n * @example\n * ```typescript\n * const myString = 'Hello';\n * const result = encode.calcByteLength(myString, 4);\n * // result = 8 (rounded up to the nearest multiple of 4)\n *\n * ```\n */\nexport function calcByteLength(str: string, byteSize: number = 8): number {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;\n}\n\n/**\n * Prepend '0' to string bytes\n *\n * *[no internal usage]*\n *\n *\n * * Prepends padding to the left of a string to ensure it matches a specific byte length.\n * The function uses a specified padding character and rounds up the string length to the nearest multiple of `byteSize`.\n *\n * @param {string} str The string to be padded.\n * @param {number} [byteSize='8'] The byte block size to which the string length should be rounded up. Defaults to 8.\n * @param {string} [padding='0'] The character to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = '123';\n * const result = encode.sanitizeBytes(myString);\n * // result: '00000123' (padded to 8 characters)\n * ```\n */\nexport function sanitizeBytes(\n  str: string,\n  byteSize: number = 8,\n  padding: string = STRING_ZERO\n): string {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\n\n/**\n * Sanitizes a hex-string by removing any existing '0x' prefix, padding the string with '0' to ensure it has even length,\n * and then re-adding the '0x' prefix.\n *\n * *[no internal usage]*\n * @param {string} hex hex-string\n * @returns {string} format: hex-string\n *\n * @example\n * ```typescript\n * const unevenHex = '0x23abc';\n * const result = encode.sanitizeHex(unevenHex);\n * // result = '0x023abc' (padded to ensure even length)\n * ```\n */\nexport function sanitizeHex(hex: string): string {\n  const hexWithoutPrefix = removeHexPrefix(hex);\n  const sanitizedHex = sanitizeBytes(hexWithoutPrefix, 2);\n  return sanitizedHex ? addHexPrefix(sanitizedHex) : sanitizedHex;\n}\n\n/**\n * String transformation util\n *\n * Pascal case to screaming snake case\n *\n * @param {string} text The PascalCase string to convert.\n * @returns {string} The converted snake_case string in uppercase.\n *\n * @example\n * ```typescript\n * const pascalString = 'PascalCaseExample';\n * const result = encode.pascalToSnake(pascalString);\n * // result: 'PASCAL_CASE_EXAMPLE'\n * ```\n */\nexport const pascalToSnake = (text: string): string =>\n  /[a-z]/.test(text)\n    ? text\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase()\n    : text;\n\n/**\n * Combine multiple Uint8Arrays into one.\n * Useful for wallet path creation.\n * @param {Uint8Array[]} uint8arrays An array of Uint8Array.\n * @returns {Uint8Array} all the Uint8Arrays joined.\n * @example\n * ```typescript\n * const path0buff = new Uint8Array([128, 0, 10, 85]);\n * const path1buff = new Uint8Array([71, 65, 233, 201]);\n * const result = encode.concatenateArrayBuffer([path0buff, path1buff]);\n * // result = Uint8Array(8) [128, 0, 10, 85, 71, 65, 233, 201]\n * ```\n */\nexport function concatenateArrayBuffer(uint8arrays: Uint8Array[]): Uint8Array {\n  const totalLength = uint8arrays.reduce((total, uint8array) => total + uint8array.byteLength, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  uint8arrays.forEach((uint8array) => {\n    result.set(uint8array, offset);\n    offset += uint8array.byteLength;\n  });\n  return result;\n}\n\n/**\n * Convert hex string to Uint8Array\n *\n * @param {string} hex The hex string to convert (with or without '0x' prefix)\n * @returns {Uint8Array} The converted byte array\n * @throws {Error} If the string contains non-hexadecimal characters\n *\n * @example\n * ```typescript\n * const hexString = '0x48656c6c6f';\n * const result = encode.hexStringToUint8Array(hexString);\n * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]\n * ```\n */\nexport function hexStringToUint8Array(hex: string): Uint8Array {\n  // Remove 0x prefix if present\n  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;\n\n  // Validate hex string (only 0-9, a-f, A-F allowed)\n  if (cleanHex.length > 0 && !/^[0-9a-fA-F]+$/.test(cleanHex)) {\n    throw new Error(`Invalid hex string: \"${hex}\" contains non-hexadecimal characters`);\n  }\n\n  // Pad to even length\n  const paddedHex = cleanHex.length % 2 !== 0 ? `0${cleanHex}` : cleanHex;\n  // Create Uint8Array directly\n  const bytes = new Uint8Array(paddedHex.length / 2);\n  for (let i = 0; i < paddedHex.length; i += 2) {\n    bytes[i / 2] = parseInt(paddedHex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Check if string is a hex string (starts with 0x/0X followed by hex digits)\n * @param hex string to check\n * @returns true if hex string\n */\nfunction isHexString(hex: string): boolean {\n  return /^0[xX][0-9a-fA-F]*$/.test(hex);\n}\n\n/**\n * Check if string contains only decimal digits\n * @param str string to check\n * @returns true if decimal string\n */\nfunction isDecimalString(str: string): boolean {\n  return /^[0-9]+$/.test(str);\n}\n\n/**\n * Convert any string to Uint8Array\n *\n * Handles three types of strings:\n * - Hex strings (e.g., '0x123f') - converts hex bytes to Uint8Array\n * - Decimal strings (e.g., '124324332') - converts decimal number to bytes\n * - Text strings (e.g., 'I am cool ☥') - converts UTF-8 text to bytes\n *\n * @param {string} str The string to convert\n * @returns {Uint8Array} The converted byte array\n *\n * @example\n * ```typescript\n * // Hex string\n * const hex = stringToUint8Array('0x48656c6c6f');\n * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]\n *\n * // Decimal string\n * const decimal = stringToUint8Array('256');\n * // result = Uint8Array(2) [ 1, 0 ]\n *\n * // Text string\n * const text = stringToUint8Array('Hello ☥');\n * // result = UTF-8 encoded bytes\n * ```\n */\nexport function stringToUint8Array(str: string): Uint8Array {\n  // Check if it's a hex string\n  if (isHexString(str)) {\n    return hexStringToUint8Array(str);\n  }\n\n  // Check if it's a decimal string\n  if (isDecimalString(str)) {\n    // Convert decimal string to bigint then to bytes\n    const value = BigInt(str);\n    return bigIntToUint8Array(value);\n  }\n\n  // Otherwise treat as UTF-8 text\n  return utf8ToUint8Array(str);\n}\n\n/**\n * Convert bigint to Uint8Array (big-endian)\n *\n * @param {bigint} value The bigint value to convert (must be non-negative)\n * @returns {Uint8Array} The converted byte array in big-endian byte order\n * @throws {Error} If value is negative\n *\n * @example\n * ```typescript\n * const value = 256n; // 0x0100\n * const result = encode.bigIntToUint8Array(value);\n * // result = Uint8Array([1, 0]) - big-endian, MSB first\n * ```\n */\nexport function bigIntToUint8Array(value: bigint): Uint8Array {\n  // Validate non-negative\n  if (value < 0n) {\n    throw new Error(`Cannot convert negative bigint ${value} to Uint8Array`);\n  }\n\n  // Special case for 0\n  if (value === 0n) {\n    return new Uint8Array([0]);\n  }\n\n  // Convert to hex string without '0x' prefix\n  let hex = value.toString(16);\n  // Pad to even length\n  if (hex.length % 2 !== 0) {\n    hex = `0${hex}`;\n  }\n  // Create Uint8Array from hex\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert Uint8Array to bigint (big-endian)\n *\n * @param {Uint8Array} data The Uint8Array to convert (interpreted as big-endian)\n * @returns {bigint} The converted bigint value\n *\n * @example\n * ```typescript\n * const data = new Uint8Array([1, 0]); // Big-endian representation\n * const result = encode.uint8ArrayToBigInt(data);\n * // result = 256n (0x0100)\n * ```\n */\nexport function uint8ArrayToBigInt(data: Uint8Array): bigint {\n  if (!data || data.length === 0) {\n    return 0n;\n  }\n  // Convert Uint8Array to hex string\n  let hex = '0x';\n  for (let i = 0; i < data.length; i += 1) {\n    hex += data[i].toString(16).padStart(2, '0');\n  }\n  return BigInt(hex);\n}\n","import { DEFAULT_GLOBAL_CONFIG } from './constants';\n\ntype DefaultConfig = typeof DEFAULT_GLOBAL_CONFIG;\ntype CustomConfig = { [key: string]: any };\n\ntype ConfigData = DefaultConfig & CustomConfig;\n\nclass Configuration {\n  private static instance: Configuration;\n\n  private config!: ConfigData;\n\n  private constructor() {\n    this.initialize();\n  }\n\n  private initialize(): void {\n    this.config = { ...DEFAULT_GLOBAL_CONFIG };\n  }\n\n  public static getInstance(): Configuration {\n    if (!Configuration.instance) {\n      Configuration.instance = new Configuration();\n    }\n    return Configuration.instance;\n  }\n\n  public get<K extends keyof DefaultConfig>(key: K): DefaultConfig[K];\n  public get(key: string, defaultValue?: any): any;\n  public get(key: string, defaultValue?: any) {\n    return this.config[key] ?? defaultValue;\n  }\n\n  public set<K extends keyof DefaultConfig>(key: K, value: DefaultConfig[K]): void;\n  public set(key: string, value: any): void;\n  public set(key: string, value: any): void {\n    this.config[key] = value;\n  }\n\n  public update(configData: Partial<DefaultConfig> & CustomConfig): void {\n    this.config = {\n      ...this.config,\n      ...configData,\n    };\n  }\n\n  public getAll(): ConfigData {\n    return { ...this.config };\n  }\n\n  public reset(): void {\n    this.initialize();\n  }\n\n  public delete<K extends keyof DefaultConfig>(key: K): void;\n  public delete(key: string): void;\n  public delete(key: string): void {\n    delete this.config[key];\n  }\n\n  public hasKey<K extends keyof DefaultConfig>(key: K): boolean;\n  public hasKey(key: string): boolean;\n  public hasKey(key: string): boolean {\n    return key in this.config;\n  }\n}\n\n// Export a single instance\nexport const config = Configuration.getInstance();\n","import { ValuesType } from '../types/helpers/valuesType';\n\nexport const LogLevelIndex = {\n  DEBUG: 5,\n  INFO: 4,\n  WARN: 3,\n  ERROR: 2,\n  FATAL: 1,\n  OFF: 0,\n};\n\nexport type LogLevelIndex = ValuesType<typeof LogLevelIndex>;\n\nexport type LogLevel = keyof typeof LogLevelIndex;\n","/* eslint-disable no-console */\nimport { config } from './config';\nimport { LogLevelIndex, LogLevel } from './logger.type';\n\ninterface LogMessage {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  data?: any;\n}\n/**\n * Logging class providing different levels of log\n */\nclass Logger {\n  private static instance: Logger;\n\n  private config: typeof config;\n\n  private constructor() {\n    this.config = config;\n  }\n\n  public static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  private getTimestamp(): string {\n    return new Date().toISOString();\n  }\n\n  private shouldLog(messageLevel: LogLevelIndex): boolean {\n    const configLevel = this.config.get('logLevel', 'INFO');\n    return messageLevel <= LogLevelIndex[configLevel as LogLevel];\n  }\n\n  private formatMessage(logMessage: LogMessage): string {\n    const { level, message, timestamp, data } = logMessage;\n    let formattedMessage = `[${timestamp}] ${level}: ${message}`;\n\n    if (data) {\n      try {\n        formattedMessage += `\\n${JSON.stringify(data, null, 2)}`;\n      } catch (error) {\n        formattedMessage += `\\n[JSON.stringify Error/Circular]: ${error}`;\n      }\n    }\n\n    return formattedMessage;\n  }\n\n  private log(level: LogLevel, message: string, data?: any): void {\n    if (!this.shouldLog(LogLevelIndex[level])) {\n      return;\n    }\n\n    const logMessage: LogMessage = {\n      level,\n      message,\n      timestamp: this.getTimestamp(),\n      data,\n    };\n\n    const formattedMessage = this.formatMessage(logMessage);\n\n    switch (level) {\n      case 'DEBUG':\n        console.debug(formattedMessage);\n        break;\n      case 'INFO':\n        console.info(formattedMessage);\n        break;\n      case 'WARN':\n        console.warn(formattedMessage);\n        break;\n      case 'ERROR':\n      case 'FATAL':\n        console.error(formattedMessage);\n        break;\n      case 'OFF':\n        // Do nothing when logging is off\n        break;\n      default:\n        console.log(formattedMessage); // Default fallback for unknown log levels\n        break;\n    }\n  }\n\n  /**\n   * debug will be displayed when LogLevel level is set to DEBUG(5)\n   */\n  public debug(message: string, data?: any): void {\n    this.log('DEBUG', message, data);\n  }\n\n  /**\n   * info will be displayed when LogLevel level is set to DEBUG(5), INFO(4)\n   */\n  public info(message: string, data?: any): void {\n    this.log('INFO', message, data);\n  }\n\n  /**\n   * warn will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3)\n   */\n  public warn(message: string, data?: any): void {\n    this.log('WARN', message, data);\n  }\n\n  /**\n   * error will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2)\n   */\n  public error(message: string, data?: any): void {\n    this.log('ERROR', message, data);\n  }\n\n  /**\n   * fatal will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2), FATAL(1)\n   */\n  public fatal(message: string, data?: any): void {\n    this.log('FATAL', message, data);\n  }\n\n  /**\n   * Set the logging level you would like system to display\n   * * 5 DEBUG  - show all logs\n   * * 4 INFO\n   * * 3 WARN\n   * * 2 ERROR\n   * * 1 FATAL\n   * * 0 OFF    - disable logs\n   */\n  public setLogLevel(level: LogLevel): void {\n    this.config.set('logLevel', level);\n  }\n\n  public getLogLevel(): LogLevel {\n    return this.config.get('logLevel', 'INFO');\n  }\n\n  /**\n   *\n   * @returns logs levels displayed on the configured LogLevel\n   */\n  public getEnabledLogLevels() {\n    return Object.keys(LogLevelIndex).filter((s) => {\n      return this.shouldLog(LogLevelIndex[s as LogLevel]) && s !== 'OFF';\n    });\n  }\n}\n\n// Export a single instance\n/**\n * Logger instance, use for the system logging.\n * Higher the logger level index, higher the LogLevel required to display log.\n * Default should be INFO\n *\n * DEBUG: 5,\n * INFO: 4,\n * WARN: 3,\n * ERROR: 2,\n * FATAL: 1,\n */\nexport const logger = Logger.getInstance();\n","import {\n  NetworkName,\n  StarknetChainId,\n  SupportedRpcVersion,\n  SYSTEM_MESSAGES,\n} from '../global/constants';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RPC_ERROR,\n  RpcProviderOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC08 as RPC, RPCSPEC08, RPCSPEC09 } from '../types/api';\nimport { BatchClient } from '../utils/batch';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { LibraryError, RpcError } from '../utils/errors';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/connect/fetch';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { isNumber } from '../utils/typed';\nimport {\n  bigNumberishArrayToHexadecimalStringArray,\n  getHexStringArray,\n  toHex,\n  toStorageKey,\n} from '../utils/num';\nimport { Block, getDefaultNodeUrl, wait } from '../utils/provider';\nimport { isSupportedSpecVersion, isV3Tx, isVersion } from '../utils/resolve';\nimport { decompressProgram, resourceBoundsToHexString, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\nimport { logger } from '../global/logger';\nimport { isRPC08Plus_ResourceBoundsBN } from '../provider/types/spec.type';\nimport { config } from '../global/config';\n// TODO: check if we can filet type before entering to this method, as so to specify here only RPC 0.8 types\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.LATEST,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  readonly id = 'RPC081';\n\n  /**\n   * RPC specification version this Channel class implements\n   */\n  readonly channelSpecVersion: SupportedRpcVersion = SupportedRpcVersion.v0_8_1;\n\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  readonly retries: number;\n\n  readonly waitMode: boolean; // behave like web2 rpc and return when tx is processed\n\n  private chainId?: StarknetChainId;\n\n  /**\n   * RPC specification version of the connected node\n   */\n  private specVersion?: SupportedRpcVersion;\n\n  private transactionRetryIntervalFallback?: number;\n\n  private batchClient?: BatchClient<RPC.Methods>;\n\n  private baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode,\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(\n        nodeUrl as NetworkName,\n        optionsOrProvider?.default,\n        this.channelSpecVersion\n      );\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(\n        undefined,\n        optionsOrProvider?.default,\n        this.channelSpecVersion\n      );\n    }\n    this.baseFetch = baseFetch || config.get('fetch') || fetch;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.retries = retries ?? defaultOptions.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n\n    this.requestId = 0;\n\n    if (isNumber(batch)) {\n      this.batchClient = new BatchClient<RPC.Methods>({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch,\n        rpcMethods: {} as RPC.Methods, // Type information only, not used at runtime\n      });\n    }\n\n    logger.debug('Using Channel', this.id);\n  }\n\n  public readSpecVersion() {\n    return this.specVersion;\n  }\n\n  private get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5000;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      throw new RpcError(rpcError as RPC_ERROR, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      if (this.batchClient) {\n        const { error, result } = await this.batchClient.fetch(\n          method,\n          params,\n          (this.requestId += 1)\n        );\n        this.errorHandler(method, params, error);\n        return result as RPC.Methods[T]['result'];\n      }\n\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  /**\n   * fetch rpc node specVersion\n   * @example this.specVersion = \"0.7.1\"\n   */\n  public getSpecVersion() {\n    return this.fetchEndpoint('starknet_specVersion');\n  }\n\n  /**\n   * fetch if undefined else just return this.specVersion\n   * @example this.specVersion = \"0.8.1\"\n   */\n  public async setUpSpecVersion() {\n    if (!this.specVersion) {\n      const unknownSpecVersion = await this.fetchEndpoint('starknet_specVersion');\n\n      // check if the channel is compatible with the node\n      if (!isVersion(this.channelSpecVersion, unknownSpecVersion)) {\n        logger.error(SYSTEM_MESSAGES.channelVersionMismatch, {\n          channelId: this.id,\n          channelSpecVersion: this.channelSpecVersion,\n          nodeSpecVersion: this.specVersion,\n        });\n      }\n\n      if (!isSupportedSpecVersion(unknownSpecVersion)) {\n        throw new LibraryError(`${SYSTEM_MESSAGES.unsupportedSpecVersion}, channelId: ${this.id}`);\n      }\n\n      this.specVersion = unknownSpecVersion;\n    }\n    return this.specVersion;\n  }\n\n  // TODO: New Method add test\n  /**\n   * Given an l1 tx hash, returns the associated l1_handler tx hashes and statuses for all L1 -> L2 messages sent by the l1 transaction, ordered by the l1 tx sending order\n   */\n  public getMessagesStatus(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getMessagesStatus', {\n      transaction_hash,\n    });\n  }\n\n  // TODO: New Method add test\n  public getStorageProof(\n    classHashes: BigNumberish[] = [],\n    contractAddresses: BigNumberish[] = [],\n    contractsStorageKeys: RPC.CONTRACT_STORAGE_KEYS[] = [], // TODO: allow BigNUmberish[] and fix formatting before request\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const class_hashes = bigNumberishArrayToHexadecimalStringArray(classHashes);\n    const contract_addresses = bigNumberishArrayToHexadecimalStringArray(contractAddresses);\n\n    return this.fetchEndpoint('starknet_getStorageProof', {\n      block_id,\n      class_hashes,\n      contract_addresses,\n      contracts_storage_keys: contractsStorageKeys,\n    });\n  }\n\n  // TODO: New Method add test\n  public getCompiledCasm(classHash: BigNumberish): Promise<RPC.CASM_COMPILED_CONTRACT_CLASS> {\n    const class_hash = toHex(classHash);\n\n    return this.fetchEndpoint('starknet_getCompiledCasm', {\n      class_hash,\n    });\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockWithReceipts(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      // RPC.ETransactionExecutionStatus.SUCCEEDED, Starknet 0.14.0 this one can have incomplete events\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    const txLife: string[] = [];\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n        txLife.push(txStatus.finality_status);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (error instanceof RpcError && error.isType('TXN_HASH_NOT_FOUND')) {\n          logger.info('txLife: ', txLife);\n          const errorMessages: Record<string, string> = {\n            [RPCSPEC09.ETransactionStatus.RECEIVED]: SYSTEM_MESSAGES.txEvictedFromMempool,\n            [RPCSPEC09.ETransactionStatus.PRE_CONFIRMED]: SYSTEM_MESSAGES.consensusFailed,\n            [RPCSPEC09.ETransactionStatus.CANDIDATE]:\n              SYSTEM_MESSAGES.txFailsBlockBuildingValidation,\n          };\n          const errorMessage = errorMessages[txLife.at(-1) as string];\n          if (errorMessage) {\n            throw new Error(errorMessage);\n          }\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions = {}\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const flags = {\n      simulation_flags: (skipValidate\n        ? [RPC.ESimulationFlag.SKIP_VALIDATE]\n        : []) as RPC.Methods['starknet_estimateFee']['params']['simulation_flags'],\n    };\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (isV3Tx(details)) {\n      if (isRPC08Plus_ResourceBoundsBN(details.resourceBounds)) {\n        // V3\n        promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n          invoke_transaction: {\n            type: RPC.ETransactionType.INVOKE,\n            sender_address: functionInvocation.contractAddress,\n            calldata: CallData.toHex(functionInvocation.calldata),\n            version: RPC.ETransactionVersion.V3,\n            signature: signatureToHexArray(functionInvocation.signature),\n            nonce: toHex(details.nonce),\n            resource_bounds: resourceBoundsToHexString(details.resourceBounds),\n            tip: toHex(details.tip),\n            paymaster_data: details.paymasterData.map((it) => toHex(it)),\n            account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n            nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n            fee_data_availability_mode: details.feeDataAvailabilityMode,\n          },\n        });\n      } else throw Error(SYSTEM_MESSAGES.SWOldV3);\n    } else throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (isSierra(contract) && isV3Tx(details)) {\n      if (isRPC08Plus_ResourceBoundsBN(details.resourceBounds)) {\n        // V3 Cairo1\n        promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n          declare_transaction: {\n            type: RPC.ETransactionType.DECLARE,\n            sender_address: senderAddress,\n            compiled_class_hash: compiledClassHash || '',\n            version: RPC.ETransactionVersion.V3,\n            signature: signatureToHexArray(signature),\n            nonce: toHex(details.nonce),\n            contract_class: {\n              sierra_program: decompressProgram(contract.sierra_program),\n              contract_class_version: contract.contract_class_version,\n              entry_points_by_type: contract.entry_points_by_type,\n              abi: contract.abi,\n            },\n            resource_bounds: resourceBoundsToHexString(details.resourceBounds),\n            tip: toHex(details.tip),\n            paymaster_data: details.paymasterData.map((it) => toHex(it)),\n            account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n            nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n            fee_data_availability_mode: details.feeDataAvailabilityMode,\n          },\n        });\n      } else throw Error(SYSTEM_MESSAGES.SWOldV3);\n    } else throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (isV3Tx(details)) {\n      if (isRPC08Plus_ResourceBoundsBN(details.resourceBounds)) {\n        promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n          deploy_account_transaction: {\n            type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n            version: RPC.ETransactionVersion.V3,\n            signature: signatureToHexArray(signature),\n            nonce: toHex(details.nonce),\n            contract_address_salt: toHex(addressSalt || 0),\n            constructor_calldata: CallData.toHex(constructorCalldata || []),\n            class_hash: toHex(classHash),\n            resource_bounds: resourceBoundsToHexString(details.resourceBounds),\n            tip: toHex(details.tip),\n            paymaster_data: details.paymasterData.map((it) => toHex(it)),\n            nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n            fee_data_availability_mode: details.feeDataAvailabilityMode,\n          },\n        });\n      } else throw Error(SYSTEM_MESSAGES.SWOldV3);\n      // v3\n    } else throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPCSPEC08.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      // console.log({ invocation });\n      throw Error('v0,v1,v2 tx are not supported on RPC 0.8');\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: resourceBoundsToHexString(invocation.resourceBounds),\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === RPCSPEC08.ETransactionType.INVOKE) {\n      return {\n        // V3\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3), // invocation.version as simulate can use fee and normal version\n        ...details,\n      } as RPC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === RPCSPEC08.ETransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        logger.error('Cairo 0 -  non Sierra v1 tx are not supported');\n        throw Error('Declaring non Sierra contract using RPC 0.8');\n      }\n      return {\n        // Cairo - V3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3), // invocation.version as simulate can use fee and normal version\n        ...details,\n      } as RPC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === RPCSPEC08.ETransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // V3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3), // invocation.version as simulate can use fee and normal version\n        ...restDetails,\n      } as RPC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","import { ValuesType } from '../../helpers/valuesType';\nimport { LegacyCompiledContract, LegacyContractClass } from './legacy';\nimport { CompiledSierra, SierraContractClass } from './sierra';\n\n// Final types\n/**\n * format produced after compressing compiled contract\n *\n * CompressedCompiledContract\n */\nexport type ContractClass = LegacyContractClass | SierraContractClass;\n\n/**\n * format produced after compile .cairo to .json\n */\nexport type CompiledContract = LegacyCompiledContract | CompiledSierra;\n\n/**\n * Compressed or decompressed Cairo0 or Cairo1 Contract\n */\nexport type CairoContract = ContractClass | CompiledContract;\n\n// Basic elements\nexport const EntryPointType = {\n  EXTERNAL: 'EXTERNAL',\n  L1_HANDLER: 'L1_HANDLER',\n  CONSTRUCTOR: 'CONSTRUCTOR',\n} as const;\n\nexport type EntryPointType = ValuesType<typeof EntryPointType>;\n\nexport * from './abi';\nexport * from './legacy';\nexport * from './sierra';\n","// this file aims to unify the RPC specification types used by the common Provider class\n\nimport { SimpleOneOf } from '../../types/helpers';\nimport { RPCSPEC09, RPCSPEC08 } from '../../types/api';\n\n// taken from type-fest\nexport type Simplify<T> = { [K in keyof T]: T[K] } & {};\n\n// taken from type-fest\nexport type RequiredKeysOf<T extends object> = Exclude<\n  {\n    [K in keyof T]: T extends Record<K, T[K]> ? K : never;\n  }[keyof T],\n  undefined\n>;\n\ntype ArrayElement<T> = T extends Array<infer U> ? U : never;\n\ntype MergeProperties<T1 extends Record<any, any>, T2 extends Record<any, any>> = {\n  [K in RequiredKeysOf<T1> & RequiredKeysOf<T2>]: Merge<T1[K], T2[K]>;\n} & {\n  [K in keyof T1 & keyof T2]?: Merge<T1[K], T2[K]>;\n} & {\n  [K in Exclude<keyof T1, keyof T2>]?: T1[K];\n} & {\n  [K in Exclude<keyof T2, keyof T1>]?: T2[K];\n};\n\n/**\n *  type a = { w: bigint[]; x: bigint; y: string };\n type b = { w: number[]; x: number; z: string };\n type c = Merge<a, b>; // { w: (bigint | number)[] x: bigint | number; y?: string; z?: string; }\n\n NOTE: handling for ambiguous overlaps, such as a shared property being an array or object,\n is simplified to resolve to only one type since there shouldn't be such occurrences in the\n currently supported RPC specifications\n */\ntype Merge<T1, T2> = Simplify<\n  T1 extends Array<any>\n    ? T2 extends Array<any>\n      ? Array<Merge<ArrayElement<T1>, ArrayElement<T2>>>\n      : T1\n    : T2 extends Array<any>\n      ? T2\n      : T1 extends object\n        ? T2 extends object\n          ? MergeProperties<T1, T2>\n          : T1\n        : T2 extends object\n          ? T2\n          : T1 | T2\n>;\n\n// Default exports for both RPCs\nexport type ETransactionVersion = RPCSPEC09.ETransactionVersion;\nexport const { ETransactionVersion } = RPCSPEC09;\n\nexport type ETransactionVersion2 = RPCSPEC09.ETransactionVersion2;\nexport const { ETransactionVersion2 } = RPCSPEC09;\n\nexport type ETransactionVersion3 = RPCSPEC09.ETransactionVersion3;\nexport const { ETransactionVersion3 } = RPCSPEC09;\n\n// MERGES\nexport type BLOCK_HASH = Merge<RPCSPEC08.BLOCK_HASH, RPCSPEC09.BLOCK_HASH>;\nexport type BLOCK_NUMBER = Merge<RPCSPEC08.BLOCK_NUMBER, RPCSPEC09.BLOCK_NUMBER>;\nexport type FELT = Merge<RPCSPEC08.FELT, RPCSPEC09.FELT>;\nexport type TXN_HASH = Merge<RPCSPEC08.TXN_HASH, RPCSPEC09.TXN_HASH>;\n\nexport type PRICE_UNIT = Merge<RPCSPEC08.PRICE_UNIT, RPCSPEC09.PRICE_UNIT>;\nexport type RESOURCE_PRICE = Merge<RPCSPEC08.RESOURCE_PRICE, RPCSPEC09.RESOURCE_PRICE>;\nexport type SIMULATION_FLAG = Merge<RPCSPEC08.SIMULATION_FLAG, RPCSPEC09.SIMULATION_FLAG>;\n\nexport type STATE_UPDATE = Merge<RPCSPEC08.STATE_UPDATE, RPCSPEC09.STATE_UPDATE>;\nexport type PENDING_STATE_UPDATE = Merge<\n  RPCSPEC08.PENDING_STATE_UPDATE,\n  RPCSPEC09.PRE_CONFIRMED_STATE_UPDATE\n>;\nexport type PRE_CONFIRMED_STATE_UPDATE = RPCSPEC09.PRE_CONFIRMED_STATE_UPDATE;\n\n// TODO: Can we remove all of this ?\n/* export type INVOKE_TXN_RECEIPT = IsInBlock<RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'INVOKE'>>;\nexport type DECLARE_TXN_RECEIPT = IsInBlock<RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'DECLARE'>>;\nexport type DEPLOY_ACCOUNT_TXN_RECEIPT = IsInBlock<\n  RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'DEPLOY_ACCOUNT'>\n>;\nexport type L1_HANDLER_TXN_RECEIPT = IsInBlock<RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'L1_HANDLER'>>; */\n\nexport type PENDING_INVOKE_TXN_RECEIPT = RPCSPEC08.IsPending<\n  RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'INVOKE'>\n>;\nexport type PENDING_DECLARE_TXN_RECEIPT = RPCSPEC08.IsPending<\n  RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'DECLARE'>\n>;\nexport type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT = RPCSPEC08.IsPending<\n  RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'DEPLOY_ACCOUNT'>\n>;\nexport type PENDING_L1_HANDLER_TXN_RECEIPT = RPCSPEC08.IsPending<\n  RPCSPEC08.IsType<RPCSPEC08.TransactionReceipt, 'L1_HANDLER'>\n>;\n//\n\nexport type BlockWithTxHashes = Merge<RPCSPEC08.BlockWithTxHashes, RPCSPEC09.BlockWithTxHashes>;\nexport type ContractClassPayload = Merge<RPCSPEC08.ContractClass, RPCSPEC09.ContractClass>;\nexport type DeclaredTransaction = Merge<\n  RPCSPEC08.DeclaredTransaction,\n  RPCSPEC09.DeclaredTransaction\n>;\nexport type InvokedTransaction = Merge<RPCSPEC08.InvokedTransaction, RPCSPEC09.InvokedTransaction>;\nexport type DeployedAccountTransaction = Merge<\n  RPCSPEC08.DeployedAccountTransaction,\n  RPCSPEC09.DeployedAccountTransaction\n>;\n\nexport type L1_HANDLER_TXN = RPCSPEC08.L1_HANDLER_TXN;\nexport type EDataAvailabilityMode = RPCSPEC08.EDataAvailabilityMode;\nexport const { EDataAvailabilityMode } = RPCSPEC08;\nexport type EDAMode = RPCSPEC08.EDAMode;\nexport const { EDAMode } = RPCSPEC08;\nexport type EmittedEvent = Merge<RPCSPEC08.EmittedEvent, RPCSPEC09.EmittedEvent>;\nexport type Event = Merge<RPCSPEC08.Event, RPCSPEC09.Event>;\n\nexport type PendingReceipt = Merge<\n  RPCSPEC08.TransactionReceiptPendingBlock,\n  RPCSPEC09.TransactionReceiptPreConfirmedBlock\n>;\nexport type Receipt = Merge<\n  RPCSPEC08.TransactionReceiptProductionBlock,\n  RPCSPEC09.TransactionReceiptProductionBlock\n>;\n\n/**\n * original response from estimate fee without parsing\n */\nexport type FeeEstimate = Merge<RPCSPEC08.FEE_ESTIMATE, RPCSPEC09.FEE_ESTIMATE>;\nexport type ApiEstimateFeeResponse = FeeEstimate[]; // 0.8 and 0.9\n\nexport function isRPC08Plus_ResourceBounds(\n  entry: ResourceBounds\n): entry is RPCSPEC08.ResourceBounds {\n  return 'l1_data_gas' in entry;\n}\n\nexport function isRPC08Plus_ResourceBoundsBN(entry: ResourceBoundsBN): entry is ResourceBoundsBN {\n  return 'l1_data_gas' in entry;\n}\n\nexport type ResourceBounds = Merge<RPCSPEC08.ResourceBounds, RPCSPEC09.ResourceBounds>; // same sa rpc0.8\n\nexport type EventFilter = RPCSPEC09.EventFilter;\n\n/**\n * Represents percentage overhead for each resource bound\n * numerical 50 means 50% overhead\n */\nexport type ResourceBoundsOverhead = {\n  [K in keyof ResourceBounds]: ResourceBounds[K] extends object\n    ? {\n        [P in keyof ResourceBounds[K]]: number;\n      }\n    : number;\n};\n\n/**\n * Resource bounds in big number format\n */\nexport type ResourceBoundsBN = {\n  [K in keyof ResourceBounds]: ResourceBounds[K] extends object\n    ? {\n        [P in keyof ResourceBounds[K]]: bigint;\n      }\n    : number;\n};\n\nexport type SimulateTransaction = SimpleOneOf<\n  RPCSPEC09.SimulateTransaction,\n  RPCSPEC08.SimulateTransaction\n>;\nexport type SimulateTransactionResponse = SimpleOneOf<\n  RPCSPEC09.SimulateTransactionResponse,\n  RPCSPEC08.SimulateTransactionResponse\n>;\n\nexport type TransactionTrace = SimpleOneOf<\n  RPCSPEC09.TRANSACTION_TRACE,\n  RPCSPEC08.TRANSACTION_TRACE\n>;\n\nexport type TransactionWithHash = Merge<\n  RPCSPEC08.TransactionWithHash,\n  RPCSPEC09.TransactionWithHash\n>;\n\nexport type TransactionReceipt = Merge<RPCSPEC08.TransactionReceipt, RPCSPEC09.TransactionReceipt>;\nexport type Methods = RPCSPEC08.Methods;\nexport type TXN_STATUS = Merge<RPCSPEC08.TXN_STATUS, RPCSPEC09.TXN_STATUS>;\nexport type TXN_EXECUTION_STATUS = Merge<\n  RPCSPEC08.TXN_EXECUTION_STATUS,\n  RPCSPEC09.TXN_EXECUTION_STATUS\n>;\nexport type TransactionStatus = Merge<RPCSPEC08.TransactionStatus, RPCSPEC09.TransactionStatus>;\nexport type ETransactionStatus = RPCSPEC08.ETransactionStatus;\nexport const { ETransactionStatus } = RPCSPEC08;\nexport type ETransactionExecutionStatus = RPCSPEC08.ETransactionExecutionStatus;\nexport const { ETransactionExecutionStatus } = RPCSPEC08;\n// export type TRANSACTION_TRACE = Merge<RPCSPEC08.TRANSACTION_TRACE, RPCSPEC09.TRANSACTION_TRACE>;\nexport type FEE_ESTIMATE = Merge<RPCSPEC08.FEE_ESTIMATE, RPCSPEC09.FEE_ESTIMATE>;\nexport type EVENTS_CHUNK = Merge<RPCSPEC08.EVENTS_CHUNK, RPCSPEC09.EVENTS_CHUNK>;\n\nexport type TransactionType = RPCSPEC09.ETransactionType;\nexport const { ETransactionType: TransactionType } = RPCSPEC09;\n\nexport type BlockStatus = RPCSPEC09.EBlockStatus;\nexport const { EBlockStatus: BlockStatus } = RPCSPEC09;\n\nexport type TransactionFinalityStatus = RPCSPEC09.ETransactionFinalityStatus;\nexport const { ETransactionFinalityStatus: TransactionFinalityStatus } = RPCSPEC09;\n\nexport type TransactionExecutionStatus = RPCSPEC09.ETransactionExecutionStatus;\nexport const { ETransactionExecutionStatus: TransactionExecutionStatus } = RPCSPEC09;\n\nexport type BlockTag = RPCSPEC09.EBlockTag;\nexport const { EBlockTag: BlockTag } = RPCSPEC09;\n","import { ValuesType } from './helpers/valuesType';\n\nexport const ValidateType = {\n  DEPLOY: 'DEPLOY',\n  CALL: 'CALL',\n  INVOKE: 'INVOKE',\n} as const;\n\nexport type ValidateType = ValuesType<typeof ValidateType>;\n\nexport const Uint = {\n  u8: 'core::integer::u8',\n  u16: 'core::integer::u16',\n  u32: 'core::integer::u32',\n  u64: 'core::integer::u64',\n  u96: 'core::integer::u96',\n  u128: 'core::integer::u128',\n  u256: 'core::integer::u256', // This one is struct\n  u512: 'core::integer::u512', // This one is struct\n} as const;\n\nexport type Uint = ValuesType<typeof Uint>;\n\nexport const Int = {\n  i8: 'core::integer::i8',\n  i16: 'core::integer::i16',\n  i32: 'core::integer::i32',\n  i64: 'core::integer::i64',\n  i128: 'core::integer::i128',\n} as const;\n\nexport type Int = ValuesType<typeof Int>;\n\nexport const Literal = {\n  ClassHash: 'core::starknet::class_hash::ClassHash',\n  ContractAddress: 'core::starknet::contract_address::ContractAddress',\n  Secp256k1Point: 'core::starknet::secp256k1::Secp256k1Point',\n  U96: 'core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>',\n} as const;\n\nexport type Literal = ValuesType<typeof Literal>;\n\nexport const ETH_ADDRESS = 'core::starknet::eth_address::EthAddress';\nexport const NON_ZERO_PREFIX = 'core::zeroable::NonZero::';\n","import type { BlockHash, TransactionHash } from '../../types/api';\nimport type { CairoEnum } from '../../types/cairoEnum';\nimport type {\n  Abi,\n  BigNumberish,\n  BlockNumber,\n  Calldata,\n  DeclareAndDeployContractPayload,\n  ParsedStruct,\n  RawArgs,\n  RawArgsArray,\n  Signature,\n} from '../../types/lib';\nimport type { UniversalDetails } from '../../account/types/index.type';\nimport type { ProviderInterface } from '../../provider';\nimport type { AccountInterface } from '../../account/interface';\nimport type { ParsingStrategy } from '../../utils/calldata/parser';\n\nexport type AsyncContractFunction<T = any> = (...args: ArgsOrCalldataWithOptions) => Promise<T>;\nexport type ContractFunction = (...args: ArgsOrCalldataWithOptions) => any;\n\nexport type CallResult =\n  | {\n      [key: string]: any;\n    }\n  | CallResult[]\n  | bigint\n  | string\n  | boolean\n  | CairoEnum;\n\n// export type ArgsOrCalldata = RawArgsArray | [Calldata] | Calldata;\n// export type ArgsOrCalldataWithOptions = ArgsOrCalldata & ContractOptions;\n\n// RawParamsOrCalldata as args\nexport type ArgsOrCalldata =\n  // params like (va,vb,vc,vd...)               as args is [va,vb,vc,vd...]\n  // params like (x) where x = {a:va,b:vb,c:vc...} as args is [x]\n  // params like (x) where x = [va,vb,vc...]       as args is [[x]]\n  | RawArgsArray // recursive definition cover all this cases\n  // [calldata] is [['0x','0x'...]]\n  | [Calldata]\n  // calldata is ['0x','0x'...]\n  | Calldata;\n\n// RawParamsOrCalldata where each can have an option\nexport type ArgsOrCalldataWithOptions =\n  // params like (va,vb,vc,vd..., option)                   as args is [va,vb,vc,vd..., option]\n  // params like (x, option) where x = {a:va,b:vb,c:vc...}  as args is [x, option]\n  // params like (x, option) where x = [va,vb,vc...]        as args is [[x], option]\n  // recursive definition cover all this cases\n  | [...RawArgsArray]\n  | [...RawArgsArray, ContractOptions]\n  // used when called compile that return array of calldata\n  // (calldata, options)                                             as args is [['0x','0x'...], options]\n  | [Calldata]\n  | [Calldata, ContractOptions]\n  // used when separate params compilations\n  // (c,a,l,l,d,a,t,a, options)                                      as args is ['0x','0x'..., options]\n  | [...Calldata]\n  | [...Calldata, ContractOptions];\n\nexport type CommonContractOptions = {\n  /**\n   * compile and validate arguments\n   * @default true\n   */\n  parseRequest?: boolean;\n\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @default true\n   */\n  parseResponse?: boolean;\n\n  /**\n   * Custom parsing strategy for request/response processing\n   */\n  parsingStrategy?: ParsingStrategy;\n};\n\nexport type ContractOptions = {\n  abi: Abi;\n  address: string;\n  /**\n   * Connect account to read and write methods\n   * Connect provider to read methods\n   * @default defaultProvider\n   */\n  providerOrAccount?: ProviderOrAccount;\n\n  /**\n   * Class hash of the contract\n   */\n  classHash?: string;\n} & CommonContractOptions;\n\nexport type ExecuteOptions = Pick<CommonContractOptions, 'parseRequest'> & {\n  /**\n   * Used when invoking with only provider\n   */\n  signature?: Signature;\n  /**\n   * Deployer contract salt\n   */\n  salt?: string;\n  /**\n   * Wait for transaction to be included in a block\n   * @default false\n   */\n  waitForTransaction?: boolean;\n} & Partial<UniversalDetails>;\n\nexport type CallOptions = CommonContractOptions & {\n  formatResponse?: FormatResponse;\n} & Pick<UniversalDetails, 'blockIdentifier' | 'version'>;\n\nexport type WithOptions = ExecuteOptions & CallOptions;\n\nexport type ParsedEvent = { [name: string]: ParsedStruct } & {\n  block_hash?: BlockHash;\n  block_number?: BlockNumber;\n  transaction_hash?: TransactionHash;\n};\n\nexport type ParsedEvents = Array<ParsedEvent> & {\n  getByPath?(path: string): ParsedStruct | null;\n};\n\n// TODO: This should be in formatResponse type\n/**\n * Advance formatting used to get js types data as result\n * @description https://starknetjs.com/docs/guides/define_call_message/#formatresponse\n * @example\n * ```typescript\n * // assign custom or existing method to resulting data\n * formatResponse: { balance: uint256ToBN },\n * ```\n * @example\n * ```typescript\n * // define resulting data js types\n * const formatAnswer = { id: 'number', description: 'string' };\n * ```\n */\nexport type FormatResponse = { [key: string]: any };\n\nexport type ProviderOrAccount = ProviderInterface | AccountInterface;\n\n/**\n * Type guard to narrow ProviderOrAccount to AccountInterface\n * @param providerOrAccount - The object to check\n * @returns true if the object is an AccountInterface\n */\nexport function isAccount(\n  providerOrAccount: ProviderOrAccount\n): providerOrAccount is AccountInterface {\n  return 'execute' in providerOrAccount;\n}\n\ntype FactoryParamsBase = {\n  account: AccountInterface;\n  /**\n   * Parse arguments to calldata.\n   * optimization when calldata are already validated and compiled.\n   * @default true\n   */\n  parseRequest?: boolean;\n};\n\ntype DeclareAndDeployParams = FactoryParamsBase & DeclareAndDeployContractPayload;\n\ntype DeployOnlyParams = FactoryParamsBase & {\n  classHash: BigNumberish;\n  salt?: string;\n  unique?: boolean;\n  constructorCalldata?: RawArgs;\n  abi?: Abi;\n};\n\nexport type FactoryParams = (DeclareAndDeployParams | DeployOnlyParams) & CommonContractOptions;\n","import { ValuesType } from './helpers/valuesType';\nimport { BigNumberish, RawArgs, type Signature } from './lib';\n\nexport interface OutsideExecutionOptions {\n  /** authorized executer of the transaction(s):  Hex address or \"ANY_CALLER\" or shortString.encodeShortString(constants.OutsideExecutionCallerAny) */\n  caller: string;\n  /** Unix timestamp of the beginning of the timeframe */\n  execute_after: BigNumberish;\n  /** Unix timestamp of the end of the timeframe */\n  execute_before: BigNumberish;\n}\n\nexport interface OutsideCall {\n  to: string;\n  selector: BigNumberish;\n  calldata: RawArgs;\n}\n\nexport interface OutsideExecution {\n  caller: string;\n  nonce: BigNumberish;\n  execute_after: BigNumberish;\n  execute_before: BigNumberish;\n  calls: OutsideCall[];\n}\n\nexport interface OutsideTransaction {\n  outsideExecution: OutsideExecution;\n  signature: Signature;\n  signerAddress: BigNumberish;\n  version: OutsideExecutionVersion;\n}\n\nexport const OutsideExecutionTypesV1 = {\n  StarkNetDomain: [\n    { name: 'name', type: 'felt' },\n    { name: 'version', type: 'felt' },\n    { name: 'chainId', type: 'felt' },\n  ],\n  OutsideExecution: [\n    { name: 'caller', type: 'felt' },\n    { name: 'nonce', type: 'felt' },\n    { name: 'execute_after', type: 'felt' },\n    { name: 'execute_before', type: 'felt' },\n    { name: 'calls_len', type: 'felt' },\n    { name: 'calls', type: 'OutsideCall*' },\n  ],\n  OutsideCall: [\n    { name: 'to', type: 'felt' },\n    { name: 'selector', type: 'felt' },\n    { name: 'calldata_len', type: 'felt' },\n    { name: 'calldata', type: 'felt*' },\n  ],\n};\n\nexport const OutsideExecutionTypesV2 = {\n  StarknetDomain: [\n    // SNIP-12 revision 1 is used, so should be \"StarknetDomain\", not \"StarkNetDomain\"\n    { name: 'name', type: 'shortstring' },\n    { name: 'version', type: 'shortstring' }, // set to 2 in v2\n    { name: 'chainId', type: 'shortstring' },\n    { name: 'revision', type: 'shortstring' },\n  ],\n  OutsideExecution: [\n    { name: 'Caller', type: 'ContractAddress' },\n    { name: 'Nonce', type: 'felt' },\n    { name: 'Execute After', type: 'u128' },\n    { name: 'Execute Before', type: 'u128' },\n    { name: 'Calls', type: 'Call*' },\n  ],\n  Call: [\n    { name: 'To', type: 'ContractAddress' },\n    { name: 'Selector', type: 'selector' },\n    { name: 'Calldata', type: 'felt*' },\n  ],\n};\n\nexport const OutsideExecutionVersion = {\n  UNSUPPORTED: '0',\n  V1: '1',\n  V2: '2',\n} as const;\nexport type OutsideExecutionVersion = ValuesType<typeof OutsideExecutionVersion>;\n","import * as json from 'lossless-json';\n\n/**\n * Helper to convert string to number or bigint based on size\n */\nconst parseIntAsNumberOrBigInt = (str: string) => {\n  if (!json.isInteger(str)) return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\n\n/**\n * Convert JSON string to JSON object\n *\n * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()\n * which can accept simple data types but is not represented in the default typing\n *\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 11223344556677889900]';\n * const result = parse(str);\n * // result = [123, 12.3, 11223344556677890048n]\n * ```\n */\nexport const parse = (str: string): any =>\n  json.parse(String(str), undefined, parseIntAsNumberOrBigInt);\n\n/**\n * Convert JSON string to JSON object with all numbers as bigint\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 1234567890]';\n * const result = parseAlwaysAsBig(str);\n * // result = [123n, 12.3, 1234567890n]\n * ```\n */\nexport const parseAlwaysAsBig = (str: string): any =>\n  json.parse(String(str), undefined, json.parseNumberAndBigInt);\n\n/**\n * Convert JSON object to JSON string\n *\n * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()\n * which can also return undefined but is not represented in the default typing\n *\n * @param value JSON object\n * @param [replacer] Function that alters the behavior of the stringification process\n * @param [space] Used to insert white space into the output JSON string\n * @param [numberStringifiers] Function used to stringify numbers (returning undefined will delete the property from the object)\n * @return {string} JSON string\n * @example\n * ```typescript\n * const value = [123, 12.3, 1234567890];\n * const result = stringify(value);\n * // result = '[123,12.3,1234567890]'\n * ```\n */\nexport const stringify = (\n  value: unknown,\n  replacer?: any,\n  space?: string | number | undefined,\n  numberStringifiers?: json.NumberStringifier[] | undefined\n): string => json.stringify(value, replacer, space, numberStringifiers)!;\n","import { stringify } from '../json';\nimport { RpcProviderOptions } from '../../types';\nimport { JRPC } from '../../types/api';\n\nexport type BatchClientOptions<T extends { [key: string]: { params?: any; result?: any } }> = {\n  nodeUrl: string;\n  headers: object;\n  interval: number;\n  baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n  rpcMethods: T;\n};\n\nexport class BatchClient<T extends { [key: string]: { params?: any; result?: any } }> {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public interval: number;\n\n  public requestId: number = 0;\n\n  private pendingRequests: Record<string | number, JRPC.RequestBody> = {};\n\n  private batchPromises: Record<string | number, Promise<JRPC.ResponseBody[]>> = {};\n\n  private delayTimer?: NodeJS.Timeout;\n\n  private delayPromise?: Promise<void>;\n\n  private delayPromiseResolve?: () => void;\n\n  private baseFetch: BatchClientOptions<T>['baseFetch'];\n\n  private rpcMethods: T;\n\n  constructor(options: BatchClientOptions<T>) {\n    this.nodeUrl = options.nodeUrl;\n    this.headers = options.headers;\n    this.interval = options.interval;\n    this.baseFetch = options.baseFetch;\n    this.rpcMethods = options.rpcMethods;\n  }\n\n  private async wait(): Promise<void> {\n    // If the promise is not set, create a new one and store the resolve function\n    if (!this.delayPromise || !this.delayPromiseResolve) {\n      this.delayPromise = new Promise((resolve) => {\n        this.delayPromiseResolve = resolve;\n      });\n    }\n\n    if (this.delayTimer) {\n      clearTimeout(this.delayTimer);\n      this.delayTimer = undefined;\n    }\n\n    this.delayTimer = setTimeout(() => {\n      if (this.delayPromiseResolve) {\n        this.delayPromiseResolve();\n\n        // Reset the promise and resolve function so that a new promise is created next time\n        this.delayPromise = undefined;\n        this.delayPromiseResolve = undefined;\n      }\n    }, this.interval);\n\n    return this.delayPromise;\n  }\n\n  private addPendingRequest<M extends keyof T>(\n    method: M,\n    params?: T[M]['params'],\n    id?: string | number\n  ) {\n    const request: JRPC.RequestBody = {\n      id: id ?? `batched_${(this.requestId += 1)}`,\n      jsonrpc: '2.0',\n      method: (method as symbol).description || String(method),\n      params: params ?? undefined,\n    };\n\n    this.pendingRequests[request.id] = request;\n\n    return request.id;\n  }\n\n  private async sendBatch(requests: JRPC.RequestBody[]) {\n    const raw = await this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(requests),\n      headers: this.headers as Record<string, string>,\n    });\n\n    return raw.json();\n  }\n\n  /**\n   * Automatically batches and fetches JSON-RPC calls in a single request.\n   * @param method Method to call\n   * @param params Method parameters\n   * @param id JSON-RPC Request ID\n   * @returns JSON-RPC Response\n   */\n  public async fetch<\n    M extends keyof T,\n    TResponse extends JRPC.ResponseBody & {\n      result?: T[M]['result'];\n      error?: JRPC.Error;\n    },\n  >(method: M, params?: T[M]['params'], id?: string | number): Promise<TResponse> {\n    const requestId = this.addPendingRequest(method, params, id);\n\n    // Wait for the interval to pass before sending the batch\n    await this.wait();\n\n    // Get the pending requests and clear the object\n    const requests = this.pendingRequests;\n    this.pendingRequests = {};\n\n    // If there is no promise for this batch, create one and send the batch\n    if (!this.batchPromises[requestId]) {\n      const promise = this.sendBatch(Object.values(requests));\n      Object.keys(requests).forEach((key) => {\n        this.batchPromises[key] = promise;\n      });\n    }\n\n    const results = await this.batchPromises[requestId];\n    delete this.batchPromises[requestId];\n\n    // Find this request in the results and return it\n    const result = results.find((res: any) => res.id === requestId);\n    if (!result)\n      throw new Error(`Couldn't find the result for the request. Method: ${String(method)}`);\n\n    return result as TResponse;\n  }\n}\n","/**\n * Asserts that the given condition is true, otherwise throws an error with an optional message.\n * @param {boolean} condition - The condition to check.\n * @param {string} [message] - The optional message to include in the error.\n * @throws {Error} Throws an error if the condition is false.\n * @example\n * ```typescript\n * const address = '0xa7ee790591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf';\n * assert(/^(0x)?[0-9a-fA-F]{64}$/.test(address), 'Invalid address format');\n * ```\n */\nexport default function assert(condition: boolean, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failure');\n  }\n}\n\n/**\n * Asserts that the given condition is true, otherwise call the method.\n * @param condition\n * @param method\n */\nexport function assertX(condition: boolean, method: () => void): asserts condition {\n  if (!condition) {\n    if (method.length === 0) {\n      method(); // Call the method if it's a function with no arguments\n    } else {\n      throw new Error('AssertionX failure: message function should not require arguments');\n    }\n  }\n}\n","import { hexToBytes as hexToBytesNoble } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { MASK_31 } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport assert from './assert';\nimport { addHexPrefix, buf2hex, removeHexPrefix } from './encode';\nimport { isBigInt, isNumber, isString } from './typed';\n\n/**\n * Test if string is hex-string\n *\n * @param hex hex-string\n * @returns {boolean} true if the input string is a hexadecimal string, false otherwise\n * @example\n * ```typescript\n * const hexString1 = \"0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result1 = isHex(hexString1);\n * // result1 = true\n *\n * const hexString2 = \"2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result2 = isHex(hexString2);\n * // result2 = false\n * ```\n */\nexport function isHex(hex: string): boolean {\n  return /^0[xX][0-9a-fA-F]*$/.test(hex);\n}\n\nexport const isHexString = isHex;\n\n/**\n * Convert BigNumberish to bigint\n *\n * @param {BigNumberish} value value to convert\n * @returns {BigInt} converted value\n * @example\n * ```typescript\n * const str = '123';\n * const result = toBigInt(str);\n * // result = 123n\n * ```\n */\nexport function toBigInt(value: BigNumberish): bigint {\n  return BigInt(value);\n}\n\n/**\n * try to convert BigNumberish to bigint\n * in case of undefined return undefined\n */\nexport function tryToBigInt(value: BigNumberish | undefined) {\n  return value ? BigInt(value) : undefined;\n}\n\n/**\n * Convert BigNumberish to hex-string\n *\n * @param {BigNumberish} value value to convert\n * @returns {string} converted number in hex-string format\n * @example\n * ```typescript\n * toHex(100); // '0x64'\n * toHex('200'); // '0xc8'\n * ```\n */\nexport function toHex(value: BigNumberish): string {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\n\n/**\n * Alias of ToHex\n */\nexport const toHexString = toHex;\n\n/**\n * Convert BigNumberish to storage-key-string\n *\n * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.\n *\n * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:\n * `0x0 + [0-7] + 62 hex = 0x + 64 hex`\n * @returns format: storage-key-string\n * @example\n * ```typescript\n * toStorageKey(0x123); // '0x0000000000000000000000000000000000000000000000000000000000000123'\n * toStorageKey(123); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toStorageKey('test'); // 'Error'\n * ```\n */\nexport function toStorageKey(number: BigNumberish): string {\n  // TODO: This is not completely correct as it will not enforce first 0 and second [0-7], 0x82bda... will pass as valid and should be false\n  return addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n}\n\n/**\n * Convert BigNumberish to hex format 0x + 64 hex chars\n *\n * Similar as toStorageKey but conforming to exactly 0x(64 hex chars).\n *\n * @returns format: hex-0x(64)-string\n * @example\n * ```typescript\n * toHex64(123); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toHex64(123n); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toHex64('test'); // 'Error'\n * ```\n */\nexport function toHex64(number: BigNumberish): string {\n  const res = addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n  if (res.length !== 66) throw TypeError('number is too big for hex 0x(64) representation');\n  return res;\n}\n\n/**\n * Convert hexadecimal string to decimal string\n *\n * @param {string} hex hex-string to convert\n * @returns {string} converted number in decimal string format\n * @example\n * ```typescript\n * hexToDecimalString('64'); // '100'\n * hexToDecimalString('c8'); // '200'\n * ```\n */\nexport function hexToDecimalString(hex: string): string {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\n\n/**\n * Remove hex-string leading zeroes and lowercase it\n *\n * @param {string} hex hex-string\n * @returns {string} updated string in hex-string format\n * @example\n * ```typescript\n * cleanHex('0x00023AB'); // '0x23ab'\n * ```\n */\nexport function cleanHex(hex: string): string {\n  return hex.toLowerCase().replace(/^(0x)0+/, '$1');\n}\n\n/**\n * Asserts input is equal to or greater then lowerBound and lower then upperBound.\n *\n * The `inputName` parameter is used in the assertion message.\n * @param input Value to check\n * @param lowerBound Lower bound value\n * @param upperBound Upper bound value\n * @param inputName Name of the input for error message\n * @throws Error if input is out of range\n * @example\n * ```typescript\n * const input1:BigNumberish = 10;\n * assertInRange(input1, 5, 20, 'value')\n *\n * const input2: BigNumberish = 25;\n * assertInRange(input2, 5, 20, 'value');\n * // throws Error: Message not signable, invalid value length.\n * ```\n */\nexport function assertInRange(\n  input: BigNumberish,\n  lowerBound: BigNumberish,\n  upperBound: BigNumberish,\n  inputName = ''\n) {\n  const messageSuffix = inputName === '' ? 'invalid length' : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\n\n/**\n * Convert BigNumberish array to decimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns {string[]} array of decimal strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToDecimalStringArray(data);\n * // result = ['100', '200']\n * ```\n */\nexport function bigNumberishArrayToDecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toBigInt(x).toString(10));\n}\n\n/**\n * Convert BigNumberish array to hexadecimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns array of hex-strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToHexadecimalStringArray(data);\n * // result = ['0x64', '0xc8']\n * ```\n */\nexport function bigNumberishArrayToHexadecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toHex(x));\n}\n\n/**\n * Test if string is a whole number (0, 1, 2, 3...)\n *\n * @param {string} str string to test\n * @returns {boolean}: true if string is a whole number, false otherwise\n * @example\n * ```typescript\n * isStringWholeNumber('100'); // true\n * isStringWholeNumber('10.0'); // false\n * isStringWholeNumber('test'); // false\n * ```\n */\nexport function isStringWholeNumber(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n\n/**\n * Convert string to decimal string\n *\n * @param {string} str string to convert\n * @returns converted string in decimal format\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getDecimalString(\"0x1a\");\n * // result = \"26\"\n *\n * const result2 = getDecimalString(\"Hello\");\n * // throws Error: \"Hello needs to be a hex-string or whole-number-string\"\n * ```\n */\nexport function getDecimalString(str: string) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string to hexadecimal string\n *\n * @param {string} str string to convert\n * @returns converted hex-string\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getHexString(\"123\");\n * // result = \"0x7b\"\n *\n * const result2 = getHexString(\"Hello\");\n * // throws Error: Hello needs to be a hex-string or whole-number-string\n * ```\n */\nexport function getHexString(str: string) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string array to hex-string array\n *\n * @param {Array<string>} array array of string elements\n * @returns array of converted elements in hex-string format\n * @example\n * ```typescript\n * const data = ['100', '200', '0xaa'];\n * const result = getHexStringArray(data);\n * // result = ['0x64', '0xc8', '0xaa']\n * ```\n */\nexport function getHexStringArray(array: Array<string>) {\n  return array.map(getHexString);\n}\n\n/**\n * Convert boolean to \"0\" or \"1\"\n *\n * @param value The boolean value to be converted.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = toCairoBool(true);\n * // result =\"1\"\n *\n * const result2 = toCairoBool(false);\n * // result2 = \"0\"\n * ```\n */\nexport function toCairoBool(value: boolean): string {\n  return (+value).toString();\n}\n\n/**\n * Convert hex-string to an array of Bytes (Uint8Array)\n *\n * @param {string} str hex-string\n * @returns {Uint8Array} array containing the converted elements\n * @throws str must be a hex-string\n * @example\n * ```typescript\n * let result;\n *\n * result = hexToBytes('0x64');\n * // result = [100]\n *\n * result = hexToBytes('test');\n * // throws Error: test needs to be a hex-string\n * ```\n */\nexport function hexToBytes(str: string): Uint8Array {\n  if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n\n  let adaptedValue: string = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return hexToBytesNoble(adaptedValue);\n}\n\n/**\n * Adds a percentage amount to the value\n *\n * @param number value to be modified\n * @param percent integer as percent ex. 50 for 50%\n * @returns {bigint} modified value\n * @example\n * ```typescript\n * addPercent(100, 50); // 150n\n * addPercent(100, 100); // 200n\n * addPercent(200, 50); // 300n\n * addPercent(200, -50); // 100n\n * addPercent(200, -100); // 0n\n * addPercent(200, -150); // -100n\n * ```\n */\nexport function addPercent(number: BigNumberish, percent: number): bigint {\n  const bigIntNum = BigInt(number);\n  return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;\n}\n\n/**\n * Calculate the sha256 hash of an utf8 string, then encode the\n * result in an uint8Array of 4 elements.\n * Useful in wallet path calculation.\n * @param {string} str utf8 string (hex string not handled).\n * @returns a uint8Array of 4 bytes.\n * @example\n * ```typescript\n * const ledgerPathApplicationName = 'LedgerW';\n * const path2Buffer = num.stringToSha256ToArrayBuff4(ledgerPathApplicationName);\n * // path2Buffer = Uint8Array(4) [43, 206, 231, 219]\n * ```\n */\nexport function stringToSha256ToArrayBuff4(str: string): Uint8Array {\n  // eslint-disable-next-line no-bitwise\n  const int31 = (n: bigint) => Number(n & MASK_31);\n  const result: number = int31(BigInt(addHexPrefix(buf2hex(sha256(str)))));\n  return hexToBytes(toHex(result));\n}\n\n/**\n * Checks if a given value is of BigNumberish type.\n * 234, 234n, \"234\", \"0xea\" are valid, exclude boolean and string\n * @param {unknown} input a value\n * @returns {boolean} true if type of input is `BigNumberish`\n * @example\n * ```typescript\n * const res = num.isBigNumberish(\"ZERO\");\n * // res = false\n *  ```\n */\nexport function isBigNumberish(input: unknown): input is BigNumberish {\n  return (\n    isNumber(input) ||\n    isBigInt(input) ||\n    (isString(input) && (isHex(input) || isStringWholeNumber(input)))\n  );\n}\n\n/**\n * Expect the next value from an iterator\n *\n * @param iterator The iterator to get the next value from.\n * @returns The next value from the iterator.\n * @throws Error if the iterator is done.\n */\nexport function getNext(iterator: Iterator<string>): string {\n  const it = iterator.next();\n  if (it.done) throw new Error('Unexpected end of response');\n  return it.value;\n}\n","/**\n * Check if a value is a undefined.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} Returns true if the value is a undefined, otherwise returns false.\n * @example\n * ```typescript\n * const result = isUndefined(undefined);\n * // result = true\n *\n * const result2 = isUndefined('existing value');\n * // result2 = false\n * ```\n * @return {boolean} Returns true if the value is undefined, otherwise returns false.\n */\nexport const isUndefined = (value: unknown): value is undefined => {\n  return typeof value === 'undefined' || value === undefined;\n};\n\n/**\n * Check if a value is a number.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = isNumber(123);\n * // result = true\n *\n * const result2 = isNumber(\"123\");\n * // result2 = false\n * ```\n * @return {boolean} Returns true if the value is a number, otherwise returns false.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\n/**\n * Checks if a given value is of boolean type.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} - True if the value is of boolean type, false otherwise.\n * @example\n * ```typescript\n * const result = isBoolean(true);\n * // result = true\n *\n * const result2 = isBoolean(false);\n * // result2 = false\n * ```\n * @return {boolean} - True if the value is of boolean type, false otherwise.\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n\n/**\n * Test if value is bigint\n *\n * @param value value to test\n * @returns {boolean} true if value is bigint, false otherwise\n * @example\n * ```typescript\n * isBigInt(10n); // true\n * isBigInt(BigInt('10')); // true\n * isBigInt(10); // false\n * isBigInt('10'); // false\n * isBigInt(null); // false\n * ```\n */\nexport function isBigInt(value: any): value is bigint {\n  return typeof value === 'bigint';\n}\n\n/**\n * Checks if a given value is a string.\n * @param {unknown} value the value to be checked.\n * @return {boolean} returns true if the value is a string, false otherwise.\n * @example\n * ```typescript\n * const result = shortString.isString(\"12345\");\n * // result = true\n * ```\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Check if a value is a Buffer.\n *\n * @param {unknown} obj - The value to check.\n * @returns {boolean} Returns true if the value is a Buffer, otherwise returns false.\n * @example\n * ```typescript\n * const result = isBuffer(Buffer.from([1, 2, 3]));\n */\nexport function isBuffer(obj: unknown): obj is Buffer {\n  return typeof Buffer !== 'undefined' && obj instanceof Buffer;\n}\n\n/**\n * Checks if a given value is an object (Object or Array)\n * @param {unknown} item the tested item\n * @returns {boolean}\n * @example\n * ```typescript\n * const result = events.isObject({event: \"pending\"});\n * // result = true\n * ```\n */\nexport function isObject(item: unknown | undefined): item is object {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n\n/**\n * Checks if a given value is an integer.\n * @param {unknown} value the value to be checked.\n * @returns {boolean} returns true if the value is an integer, false otherwise.\n */\nexport function isInteger(value: unknown): value is number {\n  return Number.isInteger(value);\n}\n","import { keccak } from '@scure/starknet';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport { bytesToHex } from '@noble/curves/abstract/utils';\nimport { MASK_250 } from '../../global/constants';\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, removeHexPrefix, utf8ToArray } from '../encode';\nimport { hexToBytes, isHex, isStringWholeNumber, toHex } from '../num';\nimport { isBigInt, isNumber } from '../typed';\n\n/**\n * Calculate the hex-string Starknet Keccak hash for a given BigNumberish\n *\n * @param value value to hash\n * @returns hex-string Keccak hash\n * @example\n * ```typescript\n * const result = keccakBn('0xabc');\n * // result = '0x11cf08aac85935e32397f410e48217a127b6855d41b1e3877eb4179c0904b77'\n * ```\n */\nexport function keccakBn(value: BigNumberish): string {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix(keccak(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\n\n/**\n * [internal]\n * Calculate hex-string Starknet Keccak hash for a given string\n *\n * String -> hex-string Keccak hash\n * @returns format: hex-string\n */\nfunction keccakHex(str: string): string {\n  return addHexPrefix(keccak(utf8ToArray(str)).toString(16));\n}\n\n/**\n * Calculate the BigInt Starknet Keccak hash for a given string\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L38)\n *\n * @param str value to hash\n * @returns BigInt Keccak hash\n * @example\n * ```typescript\n * const result = starknetKeccak('test').toString();\n * // result = '61835310290161785288773114225739080147441215596947647498723774891619563096'\n * ```\n */\nexport function starknetKeccak(str: string): bigint {\n  const hash = BigInt(keccakHex(str));\n  // eslint-disable-next-line no-bitwise\n  return hash & MASK_250;\n}\n\n/**\n * Calculate the hex-string selector for a given abi function name\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L46)\n *\n * @param funcName abi function name\n * @returns hex-string selector\n * @example\n * ```typescript\n * const result = getSelectorFromName('myFunction');\n * // result = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n * ```\n */\nexport function getSelectorFromName(funcName: string) {\n  // sometimes BigInteger pads the hex string with zeros, which is not allowed in the starknet api\n  return toHex(starknetKeccak(funcName));\n}\n\n/**\n * Calculate the hex-string selector from a given abi function name or of any representation of number.\n *\n * @param value ascii-string | hex-string | dec-string | number | BigInt\n * @returns hex-string selector\n * @example\n * ```typescript\n * const selector1: string = getSelector(\"myFunction\");\n * // selector1 = \"0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8\"\n *\n * const selector2: string = getSelector(\"0x123abc\");\n * // selector2 = \"0x123abc\"\n *\n * const selector3: string = getSelector(\"123456\");\n * // selector3 = \"0x1e240\"\n *\n * const selector4: string = getSelector(123456n);\n * // selector4 = \"0x1e240\"\n * ```\n */\nexport function getSelector(value: string | BigNumberish) {\n  if (isNumber(value) || isBigInt(value)) return toHex(value);\n  if (isHex(value)) return value;\n  if (isStringWholeNumber(value)) return toHex(value);\n  return getSelectorFromName(value);\n}\n\n/**\n * Solidity hash of an array of uint256\n * @param {BigNumberish[]} params an array of uint256 numbers\n * @returns the hash of the array of Solidity uint256\n * @example\n * ```typescript\n * const result = hash.solidityUint256PackedKeccak256(['0x100', '200', 300, 400n]);\n * // result = '0xd1e6cb422b65269603c491b0c85463295edabebfb2a6844e4fdc389ff1dcdd97'\n * ```\n */\nexport function solidityUint256PackedKeccak256(params: BigNumberish[]): string {\n  const myEncode = addHexPrefix(\n    params.reduce(\n      (res: string, par: BigNumberish) => res + removeHexPrefix(toHex(par)).padStart(64, '0'),\n      ''\n    )\n  );\n  return addHexPrefix(bytesToHex(keccak_256(hexToBytes(myEncode))));\n}\n\n/**\n * Calculate the message hash related by a message L1->L2\n * @param {BigNumberish} l1FromAddress L1 account address that paid the message.\n * @param {BigNumberish} l2ToAddress L2 contract address to execute.\n * @param {string | BigNumberish} l2Selector can be a function name (\"bridge_withdraw\") or a number (BigNumberish).\n * @param {RawCalldata} l2Calldata an array of BigNumberish of the raw parameters passed to the above function.\n * @param {BigNumberish} l1Nonce The nonce of the L1 account.\n * @returns {string} hex-string of the L2 transaction hash\n * @example\n * ```typescript\n * const l1FromAddress = \"0x0000000000000000000000008453fc6cd1bcfe8d4dfc069c400b433054d47bdc\";\n * const l2ToAddress = 2158142789748719025684046545159279785659305214176670733242887773692203401023n;\n * const l2Selector = 774397379524139446221206168840917193112228400237242521560346153613428128537n;\n * const payload = [\n *     4543560n,\n *    829565602143178078434185452406102222830667255948n,\n *     3461886633118033953192540141609307739580461579986333346825796013261542798665n,\n *     9000000000000000n,\n *     0n,\n * ];\n * const l1Nonce = 8288n;\n * const result = hash.getL2MessageHash(l1FromAddress, l2ToAddress, l2Selector, payload, l1Nonce);\n * // result = \"0x2e350fa9d830482605cb68be4fdb9f0cb3e1f95a0c51623ac1a5d1bd997c2090\"\n * ```\n */\nexport function getL2MessageHash(\n  l1FromAddress: BigNumberish,\n  l2ToAddress: BigNumberish,\n  l2Selector: string | BigNumberish,\n  l2Calldata: BigNumberish[],\n  l1Nonce: BigNumberish\n): string {\n  return solidityUint256PackedKeccak256([\n    l1FromAddress,\n    l2ToAddress,\n    l1Nonce,\n    l2Selector,\n    l2Calldata.length,\n    ...l2Calldata,\n  ]);\n}\n\n/**\n * Calculate the message hash related by a message L2->L1.\n * @param {BigNumberish} fromL2Address L2 contract address that send the message.\n * @param {BigNumberish} toL1Address Recipient L1 account address.\n * @param {BigNumberish[]} payload an array of BigNumberish of the raw parameters passed to the message.\n * @returns {string} hex-string of the message hash.\n * @example\n * ```typescript\n * const fromL2Address = '0x04c5772d1914fe6ce891b64eb35bf3522aeae1315647314aac58b01137607f3f';\n *   const toL1Address = '0x8453fc6cd1bcfe8d4dfc069c400b433054d47bdc';\n *   const payload = [\n *     0n,\n *     1270393329865452722422775477982592488490549769359n,\n *    4543560n,\n *     200000000000000,\n *    0n,\n *   ];\n *   const result = hash.getL1MessageHash(fromL2Address, toL1Address, payload);\n * // result = \"0x2eace1d0ab5dbe354a93fb0a59c6b98f26e6a0fe7c33f87329f8fc9829058b8b\"\n * ```\n */\nexport function getL1MessageHash(\n  fromL2Address: BigNumberish,\n  toL1Address: BigNumberish,\n  payload: BigNumberish[]\n): string {\n  return solidityUint256PackedKeccak256([fromL2Address, toL1Address, payload.length, ...payload]);\n}\n","import { TEXT_TO_FELT_MAX_LEN } from '../global/constants';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { isHex, isStringWholeNumber } from './num';\nimport { isString } from './typed';\n\n/**\n * Test if string contains only ASCII characters (string can be ascii text)\n * @param {string} str The string to test\n * @returns {boolean} Returns true if the string contains only ASCII characters, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isASCII(\"Hello, world!\");\n * // result = true\n * const result = shortString.isASCII(\"Hello, 世界!\");\n * // result = false\n * ```\n */\nexport function isASCII(str: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\n/**\n * Test if a string is a Cairo short string (string with less or equal 31 characters)\n * @param {string} str the string to test\n * @returns {boolean} Returns true if the string has less than or equal to 31 characters, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isShortString(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport function isShortString(str: string): boolean {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\n\n/**\n * Test if string contains only numbers (string can be converted to decimal integer number)\n * @param {string} str the string to test.\n * @returns {boolean} Returns true if the string contains only numbers, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isDecimalString(\"12345\");\n * // result = true\n * const result = shortString.isDecimalString(\"12a45\");\n * // result = false\n * ```\n */\nexport function isDecimalString(str: string): boolean {\n  return /^[0-9]*$/i.test(str);\n}\n\n/**\n * Test if value is a pure string text, and not a hex string or number string\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a free-form string text, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isText(\"Hello, world!\");\n * // result = true\n * const result = shortString.isText(\"0x7aec92f706\");\n * // result = false\n * ```\n */\nexport function isText(val: any): val is string {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\n\n/**\n * Test if value is short text\n * @param {any} val - The item to test\n * @returns {boolean} Returns true if the value is a short text (string has less or equal 31 characters), otherwise false\n * @example\n * ```typescript\n * const result = shortString.isShortText(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport const isShortText = (val: any): boolean => isText(val) && isShortString(val);\n\n/**\n * Test if value is long text\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a long text(string has more than 31 characters), otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isLongText(\"Hello, world! this is some random long string to enable you test isLongText function.\");\n * // result = true\n * ```\n */\nexport const isLongText = (val: any): boolean => isText(val) && !isShortString(val);\n\n/**\n * Split long text (string greater than 31 characters) into short strings (string lesser or equal 31 characters)\n * @param {string} longStr the long text (string greater than 31 characters) to split\n * @returns {string[]} an array of short strings (string lesser or equal 31 characters).\n * @example\n * ```typescript\n * const result = shortString.splitLongString(\"Hello, world! we just testing splitLongString function.\");\n * // result = [ 'Hello, world! we just testing s', 'plitLongString function.' ]\n * ```\n */\nexport function splitLongString(longStr: string): string[] {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, 'g');\n  return longStr.match(regex) || [];\n}\n\n/**\n * @deprecated use Utf8 instead\n * Convert an ASCII short string to a hexadecimal string.\n * @param {string} str short string (ASCII string, 31 characters max)\n * @returns {string} hex-string with 248 bits max\n * @example\n * ```typescript\n * const result = shortString.encodeShortString(\"uri/pict/t38.jpg\");\n * // result = \"0x7572692f706963742f7433382e6a7067\"\n * ```\n */\nexport function encodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\n\n/**\n * @deprecated use Utf8 instead\n * Convert a hexadecimal or decimal string to an ASCII string.\n * @param {string} str representing a 248 bit max number (ex. \"0x1A4F64EA56\" or \"236942575435676423\")\n * @returns {string} short string; 31 characters max\n * @example\n * ```typescript\n * const result = shortString.decodeShortString(\"0x7572692f706963742f7433382e6a7067\");\n * // result = \"uri/pict/t38.jpg\"\n * ```\n */\nexport function decodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString('0X'.concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n","import { BigNumberish, ByteArray } from '../../types/lib';\nimport { toHex } from '../num';\nimport { decodeShortString, encodeShortString, splitLongString } from '../shortString';\n\n/**\n * convert a Cairo ByteArray to a JS string\n * @param myByteArray Cairo representation of a LongString\n * @returns a JS string\n * @example\n * ```typescript\n * const myByteArray = {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI\n * ```\n */\nexport function stringFromByteArray(myByteArray: ByteArray): string {\n  const pending_word: string =\n    BigInt(myByteArray.pending_word) === 0n\n      ? ''\n      : decodeShortString(toHex(myByteArray.pending_word));\n  return (\n    myByteArray.data.reduce<string>((cumuledString, encodedString: BigNumberish) => {\n      const add: string =\n        BigInt(encodedString) === 0n ? '' : decodeShortString(toHex(encodedString));\n      return cumuledString + add;\n    }, '') + pending_word\n  );\n}\n\n/**\n * convert a JS string to a Cairo ByteArray\n * @param targetString a JS string\n * @returns Cairo representation of a LongString\n * @example\n * ```typescript\n * const myByteArray: ByteArray = byteArrayFromString(\"ABCDEFGHI\");\n * ```\n * Result is :\n * {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n */\nexport function byteArrayFromString(targetString: string): ByteArray {\n  const shortStrings: string[] = splitLongString(targetString);\n  const remainder: string = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded: BigNumberish[] = shortStrings.map(encodeShortString);\n\n  const [pendingWord, pendingWordLength] =\n    remainder === undefined || remainder.length === 31\n      ? ['0x00', 0]\n      : [shortStringsEncoded.pop()!, remainder.length];\n\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength,\n  };\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  ContractVersion,\n  ETH_ADDRESS,\n  Int,\n  Literal,\n  NON_ZERO_PREFIX,\n  Uint,\n  Uint256,\n  Uint512,\n} from '../../types';\nimport { CairoFelt } from '../cairoDataTypes/felt';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\n\n// Intended for internal usage, maybe should be exported somewhere else and not exported to utils\n/**\n * Checks if the given name ends with \"_len\".\n *\n * @param {string} name - The name to be checked.\n * @returns - True if the name ends with \"_len\", false otherwise.\n */\nexport const isLen = (name: string) => /_len$/.test(name);\n/**\n * Checks if a given type is felt.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is felt, false otherwise.\n */\nexport const isTypeFelt = (type: string) => type === 'felt' || type === 'core::felt252';\n/**\n * Checks if the given type is an array type.\n *\n * @param {string} type - The type to check.\n * @returns - `true` if the type is an array type, `false` otherwise.\n */\nexport const isTypeArray = (type: string) =>\n  /\\*/.test(type) ||\n  type.startsWith('core::array::Array::') ||\n  type.startsWith('core::array::Span::');\n\n/**\n * Checks if the given type is a tuple type.\n *\n * @param {string} type - The type to be checked.\n * @returns - `true` if the type is a tuple type, otherwise `false`.\n */\nexport const isTypeTuple = (type: string) => /^\\(.*\\)$/i.test(type);\n/**\n * Checks whether a given type is a named tuple.\n *\n * @param {string} type - The type to be checked.\n * @returns - True if the type is a named tuple, false otherwise.\n */\nexport const isTypeNamedTuple = (type: string) => /\\(.*\\)/i.test(type) && type.includes(':');\n/**\n * Checks if a given type is a struct.\n *\n * @param {string} type - The type to check for existence.\n * @param {AbiStructs} structs - The collection of structs to search in.\n * @returns - True if the type exists in the structs, false otherwise.\n */\nexport const isTypeStruct = (type: string, structs: AbiStructs) => type in structs;\n/**\n * Checks if a given type is an enum.\n *\n * @param {string} type - The type to check.\n * @param {AbiEnums} enums - The enumeration to search in.\n * @returns - True if the type exists in the enumeration, otherwise false.\n */\nexport const isTypeEnum = (type: string, enums: AbiEnums) => type in enums;\n/**\n * Determines if the given type is an Option type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is an Option type, false otherwise.\n */\nexport const isTypeOption = (type: string) => type.startsWith('core::option::Option::');\n/**\n * Checks whether a given type starts with 'core::result::Result::'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type starts with 'core::result::Result::', false otherwise.\n */\nexport const isTypeResult = (type: string) => type.startsWith('core::result::Result::');\n/**\n * Checks if the given value is a valid Uint type.\n *\n * @param {string} type - The value to check.\n * @returns - Returns true if the value is a valid Uint type, otherwise false.\n */\nexport const isTypeUint = (type: string) => Object.values(Uint).includes(type as Uint);\n/**\n * Checks if the given value is a valid Int type.\n *\n * @param {string} type - The value to check.\n * @returns - Returns true if the value is a valid Int type, otherwise false.\n */\nexport const isTypeInt = (type: string) => Object.values(Int).includes(type as Int);\n// Legacy Export\n/**\n * Checks if the given type is `uint256`.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is `uint256`, otherwise false.\n */\nexport const isTypeUint256 = (type: string) => CairoUint256.isAbiType(type);\n/**\n * Checks if the given type is a literal type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is a literal type, false otherwise.\n */\nexport const isTypeLiteral = (type: string) => Object.values(Literal).includes(type as Literal);\n/**\n * Checks if the given type is a boolean type.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is a boolean type, otherwise false.\n */\nexport const isTypeBool = (type: string) => type === 'core::bool';\n/**\n * Checks if the provided type is equal to 'core::starknet::contract_address::ContractAddress'.\n * @param {string} type - The type to be checked.\n * @returns - true if the type matches 'core::starknet::contract_address::ContractAddress', false otherwise.\n */\nexport const isTypeContractAddress = (type: string) => type === Literal.ContractAddress;\n/**\n * Determines if the given type is an Ethereum address type.\n *\n * @param {string} type - The type to check.\n * @returns - Returns true if the given type is 'core::starknet::eth_address::EthAddress', otherwise false.\n */\nexport const isTypeEthAddress = (type: string) => type === ETH_ADDRESS;\n\n/**\n * Checks if the given type is equal to the u96 type\n *\n * @param {string} type - The type to check.\n * @returns - True if the given type is equal to u96, false otherwise.\n */\nexport const isTypeU96 = (type: string) =>\n  type === 'core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>';\n\nexport const isTypeSecp256k1Point = (type: string) => type === Literal.Secp256k1Point;\n\nexport const isCairo1Type = (type: string) => type.includes('::');\n/**\n * Retrieves the array type from the given type string.\n *\n * Works also for core::zeroable::NonZero type.\n * @param {string} type - The type string.\n * @returns - The array type.\n */\nexport const getArrayType = (type: string) => {\n  return isCairo1Type(type)\n    ? type.substring(type.indexOf('<') + 1, type.lastIndexOf('>'))\n    : type.replace('*', '');\n};\n\n/**\n * Test if an ABI comes from a Cairo 1 contract\n * @param abi representing the interface of a Cairo contract\n * @returns TRUE if it is an ABI from a Cairo1 contract\n * @example\n * ```typescript\n * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);\n * ```\n */\nexport function isCairo1Abi(abi: Abi): boolean {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === undefined) {\n    throw Error('Unable to determine Cairo version');\n  }\n  return cairo === '1';\n}\n\n/**\n * Checks if the given type is a NonZero type.\n *\n * @param {string} type The type to check.\n * @returns `true` if the type is NonZero type, `false` otherwise.\n * @example\n * ```typescript\n * const result = cairo.isTypeNonZero(\"core::zeroable::NonZero::<u8>\");\n * //result = true\n * ```\n */\nexport function isTypeNonZero(type: string): boolean {\n  return type.startsWith(NON_ZERO_PREFIX);\n}\n\n/**\n * Return ContractVersion (Abi version) based on Abi\n * or undefined for unknown version\n * @param abi\n * @returns string\n */\nexport function getAbiContractVersion(abi: Abi): ContractVersion {\n  // determine by interface for \"Cairo 1.2\"\n  if (abi.find((it) => it.type === 'interface')) {\n    return { cairo: '1', compiler: '2' };\n  }\n\n  // determine by function io types \"Cairo 1.1\" or \"Cairo 0.0\"\n  // find first function with inputs or outputs\n  const testSubject = abi.find(\n    (it) =>\n      (it.type === 'function' || it.type === 'constructor') &&\n      (it.inputs.length || it.outputs.length)\n  );\n\n  if (!testSubject) {\n    return { cairo: undefined, compiler: undefined };\n  }\n  const io = testSubject.inputs.length ? testSubject.inputs : testSubject.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: '1', compiler: '1' };\n  }\n  return { cairo: '0', compiler: '0' };\n}\n\n/**\n * named tuple cairo type is described as js object {}\n * struct cairo type are described as js object {}\n * array cairo type are described as js array []\n */\n\n/**\n * Create Uint256 Cairo type (helper for common struct type)\n * @example\n * ```typescript\n * uint256('892349863487563453485768723498');\n * ```\n */\nexport const uint256 = (it: BigNumberish): Uint256 => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\n\n/**\n * Create Uint512 Cairo type (helper for common struct type)\n * @param it BigNumberish representation of a 512 bits unsigned number\n * @returns Uint512 struct\n * @example\n * ```typescript\n * uint512('345745685892349863487563453485768723498');\n * ```\n */\nexport const uint512 = (it: BigNumberish): Uint512 => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\n\n/**\n * Create unnamed tuple Cairo type (helper same as common struct type)\n * @example\n * ```typescript\n * tuple(1, '0x101', 16);\n * ```\n */\nexport const tuple = (\n  ...args: (BigNumberish | object | boolean)[]\n): Record<number, BigNumberish | object | boolean> => ({ ...args });\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function felt(it: BigNumberish): string {\n  return CairoFelt(it);\n}\n","/**\n * Adds a non-enumerable __compiled__ property to an array to mark it as compiled for API requests\n * @param compiled - The string array to mark as compiled\n * @returns The same array with __compiled__ property added\n */\nexport function addCompiledFlag<T extends string[]>(compiled: T): T {\n  Object.defineProperty(compiled, '__compiled__', {\n    enumerable: false,\n    writable: false,\n    value: true,\n  });\n  return compiled;\n}\n","/* eslint-disable no-underscore-dangle */\n// TODO Convert to CairoFelt base on CairoUint256 and implement it in the codebase in the backward compatible manner\n\nimport { BigNumberish } from '../../types';\nimport { PRIME } from '../../global/constants';\nimport { getNext, isHex, isStringWholeNumber } from '../num';\nimport { encodeShortString, isShortString, isText } from '../shortString';\nimport { isBoolean, isString, isBigInt, isNumber } from '../typed';\nimport {\n  stringToUint8Array,\n  bigIntToUint8Array,\n  uint8ArrayToBigInt,\n  addHexPrefix,\n} from '../encode';\nimport assert from '../assert';\nimport { addCompiledFlag } from '../helpers';\n\n/**\n * @deprecated use the CairoFelt252 class instead, this one is limited to ASCII strings\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function CairoFelt(it: BigNumberish): string {\n  // BN or number\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n\n  // Handling strings\n  if (isString(it)) {\n    // Hex strings\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    // Text strings that must be short\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      // Assuming encodeShortString returns a hex representation of the string\n      return BigInt(encodeShortString(it)).toString();\n    }\n    // Whole numeric strings\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  // bool to felt\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n/**\n * felt252 is the basic field element used in Cairo.\n * It corresponds to an integer in the range 0 ≤ x < P where P is a very large prime number currently equal to 2^251 + 17⋅2^192 + 1.\n * Any operation that uses felt252 will be computed modulo P.\n * 63 hex symbols (31 bytes + 4 bits), 252 bits\n */\nexport class CairoFelt252 {\n  /**\n   * byte representation of the felt252\n   */\n  data: Uint8Array;\n\n  static abiSelector = 'core::felt252' as const;\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoFelt252.validate(data);\n    this.data = CairoFelt252.__processData(data as BigNumberish | boolean);\n  }\n\n  static __processData(data: BigNumberish | boolean): Uint8Array {\n    if (isString(data)) {\n      return stringToUint8Array(data);\n    }\n    if (isBigInt(data)) {\n      return bigIntToUint8Array(data);\n    }\n    if (Number.isInteger(data)) {\n      return bigIntToUint8Array(BigInt(data));\n    }\n    if (isBoolean(data)) {\n      return bigIntToUint8Array(BigInt(data ? 1 : 0));\n    }\n    throw new Error(`${data} can't be computed by felt()`);\n  }\n\n  toBigInt() {\n    return uint8ArrayToBigInt(this.data);\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(this.data);\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  toApiRequest(): string[] {\n    /**\n     * HexString representation of the felt252\n     */\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null, 'null value is not allowed for felt252');\n    assert(data !== undefined, 'undefined value is not allowed for felt252');\n    assert(\n      isString(data) || isNumber(data) || isBigInt(data) || isBoolean(data),\n      `Unsupported data type '${typeof data}' for felt252. Expected string, number, bigint, or boolean`\n    );\n\n    const value = CairoFelt252.__processData(data as BigNumberish | boolean);\n    const bn = uint8ArrayToBigInt(value);\n    assert(bn >= 0n && bn < PRIME, `Value ${value} is out of felt252 range [0, ${PRIME})`);\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoFelt252.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoFelt252.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoFelt252 {\n    /**\n     * The API response is HexString\n     */\n    return new CairoFelt252(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u256 data type\n */\n\nimport { BigNumberish, Uint256 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\nimport { isObject } from '../typed';\nimport { getNext, isBigNumberish } from '../num';\nimport assert from '../assert';\n\nexport const UINT_128_MAX = (1n << 128n) - 1n;\nexport const UINT_256_MAX = (1n << 256n) - 1n;\nexport const UINT_256_MIN = 0n;\nexport const UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_LOW_MIN = 0n;\nexport const UINT_256_HIGH_MIN = 0n;\n\nexport class CairoUint256 {\n  public low: bigint; // TODO should be u128\n\n  public high: bigint; // TODO should be u128\n\n  static abiSelector = 'core::integer::u256' as const;\n\n  /**\n   * Default constructor (Lib usage)\n   */\n  public constructor(data: BigNumberish | Uint256 | unknown);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(low: BigNumberish, high: BigNumberish);\n  public constructor(...arr: any[]) {\n    if (isObject(arr[0]) && arr.length === 1 && 'low' in arr[0] && 'high' in arr[0]) {\n      const props = CairoUint256.validateProps(\n        arr[0].low as BigNumberish,\n        arr[0].high as BigNumberish\n      );\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error('Incorrect constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish: BigNumberish | unknown) {\n    assert(bigNumberish !== null, 'null value is not allowed for u256');\n    assert(bigNumberish !== undefined, 'undefined value is not allowed for u256');\n    assert(\n      isBigNumberish(bigNumberish) || isObject(bigNumberish),\n      `Unsupported data type '${typeof bigNumberish}' for u256. Expected string, number, bigint, or Uint256 object`\n    );\n\n    const bigInt = BigInt(bigNumberish as BigNumberish);\n    assert(bigInt >= UINT_256_MIN, 'bigNumberish is smaller than UINT_256_MIN');\n    assert(bigInt <= UINT_256_MAX, 'bigNumberish is bigger than UINT_256_MAX');\n    return bigInt;\n  }\n\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low: BigNumberish, high: BigNumberish) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    assert(\n      bigIntLow >= UINT_256_LOW_MIN && bigIntLow <= UINT_256_LOW_MAX,\n      'low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX'\n    );\n    assert(\n      bigIntHigh >= UINT_256_HIGH_MIN && bigIntHigh <= UINT_256_HIGH_MAX,\n      'high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX'\n    );\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish: BigNumberish | unknown) {\n    try {\n      CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string) {\n    return abiType === CairoUint256.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>) {\n    const low = getNext(responseIterator);\n    const high = getNext(responseIterator);\n    return new CairoUint256(low, high);\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u512 data type\n */\n\nimport { BigNumberish, type Uint512 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\nimport { UINT_128_MAX } from './uint256';\nimport { isObject } from '../typed';\nimport { getNext, isBigNumberish } from '../num';\nimport assert from '../assert';\n\nexport const UINT_512_MAX = (1n << 512n) - 1n;\nexport const UINT_512_MIN = 0n;\nexport const UINT_128_MIN = 0n;\n\nexport class CairoUint512 {\n  public limb0: bigint; // TODO should be u128\n\n  public limb1: bigint; // TODO should be u128\n\n  public limb2: bigint; // TODO should be u128\n\n  public limb3: bigint; // TODO should be u128\n\n  static abiSelector = 'core::integer::u512';\n\n  /**\n   * Default constructor (Lib usage)\n   */\n  public constructor(bigNumberish: BigNumberish | Uint512 | unknown);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  );\n  public constructor(...arr: any[]) {\n    if (\n      isObject(arr[0]) &&\n      arr.length === 1 &&\n      'limb0' in arr[0] &&\n      'limb1' in arr[0] &&\n      'limb2' in arr[0] &&\n      'limb3' in arr[0]\n    ) {\n      const props = CairoUint512.validateProps(\n        arr[0].limb0 as BigNumberish,\n        arr[0].limb1 as BigNumberish,\n        arr[0].limb2 as BigNumberish,\n        arr[0].limb3 as BigNumberish\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & (UINT_128_MAX << 128n)) >> 128n;\n      this.limb2 = (bigInt & (UINT_128_MAX << 256n)) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error('Incorrect Uint512 constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish: BigNumberish | unknown): bigint {\n    assert(bigNumberish !== null, 'null value is not allowed for u512');\n    assert(bigNumberish !== undefined, 'undefined value is not allowed for u512');\n    assert(\n      isBigNumberish(bigNumberish) || isObject(bigNumberish),\n      `Unsupported data type '${typeof bigNumberish}' for u512. Expected string, number, bigint, or Uint512 object`\n    );\n\n    const bigInt = BigInt(bigNumberish as BigNumberish);\n    assert(bigInt >= UINT_512_MIN, 'bigNumberish is smaller than UINT_512_MIN.');\n    assert(bigInt <= UINT_512_MAX, 'bigNumberish is bigger than UINT_512_MAX.');\n    return bigInt;\n  }\n\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  ): { limb0: bigint; limb1: bigint; limb2: bigint; limb3: bigint } {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value: bigint, index) => {\n      assert(\n        value >= UINT_128_MIN && value <= UINT_128_MAX,\n        `limb${index} is not in the range of a u128 number`\n      );\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish: BigNumberish | unknown): boolean {\n    try {\n      CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint512.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>) {\n    const limb0 = getNext(responseIterator);\n    const limb1 = getNext(responseIterator);\n    const limb2 = getNext(responseIterator);\n    const limb3 = getNext(responseIterator);\n    return new CairoUint512(limb0, limb1, limb2, limb3);\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt(): bigint {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest(): string[] {\n    // lower limb first : https://github.com/starkware-libs/cairo/blob/07484c52791b76abcc18fd86265756904557d0d2/corelib/src/test/integer_test.cairo#L767\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3),\n    ];\n  }\n}\n","import { isUndefined } from '../../typed';\n\nexport type CairoEnumRaw = Record<string, any>;\n\n/**\n * Class to handle Cairo custom Enum\n * @param enumContent object containing the variants and its content. Example :\n *  {Success: 234, Warning: undefined, Error: undefined}.\n *  Only one variant with a value, object, array.\n * @returns an instance representing a Cairo custom Enum.\n * @example\n * ```typescript\n * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: \"0x7f32ea\", Error: undefined})\n * ```\n */\nexport class CairoCustomEnum {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  readonly variant: CairoEnumRaw;\n\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent: CairoEnumRaw) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error('This Enum must have at least 1 variant');\n    }\n    const nbActiveVariants = variantsList.filter((content) => !isUndefined(content)).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error('This Enum must have exactly one active variant');\n    }\n    this.variant = enumContent;\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  public unwrap(): any {\n    const variants = Object.values(this.variant);\n    return variants.find((item) => !isUndefined(item));\n  }\n\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  public activeVariant(): string {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => !isUndefined(item[1]));\n    return isUndefined(activeVariant) ? '' : activeVariant[0];\n  }\n}\n","import { ValuesType } from '../../../types/helpers/valuesType';\nimport { isUndefined } from '../../typed';\n\nexport const CairoOptionVariant = {\n  Some: 0,\n  None: 1,\n} as const;\n\nexport type CairoOptionVariant = ValuesType<typeof CairoOptionVariant>;\n\n/**\n * Class to handle Cairo Option\n * @param variant CairoOptionVariant.Some or CairoOptionVariant.None\n * @param content value of type T.\n * @returns an instance representing a Cairo Option.\n * @example\n * ```typescript\n * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, \"0x54dda8\");\n * ```\n */\nexport class CairoOption<T> {\n  readonly Some?: T;\n\n  readonly None?: boolean;\n\n  constructor(variant: CairoOptionVariant | number, content?: T) {\n    if (!(variant in Object.values(CairoOptionVariant))) {\n      throw new Error('Wrong variant! It should be CairoOptionVariant.Some or .None.');\n    }\n    if (variant === CairoOptionVariant.Some) {\n      if (isUndefined(content)) {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = content;\n      this.None = undefined;\n    } else {\n      this.Some = undefined;\n      this.None = true;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  public unwrap(): T | undefined {\n    return this.None ? undefined : this.Some;\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  public isSome(): boolean {\n    return !isUndefined(this.Some);\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  public isNone(): boolean {\n    return this.None === true;\n  }\n}\n","import { ValuesType } from '../../../types/helpers/valuesType';\nimport { isUndefined } from '../../typed';\n\nexport const CairoResultVariant = {\n  Ok: 0,\n  Err: 1,\n} as const;\n\nexport type CairoResultVariant = ValuesType<typeof CairoResultVariant>;\n\n/**\n * Class to handle Cairo Result\n * @param variant CairoResultVariant.Ok or CairoResultVariant.Err\n * @param resultContent value of type T or U.\n * @returns an instance representing a Cairo Result.\n * @example\n * ```typescript\n * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, \"0x54dda8\");\n * ```\n */\nexport class CairoResult<T, U> {\n  readonly Ok?: T;\n\n  readonly Err?: U;\n\n  constructor(variant: CairoResultVariant | number, resultContent: T | U) {\n    if (!(variant in Object.values(CairoResultVariant))) {\n      throw new Error('Wrong variant! It should be CairoResultVariant.Ok or .Err.');\n    }\n    if (variant === CairoResultVariant.Ok) {\n      this.Ok = resultContent as T;\n      this.Err = undefined;\n    } else {\n      this.Ok = undefined;\n      this.Err = resultContent as U;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  public unwrap(): T | U {\n    if (!isUndefined(this.Ok)) {\n      return this.Ok;\n    }\n    if (!isUndefined(this.Err)) {\n      return this.Err;\n    }\n    throw new Error('Both Result.Ok and .Err are undefined. Not authorized.');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  public isOk(): boolean {\n    return !isUndefined(this.Ok);\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  public isErr(): boolean {\n    return !isUndefined(this.Err);\n  }\n}\n","import { isBigInt, isObject } from '../typed';\nimport { decodeShortString } from '../shortString';\n\nconst guard = {\n  /**\n   * Checks if the data is a BigInt (BN) and throws an error if not.\n   *\n   * @param {Record<string, any>} data - The data object containing the key to check.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the data type does not match the expected BigInt (BN) type.\n   */\n  isBN: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${\n          data[key]\n        } to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  /**\n   * Throws an error for unhandled formatter types.\n   *\n   * @param {Record<string, any>} data - The data object containing the key.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the formatter encounters an unknown type.\n   */\n  unknown: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  },\n};\n\n/**\n * Formats the given data based on the provided type definition.\n *\n * @param {Record<string, any>} data - The data to be formatted.\n * @param {Record<string, any>} type - The type definition for the data.\n * @param {any} [sameType] - The same type definition to be used (optional).\n * @returns {Record<string, any>} The formatted data.\n *\n * @example\n * // Example 1: Formatting a simple object\n * const data = { value: 1n, name: 2n };\n * const type = { value: 'number', name: 'string' };\n * const formatted = formatter(data, type);\n * // formatted: { value: 1n, name: '2n' }\n *\n * @example\n * // Example 2: Formatting an object with nested structures\n * const data = { test: { id: 1n, value: 30n }, active: 1n };\n * const type = { test: { id: 'number', value: 'number' }, active: 'number' };\n * const formatted = formatter(data, type);\n * // formatted: { test: { id: 1n, value: 30n }, active: 1n }\n *\n * @example\n * // Example 3: Handling arrays in the data object\n * const data = { items: [1n, 2n, 3n], value: 4n };\n * const type = { items: ['number'], value: 'string' };\n * const formatted = formatter(data, type);\n * // formatted: { items: [1n, 2n, 3n], value: '4n' }\n */\nexport default function formatter(\n  data: Record<string, any>,\n  type: Record<string, any>,\n  sameType?: any\n): Record<string, any> {\n  // match data element with type element\n  return Object.entries(data).reduce(\n    (acc, [key, value]: [any, any]) => {\n      const elType = sameType ?? type[key];\n\n      if (!(key in type) && !sameType) {\n        // no type definition for element return original element\n        acc[key] = value;\n        return acc;\n      }\n\n      if (elType === 'string') {\n        if (Array.isArray(data[key])) {\n          // long string (felt*)\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_: any) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join('');\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === 'number') {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === 'function') {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (isObject(elType)) {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n}\n","import { Abi, AbiEntryType, FunctionAbi } from '../../../types';\n\n/**\n * Abi parser interface\n */\nexport abstract class AbiParserInterface {\n  /**\n   * Helper to calculate inputs length from abi\n   * @param abiMethod FunctionAbi\n   * @return number\n   */\n  public abstract methodInputsLength(abiMethod: FunctionAbi): number;\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public abstract getMethod(name: string): FunctionAbi | undefined;\n\n  /**\n   * Return Abi in legacy format\n   * @return Abi\n   */\n  public abstract getLegacyFormat(): Abi;\n\n  /**\n   * Get request parser for the given abi type\n   * @param abiType AbiEntryType\n   * @returns Parser function\n   */\n  public abstract getRequestParser(abiType: AbiEntryType): (val: unknown) => any;\n\n  /**\n   * Get response parser for the given abi type\n   * @param abiType AbiEntryType\n   * @returns Parser function\n   */\n  public abstract getResponseParser(\n    abiType: AbiEntryType\n  ): (responseIterator: Iterator<string>) => any;\n}\n","/* eslint-disable no-underscore-dangle */\nimport { addHexPrefix, buf2hex, stringToUint8Array, uint8ArrayToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport assert from '../assert';\nimport { addCompiledFlag } from '../helpers';\nimport { isBuffer, isString } from '../typed';\n\nexport class CairoBytes31 {\n  static MAX_BYTE_SIZE = 31 as const;\n\n  data: Uint8Array;\n\n  static abiSelector = 'core::bytes_31::bytes31' as const;\n\n  constructor(data: string | Uint8Array | Buffer | unknown) {\n    CairoBytes31.validate(data);\n    this.data = CairoBytes31.__processData(data);\n  }\n\n  static __processData(data: Uint8Array | string | Buffer | unknown): Uint8Array {\n    if (isString(data)) {\n      return stringToUint8Array(data);\n    }\n    if (isBuffer(data)) {\n      return new Uint8Array(data);\n    }\n    if (data instanceof Uint8Array) {\n      return new Uint8Array(data);\n    }\n    throw new Error('Invalid input type for CairoBytes31. Expected string, Buffer, or Uint8Array');\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return uint8ArrayToBigInt(this.data);\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(this.data);\n  }\n\n  toHexString() {\n    // TODO: revisit empty data handling for CairoBytes31 and CairoByteArray\n    // how to differentiate empty and zero input\n    const hexValue = this.data.length === 0 ? '0' : buf2hex(this.data);\n\n    return addHexPrefix(hexValue);\n  }\n\n  static validate(data: Uint8Array | string | Buffer | unknown): void {\n    const byteLength = CairoBytes31.__processData(data).length;\n    assert(\n      byteLength <= this.MAX_BYTE_SIZE,\n      `Data is too long: ${byteLength} bytes (max ${this.MAX_BYTE_SIZE} bytes)`\n    );\n  }\n\n  static is(data: Uint8Array | string | Buffer): boolean {\n    try {\n      CairoBytes31.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoBytes31.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoBytes31 {\n    return new CairoBytes31(getNext(responseIterator));\n  }\n}\n","import { RPC_ERROR_SET } from '../../types';\n\n// NOTE: generated with scripts/generateRpcErrorMap.js\nconst errorCodes: { [K in keyof RPC_ERROR_SET]: RPC_ERROR_SET[K]['code'] } = {\n  FAILED_TO_RECEIVE_TXN: 1,\n  NO_TRACE_AVAILABLE: 10,\n  CONTRACT_NOT_FOUND: 20,\n  ENTRYPOINT_NOT_FOUND: 21,\n  BLOCK_NOT_FOUND: 24,\n  INVALID_TXN_INDEX: 27,\n  CLASS_HASH_NOT_FOUND: 28,\n  TXN_HASH_NOT_FOUND: 29,\n  PAGE_SIZE_TOO_BIG: 31,\n  NO_BLOCKS: 32,\n  INVALID_CONTINUATION_TOKEN: 33,\n  TOO_MANY_KEYS_IN_FILTER: 34,\n  CONTRACT_ERROR: 40,\n  TRANSACTION_EXECUTION_ERROR: 41,\n  STORAGE_PROOF_NOT_SUPPORTED: 42,\n  CLASS_ALREADY_DECLARED: 51,\n  INVALID_TRANSACTION_NONCE: 52,\n  INSUFFICIENT_RESOURCES_FOR_VALIDATE: 53,\n  INSUFFICIENT_ACCOUNT_BALANCE: 54,\n  VALIDATION_FAILURE: 55,\n  COMPILATION_FAILED: 56,\n  CONTRACT_CLASS_SIZE_IS_TOO_LARGE: 57,\n  NON_ACCOUNT: 58,\n  DUPLICATE_TX: 59,\n  COMPILED_CLASS_HASH_MISMATCH: 60,\n  UNSUPPORTED_TX_VERSION: 61,\n  UNSUPPORTED_CONTRACT_CLASS_VERSION: 62,\n  UNEXPECTED_ERROR: 63,\n  INVALID_SUBSCRIPTION_ID: 66,\n  TOO_MANY_ADDRESSES_IN_FILTER: 67,\n  TOO_MANY_BLOCKS_BACK: 68,\n  COMPILATION_ERROR: 100,\n  INVALID_ADDRESS: 150,\n  TOKEN_NOT_SUPPORTED: 151,\n  INVALID_SIGNATURE: 153,\n  MAX_AMOUNT_TOO_LOW: 154,\n  CLASS_HASH_NOT_SUPPORTED: 155,\n  PAYMASTER_TRANSACTION_EXECUTION_ERROR: 156,\n  INVALID_TIME_BOUNDS: 157,\n  INVALID_DEPLOYMENT_DATA: 158,\n  INVALID_CLASS_HASH: 159,\n  INVALID_ID: 160,\n  UNKNOWN_ERROR: 163,\n};\nexport default errorCodes;\n","/* eslint-disable max-classes-per-file */\nimport { RPC, RPC_ERROR, RPC_ERROR_SET } from '../../types';\nimport { stringify } from '../json';\nimport rpcErrors from './rpc';\n\n// eslint-disable-next-line max-classes-per-file\nexport function fixStack(target: Error, fn: Function = target.constructor) {\n  const { captureStackTrace } = Error as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  captureStackTrace && captureStackTrace(target, fn);\n}\n\nexport function fixProto(target: Error, prototype: {}) {\n  const { setPrototypeOf } = Object as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-proto, no-param-reassign\n  setPrototypeOf ? setPrototypeOf(target, prototype) : ((target as any).__proto__ = prototype);\n}\n\n/* eslint-disable max-classes-per-file */\nexport class CustomError extends Error {\n  name!: string;\n\n  constructor(message?: string) {\n    super(message);\n    // set error name as constructor name, make it not enumerable to keep native Error behavior\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors\n    // see https://github.com/adriengibrat/ts-custom-error/issues/30\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true,\n    });\n    // fix the extended error prototype chain\n    // because typescript __extends implementation can't\n    // see https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    fixProto(this, new.target.prototype);\n    // try to remove constructor from stack trace\n    fixStack(this);\n  }\n}\n\nexport class LibraryError extends CustomError {}\n\nexport class RpcError<BaseErrorT extends RPC_ERROR = RPC_ERROR> extends LibraryError {\n  public readonly request: {\n    method: string;\n    params: any;\n  };\n\n  constructor(\n    public readonly baseError: BaseErrorT,\n    method: string,\n    params: any\n  ) {\n    // legacy message format\n    super(`RPC: ${method} with params ${stringify(params, null, 2)}\\n\n      ${baseError.code}: ${baseError.message}: ${stringify((baseError as RPC.JRPC.Error).data)}`);\n\n    this.request = { method, params };\n  }\n\n  public get code() {\n    return this.baseError.code;\n  }\n\n  /**\n   * Verifies the underlying RPC error, also serves as a type guard for the _baseError_ property\n   * @example\n   * ```typescript\n   * SomeError.isType('UNEXPECTED_ERROR');\n   * ```\n   */\n  public isType<N extends keyof RPC_ERROR_SET, C extends RPC_ERROR_SET[N]['code']>(\n    typeName: N\n  ): this is RpcError<RPC_ERROR_SET[N] & { code: C }> {\n    return rpcErrors[typeName] === this.code;\n  }\n}\n\n/**\n * Thrown when a WebSocket request does not receive a response within the configured timeout period.\n * @property {string} name - The name of the error, always 'TimeoutError'.\n */\nexport class TimeoutError extends LibraryError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Thrown when an operation is attempted on a WebSocket that is not connected.\n * @property {string} name - The name of the error, always 'WebSocketNotConnectedError'.\n */\nexport class WebSocketNotConnectedError extends LibraryError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'WebSocketNotConnectedError';\n  }\n}\n","import { LibraryError } from '../errors';\nimport { config } from '../../global/config';\n\nexport default config.get('buffer') ||\n  (typeof Buffer !== 'undefined' && Buffer) ||\n  (typeof globalThis !== 'undefined' && globalThis.Buffer) ||\n  (typeof window !== 'undefined' && (window as any).Buffer) ||\n  (typeof global !== 'undefined' && global.Buffer) ||\n  (class {\n    constructor() {\n      throw new LibraryError(\n        'Buffer not detected, use \\'config.set(\"buffer\", YourBufferPolyfill)\\' or polyfill or Node.js environment for Buffer support'\n      );\n    }\n\n    static from(_data: any): Uint8Array {\n      throw new LibraryError(\n        'Buffer not detected, use \\'config.set(\"buffer\", YourBufferPolyfill)\\' or polyfill or Node.js environment for Buffer support'\n      );\n    }\n\n    static isBuffer(obj: any): obj is Buffer {\n      const BufferImpl = config.get('buffer') || (typeof Buffer !== 'undefined' && Buffer);\n      return BufferImpl && BufferImpl.isBuffer && BufferImpl.isBuffer(obj);\n    }\n  } as unknown as typeof Buffer);\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint32 {\n  data: bigint;\n\n  static abiSelector = 'core::u32::u32';\n\n  constructor(data: BigNumberish) {\n    CairoUint32.validate(data);\n    this.data = CairoUint32.__processData(data);\n  }\n\n  static __processData(data: BigNumberish): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint32.__processData(data);\n    assert(value >= 0n && value <= 2n ** 32n - 1n, 'Value is out of u32 range [0, 2^32)');\n  }\n\n  static is(data: BigNumberish): boolean {\n    try {\n      CairoUint32.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint32.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint32 {\n    return new CairoUint32(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport assert from '../assert';\nimport {\n  addHexPrefix,\n  bigIntToUint8Array,\n  buf2hex,\n  concatenateArrayBuffer,\n  stringToUint8Array,\n} from '../encode';\nimport { getNext } from '../num';\nimport { isBigInt, isBuffer, isInteger, isNumber, isString } from '../typed';\nimport { addCompiledFlag } from '../helpers';\nimport Buffer from '../connect/buffer';\nimport { CairoBytes31 } from './bytes31';\nimport { CairoFelt252 } from './felt';\nimport { CairoUint32 } from './uint32';\n\nexport class CairoByteArray {\n  /**\n   * entire dataset\n   */\n  data: CairoBytes31[] = [];\n\n  /**\n   * cairo specific implementation helper\n   */\n  pending_word!: CairoFelt252; // felt\n\n  /**\n   * cairo specific implementation helper\n   */\n  pending_word_len!: CairoUint32; // u32\n\n  static abiSelector = 'core::byte_array::ByteArray' as const;\n\n  /**\n   * byteArray from typed components\n   */\n  public constructor(data: CairoBytes31[], pendingWord: CairoFelt252, pendingWordLen: CairoUint32);\n  public constructor(data: BigNumberish | Buffer | Uint8Array | unknown);\n  public constructor(...arr: any[]) {\n    // Handle constructor from typed components\n    if (arr.length === 3) {\n      const [dataArg, pendingWord, pendingWordLen] = arr;\n\n      // Check if we're dealing with typed classes\n      assert(\n        Array.isArray(dataArg) &&\n          pendingWord instanceof CairoFelt252 &&\n          pendingWordLen instanceof CairoUint32,\n        'Invalid constructor parameters. Expected (CairoBytes31[], CairoFelt252, CairoUint32)'\n      );\n      // Typed classes - use directly\n      this.data = dataArg;\n      this.pending_word = pendingWord;\n      this.pending_word_len = pendingWordLen;\n      return;\n    }\n\n    // Handle custom constructor\n    const inData = arr[0] as unknown;\n    CairoByteArray.validate(inData);\n    const { data, pending_word, pending_word_len } = CairoByteArray.__processData(inData);\n    this.data = data;\n    this.pending_word = pending_word;\n    this.pending_word_len = pending_word_len;\n  }\n\n  static __processData(inData: BigNumberish | Buffer | Uint8Array | unknown) {\n    let fullData: Uint8Array;\n    // Handle different input types\n    if (inData instanceof Uint8Array) {\n      // byteArrayFromUint8Array\n      fullData = inData;\n    } else if (isBuffer(inData)) {\n      // byteArrayFromBuffer\n      fullData = new Uint8Array(inData as Buffer);\n    } else if (isString(inData)) {\n      // byteArrayFromString - stringToUint8Array handles hex, decimal, and UTF-8\n      fullData = stringToUint8Array(inData);\n    } else if (isBigInt(inData)) {\n      // byteArrayFromBigInt\n      fullData = bigIntToUint8Array(inData);\n    } else if (isInteger(inData)) {\n      // byteArrayFromNumber\n      fullData = bigIntToUint8Array(BigInt(inData));\n    } else {\n      throw new Error('Invalid input type. Expected Uint8Array, Buffer, string, number, or bigint');\n    }\n\n    const CHUNK_SIZE = CairoBytes31.MAX_BYTE_SIZE;\n\n    // Calculate how many complete 31-byte chunks we have\n    const completeChunks = Math.floor(fullData.length / CHUNK_SIZE);\n    const remainderLength = fullData.length % CHUNK_SIZE;\n\n    // Extract the data (complete 31-byte chunks) as CairoBytes31 objects\n    const data = [];\n    let pending_word: CairoFelt252;\n    let pending_word_len: CairoUint32;\n    for (let i = 0; i < completeChunks; i += 1) {\n      const chunkStart = i * CHUNK_SIZE;\n      const chunkEnd = chunkStart + CHUNK_SIZE;\n      const chunk = fullData.slice(chunkStart, chunkEnd);\n      data.push(new CairoBytes31(chunk));\n    }\n\n    // Handle the pending word (remainder)\n    if (remainderLength > 0) {\n      const remainder = fullData.slice(completeChunks * CHUNK_SIZE);\n      // Convert remainder to hex string for CairoFelt252\n      let hex = '0x';\n      for (let i = 0; i < remainder.length; i += 1) {\n        hex += remainder[i].toString(16).padStart(2, '0');\n      }\n      pending_word = new CairoFelt252(hex);\n      pending_word_len = new CairoUint32(remainderLength);\n    } else {\n      pending_word = new CairoFelt252(0);\n      pending_word_len = new CairoUint32(0);\n    }\n\n    return { data, pending_word, pending_word_len };\n  }\n\n  toApiRequest() {\n    this.assertInitialized();\n\n    return addCompiledFlag([\n      addHexPrefix(this.data.length.toString(16)),\n      ...this.data.flatMap((bytes31) => bytes31.toApiRequest()),\n      ...this.pending_word.toApiRequest(),\n      ...this.pending_word_len.toApiRequest(),\n    ]);\n  }\n\n  decodeUtf8() {\n    // Convert all bytes to Uint8Array and decode as UTF-8 string\n    // This ensures multi-byte UTF-8 characters are not split across chunk boundaries\n    const allBytes = this.reconstructBytes();\n    return new TextDecoder().decode(allBytes);\n  }\n\n  toBigInt() {\n    // Reconstruct the full byte sequence\n    const allBytes = this.reconstructBytes();\n\n    // Convert bytes array to bigint\n    if (allBytes.length === 0) {\n      return 0n;\n    }\n\n    let result = 0n;\n    allBytes.forEach((byte) => {\n      result = result * 256n + BigInt(byte);\n    });\n\n    return result;\n  }\n\n  toHexString() {\n    const allBytes = this.reconstructBytes();\n    const hexValue = allBytes.length === 0 ? '0' : buf2hex(allBytes);\n    return addHexPrefix(hexValue);\n  }\n\n  toBuffer() {\n    this.assertInitialized();\n    const allBytes = this.reconstructBytes();\n    return Buffer.from(allBytes);\n  }\n\n  static validate(data: Uint8Array | Buffer | BigNumberish | unknown) {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(\n      !Array.isArray(data) || data instanceof Uint8Array,\n      'Invalid input: arrays are not supported, use Uint8Array'\n    );\n    assert(\n      typeof data !== 'object' || isBuffer(data) || data instanceof Uint8Array,\n      'Invalid input for CairoByteArray: objects are not supported'\n    );\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input for CairoByteArray: decimal numbers are not supported, only integers'\n    );\n    assert(\n      !isNumber(data) || data >= 0,\n      'Invalid input for CairoByteArray: negative numbers are not supported'\n    );\n    assert(\n      !isBigInt(data) || data >= 0n,\n      'Invalid input for CairoByteArray: negative bigints are not supported'\n    );\n\n    // There is no particular validation from input parameters when they are composed of existing types\n    assert(\n      data instanceof Uint8Array ||\n        isBuffer(data) ||\n        isString(data) ||\n        isNumber(data) ||\n        isBigInt(data),\n      'Invalid input type. Expected Uint8Array, Buffer, string, number, or bigint'\n    );\n  }\n\n  /**\n   * Check if the provided data is a valid CairoByteArray\n   *\n   * @param data - The data to check\n   * @returns True if the data is a valid CairoByteArray, false otherwise\n   */\n  static is(data: any): boolean {\n    try {\n      CairoByteArray.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoByteArray.abiSelector;\n  }\n\n  /**\n   * Private helper to check if the CairoByteArray is properly initialized\n   */\n  private assertInitialized(): void {\n    assert(\n      this.data && this.pending_word !== undefined && this.pending_word_len !== undefined,\n      'CairoByteArray is not properly initialized'\n    );\n  }\n\n  /**\n   * Private helper to reconstruct the full byte sequence from chunks and pending word\n   */\n  private reconstructBytes(): Uint8Array {\n    this.assertInitialized();\n\n    // Add bytes from all complete chunks (each chunk contains exactly 31 bytes when full)\n    const allChunks: Uint8Array[] = this.data.flatMap((chunk) => chunk.data);\n\n    // // Add bytes from pending word\n    const pendingLen = Number(this.pending_word_len.toBigInt());\n    if (pendingLen) {\n      const pending = new Uint8Array(pendingLen);\n      const paddingDifference = pendingLen - this.pending_word.data.length;\n      pending.set(this.pending_word.data, paddingDifference);\n      allChunks.push(pending);\n    }\n\n    return concatenateArrayBuffer(allChunks);\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoByteArray {\n    const data = Array.from({ length: Number(getNext(responseIterator)) }, () =>\n      CairoBytes31.factoryFromApiResponse(responseIterator)\n    );\n    const pending_word = CairoFelt252.factoryFromApiResponse(responseIterator);\n    const pending_word_len = CairoUint32.factoryFromApiResponse(responseIterator);\n    return new CairoByteArray(data, pending_word, pending_word_len);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_U8 } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint8 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::u8';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoUint8.validate(data);\n    this.data = CairoUint8.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint8.__processData(data);\n    assert(\n      value >= RANGE_U8.min && value <= RANGE_U8.max,\n      `Value is out of u8 range [${RANGE_U8.min}, ${RANGE_U8.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoUint8.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint8.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint8 {\n    return new CairoUint8(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_U16 } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint16 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::u16';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoUint16.validate(data);\n    this.data = CairoUint16.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint16.__processData(data);\n    assert(\n      value >= RANGE_U16.min && value <= RANGE_U16.max,\n      `Value is out of u16 range [${RANGE_U16.min}, ${RANGE_U16.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoUint16.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint16.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint16 {\n    return new CairoUint16(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_U64 } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint64 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::u64';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoUint64.validate(data);\n    this.data = CairoUint64.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint64.__processData(data);\n    assert(\n      value >= RANGE_U64.min && value <= RANGE_U64.max,\n      `Value is out of u64 range [${RANGE_U64.min}, ${RANGE_U64.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoUint64.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint64.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint64 {\n    return new CairoUint64(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_U96 } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint96 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::u96';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoUint96.validate(data);\n    this.data = CairoUint96.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint96.__processData(data);\n    assert(\n      value >= RANGE_U96.min && value <= RANGE_U96.max,\n      `Value is out of u96 range [${RANGE_U96.min}, ${RANGE_U96.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoUint96.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint96.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint96 {\n    return new CairoUint96(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_U128 } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoUint128 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::u128';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoUint128.validate(data);\n    this.data = CairoUint128.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(bigIntToUint8Array(this.data));\n  }\n\n  toHexString() {\n    return addHexPrefix(this.toBigInt().toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoUint128.__processData(data);\n    assert(\n      value >= RANGE_U128.min && value <= RANGE_U128.max,\n      `Value is out of u128 range [${RANGE_U128.min}, ${RANGE_U128.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoUint128.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint128.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoUint128 {\n    return new CairoUint128(getNext(responseIterator));\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_I8, PRIME } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoInt8 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::i8';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoInt8.validate(data);\n    this.data = CairoInt8.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(\n      bigIntToUint8Array(this.data >= 0n ? this.data : 256n + this.data)\n    );\n  }\n\n  /**\n   * For negative values field element representation as positive hex string.\n   * @returns cairo field arithmetic hex string\n   */\n  toHexString() {\n    const value = this.toBigInt();\n    // For negative values, convert to field element representation\n    if (value < 0n) {\n      const fieldElement = PRIME + value;\n      return addHexPrefix(fieldElement.toString(16));\n    }\n    return addHexPrefix(value.toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoInt8.__processData(data);\n    assert(\n      value >= RANGE_I8.min && value <= RANGE_I8.max,\n      `Value is out of i8 range [${RANGE_I8.min}, ${RANGE_I8.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoInt8.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoInt8.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoInt8 {\n    const response = getNext(responseIterator);\n    const value = BigInt(response);\n    // Convert from field element representation to signed value\n    const signedValue = value > PRIME / 2n ? value - PRIME : value;\n    return new CairoInt8(signedValue);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_I16, PRIME } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoInt16 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::i16';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoInt16.validate(data);\n    this.data = CairoInt16.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(\n      bigIntToUint8Array(this.data >= 0n ? this.data : 65536n + this.data)\n    );\n  }\n\n  /**\n   * For negative values field element representation as positive hex string.\n   * @returns cairo field arithmetic hex string\n   */\n  toHexString() {\n    const value = this.toBigInt();\n    // For negative values, convert to field element representation\n    if (value < 0n) {\n      const fieldElement = PRIME + value;\n      return addHexPrefix(fieldElement.toString(16));\n    }\n    return addHexPrefix(value.toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoInt16.__processData(data);\n    assert(\n      value >= RANGE_I16.min && value <= RANGE_I16.max,\n      `Value is out of i16 range [${RANGE_I16.min}, ${RANGE_I16.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoInt16.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoInt16.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoInt16 {\n    const response = getNext(responseIterator);\n    const value = BigInt(response);\n    // Convert from field element representation to signed value\n    const signedValue = value > PRIME / 2n ? value - PRIME : value;\n    return new CairoInt16(signedValue);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_I32, PRIME } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoInt32 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::i32';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoInt32.validate(data);\n    this.data = CairoInt32.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(\n      bigIntToUint8Array(this.data >= 0n ? this.data : 4294967296n + this.data)\n    );\n  }\n\n  /**\n   * For negative values field element representation as positive hex string.\n   * @returns cairo field arithmetic hex string\n   */\n  toHexString() {\n    const value = this.toBigInt();\n    // For negative values, convert to field element representation\n    if (value < 0n) {\n      const fieldElement = PRIME + value;\n      return addHexPrefix(fieldElement.toString(16));\n    }\n    return addHexPrefix(value.toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoInt32.__processData(data);\n    assert(\n      value >= RANGE_I32.min && value <= RANGE_I32.max,\n      `Value is out of i32 range [${RANGE_I32.min}, ${RANGE_I32.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoInt32.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoInt32.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoInt32 {\n    const response = getNext(responseIterator);\n    const value = BigInt(response);\n    // Convert from field element representation to signed value\n    const signedValue = value > PRIME / 2n ? value - PRIME : value;\n    return new CairoInt32(signedValue);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_I64, PRIME } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoInt64 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::i64';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoInt64.validate(data);\n    this.data = CairoInt64.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(\n      bigIntToUint8Array(this.data >= 0n ? this.data : 2n ** 64n + this.data)\n    );\n  }\n\n  /**\n   * For negative values field element representation as positive hex string.\n   * @returns cairo field arithmetic hex string\n   */\n  toHexString() {\n    const value = this.toBigInt();\n    // For negative values, convert to field element representation\n    if (value < 0n) {\n      const fieldElement = PRIME + value;\n      return addHexPrefix(fieldElement.toString(16));\n    }\n    return addHexPrefix(value.toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoInt64.__processData(data);\n    assert(\n      value >= RANGE_I64.min && value <= RANGE_I64.max,\n      `Value is out of i64 range [${RANGE_I64.min}, ${RANGE_I64.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoInt64.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoInt64.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoInt64 {\n    const response = getNext(responseIterator);\n    const value = BigInt(response);\n    // Convert from field element representation to signed value\n    const signedValue = value > PRIME / 2n ? value - PRIME : value;\n    return new CairoInt64(signedValue);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, bigIntToUint8Array, utf8ToBigInt } from '../encode';\nimport { getNext } from '../num';\nimport { isText } from '../shortString';\nimport { isString, isObject, isNumber } from '../typed';\nimport assert from '../assert';\nimport { RANGE_I128, PRIME } from '../../global/constants';\nimport { addCompiledFlag } from '../helpers';\n\nexport class CairoInt128 {\n  data: bigint;\n\n  static abiSelector = 'core::integer::i128';\n\n  constructor(data: BigNumberish | boolean | unknown) {\n    CairoInt128.validate(data);\n    this.data = CairoInt128.__processData(data);\n  }\n\n  static __processData(data: BigNumberish | boolean | unknown): bigint {\n    if (isString(data) && isText(data)) {\n      // Only allow text strings that represent valid UTF-8 byte sequences for specific use cases\n      // For general numeric input validation, reject pure text strings\n      // This maintains compatibility while being more restrictive for validation\n      return utf8ToBigInt(data);\n    }\n    return BigInt(data as BigNumberish);\n  }\n\n  toApiRequest(): string[] {\n    return addCompiledFlag([this.toHexString()]);\n  }\n\n  toBigInt() {\n    return this.data;\n  }\n\n  decodeUtf8() {\n    return new TextDecoder().decode(\n      bigIntToUint8Array(this.data >= 0n ? this.data : 2n ** 128n + this.data)\n    );\n  }\n\n  /**\n   * For negative values field element representation as positive hex string.\n   * @returns cairo field arithmetic hex string\n   */\n  toHexString() {\n    const value = this.toBigInt();\n    // For negative values, convert to field element representation\n    if (value < 0n) {\n      const fieldElement = PRIME + value;\n      return addHexPrefix(fieldElement.toString(16));\n    }\n    return addHexPrefix(value.toString(16));\n  }\n\n  static validate(data: BigNumberish | boolean | unknown): void {\n    assert(data !== null && data !== undefined, 'Invalid input: null or undefined');\n    assert(!isObject(data) && !Array.isArray(data), 'Invalid input: objects are not supported');\n    assert(\n      !isNumber(data) || Number.isInteger(data),\n      'Invalid input: decimal numbers are not supported, only integers'\n    );\n\n    const value = CairoInt128.__processData(data);\n    assert(\n      value >= RANGE_I128.min && value <= RANGE_I128.max,\n      `Value is out of i128 range [${RANGE_I128.min}, ${RANGE_I128.max}]`\n    );\n  }\n\n  static is(data: BigNumberish | boolean | unknown): boolean {\n    try {\n      CairoInt128.validate(data);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoInt128.abiSelector;\n  }\n\n  static factoryFromApiResponse(responseIterator: Iterator<string>): CairoInt128 {\n    const response = getNext(responseIterator);\n    const value = BigInt(response);\n    // Convert from field element representation to signed value\n    const signedValue = value > PRIME / 2n ? value - PRIME : value;\n    return new CairoInt128(signedValue);\n  }\n}\n","import { CairoBytes31 } from '../../cairoDataTypes/bytes31';\nimport { CairoByteArray } from '../../cairoDataTypes/byteArray';\nimport { AbiEntryType, BigNumberish } from '../../../types';\nimport { CairoFelt252 } from '../../cairoDataTypes/felt';\nimport { felt } from '../cairo';\nimport { CairoUint256 } from '../../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../../cairoDataTypes/uint512';\nimport { CairoUint8 } from '../../cairoDataTypes/uint8';\nimport { CairoUint16 } from '../../cairoDataTypes/uint16';\nimport { CairoUint64 } from '../../cairoDataTypes/uint64';\nimport { CairoUint96 } from '../../cairoDataTypes/uint96';\nimport { CairoUint128 } from '../../cairoDataTypes/uint128';\nimport { CairoInt8 } from '../../cairoDataTypes/int8';\nimport { CairoInt16 } from '../../cairoDataTypes/int16';\nimport { CairoInt32 } from '../../cairoDataTypes/int32';\nimport { CairoInt64 } from '../../cairoDataTypes/int64';\nimport { CairoInt128 } from '../../cairoDataTypes/int128';\nimport { getNext } from '../../num';\n\n/**\n * Parsing map for parser, request and response parsers are separated\n * Configure parsing strategy for each abi type\n */\nexport type ParsingStrategy = {\n  request: Record<AbiEntryType, (val: unknown) => any>;\n  response: Record<AbiEntryType, (responseIterator: Iterator<string>) => any>;\n};\n\n// TODO: extend for complex types like structs, tuples, enums, arrays, etc.\n\n/**\n * More robust parsing strategy\n * Configuration mapping - data-driven approach\n * Configure parsing strategy for each abi type\n */\nexport const hdParsingStrategy = {\n  // TODO: provjeri svi request parseri stvaraju array, dali je to ok sa requstParserom\n  request: {\n    [CairoBytes31.abiSelector]: (val: unknown) => {\n      return new CairoBytes31(val).toApiRequest();\n    },\n    [CairoByteArray.abiSelector]: (val: unknown) => {\n      return new CairoByteArray(val).toApiRequest();\n    },\n    [CairoFelt252.abiSelector]: (val: unknown) => {\n      return new CairoFelt252(val).toApiRequest();\n    },\n    [CairoUint256.abiSelector]: (val: unknown) => {\n      return new CairoUint256(val).toApiRequest();\n    },\n    [CairoUint512.abiSelector]: (val: unknown) => {\n      return new CairoUint512(val).toApiRequest();\n    },\n    [CairoUint8.abiSelector]: (val: unknown) => {\n      return new CairoUint8(val).toApiRequest();\n    },\n    [CairoUint16.abiSelector]: (val: unknown) => {\n      return new CairoUint16(val).toApiRequest();\n    },\n    [CairoUint64.abiSelector]: (val: unknown) => {\n      return new CairoUint64(val).toApiRequest();\n    },\n    [CairoUint96.abiSelector]: (val: unknown) => {\n      return new CairoUint96(val).toApiRequest();\n    },\n    [CairoUint128.abiSelector]: (val: unknown) => {\n      return new CairoUint128(val).toApiRequest();\n    },\n    [CairoInt8.abiSelector]: (val: unknown) => {\n      return new CairoInt8(val).toApiRequest();\n    },\n    [CairoInt16.abiSelector]: (val: unknown) => {\n      return new CairoInt16(val).toApiRequest();\n    },\n    [CairoInt32.abiSelector]: (val: unknown) => {\n      return new CairoInt32(val).toApiRequest();\n    },\n    [CairoInt64.abiSelector]: (val: unknown) => {\n      return new CairoInt64(val).toApiRequest();\n    },\n    [CairoInt128.abiSelector]: (val: unknown) => {\n      return new CairoInt128(val).toApiRequest();\n    },\n  },\n  response: {\n    [CairoBytes31.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoBytes31.factoryFromApiResponse(responseIterator).decodeUtf8();\n    },\n    [CairoByteArray.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoByteArray.factoryFromApiResponse(responseIterator).decodeUtf8();\n    },\n    [CairoFelt252.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoFelt252.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint256.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint256.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint512.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint512.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint8.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint8.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint16.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint16.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint64.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint64.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint96.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint96.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint128.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint128.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoInt8.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoInt8.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoInt16.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoInt16.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoInt32.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoInt32.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoInt64.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoInt64.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoInt128.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoInt128.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n  },\n} as const;\n\n/**\n * Faster parsing strategy\n * Configuration mapping - data-driven approach\n * Configure parsing strategy for each abi type\n */\nexport const fastParsingStrategy: ParsingStrategy = {\n  request: {\n    [CairoBytes31.abiSelector]: (val: unknown) => {\n      return new CairoBytes31(val).toApiRequest();\n    },\n    [CairoByteArray.abiSelector]: (val: unknown) => {\n      return new CairoByteArray(val).toApiRequest();\n    },\n    [CairoFelt252.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoUint256.abiSelector]: (val: unknown) => {\n      return new CairoUint256(val).toApiRequest();\n    },\n    [CairoUint512.abiSelector]: (val: unknown) => {\n      return new CairoUint512(val).toApiRequest();\n    },\n    [CairoUint8.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoUint16.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoUint64.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoUint96.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoUint128.abiSelector]: (val: unknown) => {\n      return felt(val as BigNumberish);\n    },\n    [CairoInt8.abiSelector]: (val: unknown) => {\n      return new CairoInt8(val).toApiRequest();\n    },\n    [CairoInt16.abiSelector]: (val: unknown) => {\n      return new CairoInt16(val).toApiRequest();\n    },\n    [CairoInt32.abiSelector]: (val: unknown) => {\n      return new CairoInt32(val).toApiRequest();\n    },\n    [CairoInt64.abiSelector]: (val: unknown) => {\n      return new CairoInt64(val).toApiRequest();\n    },\n    [CairoInt128.abiSelector]: (val: unknown) => {\n      return new CairoInt128(val).toApiRequest();\n    },\n  },\n  response: {\n    [CairoBytes31.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoBytes31.factoryFromApiResponse(responseIterator).decodeUtf8();\n    },\n    [CairoByteArray.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoByteArray.factoryFromApiResponse(responseIterator).decodeUtf8();\n    },\n    [CairoFelt252.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoUint256.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint256.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint512.abiSelector]: (responseIterator: Iterator<string>) => {\n      return CairoUint512.factoryFromApiResponse(responseIterator).toBigInt();\n    },\n    [CairoUint8.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoUint16.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoUint64.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoUint96.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoUint128.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoInt8.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoInt16.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoInt32.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoInt64.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n    [CairoInt128.abiSelector]: (responseIterator: Iterator<string>) => {\n      return BigInt(getNext(responseIterator));\n    },\n  },\n} as const;\n","import { Abi, AbiEntryType, FunctionAbi } from '../../../types';\nimport { isLen } from '../cairo';\nimport { AbiParserInterface } from './interface';\nimport { fastParsingStrategy, ParsingStrategy } from './parsingStrategy';\n\nexport class AbiParser1 implements AbiParserInterface {\n  abi: Abi;\n\n  parsingStrategy: ParsingStrategy;\n\n  constructor(abi: Abi, parsingStrategy?: ParsingStrategy) {\n    this.abi = abi;\n    this.parsingStrategy = parsingStrategy || fastParsingStrategy;\n  }\n\n  public getRequestParser(abiType: AbiEntryType): (val: unknown) => any {\n    if (this.parsingStrategy.request[abiType]) {\n      return this.parsingStrategy.request[abiType];\n    }\n    throw new Error(`Parser for ${abiType} not found`);\n  }\n\n  public getResponseParser(abiType: AbiEntryType): (responseIterator: Iterator<string>) => any {\n    if (this.parsingStrategy.response[abiType]) {\n      return this.parsingStrategy.response[abiType];\n    }\n    throw new Error(`Parser for ${abiType} not found`);\n  }\n\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.reduce((acc, input) => (!isLen(input.name) ? acc + 1 : acc), 0);\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    return this.abi.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat() {\n    return this.abi;\n  }\n}\n","import {\n  Abi,\n  FunctionAbi,\n  AbiEvent,\n  AbiStruct,\n  InterfaceAbi,\n  type LegacyEvent,\n  AbiEntryType,\n} from '../../../types';\nimport { AbiParserInterface } from './interface';\nimport { fastParsingStrategy, ParsingStrategy } from './parsingStrategy';\n\nexport class AbiParser2 implements AbiParserInterface {\n  abi: Abi;\n\n  parsingStrategy: ParsingStrategy;\n\n  constructor(abi: Abi, parsingStrategy?: ParsingStrategy) {\n    this.abi = abi;\n    this.parsingStrategy = parsingStrategy || fastParsingStrategy;\n  }\n\n  public getRequestParser(abiType: AbiEntryType): (val: unknown) => any {\n    if (this.parsingStrategy.request[abiType]) {\n      return this.parsingStrategy.request[abiType];\n    }\n    throw new Error(`Parser for ${abiType} not found`);\n  }\n\n  public getResponseParser(abiType: AbiEntryType): (responseIterator: Iterator<string>) => any {\n    if (this.parsingStrategy.response[abiType]) {\n      return this.parsingStrategy.response[abiType];\n    }\n    throw new Error(`Parser for ${abiType} not found`);\n  }\n\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.length;\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    const intf = this.abi.find(\n      (it: FunctionAbi | AbiEvent | AbiStruct | InterfaceAbi) => it.type === 'interface'\n    ) as InterfaceAbi;\n    return intf?.items?.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat(): Abi {\n    return this.abi.flatMap((it: FunctionAbi | LegacyEvent | AbiStruct | InterfaceAbi) => {\n      return it.type === 'interface' ? it.items : it;\n    });\n  }\n}\n","import { Abi, FunctionAbi, RawArgs } from '../../../types';\nimport { isCairo1Abi } from '../cairo';\nimport { AbiParserInterface } from './interface';\nimport { AbiParser1 } from './parser-0-1.1.0';\nimport { AbiParser2 } from './parser-2.0.0';\nimport { ParsingStrategy } from './parsingStrategy';\n\nexport { AbiParser2 };\nexport { AbiParser1 };\nexport { AbiParserInterface };\nexport * from './parsingStrategy';\n\n/**\n * Creates ABI parser\n *\n * @param {Abi} abi\n * @returns {AbiParserInterface} abi parser interface\n *\n * @example\n * const abiParser2 = createAbiParser([getInterfaceAbi('struct')]);\n * // abiParser2 instanceof AbiParser2 === true\n *\n * const abiParser1 = createAbiParser([getFunctionAbi('struct')]);\n * // abiParser1 instanceof AbiParser1 === true\n */\nexport function createAbiParser(abi: Abi, parsingStrategy?: ParsingStrategy): AbiParserInterface {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi, parsingStrategy);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi, parsingStrategy);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\n\n/**\n * Retrieves ABI version\n *\n * @param {Abi} abi\n * @returns {1 | 2 | 0} abi 1, 2 or 0 version\n *\n * @example\n * // Example 1: Return ABI version 2\n * const version = getAbiVersion([getInterfaceAbi()]);\n * // version === 2\n *\n * // Example 2: Return ABI version 1\n * const version = getAbiVersion([getInterfaceAbi('core::bool')]);\n * // version === 1\n *\n * // Example 3: Return ABI version 0\n * const version = getAbiVersion([getInterfaceAbi('felt')]);\n * // version === 0\n */\nexport function getAbiVersion(abi: Abi): 1 | 2 | 0 {\n  if (abi.find((it) => it.type === 'interface')) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\n\n/**\n * Checks if no constructor valid\n *\n * @param {string} method\n * @param {RawArgs} argsCalldata\n * @param {FunctionAbi} abiMethod\n * @returns boolean\n *\n * @example\n * const result1 = isNoConstructorValid('constructor', [])\n * // result1 === true\n * const result2 = isNoConstructorValid('test', ['test'])\n * // result2 === false\n */\nexport function isNoConstructorValid(\n  method: string,\n  argsCalldata: RawArgs,\n  abiMethod?: FunctionAbi\n): boolean {\n  // No constructor in abi and validly empty args\n  return method === 'constructor' && !abiMethod && !argsCalldata.length;\n}\n","/* eslint-disable no-plusplus */\nimport { isCairo1Type, isTypeNamedTuple } from './cairo';\n\nfunction parseNamedTuple(namedTuple: string): any {\n  const name = namedTuple.substring(0, namedTuple.indexOf(':'));\n  const type = namedTuple.substring(name.length + ':'.length);\n  return { name, type };\n}\n\nfunction parseSubTuple(s: string) {\n  if (!s.includes('(')) return { subTuple: [], result: s };\n  const subTuple: string[] = [];\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === '(') {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === ')') counter--;\n        if (s[i] === '(') counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += ' ';\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n\n  return {\n    subTuple,\n    result,\n  };\n}\n\nfunction extractCairo0Tuple(type: string) {\n  const cleanType = type.replace(/\\s/g, '').slice(1, -1); // remove first lvl () and spaces\n\n  // Decompose subTuple\n  const { subTuple, result } = parseSubTuple(cleanType);\n\n  // Recompose subTuple\n  let recomposed = result.split(',').map((it) => {\n    return subTuple.length ? it.replace(' ', subTuple.shift() as string) : it;\n  });\n\n  // Parse named tuple\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n\n  return recomposed;\n}\n\nfunction getClosureOffset(input: string, open: string, close: string): number {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\n\nfunction extractCairo1Tuple(type: string): string[] {\n  // un-named tuples support\n  const input = type.slice(1, -1); // remove first lvl ()\n  const result: string[] = [];\n\n  let currentIndex: number = 0;\n  let limitIndex: number;\n\n  while (currentIndex < input.length) {\n    switch (true) {\n      // Tuple\n      case input[currentIndex] === '(': {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '(', ')') + 1;\n        break;\n      }\n      case input.startsWith('core::result::Result::<', currentIndex) ||\n        input.startsWith('core::array::Array::<', currentIndex) ||\n        input.startsWith('core::option::Option::<', currentIndex): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '<', '>') + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(',', currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2; // +2 to skip ', '\n  }\n\n  return result;\n}\n\n/**\n * Convert a tuple string definition into an object-like definition.\n * Supports both Cairo 0 and Cairo 1 tuple formats.\n *\n * @param type - The tuple string definition (e.g., \"(u8, u8)\" or \"(x:u8, y:u8)\").\n * @returns An array of strings or objects representing the tuple components.\n *\n * @example\n * // Cairo 0 Tuple\n * const cairo0Tuple = \"(u8, u8)\";\n * const result = extractTupleMemberTypes(cairo0Tuple);\n * // result: [\"u8\", \"u8\"]\n *\n * @example\n * // Named Cairo 0 Tuple\n * const namedCairo0Tuple = \"(x:u8, y:u8)\";\n * const namedResult = extractTupleMemberTypes(namedCairo0Tuple);\n * // namedResult: [{ name: \"x\", type: \"u8\" }, { name: \"y\", type: \"u8\" }]\n *\n * @example\n * // Cairo 1 Tuple\n * const cairo1Tuple = \"(core::result::Result::<u8, u8>, u8)\";\n * const cairo1Result = extractTupleMemberTypes(cairo1Tuple);\n * // cairo1Result: [\"core::result::Result::<u8, u8>\", \"u8\"]\n */\nexport default function extractTupleMemberTypes(type: string): (string | object)[] {\n  return isCairo1Type(type) ? extractCairo1Tuple(type) : extractCairo0Tuple(type);\n}\n","import assert from '../assert';\n\nexport class CairoFixedArray {\n  /**\n   * JS array representing a Cairo fixed array.\n   */\n  public readonly content: any[];\n\n  /**\n   * Cairo fixed array type.\n   */\n  public readonly arrayType: string;\n\n  /**\n   * Create an instance representing a Cairo fixed Array.\n   * @param {any[]} content JS array representing a Cairo fixed array.\n   * @param {string} arrayType Cairo fixed array type.\n   */\n  constructor(content: any[], arrayType: string) {\n    assert(\n      CairoFixedArray.isTypeFixedArray(arrayType),\n      `The type ${arrayType} is not a Cairo fixed array. Needs [type; length].`\n    );\n\n    // Validate that the type includes content type\n    try {\n      CairoFixedArray.getFixedArrayType(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} do not includes any content type. Needs [type; length].`\n      );\n    }\n\n    // Validate that the type includes array size\n    let arraySize: number;\n    try {\n      arraySize = CairoFixedArray.getFixedArraySize(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} type do not includes any length. Needs [type; length].`\n      );\n    }\n\n    assert(\n      arraySize === content.length,\n      `The ABI type ${arrayType} is expecting ${arraySize} items. ${content.length} items provided.`\n    );\n    this.content = content;\n    this.arrayType = arrayType;\n  }\n\n  /**\n   * Retrieves the array size from the given type string representing a Cairo fixed array.\n   * @param {string} type - The Cairo fixed array type.\n   * @returns {number} The array size.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArraySize(\"[core::integer::u32; 8]\");\n   * // result = 8\n   * ```\n   */\n  static getFixedArraySize(type: string) {\n    const matchArray = type.match(/(?<=; )\\d+(?=\\])/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid number after ';' character.`);\n    return Number(matchArray[0]);\n  }\n\n  /**\n   * Retrieves the Cairo fixed array size from the CairoFixedArray instance.\n   * @returns {number} The fixed array size.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArraySize();\n   * // result = 3\n   * ```\n   */\n  getFixedArraySize() {\n    return CairoFixedArray.getFixedArraySize(this.arrayType);\n  }\n\n  /**\n   * Retrieve the Cairo content type from a Cairo fixed array type.\n   * @param {string} type - The type string.\n   * @returns {string} The fixed-array type.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArrayType(\"[core::integer::u32; 8]\");\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  static getFixedArrayType = (type: string) => {\n    const matchArray = type.match(/(?<=\\[).+(?=;)/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid type of data.`);\n    return matchArray[0];\n  };\n\n  /**\n   * Retrieve the Cairo content type of the Cairo fixed array.\n   * @returns {string} The fixed-array content type.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArrayType();\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  getFixedArrayType() {\n    return CairoFixedArray.getFixedArrayType(this.arrayType);\n  }\n\n  /**\n   * Create an object from a Cairo fixed array.\n   * Be sure to have an array length conform to the ABI.\n   * To be used with CallData.compile().\n   * @param {Array<any>} input JS array representing a Cairo fixed array.\n   * @returns {Object} a specific struct representing a fixed Array.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.compile([10,20,30]);\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  static compile(input: Array<any>): Object {\n    return input.reduce((acc: any, item: any, idx: number) => {\n      acc[idx] = item;\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Generate an object from the Cairo fixed array instance.\n   * To be used with CallData.compile().\n   * @returns a specific struct representing a fixed array.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.compile();\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  public compile(): Object {\n    return CairoFixedArray.compile(this.content);\n  }\n\n  /**\n   * Checks if the given Cairo type is a fixed-array type.\n   * structure: [string; number]\n   *\n   * @param {string} type - The type to check.\n   * @returns - `true` if the type is a fixed array type, `false` otherwise.\n   * ```typescript\n   * const result = CairoFixedArray.isTypeFixedArray(\"[core::integer::u32; 8]\");\n   * // result = true\n   */\n  static isTypeFixedArray(type: string) {\n    return (\n      /^\\[.*;\\s.*\\]$/.test(type) && /(?<=\\[).+(?=;)/.test(type) && /(?<=; )\\d+(?=\\])/.test(type)\n    );\n  }\n}\n","import { AbiEntry, AbiEnums, AbiStructs, CairoEnum, RawArgsObject } from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeU96,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\nimport { isUndefined, isString } from '../typed';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoByteArray } from '../cairoDataTypes/byteArray';\n\nfunction errorU256(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\n\nfunction errorU512(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\n\nexport default function orderPropsByAbi(\n  unorderedObject: RawArgsObject,\n  abiOfObject: AbiEntry[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): object {\n  const orderInput = (unorderedItem: any, abiType: string): any => {\n    if (CairoFixedArray.isTypeFixedArray(abiType)) {\n      return orderFixedArray(unorderedItem, abiType);\n    }\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoByteArray.isAbiType(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeU96(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== 'object') {\n        // BigNumberish --> just copy\n        return u256;\n      }\n      if (!('low' in u256 && 'high' in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== 'object') {\n        // BigNumberish --> just copy\n        return u512;\n      }\n      if (!['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    // literals\n    return unorderedItem;\n  };\n\n  const orderStruct = (unorderedObject2: RawArgsObject, abiObject: AbiEntry[]): object => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, abiParam.name, {\n          enumerable: true,\n          value: value ?? unorderedObject2[abiParam.name],\n        });\n\n      if (unorderedObject2[abiParam.name] === 'undefined') {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n\n  function orderArray(myArray: Array<any> | string, abiParam: string): Array<any> | string {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray; // longstring\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n\n  function orderFixedArray(input: Array<any> | Record<string, any>, abiParam: string): Array<any> {\n    const typeInFixedArray = CairoFixedArray.getFixedArrayType(abiParam);\n    const arraySize = CairoFixedArray.getFixedArraySize(abiParam);\n    if (Array.isArray(input)) {\n      if (arraySize !== input.length) {\n        throw new Error(\n          `ABI type ${abiParam}: array provided do not includes  ${arraySize} items. ${input.length} items provided.`\n        );\n      }\n      return input.map((myElem) => orderInput(myElem, typeInFixedArray));\n    }\n    if (arraySize !== Object.keys(input).length) {\n      throw new Error(\n        `ABI type ${abiParam}: object provided do not includes  ${arraySize} properties. ${Object.keys(input).length} items provided.`\n      );\n    }\n    return orderInput(input, typeInFixedArray);\n  }\n\n  function orderTuple(unorderedObject2: RawArgsObject, abiParam: string): object {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject: object, abiTypeCairoX: any, index) => {\n      const myObjKeys: string[] = Object.keys(unorderedObject2);\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, index.toString(), {\n          enumerable: true,\n          value: value ?? unorderedObject2[myObjKeys[index]],\n        });\n      const abiType: string = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX; // Named tuple, or tuple\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n\n  const orderEnum = (unorderedObject2: CairoEnum, abiObject: AbiEntry): CairoEnum => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2 as CairoResult<any, any>;\n      const resultOkType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf(',')\n      );\n      const resultErrType: string = abiObject.name.substring(\n        abiObject.name.indexOf(',') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult<any, any>(\n          CairoResultVariant.Ok,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult<any, any>(\n        CairoResultVariant.Err,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2 as CairoOption<any>;\n      const resultSomeType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption<any>(\n          CairoOptionVariant.Some,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      // none(())\n      return new CairoOption<any>(CairoOptionVariant.None, {});\n    }\n    // custom Enum\n    const unorderedCustomEnum = unorderedObject2 as CairoCustomEnum;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (isUndefined(variant[1])) {\n        return variant;\n      }\n      const variantType: string = abiObject.type.substring(\n        abiObject.type.lastIndexOf('<') + 1,\n        abiObject.type.lastIndexOf('>')\n      );\n      if (variantType === '()') {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n\n  // Order Call Parameters\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value: any) =>\n      Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value,\n      });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  BigNumberish,\n  CairoEnum,\n  ParsedStruct,\n  Tupled,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoByteArray } from '../cairoDataTypes/byteArray';\nimport { CairoBytes31 } from '../cairoDataTypes/bytes31';\nimport { CairoFelt252 } from '../cairoDataTypes/felt';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { CairoUint8 } from '../cairoDataTypes/uint8';\nimport { CairoUint16 } from '../cairoDataTypes/uint16';\nimport { CairoUint64 } from '../cairoDataTypes/uint64';\nimport { CairoUint96 } from '../cairoDataTypes/uint96';\nimport { CairoUint128 } from '../cairoDataTypes/uint128';\nimport { CairoInt8 } from '../cairoDataTypes/int8';\nimport { CairoInt16 } from '../cairoDataTypes/int16';\nimport { CairoInt32 } from '../cairoDataTypes/int32';\nimport { CairoInt64 } from '../cairoDataTypes/int64';\nimport { CairoInt128 } from '../cairoDataTypes/int128';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport { toHex } from '../num';\nimport { isText, splitLongString } from '../shortString';\nimport { isUndefined, isString } from '../typed';\nimport {\n  felt,\n  getArrayType,\n  isTypeArray,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n  uint256,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport { AbiParserInterface } from './parser';\nimport extractTupleMemberTypes from './tuple';\n\n// TODO: cleanup implementations to work with unknown, instead of blind casting with 'as'\n\n/**\n * parse base types\n * @param type type from abi\n * @param val value provided\n * @returns string | string[]\n */\nfunction parseBaseTypes({\n  type,\n  val,\n  parser,\n}: {\n  type: string;\n  val: unknown;\n  parser: AbiParserInterface;\n}): AllowArray<string> {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint512.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint8.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint16.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint64.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint96.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoUint128.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoInt8.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoInt16.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoInt32.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoInt64.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoInt128.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case CairoBytes31.isAbiType(type):\n      return parser.getRequestParser(type)(val);\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val as BigNumberish)).padStart(128, '0');\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high),\n      ];\n    }\n    default:\n      // TODO: check but u32 should land here with rest of the simple types, at the moment handle as felt\n      return parser.getRequestParser(CairoFelt252.abiSelector)(val);\n  }\n}\n\n/**\n * Parse tuple type string to array of known objects\n * @param element request element\n * @param typeStr tuple type string\n * @returns Tupled[]\n */\nfunction parseTuple(element: object, typeStr: string): Tupled[] {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements}\n      expected: ${memberTypes}`\n    );\n  }\n\n  return memberTypes.map((it: any, dx: number) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it,\n    };\n  });\n}\n\n/**\n * Deep parse of the object that has been passed to the method\n *\n * @param element - element that needs to be parsed\n * @param type  - name of the method\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nfunction parseCalldataValue({\n  element,\n  type,\n  structs,\n  enums,\n  parser,\n}: {\n  element: unknown;\n  type: string;\n  structs: AbiStructs;\n  enums: AbiEnums;\n  parser: AbiParserInterface;\n}): string | string[] {\n  if (element === undefined) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n\n  // value is fixed array\n  if (CairoFixedArray.isTypeFixedArray(type)) {\n    const arrayType = CairoFixedArray.getFixedArrayType(type);\n    let values: any[] = [];\n    if (Array.isArray(element)) {\n      const array = new CairoFixedArray(element, type);\n      values = array.content;\n    } else if (typeof element === 'object') {\n      values = Object.values(element as object);\n      assert(\n        values.length === CairoFixedArray.getFixedArraySize(type),\n        `ABI type ${type}: object provided do not includes  ${CairoFixedArray.getFixedArraySize(type)} items. ${values.length} items provided.`\n      );\n    } else {\n      throw new Error(`ABI type ${type}: not an Array representing a cairo.fixedArray() provided.`);\n    }\n    return values.reduce((acc, it) => {\n      return acc.concat(\n        parseCalldataValue({ element: it, type: arrayType, structs, enums, parser })\n      );\n    }, [] as string[]);\n  }\n\n  // value is Array\n  if (Array.isArray(element)) {\n    const result: string[] = [];\n    result.push(felt(element.length)); // Add length to array\n    const arrayType = getArrayType(type);\n\n    return element.reduce((acc, it) => {\n      return acc.concat(\n        parseCalldataValue({ element: it, type: arrayType, structs, enums, parser })\n      );\n    }, result);\n  }\n\n  // check if u256 C1v0\n  if (CairoUint256.isAbiType(type)) {\n    return parser.getRequestParser(type)(element);\n  }\n  // check if u512\n  if (CairoUint512.isAbiType(type)) {\n    return parser.getRequestParser(type)(element);\n  }\n\n  // checking if the passed element is struct\n  if (structs[type] && structs[type].members.length) {\n    if (isTypeEthAddress(type)) {\n      return parseBaseTypes({ type, val: element as BigNumberish, parser });\n    }\n\n    if (CairoByteArray.isAbiType(type)) {\n      return parser.getRequestParser(type)(element);\n    }\n\n    const { members } = structs[type];\n    const subElement = element as any;\n\n    return members.reduce((acc, it: AbiEntry) => {\n      return acc.concat(\n        parseCalldataValue({\n          element: subElement[it.name],\n          type: it.type,\n          structs,\n          enums,\n          parser,\n        })\n      );\n    }, [] as string[]);\n  }\n  // check if abi element is tuple\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element as object, type);\n\n    return tupled.reduce((acc, it: Tupled) => {\n      const parsedData = parseCalldataValue({\n        element: it.element,\n        type: it.type,\n        structs,\n        enums,\n        parser,\n      });\n      return acc.concat(parsedData);\n    }, [] as string[]);\n  }\n\n  // check if Enum\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    // Option Enum\n    if (isTypeOption(type)) {\n      const myOption = element as CairoOption<any>;\n      if (myOption.isSome()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Some');\n        if (isUndefined(listTypeVariant)) {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant.type;\n        if (typeVariantSome === '()') {\n          return CairoOptionVariant.Some.toString();\n        }\n        const parsedParameter = parseCalldataValue({\n          element: myOption.unwrap(),\n          type: typeVariantSome,\n          structs,\n          enums,\n          parser,\n        });\n        if (Array.isArray(parsedParameter)) {\n          return [CairoOptionVariant.Some.toString(), ...parsedParameter];\n        }\n        return [CairoOptionVariant.Some.toString(), parsedParameter];\n      }\n      return CairoOptionVariant.None.toString();\n    }\n    // Result Enum\n    if (isTypeResult(type)) {\n      const myResult = element as CairoResult<any, any>;\n      if (myResult.isOk()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Ok');\n        if (isUndefined(listTypeVariant)) {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant.type;\n        if (typeVariantOk === '()') {\n          return CairoResultVariant.Ok.toString();\n        }\n        const parsedParameter = parseCalldataValue({\n          element: myResult.unwrap(),\n          type: typeVariantOk,\n          structs,\n          enums,\n          parser,\n        });\n        if (Array.isArray(parsedParameter)) {\n          return [CairoResultVariant.Ok.toString(), ...parsedParameter];\n        }\n        return [CairoResultVariant.Ok.toString(), parsedParameter];\n      }\n\n      // is Result::Err\n      const listTypeVariant = variants.find((variant) => variant.name === 'Err');\n      if (isUndefined(listTypeVariant)) {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant.type;\n      if (typeVariantErr === '()') {\n        return CairoResultVariant.Err.toString();\n      }\n      const parsedParameter = parseCalldataValue({\n        element: myResult.unwrap(),\n        type: typeVariantErr,\n        structs,\n        enums,\n        parser,\n      });\n      if (Array.isArray(parsedParameter)) {\n        return [CairoResultVariant.Err.toString(), ...parsedParameter];\n      }\n      return [CairoResultVariant.Err.toString(), parsedParameter];\n    }\n    // Custom Enum\n    const myEnum = element as CairoCustomEnum;\n    const activeVariant: string = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (isUndefined(listTypeVariant)) {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant); // can not fail due to check of listTypeVariant\n    if (typeActiveVariant === '()') {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue({\n      element: myEnum.unwrap(),\n      type: typeActiveVariant,\n      structs,\n      enums,\n      parser,\n    });\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes({ type: getArrayType(type), val: element, parser });\n  }\n\n  if (typeof element === 'object') {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes({ type, val: element, parser });\n}\n\n/**\n * Parse one field of the calldata by using input field from the abi for that method\n *\n * @param argsIterator - Iterator for value of the field\n * @param input  - input(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n *\n * @example\n * const abiEntry = { name: 'test', type: 'struct' };\n * const abiStructs: AbiStructs = {\n *  struct: {\n *    members: [\n *        {\n *          name: 'test_name',\n *          type: 'test_type',\n *          offset: 1,\n *        },\n *    ],\n *    size: 2,\n *    name: 'cairo__struct',\n *    type: 'struct',\n *   },\n * };\n *\n * const abiEnums: AbiEnums = {\n *   enum: {\n *     variants: [\n *       {\n *         name: 'test_name',\n *         type: 'cairo_struct_variant',\n *         offset: 1,\n *       },\n *     ],\n *     size: 2,\n *     name: 'test_cairo',\n *     type: 'enum',\n *   },\n * };\n *\n * const args = [{ test_name: 'test' }];\n * const argsIterator = args[Symbol.iterator]();\n * const parsedField = parseCalldataField(\n *   argsIterator,\n *   abiEntry,\n *   abiStructs,\n *   abiEnums\n * );\n * // parsedField === ['1952805748']\n */\nexport function parseCalldataField({\n  argsIterator,\n  input,\n  structs,\n  enums,\n  parser,\n}: {\n  argsIterator: Iterator<any>;\n  input: AbiEntry;\n  structs: AbiStructs;\n  enums: AbiEnums;\n  parser: AbiParserInterface;\n}): string | string[] {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n\n  switch (true) {\n    // Fixed array\n    case CairoFixedArray.isTypeFixedArray(type):\n      if (!Array.isArray(value) && !(typeof value === 'object')) {\n        throw Error(`ABI expected parameter ${name} to be an array or an object, got ${value}`);\n      }\n      return parseCalldataValue({ element: value, type: input.type, structs, enums, parser });\n    // Normal Array\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        // long string match cairo felt*\n        value = splitLongString(value);\n      }\n      return parseCalldataValue({ element: value, type: input.type, structs, enums, parser });\n    case isTypeNonZero(type):\n      return parseBaseTypes({ type: getArrayType(type), val: value, parser });\n    case isTypeEthAddress(type):\n      return parseBaseTypes({ type, val: value, parser });\n    // Struct or Tuple\n    case isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type):\n      return parseCalldataValue({\n        element: value as ParsedStruct | BigNumberish[],\n        type,\n        structs,\n        enums,\n        parser,\n      });\n\n    // Enums\n    case isTypeEnum(type, enums):\n      return parseCalldataValue({\n        element: value as CairoOption<any> | CairoResult<any, any> | CairoEnum,\n        type,\n        structs,\n        enums,\n        parser,\n      });\n\n    // Felt or unhandled\n    default:\n      return parseBaseTypes({ type, val: value, parser });\n  }\n}\n","/* eslint-disable no-case-declarations */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  Args,\n  BigNumberish,\n  CairoEnum,\n  EventEntry,\n  ParsedStruct,\n} from '../../types';\nimport { CairoByteArray } from '../cairoDataTypes/byteArray';\nimport { CairoBytes31 } from '../cairoDataTypes/bytes31';\nimport { CairoFelt252 } from '../cairoDataTypes/felt';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { CairoUint8 } from '../cairoDataTypes/uint8';\nimport { CairoUint16 } from '../cairoDataTypes/uint16';\nimport { CairoUint64 } from '../cairoDataTypes/uint64';\nimport { CairoUint96 } from '../cairoDataTypes/uint96';\nimport { CairoUint128 } from '../cairoDataTypes/uint128';\nimport { CairoInt8 } from '../cairoDataTypes/int8';\nimport { CairoInt16 } from '../cairoDataTypes/int16';\nimport { CairoInt32 } from '../cairoDataTypes/int32';\nimport { CairoInt64 } from '../cairoDataTypes/int64';\nimport { CairoInt128 } from '../cairoDataTypes/int128';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeSecp256k1Point,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoEnumRaw,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport { AbiParserInterface } from './parser/interface';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * Parse base types\n * @param type type of element\n * @param it iterator\n * @returns bigint | boolean\n */\nfunction parseBaseTypes(type: string, it: Iterator<string>, parser: AbiParserInterface) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint512.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint8.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint16.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint64.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint96.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoUint128.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoInt8.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoInt16.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoInt32.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoInt64.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case CairoInt128.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case isTypeEthAddress(type):\n      temp = it.next().value;\n      return BigInt(temp);\n    case CairoBytes31.isAbiType(type):\n      return parser.getResponseParser(type)(it);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      // TODO: this is for all simple types felt and rest to BN, at the moment handle as felt\n      return parser.getResponseParser(CairoFelt252.abiSelector)(it);\n  }\n}\n\n/**\n * Parse of the response elements that are converted to Object (Struct) by using the abi\n *\n * @param responseIterator - iterator of the response\n * @param element - element of the field {name: string, type: string}\n * @param structs - structs from abi\n * @param enums\n * @return {any} - parsed arguments in format that contract is expecting\n */\nfunction parseResponseValue(\n  responseIterator: Iterator<string>,\n  element: { name: string; type: string },\n  parser: AbiParserInterface,\n  structs?: AbiStructs,\n  enums?: AbiEnums\n): BigNumberish | ParsedStruct | boolean | any[] | CairoEnum {\n  if (element.type === '()') {\n    return {};\n  }\n  // type uint256 struct (c1v2)\n  if (CairoUint256.isAbiType(element.type)) {\n    return parser.getResponseParser(element.type)(responseIterator);\n  }\n  // type uint512 struct\n  if (CairoUint512.isAbiType(element.type)) {\n    return parser.getResponseParser(element.type)(responseIterator);\n  }\n  // type ByteArray struct\n  if (CairoByteArray.isAbiType(element.type)) {\n    return parser.getResponseParser(element.type)(responseIterator);\n  }\n\n  // type fixed-array\n  if (CairoFixedArray.isTypeFixedArray(element.type)) {\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: CairoFixedArray.getFixedArrayType(element.type) };\n    const arraySize = CairoFixedArray.getFixedArraySize(element.type);\n    while (parsedDataArr.length < arraySize) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, parser, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, parser, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type NonZero\n  if (isTypeNonZero(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    // const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    // parsedDataArr.push();\n    return parseResponseValue(responseIterator, el, parser, structs, enums);\n  }\n\n  // type struct\n  if (structs && element.type in structs && structs[element.type]) {\n    if (isTypeEthAddress(element.type)) {\n      return parseBaseTypes(element.type, responseIterator, parser);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, parser, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type Enum (only CustomEnum)\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum: number = Number(responseIterator.next().value); // get variant number\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: '', type: variant.type },\n          parser,\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = undefined;\n      return acc;\n    }, {} as CairoEnumRaw);\n    // Option\n    if (element.type.startsWith('core::option::Option')) {\n      const content = variantNum === CairoOptionVariant.Some ? rawEnum.Some : undefined;\n      return new CairoOption<Object>(variantNum, content);\n    }\n    // Result\n    if (element.type.startsWith('core::result::Result')) {\n      let content: Object;\n      if (variantNum === CairoResultVariant.Ok) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult<Object, Object>(variantNum, content);\n    }\n    // Cairo custom Enum\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n\n  // type tuple\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it: any, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, parser, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // TODO: duplicated, investigate why and what was an issue then de-duplicate\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, parser, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // base type\n  return parseBaseTypes(element.type, responseIterator, parser);\n}\n\n/**\n * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n *\n * @param responseIterator - iterator of the response\n * @param output - output(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param parsedResult\n * @return - parsed response corresponding to the abi structure of the field\n */\nexport default function responseParser({\n  responseIterator,\n  output,\n  structs,\n  enums,\n  parsedResult,\n  parser,\n}: {\n  responseIterator: Iterator<string>;\n  output: AbiEntry | EventEntry;\n  structs: AbiStructs;\n  enums: AbiEnums;\n  parsedResult?: Args | ParsedStruct;\n  parser: AbiParserInterface;\n}): any {\n  const { name, type } = output;\n  let temp;\n\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n\n    case (structs && type in structs) || isTypeTuple(type):\n      return parseResponseValue(responseIterator, output, parser, structs, enums);\n\n    case enums && isTypeEnum(type, enums):\n      return parseResponseValue(responseIterator, output, parser, structs, enums);\n\n    case CairoFixedArray.isTypeFixedArray(type):\n      return parseResponseValue(responseIterator, output, parser, structs, enums);\n\n    case isTypeArray(type):\n      // C1 Array\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, parser, structs, enums);\n      }\n      // C0 Array\n      // eslint-disable-next-line no-case-declarations\n      const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`] as number;\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace('*', '') },\n              parser,\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, parser, structs, enums);\n\n    default:\n      return parseBaseTypes(type, responseIterator, parser);\n  }\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  FunctionAbi,\n  Literal,\n  Uint,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoByteArray } from '../cairoDataTypes/byteArray';\nimport { CairoBytes31 } from '../cairoDataTypes/bytes31';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoInt8 } from '../cairoDataTypes/int8';\nimport { CairoInt16 } from '../cairoDataTypes/int16';\nimport { CairoInt32 } from '../cairoDataTypes/int32';\nimport { CairoInt64 } from '../cairoDataTypes/int64';\nimport { CairoInt128 } from '../cairoDataTypes/int128';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { isHex, toBigInt } from '../num';\nimport { isLongText } from '../shortString';\nimport { isBoolean, isNumber, isString, isBigInt, isObject } from '../typed';\nimport {\n  getArrayType,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeFelt,\n  isTypeLiteral,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeUint,\n} from './cairo';\n\n// TODO: separate validate is redundant as CairoTypes are validated during construction.\n// TODO: This validate should provide added valie method base validate poiniting to incorect value for method, opt. using color coding\n// TODO: Something like: store_message(a -> *INVALID JS TYPE*, b, c -> *MISSING REQUIRED ARG*)\n\nconst validateFelt = (parameter: any, input: AbiEntry) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter)) return; // shortstring\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\n\nconst validateUint = (parameter: any, input: AbiEntry) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      'Validation: Parameter is too large to be typed as Number use (BigInt or String)'\n    );\n  }\n  assert(\n    isString(parameter) ||\n      isNumber(parameter) ||\n      isBigInt(parameter) ||\n      (isObject(parameter) && 'low' in parameter && 'high' in parameter) ||\n      (isObject(parameter) &&\n        ['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in parameter)),\n    `Validate: arg ${input.name} of cairo type ${\n      input.type\n    } should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param: bigint;\n  switch (input.type) {\n    case Uint.u256:\n      param = new CairoUint256(parameter as BigNumberish).toBigInt();\n      break;\n    case Uint.u512:\n      param = new CairoUint512(parameter as BigNumberish).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter as BigNumberish);\n  }\n  switch (input.type) {\n    case Uint.u8:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n\n    case Uint.u16:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n\n    case Uint.u32:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n\n    case Uint.u64:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n\n    case Uint.u128:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n\n    case Uint.u256:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^256-1`\n      );\n      break;\n\n    case Uint.u512:\n      assert(\n        CairoUint512.is(param),\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^512-1`\n      );\n      break;\n\n    case Literal.ClassHash:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n\n    case Literal.ContractAddress:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case Literal.Secp256k1Point: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    case Literal.U96: {\n      assert(\n        param >= 0n && param <= 2n ** 96n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 96 bits number.`\n      );\n      break;\n    }\n\n    default:\n      break;\n  }\n};\n\nconst validateBool = (parameter: any, input: AbiEntry) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\n\nconst validateStruct = (parameter: any, input: AbiEntry, structs: AbiStructs) => {\n  // c1v2 uint256 or u512 in struct\n  if (input.type === Uint.u256 || input.type === Uint.u512) {\n    validateUint(parameter, input);\n    return;\n  }\n\n  if (isTypeEthAddress(input.type)) {\n    assert(!isObject(parameter), `EthAddress type is waiting a BigNumberish. Got \"${parameter}\"`);\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as a js object (not array)`\n  );\n\n  // shallow struct validation, only first depth level\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\n\nconst validateEnum = (parameter: any, input: AbiEntry) => {\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as a js object (not array)`\n  );\n\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes('isSome') && keys.includes('isNone')) {\n    return; // Option Enum\n  }\n  if (isTypeResult(input.type) && keys.includes('isOk') && keys.includes('isErr')) {\n    return; // Result Enum\n  }\n  if (keys.includes('variant') && keys.includes('activeVariant')) {\n    return; // Custom Enum\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received \"${parameter}\", is not an Enum.`\n  );\n};\n\nconst validateTuple = (parameter: any, input: AbiEntry) => {\n  assert(isObject(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n  // todo: skip tuple structural validation for now\n};\n\nconst validateArray = (\n  parameterArray: Array<any> | Record<string, any>,\n  input: AbiEntry,\n  structs: AbiStructs,\n  enums: AbiEnums\n) => {\n  const isNormalArray = isTypeArray(input.type);\n  const baseType = isNormalArray\n    ? getArrayType(input.type)\n    : CairoFixedArray.getFixedArrayType(input.type);\n\n  // Long text (special case when parameter is not an array but long text)\n  if (isNormalArray && isTypeFelt(baseType) && isLongText(parameterArray)) {\n    return;\n  }\n  let parameter: Array<any> = [];\n  if (isNormalArray) {\n    assert(Array.isArray(parameterArray), `Validate: arg ${input.name} should be an Array`);\n    parameter = parameterArray;\n  } else {\n    // fixedArray\n    switch (true) {\n      case Array.isArray(parameterArray):\n        // the type cast is just for the documentation generation, TS narrowing works as expected\n        parameter = parameterArray as any;\n        break;\n      case typeof parameterArray === 'object':\n        parameter = Object.values(parameterArray);\n        break;\n      default:\n        throw new Error(`Validate: arg ${input.name} should be an Array or an object.`);\n    }\n  }\n\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param: BigNumberish) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it: any) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n\n    case isTypeArray(baseType):\n      parameter.forEach((param: any) =>\n        validateArray(param, { name: '', type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach((it: any) =>\n        validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it: any) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeUint(baseType) || isTypeLiteral(baseType):\n      parameter.forEach((param: BigNumberish) => validateUint(param, { name: '', type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param: BigNumberish) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\n\nconst validateNonZero = (parameter: any, input: AbiEntry) => {\n  // Telegram : https://t.me/sncorestars/11902/45433\n  // Author : Ori Ziv (08/apr/2024)\n  // \"NonZero is only supported for purely numeric types (u*, i* and felt252) and EcPoint.\"\n  //\n  // As EcPoint do not includes trait Serde, it can't be seen in an ABI.\n  // u512 is not compatible.\n  // i* are not currently handled by Starknet.js (and core::zeroable::NonZero::<i*> seems not to work in Cairo 2.6.3).\n  // so, are authorized here : u8, u16, u32, u64, u128, u256 and felt252.\n\n  const baseType = getArrayType(input.type);\n\n  assert(\n    (isTypeUint(baseType) && baseType !== CairoUint512.abiSelector) || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        'Validate: value 0 is not authorized in NonZero felt252 type.'\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: '', type: baseType });\n\n      switch (baseType) {\n        case Uint.u256:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            'Validate: value 0 is not authorized in NonZero uint256 type.'\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            'Validate: value 0 is not authorized in NonZero uint type.'\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value \"${parameter}\"`\n      );\n  }\n};\n\n/**\n * Validate cairo contract method arguments\n * Flow: Determine type from abi and than validate against parameter\n *\n * @param {FunctionAbi} abiMethod - Abi method.\n * @param {any[]} args - Arguments.\n * @param {AbiStructs} structs - ABI structs.\n * @param {AbiEnums} enums - ABI enums.\n * @returns {void} - Return void if validation passes\n *\n * @example\n * const functionAbi: FunctionAbi = {\n *   inputs: [{ name: 'test', type: 'felt' }],\n *   name: 'test',\n *   outputs: [{ name: 'test', type: 'felt' }],\n *   stateMutability: 'view',\n *   type: 'function',\n * };\n *\n * const abiStructs: AbiStructs = {\n *  abi_structs: {\n *    members: [\n *        {\n *          name: 'test_name',\n *          type: 'test_type',\n *          offset: 1,\n *        },\n *    ],\n *    size: 2,\n *    name: 'cairo_event_struct',\n *    type: 'struct',\n *   },\n * };\n *\n * const abiEnums: AbiEnums = {\n *   abi_enums: {\n *     variants: [\n *       {\n *         name: 'test_name',\n *         type: 'cairo_event_struct_variant',\n *         offset: 1,\n *       },\n *     ],\n *     size: 2,\n *     name: 'test_cairo_event',\n *     type: 'enum',\n *   },\n * };\n *\n * validateFields(functionAbi, [1n], abiStructs, abiEnums); // Returns void since validation passes\n * validateFields(functionAbi, [{}], abiStructs, abiEnums); // Throw an error because paramters are not valid\n */\nexport default function validateFields(\n  abiMethod: FunctionAbi,\n  args: any[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): void {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case CairoBytes31.isAbiType(input.type):\n        CairoBytes31.validate(parameter);\n        break;\n      case isTypeUint(input.type) || isTypeLiteral(input.type):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case CairoByteArray.isAbiType(input.type):\n        CairoByteArray.validate(parameter);\n        break;\n      case CairoInt8.isAbiType(input.type):\n        CairoInt8.validate(parameter);\n        break;\n      case CairoInt16.isAbiType(input.type):\n        CairoInt16.validate(parameter);\n        break;\n      case CairoInt32.isAbiType(input.type):\n        CairoInt32.validate(parameter);\n        break;\n      case CairoInt64.isAbiType(input.type):\n        CairoInt64.validate(parameter);\n        break;\n      case CairoInt128.isAbiType(input.type):\n        CairoInt128.validate(parameter);\n        break;\n      case isTypeArray(input.type) || CairoFixedArray.isTypeFixedArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n\n    return acc + 1;\n  }, 0);\n}\n","/* eslint-disable no-plusplus */\nimport {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  Args,\n  ArgsOrCalldata,\n  Calldata,\n  FunctionAbi,\n  HexCalldata,\n  RawArgs,\n  RawArgsArray,\n  CallResult,\n  ValidateType,\n} from '../../types';\nimport assert from '../assert';\nimport { toHex } from '../num';\nimport { isBigInt } from '../typed';\nimport { getSelectorFromName } from '../hash/selector';\nimport { isLongText } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport { felt, isCairo1Type, isLen } from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport formatter from './formatter';\nimport { createAbiParser, isNoConstructorValid, ParsingStrategy } from './parser';\nimport { AbiParserInterface } from './parser/interface';\nimport orderPropsByAbi from './propertyOrder';\nimport { parseCalldataField } from './requestParser';\nimport responseParser from './responseParser';\nimport validateFields from './validate';\n\nexport * as cairo from './cairo';\nexport * as byteArray from './byteArray';\nexport { parseCalldataField } from './requestParser';\nexport * from './parser';\n\nexport class CallData {\n  abi: Abi;\n\n  parser: AbiParserInterface;\n\n  protected readonly structs: AbiStructs;\n\n  protected readonly enums: AbiEnums;\n\n  constructor(abi: Abi, parsingStrategy?: ParsingStrategy) {\n    this.structs = CallData.getAbiStruct(abi);\n    this.enums = CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi, parsingStrategy);\n    this.abi = this.parser.getLegacyFormat();\n  }\n\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  public validate(type: ValidateType, method: string, args: ArgsOrCalldata = []) {\n    // ensure provided method of type exists\n    if (type !== ValidateType.DEPLOY) {\n      const invocableFunctionNames = this.abi\n        .filter((abi) => {\n          if (abi.type !== 'function') return false;\n          const isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';\n          return type === ValidateType.INVOKE ? !isView : isView;\n        })\n        .map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === ValidateType.INVOKE ? 'invocable' : 'viewable'} method not found in abi`\n      );\n    }\n\n    // get requested method from abi\n    const abiMethod = this.abi.find((abi) =>\n      type === ValidateType.DEPLOY\n        ? abi.name === method && abi.type === 'constructor'\n        : abi.name === method && abi.type === 'function'\n    ) as FunctionAbi;\n\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n\n    // validate arguments length\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n\n    // validate parameters\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  public compile(method: string, argsCalldata: RawArgs): Calldata {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method) as FunctionAbi;\n\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n\n    let args: RawArgsArray;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      // order the object\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      //   // validate array elements to abi\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n\n    const argsIterator = args[Symbol.iterator]();\n\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) =>\n        isLen(input.name) && !isCairo1Type(input.type)\n          ? acc\n          : acc.concat(\n              parseCalldataField({\n                argsIterator,\n                input,\n                structs: this.structs,\n                enums: this.enums,\n                parser: this.parser,\n              })\n            ),\n      [] as Calldata\n    );\n\n    // add compiled property to array object\n    Object.defineProperty(callArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callArray;\n  }\n\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs: RawArgs): Calldata {\n    const createTree = (obj: object) => {\n      const getEntries = (o: object, prefix = '.'): any => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === 'entrypoint') value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === '0' ? '$$len' : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes('isSome') && keys.includes('isNone')) {\n              // Option\n              const myOption = value as CairoOption<any>;\n              const variantNb = myOption.isSome()\n                ? CairoOptionVariant.Some\n                : CairoOptionVariant.None;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes('isOk') && keys.includes('isErr')) {\n              // Result\n              const myResult = value as CairoResult<any, any>;\n              const variantNb = myResult.isOk() ? CairoResultVariant.Ok : CairoResultVariant.Err;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes('variant') && keys.includes('activeVariant')) {\n              // CustomEnum\n              const myEnum = value as CairoCustomEnum;\n              const activeVariant: string = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant: any) => variant === activeVariant\n              );\n              if (\n                typeof myEnum.unwrap() === 'object' &&\n                Object.keys(myEnum.unwrap()).length === 0 // empty object : {}\n              ) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            // normal object\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      // flatten structs, tuples, add array length. Process leafs as Felt\n      const callTree = createTree(rawArgs);\n      // convert to array\n      callTreeArray = Object.values(callTree);\n    } else {\n      // already compiled data but modified or raw args provided as array, recompile it\n      // recreate tree\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n\n    // add compiled property to array object\n    Object.defineProperty(callTreeArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callTreeArray;\n  }\n\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  public parse(method: string, response: string[]): CallResult {\n    const { outputs } = this.abi.find((abi) => abi.name === method) as FunctionAbi;\n    const responseIterator = response.flat()[Symbol.iterator]();\n\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser({\n        responseIterator,\n        output,\n        structs: this.structs,\n        enums: this.enums,\n        parsedResult: acc,\n        parser: this.parser,\n      });\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {} as Args);\n\n    // Cairo1 avoid object.0 structure\n    return Object.keys(parsed).length === 1 && 0 in parsed ? (parsed[0] as CallResult) : parsed;\n  }\n\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  public format(method: string, response: string[], format: object): CallResult {\n    const parsed = this.parse(method, response);\n    return formatter(parsed as Record<string, any>, format);\n  }\n\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi: Abi): AbiStructs {\n    return abi\n      .filter((abiEntry) => abiEntry.type === 'struct')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n  }\n\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi: Abi): AbiEnums {\n    const fullEnumList = abi\n      .filter((abiEntry) => abiEntry.type === 'enum')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n    delete fullEnumList['core::bool'];\n    return fullEnumList;\n  }\n\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata: RawArgs = []): Calldata {\n    return CallData.compile(rawCalldata);\n  }\n\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw: RawArgs = []): HexCalldata {\n    const calldata = CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  public decodeParameters(\n    typeCairo: AllowArray<string>,\n    response: string[]\n  ): AllowArray<CallResult> {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) =>\n        responseParser({\n          responseIterator,\n          output: { name: '', type: typeParam },\n          parser: this.parser,\n          structs: this.structs,\n          enums: this.enums,\n        }) as CallResult\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n}\n","/**\n * Hashes Exports\n */\nexport * as poseidon from '@noble/curves/abstract/poseidon';\nexport * from './selector'; // Preserve legacy export structure\n\nexport * from './transactionHash';\nexport * from './classHash';\n","/**\n * Calculate Hashes for v3 transactions\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { StarknetChainId, TransactionHashPrefix } from '../../../global/constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport { toHex } from '../../num';\nimport { encodeShortString } from '../../shortString';\nimport { EDAMode, type ResourceBoundsBN } from '../../../provider/types/spec.type';\n\nconst AToBI = (array: BigNumberish[]) => array.map((it: BigNumberish) => BigInt(it));\n\n/* eslint-disable no-bitwise */\nconst DATA_AVAILABILITY_MODE_BITS = 32n;\nconst MAX_AMOUNT_BITS = 64n;\nconst MAX_PRICE_PER_UNIT_BITS = 128n;\nconst RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nconst L1_GAS_NAME = BigInt(encodeShortString('L1_GAS'));\nconst L2_GAS_NAME = BigInt(encodeShortString('L2_GAS'));\nconst L1_DATA_GAS_NAME = BigInt(encodeShortString('L1_DATA'));\n\nexport function hashDAMode(nonceDAMode: BigNumberish, feeDAMode: BigNumberish) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\n\n/**\n * Encode the L1&L2 gas limits of a V3 transaction\n * @param {ResourceBounds} bounds object including the limits for L1 & L2 gas\n * @returns {bigint} encoded data\n */\nexport function encodeResourceBoundsL1(bounds: ResourceBoundsBN): bigint {\n  return (\n    (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (bounds.l1_gas.max_amount << MAX_PRICE_PER_UNIT_BITS) +\n    bounds.l1_gas.max_price_per_unit\n  );\n}\n\n/**\n * Encode the L2 bound of a V3 transaction\n * @param {ResourceBounds} bounds \n * {l1_gas: {max_amount: u64, max_price_per_unit: u128},\n *  l2_gas: {max_amount: u64, max_price_per_unit: u128}}\n}\n * @returns {bigint} encoded data\n */\nexport function encodeResourceBoundsL2(bounds: ResourceBoundsBN): bigint {\n  return (\n    (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (bounds.l2_gas.max_amount << MAX_PRICE_PER_UNIT_BITS) +\n    bounds.l2_gas.max_price_per_unit\n  );\n}\n\nexport function encodeDataResourceBoundsL1(bounds: ResourceBoundsBN): bigint {\n  return (\n    (L1_DATA_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (bounds.l1_data_gas.max_amount << MAX_PRICE_PER_UNIT_BITS) +\n    bounds.l1_data_gas.max_price_per_unit\n  );\n}\n\n/**\n * hash tip and resource bounds (3 bounds params) V3 RPC 0.8\n */\nexport function hashFeeFieldV3B3(tip: BigNumberish, bounds: ResourceBoundsBN) {\n  const L1Bound = encodeResourceBoundsL1(bounds);\n  const L2Bound = encodeResourceBoundsL2(bounds);\n  const L1Data = encodeDataResourceBoundsL1(bounds);\n  return poseidonHashMany([BigInt(tip), L1Bound, L2Bound, L1Data]);\n}\n\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  senderAddress: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBoundsBN,\n  additionalData: BigNumberish[] = []\n): string {\n  const feeFieldHash = hashFeeFieldV3B3(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    poseidonHashMany(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData),\n  ]);\n  return toHex(poseidonHashMany(dataToHash));\n}\n\n/**\n * Calculate v3 deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  compiledConstructorCalldata: Calldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBoundsBN,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n) {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\n\n/**\n * Calculate v3 declare transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  compiledClassHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBoundsBN,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\n\n/**\n * Calculate v3 invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateInvokeTransactionHash(\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  compiledCalldata: Calldata,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBoundsBN,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), poseidonHashMany(AToBI(compiledCalldata))]\n  );\n}\n","/**\n * Calculate Hashes for v0 - v2 transactions\n */\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable import/extensions */\nimport { StarknetChainId, TransactionHashPrefix } from '../../../global/constants';\nimport { BigNumberish, RawCalldata } from '../../../types';\nimport { starkCurve } from '../../ec';\nimport { toBigInt } from '../../num';\nimport { getSelector } from '../selector';\n\n/**\n * Compute pedersen hash from data\n * @returns format: hex-string - pedersen hash\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0)\n    .toString();\n}\n\n/**\n * Calculate transaction pedersen hash for common properties\n *\n * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)\n * @returns format: hex-string\n */\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  contractAddress: BigNumberish,\n  entryPointSelector: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  additionalData: BigNumberish[] = []\n): string {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData,\n  ];\n  return computeHashOnElements(dataToHash);\n}\n\n/**\n * Calculate declare transaction hash\n * @param classHash hex-string\n * @param compiledClassHash hex-string\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  compiledClassHash?: string\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...(compiledClassHash ? [compiledClassHash] : [])]\n  );\n}\n\n/**\n * Calculate deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawCalldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateTransactionHash(\n  contractAddress: BigNumberish,\n  version: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate the L2 transaction hash generated by a message L1->L2\n * @param {BigNumberish} l1FromAddress L1 account address that paid the message.\n * @param {BigNumberish} l2ToAddress L2 contract address to execute.\n * @param {string | BigNumberish} l2Selector can be a function name (\"bridge_withdraw\") or a number (BigNumberish).\n * @param {RawCalldata} l2Calldata an array of BigNumberish of the raw parameters passed to the above function.\n * @param {BigNumberish} l2ChainId L2 chain ID : from constants.StarknetChainId.xxx\n * @param {BigNumberish} l1Nonce The nonce of the L1 account.\n * @returns {string} hex-string of the L2 transaction hash\n * @example\n * ```typescript\n * const l1FromAddress = \"0x0000000000000000000000008453fc6cd1bcfe8d4dfc069c400b433054d47bdc\";\n * const l2ToAddress = 2158142789748719025684046545159279785659305214176670733242887773692203401023n;\n * const l2Selector = 774397379524139446221206168840917193112228400237242521560346153613428128537n;\n * const payload = [\n *     4543560n,\n *    829565602143178078434185452406102222830667255948n,\n *     3461886633118033953192540141609307739580461579986333346825796013261542798665n,\n *     9000000000000000n,\n *     0n,\n * ];\n * const l1Nonce = 8288n;\n * const result = hash.calculateL2MessageTxHash(l1FromAddress, l2ToAddress, l2Selector, payload, constants.StarknetChainId.SN_SEPOLIA, l1Nonce);\n * // result = \"0x67d959200d65d4ad293aa4b0da21bb050a1f669bce37d215c6edbf041269c07\"\n * ```\n */\nexport function calculateL2MessageTxHash(\n  l1FromAddress: BigNumberish,\n  l2ToAddress: BigNumberish,\n  l2Selector: string | BigNumberish,\n  l2Calldata: RawCalldata,\n  l2ChainId: StarknetChainId,\n  l1Nonce: BigNumberish\n): string {\n  const payload = [l1FromAddress, ...l2Calldata];\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.L1_HANDLER,\n    0,\n    l2ToAddress,\n    getSelector(l2Selector),\n    payload,\n    0,\n    l2ChainId,\n    [l1Nonce]\n  );\n}\n","// TODO rename\nexport * as starkCurve from '@scure/starknet';\nexport * as weierstrass from '@noble/curves/abstract/weierstrass';\n","/**\n * Transaction Hash based on Transaction Version\n */\n\nimport { StarknetChainId } from '../../../global/constants';\nimport { ResourceBoundsBN } from '../../../provider/types/spec.type';\nimport { BigNumberish, Calldata } from '../../../types';\nimport { EDAMode, ETransactionVersion, ETransactionVersion3 } from '../../../types/api';\nimport {\n  calculateDeclareTransactionHash as v3calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v3calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash as v3calculateInvokeTransactionHash,\n} from './v3';\n\nexport { calculateL2MessageTxHash } from './v2';\n/*\n * INVOKE TX HASH\n */\n\ntype Version = typeof ETransactionVersion.V3 | typeof ETransactionVersion.F3;\n\nfunction isV3InvokeTx(args: CalcInvokeTxHashArgs): args is CalcV3InvokeTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV3InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  compiledCalldata: Calldata;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBoundsBN;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcInvokeTxHashArgs = CalcV3InvokeTxHashArgs;\n\nexport function calculateInvokeTransactionHash(args: CalcInvokeTxHashArgs) {\n  if (isV3InvokeTx(args)) {\n    return v3calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  throw new Error('Invalid Tx version for hash calculation');\n}\n\n/*\n * DECLARE TX HASH\n */\nfunction isV3DeclareTx(args: CalcDeclareTxHashArgs): args is CalcV3DeclareTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV3DeclareTxHashArgs = {\n  classHash: string;\n  compiledClassHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBoundsBN;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeclareTxHashArgs = CalcV3DeclareTxHashArgs;\n\nexport function calculateDeclareTransactionHash(args: CalcDeclareTxHashArgs) {\n  if (isV3DeclareTx(args)) {\n    return v3calculateDeclareTransactionHash(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  throw new Error('Invalid Tx version for hash calculation');\n}\n\n/*\n * DEPLOY ACCOUNT TX HASH\n */\n\nfunction isV3DeployAccountTx(\n  args: CalcDeployAccountTxHashArgs\n): args is CalcV3DeployAccountTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV3DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  compiledConstructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBoundsBN;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeployAccountTxHashArgs = CalcV3DeployAccountTxHashArgs;\n\nexport function calculateDeployAccountTransactionHash(args: CalcDeployAccountTxHashArgs) {\n  if (isV3DeployAccountTx(args)) {\n    return v3calculateDeployAccountTransactionHash(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  throw new Error('Invalid Tx version for hash calculation');\n}\n","/**\n * Class Hash\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { ADDR_BOUND, API_VERSION } from '../../global/constants';\nimport {\n  BigNumberish,\n  Builtins,\n  CompiledContract,\n  CompiledSierra,\n  CompiledSierraCasm,\n  ContractEntryPointFields,\n  LegacyCompiledContract,\n  RawArgs,\n  SierraContractEntryPointFields,\n} from '../../types';\nimport { CallData } from '../calldata';\nimport { felt } from '../calldata/cairo';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { parse, stringify } from '../json';\nimport { toHex } from '../num';\nimport { encodeShortString } from '../shortString';\nimport { isString } from '../typed';\n\nexport function computePedersenHash(a: BigNumberish, b: BigNumberish): string {\n  return starkCurve.pedersen(BigInt(a), BigInt(b));\n}\n\nexport function computePoseidonHash(a: BigNumberish, b: BigNumberish): string {\n  return toHex(starkCurve.poseidonHash(BigInt(a), BigInt(b)));\n}\n\n/**\n * Compute Pedersen hash from data\n *\n * @param {BigNumberish[]} data Array of data to compute Pedersen hash on\n * @returns {string} hex-string of Pedersen hash\n *\n * @example\n * ```typescript\n * const result = hash.computeHashOnElements(['0xabc', '0x123', '0xabc123'])\n * // result = 0x148141e8f7db29d005a0187669a56f0790d7e8c2c5b2d780e4d8b9e436a5521\n * ```\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0)\n    .toString();\n}\n\nexport const computePedersenHashOnElements = computeHashOnElements;\n\nexport function computePoseidonHashOnElements(data: BigNumberish[]) {\n  return toHex(poseidonHashMany(data.map((x) => BigInt(x))));\n}\n\n/**\n * Calculate contract address from class hash\n *\n * @param {BigNumberish} salt Salt to be used for hashing\n * @param {BigNumberish} classHash Class hash of contract to generate address for\n * @param {RawArgs} constructorCalldata Call data for contract constructor\n * @param {BigNumberish} deployerAddress Address of contract deployer\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const result = hash.calculateContractAddressFromHash(1234, 0x1cf4fe5d37868d25524cdacb89518d88bf217a9240a1e6fde71cc22c429e0e3, [1234, true, false], 0x052fb1a9ab0db3c4f81d70fea6a2f6e55f57c709a46089b25eeec0e959db3695);\n * // result = 0x5fb03d3a88d8e474976932f927ff6a9e332e06ed36642ea3e8c7e38bf010f76\n * ```\n */\nexport function calculateContractAddressFromHash(\n  salt: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawArgs,\n  deployerAddress: BigNumberish\n): string {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n\n  const CONTRACT_ADDRESS_PREFIX = felt('0x535441524b4e45545f434f4e54524143545f41444452455353'); // Equivalent to 'STARKNET_CONTRACT_ADDRESS'\n\n  const hash = computeHashOnElements([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash,\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\n\nfunction nullSkipReplacer(key: string, value: any) {\n  if (key === 'attributes' || key === 'accessible_scopes') {\n    return Array.isArray(value) && value.length === 0 ? undefined : value;\n  }\n\n  if (key === 'debug_info') {\n    return null;\n  }\n\n  return value === null ? undefined : value;\n}\n\n/**\n * Format json-string without spaces to conform starknet json-string\n * @param {string} json json-string without spaces\n * @returns {string} json-string with additional spaces after `:` and `,`\n * @example\n * ```typescript\n * const result = hash.formatSpaces(\"{'onchain':true,'isStarknet':true}\");\n * // result = \"{'onchain': true, 'isStarknet': true}\"\n * ```\n */\nexport function formatSpaces(json: string): string {\n  let insideQuotes = false;\n  const newString = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const char of json) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === '\\\\') === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      // eslint-disable-next-line no-nested-ternary\n      newString.push(char === ':' ? ': ' : char === ',' ? ', ' : char);\n    }\n  }\n  return newString.join('');\n}\n\n/**\n * Compute hinted class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract} compiledContract\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeHintedClassHash(compiledCairo0);\n * // result = \"0x293eabb06955c0a1e55557014675aa4e7a1fd69896147382b29b2b6b166a2ac\"\n * ``` */\nexport function computeHintedClassHash(compiledContract: LegacyCompiledContract): string {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify(contractClass, nullSkipReplacer));\n  return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));\n}\n\n/**\n * Computes the class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract | string} contract legacy compiled contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeLegacyContractClassHash(compiledCairo0);\n * // result = \"0x4a5cae61fa8312b0a3d0c44658b403d3e4197be80027fd5020ffcdf0c803331\"\n * ```\n */\nexport function computeLegacyContractClassHash(contract: LegacyCompiledContract | string): string {\n  const compiledContract = isString(contract)\n    ? (parse(contract) as LegacyCompiledContract)\n    : contract;\n\n  const apiVersion = toHex(API_VERSION);\n\n  const externalEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const l1HandlerEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const constructorEntryPointHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const builtinsHash = computeHashOnElements(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n\n  const dataHash = computeHashOnElements(compiledContract.program.data);\n\n  return computeHashOnElements([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash,\n  ]);\n}\n\n// Cairo 1 Contract Hashes\n\nfunction hashBuiltins(builtins: Builtins) {\n  return poseidonHashMany(\n    builtins.flatMap((it: any) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\n\nfunction hashEntryPoint(data: ContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return poseidonHashMany(base);\n}\n\n/**\n * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)\n * Each segment is Poseidon hashed.\n * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)\n * @param {CompiledSierraCasm} casm compiled Sierra CASM file content.\n * @returns {bigint} the bytecode hash as bigint.\n * @example\n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./contractC260.casm.json\").toString(\"ascii\"));\n * const result = hash.hashByteCodeSegments(compiledCasm);\n * // result = 80499149343908132326491548897246987792410240503053732367044713070598981699n\n * ```\n */\nexport function hashByteCodeSegments(casm: CompiledSierraCasm): bigint {\n  const byteCode: bigint[] = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths: number[] = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, (segmentStart += len));\n    return [BigInt(len), poseidonHashMany(segment)];\n  });\n  return 1n + poseidonHashMany(hashLeaves);\n}\n\n/**\n * Compute compiled class hash for contract (Cairo 1)\n * @param {CompiledSierraCasm} casm Cairo 1 compiled contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./cairo260.casm.json\").toString(\"ascii\"));\n * const result = hash.computeCompiledClassHash(compiledCasm);\n * // result = \"0x4087905743b4fa2b3affc1fc71333f1390c8c5d1e8ea47d6ba70786de3fc01a\"\n```\n */\nexport function computeCompiledClassHash(casm: CompiledSierraCasm): string {\n  const COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';\n\n  // Hash compiled class version\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash bytecode.\n  const bytecode = casm.bytecode_segment_lengths\n    ? hashByteCodeSegments(casm)\n    : poseidonHashMany(casm.bytecode.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode,\n    ])\n  );\n}\n\nfunction hashEntryPointSierra(data: SierraContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return poseidonHashMany(base);\n}\n\nfunction hashAbi(sierra: CompiledSierra) {\n  const indentString = formatSpaces(stringify(sierra.abi, null));\n  return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));\n}\n\n/**\n * Compute sierra contract class hash (Cairo 1)\n * @param {CompiledSierra} sierra Cairo 1 Sierra contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeSierraContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeSierraContractClassHash(sierra: CompiledSierra): string {\n  const CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';\n\n  // Hash class version\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash abi_hash.\n  const abiHash = hashAbi(sierra);\n\n  // Hash Sierra program.\n  const sierraProgram = poseidonHashMany(sierra.sierra_program.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram,\n    ])\n  );\n}\n\n/**\n * Compute ClassHash (sierra or legacy) based on provided contract\n * @param {CompiledContract | string} contract Cairo 1 contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeContractClassHash(contract: CompiledContract | string): string {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n\n  if ('sierra_program' in compiledContract) {\n    return computeSierraContractClassHash(compiledContract as CompiledSierra);\n  }\n\n  return computeLegacyContractClassHash(compiledContract as LegacyCompiledContract);\n}\n","import { getPublicKey, getStarkKey, utils } from '@scure/starknet';\nimport { gzip, ungzip } from 'pako';\nimport { config } from '../../global/config';\nimport { EstimateFeeResponseOverhead, FeeEstimate } from '../../provider/types/index.type';\nimport {\n  EDAMode,\n  EDataAvailabilityMode,\n  ETransactionVersion,\n  ETransactionVersion3,\n  ResourceBounds,\n  ResourceBoundsBN,\n  ResourceBoundsOverhead,\n} from '../../provider/types/spec.type';\nimport {\n  ArraySignatureType,\n  BigNumberish,\n  CompressedProgram,\n  Program,\n  Signature,\n  UniversalDetails,\n} from '../../types';\nimport {\n  addHexPrefix,\n  arrayBufferToString,\n  atobUniversal,\n  btoaUniversal,\n  buf2hex,\n} from '../encode';\nimport { parse, stringify } from '../json';\nimport {\n  addPercent,\n  bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray,\n  toHex,\n} from '../num';\nimport { isBigInt, isObject, isString } from '../typed';\n\ntype V3Details = Required<\n  Pick<\n    UniversalDetails,\n    | 'tip'\n    | 'paymasterData'\n    | 'accountDeploymentData'\n    | 'nonceDataAvailabilityMode'\n    | 'feeDataAvailabilityMode'\n    | 'resourceBounds'\n  >\n>;\n\n/**\n * Compress compiled Cairo 0 program\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)\n * @param {Program | string} jsonProgram Representing the compiled Cairo 0 program\n * @return {CompressedProgram} Compressed Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result = stark.compressProgram(contractCairo0);\n * // result = \"H4sIAAAAAAAAA+1dC4/bOJL+K4aBu01me7r5EEUyixzQk/TuB...\"\n * ```\n */\nexport function compressProgram(jsonProgram: Program | string): CompressedProgram {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify(jsonProgram);\n  const compressedProgram = gzip(stringified);\n  return btoaUniversal(compressedProgram);\n}\n\n/**\n * Decompress compressed compiled Cairo 0 program\n * @param {CompressedProgram | CompressedProgram[]} base64 Compressed Cairo 0 program\n * @returns Parsed decompressed compiled Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const compressedCairo0 = stark.compressProgram(contractCairo0);\n * const result = stark.decompressProgram(compressedCairo0);\n * // result = {\n * //   abi: [\n * //     {\n * //       inputs: [Array],\n * //       name: 'increase_balance',\n * //       outputs: [],\n * //       type: 'function'\n * //     }\n * //   ],\n * //   entry_points_by_type: { CONSTRUCTOR: [], EXTERNAL: [ [Object], [Object] ], L1_HANDLER: [] },\n * //   program: {\n * //     attributes: [],\n * //     builtins: [ 'pedersen', 'range_check' ],\n * //     compiler_version: '0.10.2',\n * //     data: [\n * //       '0x480680017fff8000',\n * // ...\n * ```\n */\nexport function decompressProgram(base64: CompressedProgram | CompressedProgram[]) {\n  if (Array.isArray(base64)) return base64;\n  const decompressed = arrayBufferToString(ungzip(atobUniversal(base64)));\n  return parse(decompressed);\n}\n\n/**\n * Random Address based on random keyPair\n * @returns {string} an hex string of a random Starknet address\n * @example\n * ```typescript\n * const result = stark.randomAddress();\n * // result = \"0x51fc8126a13cd5ddb29a71ca399cb1e814f086f5af1b502d7151c14929554f\"\n * ```\n */\nexport function randomAddress(): string {\n  const randomKeyPair = utils.randomPrivateKey();\n  return getStarkKey(randomKeyPair);\n}\n\n/**\n * Format Signature to standard type (hex array)\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.formatSignature(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function formatSignature(sig?: Signature): ArraySignatureType {\n  if (!sig) throw Error('formatSignature: provided signature is undefined');\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');\n  }\n}\n\n/**\n * Format Signature to decimal string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToDecimalArray(signature);\n * // result = ['329619989660444495690615805546674399714973829707166906185976654753023887767',\n * //  '2994745480203297689255012826403147585778741462125743754529207781488706428188']\n * ```\n */\nexport function signatureToDecimalArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Format Signature to hex string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToHexArray(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function signatureToHexArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Returns a resource bounds with zero values and no overhead.\n * @returns {ResourceBoundsBN} A resource bounds with zero values and no overhead.\n */\nexport function zeroResourceBounds(): ResourceBoundsBN {\n  return toOverheadResourceBounds(ZeroFeeEstimate(), false);\n}\n\n/**\n * Calculates the maximum resource bounds for fee estimation.\n *\n * @param {FeeEstimate} estimate The estimate for the fee.\n * @param {ResourceBoundsOverhead | false} [overhead] - The percentage overhead added to the max units and max price per unit. Pass `false` to disable overhead.\n * @returns {ResourceBoundsBN} The resource bounds with overhead represented as BigInt.\n * @throws {Error} If the estimate object is undefined or does not have the required properties.\n */\nexport function toOverheadResourceBounds(\n  estimate: FeeEstimate,\n  overhead: ResourceBoundsOverhead | false = config.get('resourceBoundsOverhead')\n): ResourceBoundsBN {\n  return {\n    l2_gas: {\n      max_amount: addPercent(\n        estimate.l2_gas_consumed,\n        overhead !== false ? overhead.l2_gas.max_amount : 0\n      ),\n      max_price_per_unit: addPercent(\n        estimate.l2_gas_price,\n        overhead !== false ? overhead.l2_gas.max_price_per_unit : 0\n      ),\n    },\n    l1_gas: {\n      max_amount: addPercent(\n        estimate.l1_gas_consumed,\n        overhead !== false ? overhead.l1_gas.max_amount : 0\n      ),\n      max_price_per_unit: addPercent(\n        estimate.l1_gas_price,\n        overhead !== false ? overhead.l1_gas.max_price_per_unit : 0\n      ),\n    },\n    l1_data_gas: {\n      max_amount: addPercent(\n        estimate.l1_data_gas_consumed,\n        overhead !== false ? overhead.l1_data_gas.max_amount : 0\n      ),\n      max_price_per_unit: addPercent(\n        estimate.l1_data_gas_price,\n        overhead !== false ? overhead.l1_data_gas.max_price_per_unit : 0\n      ),\n    },\n  };\n}\n\n/**\n * Converts a resource bounds to an estimate fee response. No overhead is applied.\n * @param {ResourceBoundsBN} resourceBounds - The resource bounds to convert.\n * @returns {EstimateFeeResponseOverhead} The estimate fee response.\n * @example\n * ```typescript\n * const resourceBounds = {\n *   l1_gas: { max_amount: 1000n, max_price_per_unit: 100n },\n *   l2_gas: { max_amount: 2000n, max_price_per_unit: 200n },\n *   l1_data_gas: { max_amount: 500n, max_price_per_unit: 50n }\n * };\n * const result = stark.resourceBoundsToEstimateFeeResponse(resourceBounds);\n * // result = {\n * //   resourceBounds: resourceBounds,\n * //   overall_fee: 129000n,\n * //   unit: 'FRI'\n * // }\n * ```\n */\nexport function resourceBoundsToEstimateFeeResponse(\n  resourceBounds: ResourceBoundsBN\n): EstimateFeeResponseOverhead {\n  return {\n    resourceBounds,\n    /**\n     * maximum overall fee for provided resource bounds\n     */\n    overall_fee:\n      resourceBounds.l1_gas.max_amount * resourceBounds.l1_gas.max_price_per_unit +\n      resourceBounds.l1_data_gas.max_amount * resourceBounds.l1_data_gas.max_price_per_unit +\n      resourceBounds.l2_gas.max_amount * resourceBounds.l2_gas.max_price_per_unit,\n    unit: 'FRI',\n  };\n}\n\n/**\n * Calculates the overall fee for a transaction based on resource consumption and prices.\n *\n * The estimated fee for the transaction (in wei or fri, depending on the tx version), equals to:\n * l1_gas_consumed*l1_gas_price + l1_data_gas_consumed*l1_data_gas_price + l2_gas_consumed*l2_gas_price\n *\n * @param {FeeEstimate} estimate - The fee estimate containing gas consumption and price data\n * @param {ResourceBoundsOverhead | false} overhead - The overhead percentage. Pass `false` to disable overhead.\n * @returns {bigint} The calculated overall fee in wei or fri\n * @example\n * ```typescript\n * const estimate = {\n *   l1_gas_consumed: 1000n,\n *   l1_gas_price: 100n,\n *   l1_data_gas_consumed: 500n,\n *   l1_data_gas_price: 50n,\n *   l2_gas_consumed: 200n,\n *   l2_gas_price: 20n\n * };\n * const result = stark.toOverheadOverallFee(estimate, overhead);\n * // result = 1000n * 100n + 500n * 50n + 200n * 20n = 129000n\n * ```\n */\nexport function toOverheadOverallFee(\n  estimate: FeeEstimate,\n  overhead: ResourceBoundsOverhead | false = config.get('resourceBoundsOverhead')\n): bigint {\n  return (\n    addPercent(estimate.l1_gas_consumed, overhead !== false ? overhead.l1_gas.max_amount : 0) *\n      addPercent(\n        estimate.l1_gas_price,\n        overhead !== false ? overhead.l1_gas.max_price_per_unit : 0\n      ) +\n    addPercent(\n      estimate.l1_data_gas_consumed,\n      overhead !== false ? overhead.l1_data_gas.max_amount : 0\n    ) *\n      addPercent(\n        estimate.l1_data_gas_price,\n        overhead !== false ? overhead.l1_data_gas.max_price_per_unit : 0\n      ) +\n    addPercent(estimate.l2_gas_consumed, overhead !== false ? overhead.l2_gas.max_amount : 0) *\n      addPercent(estimate.l2_gas_price, overhead !== false ? overhead.l2_gas.max_price_per_unit : 0)\n  );\n}\n\n/**\n * Mock zero fee API response\n */\nexport function ZeroFeeEstimate(): FeeEstimate {\n  return {\n    l1_gas_consumed: '0',\n    l1_gas_price: '0',\n    l1_data_gas_consumed: '0',\n    l1_data_gas_price: '0',\n    l2_gas_consumed: '0',\n    l2_gas_price: '0',\n    overall_fee: '0',\n    unit: 'FRI',\n  };\n}\n\n/**\n * Converts the data availability mode from EDataAvailabilityMode to EDAMode.\n *\n * @param {EDataAvailabilityMode} dam The data availability mode to be converted.\n * @return {EDAMode} The converted data availability mode.\n * @throws {Error} If the data availability mode is not a valid value.\n * @example\n * ```typescript\n * const result = stark.intDAM(RPC.EDataAvailabilityMode.L1);\n * // result = 0\n * ```\n */\nexport function intDAM(dam: EDataAvailabilityMode): EDAMode {\n  if (dam === EDataAvailabilityMode.L1) return EDAMode.L1;\n  if (dam === EDataAvailabilityMode.L2) return EDAMode.L2;\n  throw Error('EDAM conversion');\n}\n\n/**\n * Convert input versions to ETransactionVersion or throw an error.\n * Returns providedVersion if specified, otherwise returns defaultVersion.\n * @param {BigNumberish} defaultVersion - The default transaction version to use if providedVersion is not specified\n * @param {BigNumberish} [providedVersion] - Optional transaction version that takes precedence if provided\n * @returns {ETransactionVersion} The transaction version - either providedVersion if specified or defaultVersion\n * @throws {Error} If either version is not a valid ETransactionVersion\n * @example\n * ```typescript\n * const result = stark.toTransactionVersion(\"0x100000000000000000000000000000003\", stark.toFeeVersion(2));\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toTransactionVersion(defaultVersion: BigNumberish, providedVersion?: BigNumberish) {\n  const version = providedVersion ? toHex(providedVersion) : toHex(defaultVersion);\n  const validVersions = Object.values(ETransactionVersion3);\n\n  if (!validVersions.includes(version as ETransactionVersion3)) {\n    throw Error(\n      `${providedVersion ? 'providedVersion' : 'defaultVersion'} ${version} is not ETransactionVersion`\n    );\n  }\n\n  return version as ETransactionVersion3;\n}\n\n/**\n * Convert Transaction version to Fee version or throw an error\n * @param {BigNumberish} [providedVersion] 0..3 number representing the transaction version\n * @returns {ETransactionVersion | undefined} the fee estimation version corresponding to the transaction version provided\n * @throws {Error} if the transaction version is unknown\n * @example\n * ```typescript\n * const result = stark.toFeeVersion(2);\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toFeeVersion(providedVersion?: BigNumberish): ETransactionVersion | undefined {\n  if (!providedVersion) return undefined;\n  const version = toHex(providedVersion);\n\n  if (version === ETransactionVersion.V0) return ETransactionVersion.F0;\n  if (version === ETransactionVersion.V1) return ETransactionVersion.F1;\n  if (version === ETransactionVersion.V2) return ETransactionVersion.F2;\n  if (version === ETransactionVersion.V3) return ETransactionVersion.F3;\n\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\n\n/**\n * Return provided or default v3 tx details\n * @param {UniversalDetails} details details of the transaction\n * @return {V3Details} an object including the V3 transaction details.\n * @example\n * ```typescript\n * const detail: UniversalDetails = { tip: 3456n };\n * const result = stark.v3Details(detail);\n * // result = {\n * //   tip: 3456n,\n * //   paymasterData: [],\n * //   accountDeploymentData: [],\n * //   nonceDataAvailabilityMode: 'L1',\n * //   feeDataAvailabilityMode: 'L1',\n * //   resourceBounds: {\n * //     l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n * //     l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }\n * //   }\n * // }\n * ```\n */\n\nexport function v3Details(details: UniversalDetails): V3Details {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? zeroResourceBounds(),\n  };\n}\n\n/**\n * get the hex string of the full public key related to a Starknet private key.\n * @param {BigNumberish} privateKey a 252 bits private key.\n * @returns {string} an hex string of a 520 bit number, representing the full public key related to `privateKey`.\n * @example\n * ```typescript\n * const result = ec.getFullPublicKey(\"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\");\n * // result = \"0x0400b730bd22358612b5a67f8ad52ce80f9e8e893639ade263537e6ef35852e5d3057795f6b090f7c6985ee143f798608a53b3659222c06693c630857a10a92acf\"\n * ```\n */\nexport function getFullPublicKey(privateKey: BigNumberish): string {\n  const privKey = toHex(privateKey);\n  const fullPrivKey = addHexPrefix(buf2hex(getPublicKey(privKey, false)));\n  return fullPrivKey;\n}\n\n/**\n * Converts ResourceBoundsBN (with bigint values) to ResourceBounds (with string values)\n *\n * @param {ResourceBoundsBN} resourceBoundsBN The resource bounds with bigint values\n * @returns {ResourceBounds} The resource bounds with hex string values\n * @example\n * ```typescript\n * const resourceBoundsBN = {\n *   l1_gas: { max_amount: 1000n, max_price_per_unit: 100n },\n *   l2_gas: { max_amount: 2000n, max_price_per_unit: 200n },\n *   l1_data_gas: { max_amount: 500n, max_price_per_unit: 50n }\n * };\n * const result = stark.resourceBoundsToHexString(resourceBoundsBN);\n * // result = {\n * //   l1_gas: { max_amount: '0x3e8', max_price_per_unit: '0x64' },\n * //   l2_gas: { max_amount: '0x7d0', max_price_per_unit: '0xc8' },\n * //   l1_data_gas: { max_amount: '0x1f4', max_price_per_unit: '0x32' }\n * // }\n * ```\n */\nexport function resourceBoundsToHexString(resourceBoundsBN: ResourceBoundsBN): ResourceBounds {\n  const convertBigIntToHex = (obj: any): any => {\n    if (isBigInt(obj)) {\n      return toHex(obj);\n    }\n    if (isObject(obj)) {\n      const result: any = {};\n      Object.keys(obj).forEach((key) => {\n        result[key] = convertBigIntToHex(obj[key as keyof typeof obj]);\n      });\n      return result;\n    }\n    return obj;\n  };\n\n  return convertBigIntToHex(resourceBoundsBN) as ResourceBounds;\n}\n\n/**\n * Converts ResourceBounds (with string values) to ResourceBoundsBN (with BigInt values)\n *\n * @param {ResourceBounds} resourceBounds The resource bounds with string values\n * @returns {ResourceBoundsBN} The resource bounds with BigInt values\n * @example\n * ```typescript\n * const resourceBounds = {\n *   l1_gas: { max_amount: '0x3e8', max_price_per_unit: '0x64' },\n *   l2_gas: { max_amount: '0x7d0', max_price_per_unit: '0xc8' },\n *   l1_data_gas: { max_amount: '0x1f4', max_price_per_unit: '0x32' }\n * };\n * const result = stark.resourceBoundsToBigInt(resourceBounds);\n * // result = {\n * //   l1_gas: { max_amount: 1000n, max_price_per_unit: 100n },\n * //   l2_gas: { max_amount: 2000n, max_price_per_unit: 200n },\n * //   l1_data_gas: { max_amount: 500n, max_price_per_unit: 50n }\n * // }\n * ```\n */\nexport function resourceBoundsToBigInt(resourceBounds: ResourceBounds): ResourceBoundsBN {\n  const convertStringToBigInt = (obj: any): any => {\n    if (isString(obj)) {\n      return BigInt(obj);\n    }\n    if (isObject(obj)) {\n      const result: any = {};\n      Object.keys(obj).forEach((key) => {\n        result[key] = convertStringToBigInt(obj[key as keyof typeof obj]);\n      });\n      return result;\n    }\n    return obj;\n  };\n\n  return convertStringToBigInt(resourceBounds) as ResourceBoundsBN;\n}\n","import { ContractClassResponse } from '../types';\nimport {\n  CairoContract,\n  CompiledSierra,\n  LegacyCompiledContract,\n  LegacyContractClass,\n  SierraContractClass,\n} from '../types/lib/contract/index';\nimport { CompleteDeclareContractPayload, DeclareContractPayload } from '../types/lib/index';\nimport { computeCompiledClassHash, computeContractClassHash } from './hash';\nimport { parse } from './json';\nimport { decompressProgram } from './stark';\nimport { isString } from './typed';\n\n/**\n * Checks if a given contract is in Sierra (Safe Intermediate Representation) format.\n *\n * @param {CairoContract | string} contract - The contract to check. Can be either a CairoContract object or a string representation of the contract.\n * @return {boolean} - Returns true if the contract is a Sierra contract, otherwise false.\n * @example\n * ```typescript\n * const result = isSierra(contract);\n * // result = true | false\n * ```\n */\nexport function isSierra(\n  contract: CairoContract | string\n): contract is SierraContractClass | CompiledSierra {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n  return 'sierra_program' in compiledContract;\n}\n\n/**\n * Extracts contract hashes from `DeclareContractPayload`.\n *\n * @param {DeclareContractPayload} payload - The payload containing contract information.\n * @return {CompleteDeclareContractPayload} - The `CompleteDeclareContractPayload` with extracted contract hashes.\n * @throws {Error} - If extraction of compiledClassHash or classHash fails.\n * @example\n * ```typescript\n * const result = extractContractHashes(contract);\n * // result = {\n * //   contract: ...,\n * //   classHash: ...,\n * //   casm: ...,\n * //   compiledClassHash: ...,\n * // }\n * ```\n */\nexport function extractContractHashes(\n  payload: DeclareContractPayload\n): CompleteDeclareContractPayload {\n  const response = { ...payload } as CompleteDeclareContractPayload;\n\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        'Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash'\n      );\n  }\n\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error('Extract classHash failed, provide (CompiledContract).json file or classHash');\n\n  return response;\n}\n\n/**\n * Helper to redeclare response Cairo0 contract\n */\nexport function contractClassResponseToLegacyCompiledContract(ccr: ContractClassResponse) {\n  if (isSierra(ccr)) {\n    throw Error('ContractClassResponse need to be LegacyContractClass (cairo0 response class)');\n  }\n  const contract = ccr as LegacyContractClass;\n  return { ...contract, program: decompressProgram(contract.program) } as LegacyCompiledContract;\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from './encode';\nimport type { BigNumberish } from '../types';\nimport { assertInRange, toHex } from './num';\nimport { ZERO } from '../global/constants';\nimport assert from './assert';\n\n/**\n * Get random Ethereum private Key.\n * @returns an Hex string\n * @example\n * ```typescript\n * const myPK: string = randomAddress()\n * // result = \"0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83\"\n * ```\n */\nexport function ethRandomPrivateKey(): string {\n  return sanitizeHex(buf2hex(secp256k1.utils.randomPrivateKey()));\n}\n\n/**\n * Get a string formatted for an Ethereum address, without uppercase characters.\n * @param {BigNumberish} address Address of an Ethereum account.\n * @returns an Hex string coded on 20 bytes\n * @example\n * ```typescript\n * const myEthAddress: string = validateAndParseEthAddress(\"0x8359E4B0152ed5A731162D3c7B0D8D56edB165\")\n * // result = \"0x008359e4b0152ed5a731162d3c7b0d8d56edb165\"\n * ```\n */\nexport function validateAndParseEthAddress(address: BigNumberish): string {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, 'Ethereum Address ');\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, '0'));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), 'Invalid Ethereum Address Format');\n  return result;\n}\n","import { LibraryError } from '../errors';\n\nexport default (typeof globalThis !== 'undefined' && globalThis.fetch.bind(globalThis)) ||\n  (typeof window !== 'undefined' && window.fetch.bind(window)) ||\n  (typeof global !== 'undefined' && global.fetch.bind(global)) ||\n  ((() => {\n    throw new LibraryError(\n      \"'fetch()' not detected, use the 'baseFetch' constructor parameter to set it\"\n    );\n  }) as WindowOrWorkerGlobalScope['fetch']);\n","import { config } from '../global/config';\nimport { NetworkName, RPC_DEFAULT_NODES, SupportedRpcVersion } from '../global/constants';\nimport { logger } from '../global/logger';\nimport {\n  Abi,\n  BlockIdentifier,\n  BlockTag,\n  CompiledContract,\n  CompiledSierra,\n  ContractClass,\n  LegacyContractClass,\n  SierraContractClass,\n} from '../types';\nimport { isSierra } from './contract';\nimport { formatSpaces } from './hash';\nimport { parse, stringify } from './json';\nimport { isHex, toHex } from './num';\nimport { toApiVersion } from './resolve';\nimport { isDecimalString } from './shortString';\nimport { compressProgram } from './stark';\nimport { isBigInt, isNumber, isString } from './typed';\n\n/**\n * Helper - Async Sleep for 'delay' time\n *\n * @param {number} delay - Number of milliseconds to delay\n * @returns {Promise<unknown>}\n * @example\n * ```typescript\n * await provider.wait(1000) // 1000 milliseconds == 1 second\n * ```\n */\nexport function wait(delay: number): Promise<unknown> {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\n\n/**\n * Create Sierra compressed Contract Class from a given Compiled Sierra\n *\n * CompiledSierra -> SierraContractClass\n *\n * @param {CompiledSierra} contract sierra code from the Cairo compiler\n * @returns {SierraContractClass} compressed Sierra\n * @example\n * ```typescript\n * const result = provider.createSierraContractClass({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function createSierraContractClass(contract: CompiledSierra): SierraContractClass {\n  const result = { ...contract } as any;\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify(contract.abi));\n  result.sierra_program = formatSpaces(stringify(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\n\n/**\n * Create a compressed contract from a given compiled Cairo 0 & 1 contract or a string.\n * Parse contract string to json and compile contract.sierra_program or contract.program property\n * @param {CompiledContract | string} contract - Compiled Cairo 0 or Cairo 1 contract, or string\n * @returns {ContractClass} Cairo 0 or Cairo 1 compressed contract\n * @example\n * ```typescript\n * const result = provider.parseContract({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function parseContract(contract: CompiledContract | string): ContractClass {\n  const parsedContract = isString(contract) ? (parse(contract) as CompiledContract) : contract;\n\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...('program' in parsedContract && { program: compressProgram(parsedContract.program) }),\n    } as LegacyContractClass;\n  }\n\n  return createSierraContractClass(parsedContract as CompiledSierra) as SierraContractClass;\n}\n\n// TODO: Check if something like this exist\n/**\n * Extract the ABI from a given ContractClass.\n * @param contract ContractClass\n * @returns Abi\n */\nexport function extractAbi(contract: ContractClass): Abi {\n  return isString(contract.abi) ? parse(contract.abi) : contract.abi;\n}\n\n/**\n * Return randomly select available public node\n * @param {NetworkName} networkName NetworkName\n * @param {boolean} mute mute public node warning\n * @returns {string} default node url\n * @example\n * ```typescript\n * const result= provider.getDefaultNodeUrl(constants.NetworkName.SN_MAIN,false);\n * // console : \"Using default public node url, please provide nodeUrl in provider options!\"\n * // result = \"https://starknet-mainnet.public.blastapi.io/rpc/v0_7\"\n * ```\n */\nexport const getDefaultNodeUrl = (\n  networkName?: NetworkName,\n  mute: boolean = false,\n  rpcVersion?: SupportedRpcVersion\n): string => {\n  if (!mute) {\n    logger.info('Using default public node url, please provide nodeUrl in provider options!');\n  }\n  const rpcNodes = getDefaultNodes(rpcVersion ?? config.get('rpcVersion'));\n\n  const nodes = rpcNodes[networkName ?? NetworkName.SN_SEPOLIA];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\n\n/**\n * return Defaults RPC Nodes endpoints\n */\nexport function getDefaultNodes(rpcVersion: SupportedRpcVersion) {\n  const nodes: any = { ...RPC_DEFAULT_NODES };\n\n  Object.keys(nodes).forEach(function (key, _) {\n    nodes[key] = nodes[key].map((it: any) => {\n      return `${it}${toApiVersion(rpcVersion)}`;\n    });\n  });\n\n  return nodes;\n}\n\n/**\n * Return supported RPC versions\n * @returns {SupportedRpcVersion[]} available RPC versions\n */\nexport function getSupportedRpcVersions(): SupportedRpcVersion[] {\n  return [...new Set(Object.values(SupportedRpcVersion))];\n}\n\nexport const validBlockTags = Object.values(BlockTag);\n\n/**\n * This class is formatting the identifier of a block.\n *\n * hex string and BigInt are detected as block hashes. identifier return { block_hash: hash }\n *\n * decimal string and number are detected as block numbers. identifier return { block_number: number }\n *\n * text string are detected as block tag. identifier return tag\n *\n * null is detected as 'pending' block tag. identifier return 'pending'\n * @example\n * ```typescript\n * const result = new provider.Block(null).identifier;\n * // result = \"pending\"\n * ```\n */\nexport class Block {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag: BlockIdentifier = null;\n\n  private setIdentifier(__identifier: BlockIdentifier): void {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier as BlockTag)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = BlockTag.LATEST;\n    }\n\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier(): any {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n\n    return `blockNumber=${this.tag}`;\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier(): any {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n\n    return this.tag;\n  }\n\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  valueOf = () => this.number;\n\n  toString = () => this.hash;\n}\n","import { SupportedRpcVersion } from '../global/constants';\nimport {\n  ETransactionVersion,\n  GetBlockResponse,\n  GetTransactionReceiptResponse,\n  InvocationsDetailsWithNonce,\n  PendingBlock,\n  PendingStateUpdate,\n  StateUpdateResponse,\n  V3TransactionDetails,\n} from '../types';\nimport { toHex } from './num';\n\n/**\n * Check if the given transaction details is a V3 transaction.\n *\n * @param {InvocationsDetailsWithNonce} details The transaction details to be checked.\n * @return {boolean} Returns true if the transaction is a V3 transaction, otherwise false.\n * @example\n * ```typescript\n * const invocation: InvocationsDetailsWithNonce = {\n *   nonce: 1,\n *   version: 3,\n *   maxFee: 10 ** 15,\n *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n *   tip: 10 ** 13,\n *   paymasterData: [],\n *   resourceBounds: {\n *       l1_gas: { max_amount: num.toHex(10 ** 14), max_price_per_unit: num.toHex(50) },\n *       l2_gas: { max_amount: num.toHex(0), max_price_per_unit: num.toHex(0) }}};\n * const result = provider.isV3Tx(invocation);\n * // result = true\n * ```\n */\nexport function isV3Tx(details: InvocationsDetailsWithNonce): details is V3TransactionDetails {\n  const version = details.version ? toHex(details.version) : ETransactionVersion.V3;\n  return version === ETransactionVersion.V3 || version === ETransactionVersion.F3;\n}\n\n/**\n * Determines if the provided version matches the specified version.\n * Version must be formatted \"major.minor.patch\" using dot delimiters.\n * Use wildcard * or unspecified to match 'any' value on the position.\n * ex. 7.3.* == 7.3.15, * == 1.1.1, 0.8 == 0.8.5. '' != 0.8.5\n *\n *\n * @param {string} expected version.\n * @param {string} provided to check against the expected version.\n * @returns {boolean} True if the response matches the version, false otherwise.\n * @example\n * ``` typescript\n * const result = provider.isVersion(\"0.7\",\"0.7.1\");\n * // result = true\n * ```\n */\nexport function isVersion(expected: string, provided: string): boolean {\n  const expectedParts = expected.split('.');\n  const providedParts = provided.split('.');\n\n  return expectedParts.every((part, index) => part === '*' || part === providedParts[index]);\n}\n\n/**\n * Define if provided version is SDK supported rpc specification version\n */\nexport function isSupportedSpecVersion(\n  version: string,\n  options: { allowAnyPatchVersion: boolean } = { allowAnyPatchVersion: false }\n): version is SupportedRpcVersion {\n  return Object.values(SupportedRpcVersion).some((v) =>\n    isVersion(options.allowAnyPatchVersion ? toAnyPatchVersion(v) : v, version)\n  );\n}\n\n/**\n * Convert fixed version to any patch version.\n * ex. 0.8.1 -> 0.8.*\n */\nexport function toAnyPatchVersion(version: string) {\n  const parts = version.split('.');\n  if (parts.length < 3) {\n    return version;\n  }\n  return `${parts[0]}.${parts[1]}.*`;\n}\n\n/**\n * Convert version to API format.\n * ex. '0.8.1' -> 'v0_8', '0.8' -> 'v0_8'\n * @param {string} version\n * @returns {string}\n */\nexport function toApiVersion(version: string): string {\n  const [major, minor] = version.replace(/^v/, '').split('.');\n  return `v${major}_${minor}`;\n}\n\n/**\n * Guard Pending Block\n * @param {GetBlockResponse} response answer of myProvider.getBlock()\n * @return {boolean} true if block is the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlock(\"pending\");\n * const result = provider.isPendingBlock(block);\n * // result = true\n * ```\n */\nexport function isPendingBlock(response: GetBlockResponse): response is PendingBlock {\n  return response.status === 'PENDING';\n}\n\n/**\n * Guard Pending Transaction\n * @param {GetTransactionReceiptResponse} response transaction Receipt\n * @return {boolean} true if the transaction is part of the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlockWithTxs(\"pending\");\n * const txR = await myProvider.getTransactionReceipt(block.transactions[0].transaction_hash);\n * const result = provider.isPendingTransaction(txR);\n * // result = true\n * ```\n */\nexport function isPendingTransaction(response: GetTransactionReceiptResponse): boolean {\n  return !('block_hash' in response);\n}\n\n/**\n * Guard Pending State Update\n * @param {StateUpdateResponse} response State of a block\n * @return {boolean} true if the block is pending\n * @example\n * ```typescript\n * const state: StateUpdateResponse = await myProvider.getStateUpdate(\"pending\");\n * const result = provider.isPendingStateUpdate(state);\n * // result = true\n * ```\n */\nexport function isPendingStateUpdate(\n  response: StateUpdateResponse\n): response is PendingStateUpdate {\n  return !('block_hash' in response);\n}\n","export * from './getCompiledCalldata';\nexport * from './transaction';\n","import type { Calldata, RawArgs } from '../../types/lib';\n\n/**\n * Extract compiled calldata from args or execute callback\n */\nexport function getCompiledCalldata(constructorArguments: RawArgs, callback: Function): Calldata {\n  // Check if Calldata in args or args[0] else compile\n  if (Array.isArray(constructorArguments) && '__compiled__' in constructorArguments)\n    return constructorArguments as Calldata;\n  if (\n    Array.isArray(constructorArguments) &&\n    Array.isArray(constructorArguments[0]) &&\n    '__compiled__' in constructorArguments[0]\n  )\n    return constructorArguments[0] as Calldata;\n  return callback();\n}\n","import { ETransactionVersion } from '../../provider/types/spec.type';\nimport { BigNumberish, CairoVersion, Call, Calldata, ParsedStruct, RawArgs } from '../../types';\nimport { CallData } from '../calldata';\nimport { getSelectorFromName } from '../hash';\nimport { toBigInt } from '../num';\n\n/**\n * Transforms a list of Calls, each with their own calldata, into\n * two arrays: one with the entry points, and one with the concatenated calldata\n * @param {Call[]} calls the list of calls to transform.\n * @returns {callArray: ParsedStruct[], calldata: BigNumberish[]} An object containing two arrays: callArray and calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1,2,3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4,5,6]\n * \t}\n * ];\n * const result = transaction.transformCallsToMulticallArrays(calls);\n * // result = {\n * // callArray: [\n * // { to: \"0x1234567890123456789012345678901234567890\", selector: \"1234567890\",\n * // data_offset: \"0\", data_len: \"3\" },\n * // { to: \"0x0987654321098765432109876543210987654321\", selector: \"1234567890\",\n * // data_offset: \"0987654321\", data_offset: \"3\", data_len: \"3\"}\n * // ], calldata: [1, 2, 3, 4, 5, 6]\n * // }\n * ```\n */\nexport const transformCallsToMulticallArrays = (calls: Call[]) => {\n  const callArray: ParsedStruct[] = [];\n  const calldata: BigNumberish[] = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString(),\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata }),\n  };\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform\n * @returns {Calldata} the Cairo 0 `__execute__` calldata\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699', '0',\n * //   '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '3', '6', '1', '2', '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata = (calls: Call[]) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata] as Calldata;\n};\n\n/**\n * Transforms a list of calls into the Cairo 1 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform.\n * @returns {Calldata} the Cairo 1 `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata_cairo1(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata_cairo1 = (calls: Call[]) => {\n  // ensure property order\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata:\n      Array.isArray(call.calldata) && '__compiled__' in call.calldata\n        ? call.calldata // Calldata type\n        : CallData.compile(call.calldata as RawArgs), // RawArgsObject | RawArgsArray type\n  }));\n\n  return CallData.compile({ orderCalls });\n};\n\n/**\n * Create `__execute__` Calldata from Calls based on Cairo versions.\n * @param {Call[]} calls the list of calls to transform\n * @param {CairoVersion} cairoVersion the Cairo version\n * @returns {Calldata} the `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.getExecuteCalldata(calls, '1');\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const getExecuteCalldata = (calls: Call[], cairoVersion: CairoVersion = '0') => {\n  if (cairoVersion === '1') {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\n\n/**\n * Return transaction versions based on version type, default version type is 'transaction'.\n * @param {'fee' | 'transaction'} [versionType] the type of version (\"fee\" or \"transaction\")\n * @returns {v1: ETransactionVersion, v2: ETransactionVersion, v3: ETransactionVersion} an object containing the transaction versions.\n * @example\n * ```typescript\n * const result = transaction.getVersionsByType('fee');\n * // result = {\n * //   v1: '0x100000000000000000000000000000001',\n * //   v2: '0x100000000000000000000000000000002',\n * //   v3: '0x100000000000000000000000000000003'\n * // }\n * ```\n */\nexport function getVersionsByType(versionType?: 'fee' | 'transaction') {\n  return versionType === 'fee'\n    ? {\n        v3: ETransactionVersion.F3,\n      }\n    : { v3: ETransactionVersion.V3 };\n}\n","import {\n  NetworkName,\n  StarknetChainId,\n  SupportedRpcVersion,\n  SYSTEM_MESSAGES,\n} from '../global/constants';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  isRPC08Plus_ResourceBoundsBN,\n  RPC_ERROR,\n  RpcProviderOptions,\n  waitForTransactionOptions,\n  type fastWaitForTransactionOptions,\n} from '../types';\nimport assert from '../utils/assert';\nimport { ETransactionType, JRPC, RPCSPEC09 as RPC } from '../types/api';\nimport { BatchClient } from '../utils/batch';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { LibraryError, RpcError } from '../utils/errors';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/connect/fetch';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { isNumber } from '../utils/typed';\nimport {\n  bigNumberishArrayToHexadecimalStringArray,\n  getHexStringArray,\n  toHex,\n  toStorageKey,\n} from '../utils/num';\nimport { Block, getDefaultNodeUrl, wait } from '../utils/provider';\nimport { isSupportedSpecVersion, isV3Tx, isVersion } from '../utils/resolve';\nimport {\n  decompressProgram,\n  signatureToHexArray,\n  resourceBoundsToHexString,\n  toTransactionVersion,\n} from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\nimport { logger } from '../global/logger';\nimport { config } from '../global/config';\n// TODO: check if we can filet type before entering to this method, as so to specify here only RPC 0.8 types\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.LATEST,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  readonly id = 'RPC090';\n\n  /**\n   * RPC specification version this Channel class implements\n   */\n  readonly channelSpecVersion: SupportedRpcVersion = SupportedRpcVersion.v0_9_0;\n\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  readonly retries: number;\n\n  readonly waitMode: boolean; // behave like web2 rpc and return when tx is processed\n\n  private chainId?: StarknetChainId;\n\n  /**\n   * RPC specification version of the connected node\n   */\n  private specVersion?: SupportedRpcVersion;\n\n  private transactionRetryIntervalFallback?: number;\n\n  private batchClient?: BatchClient<RPC.Methods>;\n\n  private baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode,\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(\n        nodeUrl as NetworkName,\n        optionsOrProvider?.default,\n        this.channelSpecVersion\n      );\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(\n        undefined,\n        optionsOrProvider?.default,\n        this.channelSpecVersion\n      );\n    }\n    this.baseFetch = baseFetch || config.get('fetch') || fetch;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.retries = retries ?? defaultOptions.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n\n    this.requestId = 0;\n\n    if (isNumber(batch)) {\n      this.batchClient = new BatchClient<RPC.Methods>({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch,\n        rpcMethods: {} as RPC.Methods, // Type information only, not used at runtime\n      });\n    }\n\n    logger.debug('Using Channel', this.id);\n  }\n\n  public readSpecVersion() {\n    return this.specVersion;\n  }\n\n  private get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5000;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      throw new RpcError(rpcError as RPC_ERROR, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      if (this.batchClient) {\n        const { error, result } = await this.batchClient.fetch(\n          method,\n          params,\n          (this.requestId += 1)\n        );\n        this.errorHandler(method, params, error);\n        return result as RPC.Methods[T]['result'];\n      }\n\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  /**\n   * fetch rpc node specVersion\n   * @example this.specVersion = \"0.7.1\"\n   */\n  public getSpecVersion() {\n    return this.fetchEndpoint('starknet_specVersion');\n  }\n\n  /**\n   * fetch if undefined else just return this.specVersion\n   * @example this.specVersion = \"0.8.1\"\n   */\n  public async setUpSpecVersion() {\n    if (!this.specVersion) {\n      const unknownSpecVersion = await this.fetchEndpoint('starknet_specVersion');\n\n      // check if the channel is compatible with the node\n      if (!isVersion(this.channelSpecVersion, unknownSpecVersion)) {\n        logger.error(SYSTEM_MESSAGES.channelVersionMismatch, {\n          channelId: this.id,\n          channelSpecVersion: this.channelSpecVersion,\n          nodeSpecVersion: this.specVersion,\n        });\n      }\n\n      if (!isSupportedSpecVersion(unknownSpecVersion)) {\n        throw new LibraryError(`${SYSTEM_MESSAGES.unsupportedSpecVersion}, channelId: ${this.id}`);\n      }\n\n      this.specVersion = unknownSpecVersion;\n    }\n    return this.specVersion;\n  }\n\n  // TODO: New Method add test\n  /**\n   * Given an l1 tx hash, returns the associated l1_handler tx hashes and statuses for all L1 -> L2 messages sent by the l1 transaction, ordered by the l1 tx sending order\n   */\n  public getMessagesStatus(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getMessagesStatus', {\n      transaction_hash,\n    });\n  }\n\n  // TODO: New Method add test\n  public getStorageProof(\n    classHashes: BigNumberish[] = [],\n    contractAddresses: BigNumberish[] = [],\n    contractsStorageKeys: RPC.CONTRACT_STORAGE_KEYS[] = [], // TODO: allow BigNUmberish[] and fix formatting before request\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const class_hashes = bigNumberishArrayToHexadecimalStringArray(classHashes);\n    const contract_addresses = bigNumberishArrayToHexadecimalStringArray(contractAddresses);\n\n    return this.fetchEndpoint('starknet_getStorageProof', {\n      block_id,\n      class_hashes,\n      contract_addresses,\n      contracts_storage_keys: contractsStorageKeys,\n    });\n  }\n\n  // TODO: New Method add test\n  public getCompiledCasm(classHash: BigNumberish): Promise<RPC.CASM_COMPILED_CONTRACT_CLASS> {\n    const class_hash = toHex(classHash);\n\n    return this.fetchEndpoint('starknet_getCompiledCasm', {\n      class_hash,\n    });\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockWithReceipts(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates: any = options?.errorStates ?? [];\n    const successStates: any = options?.successStates ?? [\n      // RPC.ETransactionExecutionStatus.SUCCEEDED, // UDC  on SUCCEEDED + pre_confirmed had no proper events to parse UDC\n      RPC.ETransactionFinalityStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionFinalityStatus.ACCEPTED_ON_L1,\n    ];\n\n    const txLife: string[] = [];\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n        txLife.push(txStatus.finality_status);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (error instanceof RpcError && error.isType('TXN_HASH_NOT_FOUND')) {\n          logger.info('txLife: ', txLife);\n          const errorMessages: Record<string, string> = {\n            [RPC.ETransactionStatus.RECEIVED]: SYSTEM_MESSAGES.txEvictedFromMempool,\n            [RPC.ETransactionStatus.PRE_CONFIRMED]: SYSTEM_MESSAGES.consensusFailed,\n            [RPC.ETransactionStatus.CANDIDATE]: SYSTEM_MESSAGES.txFailsBlockBuildingValidation,\n          };\n          const errorMessage = errorMessages[txLife.at(-1) as string];\n          if (errorMessage) {\n            throw new Error(errorMessage);\n          }\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.TXN_RECEIPT;\n  }\n\n  public async fastWaitForTransaction(\n    txHash: BigNumberish,\n    address: string,\n    initNonceBN: BigNumberish,\n    options?: fastWaitForTransactionOptions\n  ): Promise<boolean> {\n    const initNonce = BigInt(initNonceBN);\n    let retries = options?.retries ?? 50;\n    const retryInterval = options?.retryInterval ?? 500; // 0.5s\n    const errorStates: string[] = [RPC.ETransactionExecutionStatus.REVERTED];\n    const successStates: string[] = [\n      RPC.ETransactionFinalityStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionFinalityStatus.ACCEPTED_ON_L1,\n      RPC.ETransactionFinalityStatus.PRE_CONFIRMED,\n    ];\n    let txStatus: RPC.TransactionStatus;\n    const start = new Date().getTime();\n    while (retries > 0) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n\n      // eslint-disable-next-line no-await-in-loop\n      txStatus = await this.getTransactionStatus(txHash);\n      logger.info(\n        `${retries} ${JSON.stringify(txStatus)} ${(new Date().getTime() - start) / 1000}s.`\n      );\n      const executionStatus = txStatus.execution_status ?? '';\n      const finalityStatus = txStatus.finality_status;\n      if (errorStates.includes(executionStatus)) {\n        const message = `${executionStatus}: ${finalityStatus}`;\n        const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n        error.response = txStatus;\n        throw error;\n      } else if (successStates.includes(finalityStatus)) {\n        let currentNonce = initNonce;\n        while (currentNonce === initNonce && retries > 0) {\n          // eslint-disable-next-line no-await-in-loop\n          currentNonce = BigInt(await this.getNonceForAddress(address, BlockTag.PRE_CONFIRMED));\n          logger.info(\n            `${retries} Checking new nonce ${currentNonce} ${(new Date().getTime() - start) / 1000}s.`\n          );\n          if (currentNonce !== initNonce) return true;\n          // eslint-disable-next-line no-await-in-loop\n          await wait(retryInterval);\n          retries -= 1;\n        }\n        return false;\n      }\n\n      retries -= 1;\n    }\n    return false;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions = {}\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const flags = {\n      simulation_flags: (skipValidate\n        ? [RPC.ESimulationFlag.SKIP_VALIDATE]\n        : []) as RPC.Methods['starknet_estimateFee']['params']['simulation_flags'],\n    };\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    const transaction = this.buildTransaction(\n      {\n        type: ETransactionType.INVOKE,\n        ...functionInvocation,\n        ...details,\n      },\n      'transaction'\n    );\n\n    const promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n      invoke_transaction: transaction,\n    });\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    declareTransaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    const transaction = this.buildTransaction(\n      {\n        type: ETransactionType.DECLARE,\n        ...declareTransaction,\n        ...details,\n      },\n      'transaction'\n    );\n\n    const promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n      declare_transaction: transaction,\n    });\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    deployAccountTransaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    const transaction = this.buildTransaction(\n      {\n        type: ETransactionType.DEPLOY_ACCOUNT,\n        ...deployAccountTransaction,\n        ...details,\n      },\n      'transaction'\n    );\n\n    const promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n      deploy_account_transaction: transaction,\n    });\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  // Generic buildTransaction that automatically narrows return type based on input\n  public buildTransaction<T extends AccountInvocationItem>(\n    invocation: T,\n    versionType?: 'fee' | 'transaction'\n  ): T extends { type: typeof ETransactionType.INVOKE }\n    ? RPC.INVOKE_TXN_V3\n    : T extends { type: typeof ETransactionType.DECLARE }\n      ? RPC.BROADCASTED_DECLARE_TXN_V3\n      : T extends { type: typeof ETransactionType.DEPLOY_ACCOUNT }\n        ? RPC.DEPLOY_ACCOUNT_TXN_V3\n        : never {\n    const defaultVersions = getVersionsByType(versionType);\n\n    // V0,V1,V2 not supported on RPC 0.9\n    assert(isV3Tx(invocation), SYSTEM_MESSAGES.legacyTxRPC08Message);\n\n    // V3 - Add resource bounds validation for transaction building (not fee estimation)\n    assert(\n      versionType !== 'transaction' || isRPC08Plus_ResourceBoundsBN(invocation.resourceBounds),\n      SYSTEM_MESSAGES.SWOldV3\n    );\n\n    const details = {\n      signature: signatureToHexArray(invocation.signature),\n      nonce: toHex(invocation.nonce),\n      resource_bounds: resourceBoundsToHexString(invocation.resourceBounds),\n      tip: toHex(invocation.tip),\n      paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n      nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n      fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n      account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      version: toTransactionVersion(defaultVersions.v3, invocation.version),\n    };\n\n    if (invocation.type === ETransactionType.INVOKE) {\n      const btx: RPC.INVOKE_TXN_V3 = {\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        ...details,\n      };\n      return btx as any; // This 'as any' is internal to the generic function - the external API is type-safe\n    }\n    if (invocation.type === ETransactionType.DECLARE) {\n      // Sierra contracts required for DECLARE transactions in RPC 0.9\n      assert(isSierra(invocation.contract), 'Declaring non Sierra contract using RPC 0.9');\n\n      const btx: RPC.BROADCASTED_DECLARE_TXN_V3 = {\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        ...details,\n      };\n      return btx as any; // This 'as any' is internal to the generic function - the external API is type-safe\n    }\n    if (invocation.type === ETransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      const btx: RPC.DEPLOY_ACCOUNT_TXN_V3 = {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        ...restDetails,\n      };\n      return btx as any; // This 'as any' is internal to the generic function - the external API is type-safe\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","/* eslint-disable max-classes-per-file */\ntype Listener<T> = (data: T) => void;\n\nexport class EventEmitter<T extends Record<string, any>> {\n  private listeners: { [K in keyof T]?: Listener<T[K]>[] } = {};\n\n  public on<K extends keyof T>(event: K, listener: Listener<T[K]>): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(listener);\n  }\n\n  public off<K extends keyof T>(event: K, listener: Listener<T[K]>): void {\n    if (!this.listeners[event]) {\n      return;\n    }\n    this.listeners[event] = this.listeners[event]!.filter((l) => l !== listener);\n  }\n\n  public emit<K extends keyof T>(event: K, data: T[K]): void {\n    if (this.listeners[event]) {\n      this.listeners[event]!.forEach((listener) => listener(data));\n    }\n  }\n\n  public clear(): void {\n    this.listeners = {};\n  }\n}\n","import { LibraryError } from '../errors';\n\nexport default (typeof WebSocket !== 'undefined' && WebSocket) ||\n  (typeof globalThis !== 'undefined' && globalThis.WebSocket) ||\n  (typeof window !== 'undefined' && window.WebSocket && window.WebSocket.bind(window)) ||\n  (typeof global !== 'undefined' && global.WebSocket) ||\n  (class {\n    constructor() {\n      throw new LibraryError(\n        \"WebSocket module not detected, use the 'websocket' constructor parameter to set a compatible connection\"\n      );\n    }\n  } as unknown as typeof WebSocket);\n","/* eslint-disable no-underscore-dangle */\nimport type { SUBSCRIPTION_ID } from '../../types/api';\nimport { logger } from '../../global/logger';\nimport type { WebSocketChannel } from './ws_0_9';\nimport { EventEmitter } from '../../utils/eventEmitter';\n\ntype SubscriptionEvents<T> = {\n  event: T;\n  error: Error;\n  unsubscribe: void;\n};\n\n/**\n * Options for creating a new Subscription instance\n */\nexport type SubscriptionOptions = {\n  /** The containing WebSocketChannel instance */\n  channel: WebSocketChannel;\n  /** The JSON-RPC method used to create this subscription */\n  method: string;\n  /** The parameters used to create this subscription (optional, defaults to empty object) */\n  params?: object;\n  /** The unique identifier for this subscription */\n  id: SUBSCRIPTION_ID;\n  /** The maximum number of events to buffer */\n  maxBufferSize: number;\n};\n\n/**\n * Represents an active WebSocket subscription.\n *\n * This class should not be instantiated directly. It is returned by the\n * `subscribe` methods on the `WebSocketChannel`.\n *\n * @template T - The type of data expected from the subscription event.\n * @example\n * ```typescript\n * const channel = new WebSocketChannel({ nodeUrl: 'YOUR_NODE_URL' });\n * await channel.waitForConnection();\n *\n * // The 'sub' object is an instance of the Subscription class.\n * const sub = await channel.subscribeNewHeads();\n *\n * sub.on((data) => {\n *   console.log('Received new head:', data);\n * });\n *\n * // ... later\n * await sub.unsubscribe();\n * ```\n */\nexport class Subscription<T = any> {\n  /**\n   * The containing `WebSocketChannel` instance.\n   * @internal\n   */\n  public channel: WebSocketChannel;\n\n  /**\n   * The JSON-RPC method used to create this subscription.\n   * @internal\n   */\n  public method: string;\n\n  /**\n   * The parameters used to create this subscription.\n   * @internal\n   */\n  public params: any;\n\n  /**\n   * The unique identifier for this subscription.\n   * @internal\n   */\n  public id: SUBSCRIPTION_ID;\n\n  private events = new EventEmitter<SubscriptionEvents<T>>();\n\n  private buffer: T[] = [];\n\n  private maxBufferSize: number;\n\n  private handler: ((data: T) => void) | null = null;\n\n  private _isClosed = false;\n\n  /**\n   * @internal\n   * @param options - Subscription configuration options\n   */\n  constructor(options: SubscriptionOptions) {\n    this.channel = options.channel;\n    this.method = options.method;\n    this.params = options.params ?? {};\n    this.id = options.id;\n    this.maxBufferSize = options.maxBufferSize;\n  }\n\n  /**\n   * Indicates if the subscription has been closed.\n   * @returns {boolean} `true` if unsubscribed, `false` otherwise.\n   */\n  public get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * Internal method to handle incoming events from the WebSocket channel.\n   * If a handler is attached, it's invoked immediately. Otherwise, the event is buffered.\n   * @internal\n   * @param {T} data - The event data.\n   */\n  public _handleEvent(data: T): void {\n    if (this.handler) {\n      this.handler(data);\n    } else {\n      if (this.buffer.length >= this.maxBufferSize) {\n        const droppedEvent = this.buffer.shift(); // Drop the oldest event.\n        logger.warn(`Subscription ${this.id}: Buffer full. Dropping oldest event:`, droppedEvent);\n      }\n      this.buffer.push(data);\n    }\n  }\n\n  /**\n   * Attaches a handler function to be called for each event.\n   *\n   * When a handler is attached, any buffered events will be passed to it sequentially.\n   * Subsequent events will be passed directly as they arrive.\n   *\n   * @param {(data: T) => void} handler - The function to call with event data.\n   * @throws {Error} If a handler is already attached to this subscription.\n   */\n  public on(handler: (data: T) => void): void {\n    if (this.handler) {\n      // To avoid complexity, we only allow one handler at a time.\n      // Users can implement their own multi-handler logic if needed.\n      throw new Error('A handler is already attached to this subscription.');\n    }\n    this.handler = handler;\n\n    // Process the buffer.\n    while (this.buffer.length > 0) {\n      const event = this.buffer.shift();\n      if (event) {\n        this.handler(event);\n      }\n    }\n  }\n\n  /**\n   * Sends an unsubscribe request to the node and cleans up local resources.\n   * @returns {Promise<boolean>} A Promise that resolves to `true` if the unsubscription was successful.\n   */\n  public async unsubscribe(): Promise<boolean> {\n    if (this._isClosed) {\n      return true; // Already unsubscribed, treat as success.\n    }\n    const success = await this.channel.unsubscribe(this.id);\n    if (success) {\n      this._isClosed = true;\n      this.channel.removeSubscription(this.id);\n      this.events.emit('unsubscribe', undefined);\n      this.events.clear(); // Clean up all listeners.\n    }\n    return success;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport {\n  JRPC,\n  StarknetEventsEvent,\n  NewHeadsEvent,\n  TransactionsStatusEvent,\n  NewTransactionReceiptsEvent,\n  TXN_STATUS_WITHOUT_L1,\n  NewTransactionEvent,\n  SUBSCRIPTION_ID,\n  TXN_FINALITY_STATUS,\n  STATUS_ACCEPTED_ON_L1,\n} from '../../types/api'; // Default exported RPC 0.9 Types\n\nimport { BigNumberish, SubscriptionBlockIdentifier } from '../../types';\nimport { WebSocketEvent } from '../../types/api/jsonrpc';\nimport { EventEmitter } from '../../utils/eventEmitter';\nimport { TimeoutError, WebSocketNotConnectedError } from '../../utils/errors';\nimport WebSocket from '../../utils/connect/ws';\nimport { stringify } from '../../utils/json';\nimport { isString, isObject } from '../../utils/typed';\nimport { bigNumberishArrayToHexadecimalStringArray, toHex } from '../../utils/num';\nimport { Block } from '../../utils/provider';\nimport { config } from '../../global/config';\nimport { logger } from '../../global/logger';\nimport { Subscription } from './subscription';\n\n// Subscription parameter interfaces for object-based API\nexport interface SubscribeNewHeadsParams {\n  blockIdentifier?: SubscriptionBlockIdentifier;\n}\n\nexport interface SubscribeEventsParams {\n  fromAddress?: BigNumberish;\n  keys?: string[][];\n  blockIdentifier?: SubscriptionBlockIdentifier;\n  finalityStatus?: Exclude<TXN_FINALITY_STATUS, STATUS_ACCEPTED_ON_L1>;\n}\n\nexport interface SubscribeTransactionStatusParams {\n  transactionHash: BigNumberish;\n  blockIdentifier?: SubscriptionBlockIdentifier;\n}\n\nexport interface SubscribeNewTransactionReceiptsParams {\n  finalityStatus?: Exclude<TXN_FINALITY_STATUS, STATUS_ACCEPTED_ON_L1>[];\n  senderAddress?: BigNumberish[];\n}\n\nexport interface SubscribeNewTransactionsParams {\n  finalityStatus?: TXN_STATUS_WITHOUT_L1[];\n  senderAddress?: BigNumberish[];\n}\n\n// Subscription Result types\nexport type SubscriptionNewHeadsEvent = Subscription<NewHeadsEvent['result']>;\nexport type SubscriptionStarknetEventsEvent = Subscription<StarknetEventsEvent['result']>;\nexport type SubscriptionTransactionStatusEvent = Subscription<TransactionsStatusEvent['result']>;\nexport type SubscriptionNewTransactionReceiptsEvent = Subscription<\n  NewTransactionReceiptsEvent['result']\n>;\nexport type SubscriptionNewTransactionEvent = Subscription<NewTransactionEvent['result']>;\n\n/**\n * Options for configuring the automatic reconnection behavior of the WebSocketChannel.\n */\nexport type ReconnectOptions = {\n  /**\n   * The number of retries to attempt before giving up.\n   * @default 5\n   */\n  retries?: number;\n  /**\n   * The initial delay in milliseconds before the first retry.\n   * This delay will be doubled for each subsequent retry (exponential backoff).\n   * @default 2000\n   */\n  delay?: number;\n};\n\n/**\n * The type of the WebSocket implementation.\n */\nexport type WebSocketModule = { new (nodeUrl: WebSocketOptions['nodeUrl']): WebSocket };\n\n/**\n * Options for configuring the WebSocketChannel.\n */\nexport type WebSocketOptions = {\n  /**\n   * The URL of the WebSocket endpoint of the Starknet node.\n   * @example 'ws://localhost:9545'\n   */\n  nodeUrl: string;\n  /**\n   * This parameter can be used to provide a custom WebSocket implementation.\n   * This is useful in environments where the global WebSocket object is not available (e.g., Node.js).\n   * @example\n   * ```typescript\n   * import WebSocket from 'ws';\n   * const channel = new WebSocketChannel({ nodeUrl: '...', websocket: WebSocket });\n   * ```\n   */\n  websocket?: WebSocketModule;\n  /**\n   * The maximum number of events to buffer per subscription when no handler is attached.\n   * @default 1000\n   */\n  maxBufferSize?: number;\n  /**\n   * Whether to automatically reconnect when the connection is lost.\n   * @default true\n   */\n  autoReconnect?: boolean;\n  /**\n   * Options for the automatic reconnection behavior.\n   */\n  reconnectOptions?: ReconnectOptions;\n  /**\n   * The timeout in milliseconds for a `sendReceive` call.\n   * @default 60000\n   */\n  requestTimeout?: number;\n};\n\ntype WebSocketChannelEvents = {\n  open: Event;\n  close: CloseEvent;\n  message: MessageEvent<any>;\n  error: Event;\n  unsubscribe: SUBSCRIPTION_ID;\n};\n\n/**\n * Manages a WebSocket connection to a Starknet node for receiving real-time updates.\n * This class handles subscriptions, automatic reconnection, and request queueing.\n *\n * @example\n * ```typescript\n * const channel = new WebSocketChannel({ nodeUrl: 'YOUR_NODE_URL' });\n * await channel.waitForConnection();\n *\n * const sub = await channel.subscribeNewHeads();\n * sub.on((data) => {\n *   console.log('New Block:', data);\n * });\n *\n * // ... later\n * await sub.unsubscribe();\n * channel.disconnect();\n * ```\n */\nexport class WebSocketChannel {\n  /**\n   * The URL of the WebSocket RPC Node.\n   * @example 'wss://starknet-sepolia.public.blastapi.io/rpc/v0_8'\n   */\n  public nodeUrl: string;\n\n  /**\n   * The underlying WebSocket instance.\n   */\n  public websocket: WebSocket;\n\n  // Store the WebSocket implementation class to allow for custom implementations.\n  private WsImplementation: WebSocketModule;\n\n  // Map of active subscriptions, keyed by their ID.\n  private activeSubscriptions: Map<SUBSCRIPTION_ID, Subscription<any>> = new Map();\n\n  private readonly maxBufferSize: number;\n\n  private readonly autoReconnect: boolean;\n\n  private readonly reconnectOptions: Required<ReconnectOptions>;\n\n  private readonly requestTimeout: number;\n\n  private isReconnecting = false;\n\n  private reconnectAttempts = 0;\n\n  private userInitiatedClose = false;\n\n  private reconnectTimeoutId: NodeJS.Timeout | null = null;\n\n  private requestQueue: Array<{\n    method: string;\n    params?: object;\n    resolve: (value: any) => void;\n    reject: (reason?: any) => void;\n  }> = [];\n\n  private events = new EventEmitter<WebSocketChannelEvents>();\n\n  private openListener = (ev: Event) => this.events.emit('open', ev);\n\n  private closeListener = this.onCloseProxy.bind(this);\n\n  private messageListener = this.onMessageProxy.bind(this);\n\n  private errorListener = (ev: Event) => this.events.emit('error', ev);\n\n  /**\n   * JSON RPC latest sent message ID.\n   * The receiving message is expected to contain the same ID.\n   */\n  private sendId: number = 0;\n\n  /**\n   * Creates an instance of WebSocketChannel.\n   * @param {WebSocketOptions} options - The options for configuring the channel.\n   */\n  constructor(options: WebSocketOptions) {\n    this.nodeUrl = options.nodeUrl;\n    this.maxBufferSize = options.maxBufferSize ?? 1000;\n    this.autoReconnect = options.autoReconnect ?? true;\n    this.reconnectOptions = {\n      retries: options.reconnectOptions?.retries ?? 5,\n      delay: options.reconnectOptions?.delay ?? 2000,\n    };\n    this.requestTimeout = options.requestTimeout ?? 60000;\n\n    this.WsImplementation = options.websocket || config.get('websocket') || WebSocket;\n    this.websocket = new this.WsImplementation(this.nodeUrl);\n\n    this.websocket.addEventListener('open', this.openListener);\n    this.websocket.addEventListener('close', this.closeListener);\n    this.websocket.addEventListener('message', this.messageListener);\n    this.websocket.addEventListener('error', this.errorListener);\n  }\n\n  private idResolver(id?: number) {\n    // An unmanaged, user-set ID.\n    if (id) return id;\n    // Managed ID, intentionally returned old and then incremented.\n    // eslint-disable-next-line no-plusplus\n    return this.sendId++;\n  }\n\n  /**\n   * Sends a JSON-RPC request over the WebSocket connection without waiting for a response.\n   * This is a low-level method. Prefer `sendReceive` for most use cases.\n   * @param {string} method - The RPC method name.\n   * @param {object} [params] - The parameters for the RPC method.\n   * @param {number} [id] - A specific request ID. If not provided, an auto-incrementing ID is used.\n   * @returns {number} The ID of the sent request.\n   * @throws {WebSocketNotConnectedError} If the WebSocket is not connected.\n   */\n  public send(method: string, params?: object, id?: number) {\n    if (!this.isConnected()) {\n      throw new WebSocketNotConnectedError(\n        'WebSocketChannel.send() failed due to socket being disconnected'\n      );\n    }\n    const usedId = this.idResolver(id);\n    const rpcRequestBody: JRPC.RequestBody = {\n      id: usedId,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    // Stringify should remove undefined params\n    this.websocket.send(stringify(rpcRequestBody));\n    return usedId;\n  }\n\n  /**\n   * Sends a JSON-RPC request and returns a Promise that resolves with the result.\n   * This method abstracts the request/response cycle over WebSockets.\n   * If the connection is lost, it will queue the request and send it upon reconnection.\n   * @template T - The expected type of the result.\n   * @param {string} method - The RPC method name.\n   * @param {object} [params] - The parameters for the RPC method.\n   * @returns {Promise<T>} A Promise that resolves with the RPC response result.\n   * @throws {TimeoutError} If the request does not receive a response within the configured `requestTimeout`.\n   * @throws {WebSocketNotConnectedError} If the WebSocket is not connected and auto-reconnect is disabled.\n   */\n  public sendReceive<T = any>(method: string, params?: object): Promise<T> {\n    // If we are in the process of reconnecting, or if we are disconnected but expect to reconnect, queue the request.\n    if (\n      this.isReconnecting ||\n      (!this.isConnected() && this.autoReconnect && !this.userInitiatedClose)\n    ) {\n      logger.info(`WebSocket: Connection unavailable, queueing request: ${method}`);\n      return new Promise<T>((resolve, reject) => {\n        this.requestQueue.push({ method, params, resolve, reject });\n      });\n    }\n\n    const sendId = this.send(method, params);\n\n    return new Promise((resolve, reject) => {\n      let timeoutId: NodeJS.Timeout;\n\n      if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n        reject(new WebSocketNotConnectedError('WebSocket not available or not connected.'));\n        return;\n      }\n\n      const messageHandler = (event: MessageEvent) => {\n        if (!isString(event.data)) {\n          logger.warn('WebSocket received non-string message data:', event.data);\n          return;\n        }\n        const message: JRPC.ResponseBody = JSON.parse(event.data);\n        if (message.id === sendId) {\n          clearTimeout(timeoutId);\n          this.websocket.removeEventListener('message', messageHandler);\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          this.websocket.removeEventListener('error', errorHandler);\n\n          if ('result' in message) {\n            resolve(message.result as T);\n          } else {\n            reject(\n              new Error(`Error on ${method} (id: ${sendId}): ${JSON.stringify(message.error)}`)\n            );\n          }\n        }\n      };\n\n      const errorHandler = (event: Event) => {\n        clearTimeout(timeoutId);\n        this.websocket.removeEventListener('message', messageHandler);\n        this.websocket.removeEventListener('error', errorHandler);\n        reject(\n          new Error(\n            `WebSocket error during ${method} (id: ${sendId}): ${event.type || 'Unknown error'}`\n          )\n        );\n      };\n\n      this.websocket.addEventListener('message', messageHandler);\n      this.websocket.addEventListener('error', errorHandler);\n\n      timeoutId = setTimeout(() => {\n        // Clean up listeners\n        this.websocket.removeEventListener('message', messageHandler);\n        this.websocket.removeEventListener('error', errorHandler);\n        reject(\n          new TimeoutError(\n            `Request ${method} (id: ${sendId}) timed out after ${this.requestTimeout}ms`\n          )\n        );\n      }, this.requestTimeout);\n    });\n  }\n\n  /**\n   * Checks if the WebSocket connection is currently open.\n   * @returns {boolean} `true` if the connection is open, `false` otherwise.\n   */\n  public isConnected() {\n    return this.websocket.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Returns a Promise that resolves when the WebSocket connection is open.\n   * Can be used to block execution until the connection is established.\n   * @returns {Promise<number>} A Promise that resolves with the WebSocket's `readyState` when connected.\n   * @example\n   * ```typescript\n   * const channel = new WebSocketChannel({ nodeUrl: '...' });\n   * await channel.waitForConnection();\n   * console.log('Connected!');\n   * ```\n   */\n  public async waitForConnection(): Promise<WebSocket['readyState']> {\n    // Wait for the websocket to connect\n    if (this.websocket.readyState !== WebSocket.OPEN) {\n      return new Promise((resolve, reject) => {\n        if (!this.websocket) return;\n        this.websocket.onopen = () => resolve(this.websocket.readyState);\n        this.websocket.onerror = (error) => {\n          return reject(error);\n        };\n      });\n    }\n\n    return this.websocket.readyState;\n  }\n\n  /**\n   * Closes the WebSocket connection.\n   * This method is user-initiated and will prevent automatic reconnection for this closure.\n   * @param {number} [code] - The WebSocket connection close code.\n   * @param {string} [reason] - The WebSocket connection close reason.\n   */\n  public disconnect(code?: number, reason?: string) {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n    this.websocket.close(code, reason);\n    this.userInitiatedClose = true;\n  }\n\n  /**\n   * Returns a Promise that resolves when the WebSocket connection is closed.\n   * @returns {Promise<number | Event>} A Promise that resolves with the WebSocket's `readyState` or a `CloseEvent` when disconnected.\n   */\n  public async waitForDisconnection(): Promise<WebSocket['readyState'] | Event> {\n    // Wait for the websocket to disconnect\n    if (this.websocket.readyState !== WebSocket.CLOSED) {\n      return new Promise((resolve, reject) => {\n        if (!this.websocket) return;\n        this.websocket.onclose = () => resolve(this.websocket.readyState);\n        this.websocket.onerror = reject;\n      });\n    }\n\n    return this.websocket.readyState;\n  }\n\n  /**\n   * Unsubscribes from a Starknet subscription.\n   * It is recommended to use the `unsubscribe()` method on the `Subscription` object instead.\n   * @internal\n   * @param {SUBSCRIPTION_ID} subscriptionId - The ID of the subscription to unsubscribe from.\n   * @returns {Promise<boolean>} A Promise that resolves with `true` if the unsubscription was successful.\n   */\n  public async unsubscribe(subscriptionId: SUBSCRIPTION_ID) {\n    const status = await this.sendReceive<boolean>('starknet_unsubscribe', {\n      subscription_id: subscriptionId,\n    });\n    if (status) {\n      this.events.emit('unsubscribe', subscriptionId);\n    }\n    return status;\n  }\n\n  /**\n   * Returns a Promise that resolves when a specific subscription is successfully unsubscribed.\n   * @param {SUBSCRIPTION_ID} targetId - The ID of the subscription to wait for.\n   * @returns {Promise<void>}\n   * @example\n   * ```typescript\n   * await channel.waitForUnsubscription(mySubscription.id);\n   * console.log('Successfully unsubscribed.');\n   * ```\n   */\n  public waitForUnsubscription(targetId: SUBSCRIPTION_ID): Promise<void> {\n    return new Promise((resolve) => {\n      const listener = (unsubId: SUBSCRIPTION_ID) => {\n        if (unsubId === targetId) {\n          this.events.off('unsubscribe', listener);\n          resolve();\n        }\n      };\n      this.events.on('unsubscribe', listener);\n    });\n  }\n\n  /**\n   * Manually initiates a reconnection attempt.\n   * This creates a new WebSocket instance and re-establishes listeners.\n   */\n  public reconnect() {\n    this.userInitiatedClose = false;\n    this.websocket = new this.WsImplementation(this.nodeUrl);\n\n    this.websocket.addEventListener('open', this.openListener);\n    this.websocket.addEventListener('close', this.closeListener);\n    this.websocket.addEventListener('message', this.messageListener);\n    this.websocket.addEventListener('error', this.errorListener);\n  }\n\n  private _processRequestQueue(): void {\n    logger.info(`WebSocket: Processing ${this.requestQueue.length} queued requests.`);\n    while (this.requestQueue.length > 0) {\n      const { method, params, resolve, reject } = this.requestQueue.shift()!;\n      this.sendReceive(method, params).then(resolve).catch(reject);\n    }\n  }\n\n  private async _restoreSubscriptions(): Promise<void> {\n    const oldSubscriptions = Array.from(this.activeSubscriptions.values());\n    this.activeSubscriptions.clear();\n\n    const restorePromises = oldSubscriptions.map(async (sub) => {\n      try {\n        const newSubId = await this.sendReceive<SUBSCRIPTION_ID>(sub.method, sub.params);\n        // eslint-disable-next-line no-param-reassign\n        sub.id = newSubId; // Update the subscription with the new ID\n        this.activeSubscriptions.set(newSubId, sub);\n        logger.info(`Subscription ${sub.method} restored with new ID: ${newSubId}`);\n      } catch (error) {\n        logger.error(`Failed to restore subscription ${sub.method}:`, error);\n        // The subscription is not added back to activeSubscriptions if it fails\n      }\n    });\n\n    await Promise.all(restorePromises);\n  }\n\n  private _startReconnect() {\n    if (this.isReconnecting || !this.autoReconnect) {\n      return;\n    }\n\n    this.isReconnecting = true;\n    this.reconnectAttempts = 0;\n\n    const tryReconnect = () => {\n      if (this.reconnectAttempts >= this.reconnectOptions.retries) {\n        logger.error('WebSocket: Maximum reconnection retries reached. Giving up.');\n        this.isReconnecting = false;\n        return;\n      }\n\n      this.reconnectAttempts += 1;\n      logger.info(\n        `WebSocket: Connection lost. Attempting to reconnect... (${this.reconnectAttempts}/${this.reconnectOptions.retries})`\n      );\n\n      this.reconnect(); // Attempt to reconnect\n\n      this.websocket.onopen = async () => {\n        logger.info('WebSocket: Reconnection successful.');\n        this.isReconnecting = false;\n        this.reconnectAttempts = 0;\n        await this._restoreSubscriptions();\n        this._processRequestQueue();\n        // Manually trigger the onOpen listeners as the original 'open' event was consumed.\n        this.events.emit('open', new Event('open'));\n      };\n\n      this.websocket.onerror = () => {\n        const delay = this.reconnectOptions.delay * 2 ** (this.reconnectAttempts - 1);\n        logger.info(`WebSocket: Reconnect attempt failed. Retrying in ${delay}ms.`);\n        this.reconnectTimeoutId = setTimeout(tryReconnect, delay);\n      };\n    };\n\n    tryReconnect();\n  }\n\n  private onCloseProxy(ev: CloseEvent) {\n    this.websocket.removeEventListener('open', this.openListener);\n    this.websocket.removeEventListener('close', this.closeListener);\n    this.websocket.removeEventListener('message', this.messageListener);\n    this.websocket.removeEventListener('error', this.errorListener);\n    this.events.emit('close', ev);\n\n    if (!this.userInitiatedClose) {\n      this._startReconnect();\n    }\n  }\n\n  private onMessageProxy(event: MessageEvent<any>) {\n    let message: WebSocketEvent;\n    try {\n      message = JSON.parse(event.data);\n    } catch (error) {\n      logger.error(\n        `WebSocketChannel: Error parsing incoming message: ${event.data}, Error: ${error}`\n      );\n      return; // Stop processing this malformed message.\n    }\n\n    // Check if it's a subscription event.\n    if (message.method && isObject(message.params) && 'subscription_id' in message.params) {\n      const { result, subscription_id } = message.params as {\n        result: any;\n        subscription_id: SUBSCRIPTION_ID;\n      };\n      const subscription = this.activeSubscriptions.get(subscription_id);\n\n      if (subscription) {\n        subscription._handleEvent(result);\n      } else {\n        logger.warn(\n          `WebSocketChannel: Received event for untracked subscription ID: ${subscription_id}.`\n        );\n      }\n    }\n\n    logger.debug('onMessageProxy:', event.data);\n\n    // Call the general onMessage handler if provided by the user for all messages.\n    this.events.emit('message', event);\n  }\n\n  /**\n   * Subscribes to new block headers.\n   * @param {SubscribeNewHeadsParams} params - The parameters for the subscription.\n   * @returns {Promise<Subscription<BLOCK_HEADER>>} A Promise that resolves with a `Subscription` object for new block headers.\n   */\n  public async subscribeNewHeads(\n    params: SubscribeNewHeadsParams = {}\n  ): Promise<SubscriptionNewHeadsEvent> {\n    const method = 'starknet_subscribeNewHeads';\n    const rpcParams = {\n      block_id: params.blockIdentifier ? new Block(params.blockIdentifier).identifier : undefined,\n    };\n    const subId = await this.sendReceive<SUBSCRIPTION_ID>(method, rpcParams);\n    const subscription = new Subscription({\n      channel: this,\n      method,\n      params: rpcParams,\n      id: subId,\n      maxBufferSize: this.maxBufferSize,\n    });\n    this.activeSubscriptions.set(subId, subscription);\n    return subscription;\n  }\n\n  /**\n   * Subscribes to events matching a given filter.\n   * @param {SubscribeEventsParams} params - The parameters for the subscription.\n   * @returns {Promise<Subscription<EMITTED_EVENT>>} A Promise that resolves with a `Subscription` object for the specified events.\n   */\n  public async subscribeEvents(\n    params: SubscribeEventsParams = {}\n  ): Promise<SubscriptionStarknetEventsEvent> {\n    const method = 'starknet_subscribeEvents';\n    const rpcParams = {\n      from_address: params.fromAddress !== undefined ? toHex(params.fromAddress) : undefined,\n      keys: params.keys,\n      block_id: params.blockIdentifier ? new Block(params.blockIdentifier).identifier : undefined,\n      finality_status: params.finalityStatus,\n    };\n    const subId = await this.sendReceive<SUBSCRIPTION_ID>(method, rpcParams);\n    const subscription = new Subscription({\n      channel: this,\n      method,\n      params: rpcParams,\n      id: subId,\n      maxBufferSize: this.maxBufferSize,\n    });\n    this.activeSubscriptions.set(subId, subscription);\n    return subscription;\n  }\n\n  /**\n   * Subscribes to status updates for a specific transaction.\n   * @param {SubscribeTransactionStatusParams} params - The parameters for the subscription.\n   * @returns {Promise<Subscription<NEW_TXN_STATUS>>} A Promise that resolves with a `Subscription` object for the transaction's status.\n   */\n  public async subscribeTransactionStatus(\n    params: SubscribeTransactionStatusParams\n  ): Promise<SubscriptionTransactionStatusEvent> {\n    const method = 'starknet_subscribeTransactionStatus';\n    const rpcParams = {\n      transaction_hash: toHex(params.transactionHash),\n      block_id: params.blockIdentifier ? new Block(params.blockIdentifier).identifier : undefined,\n    };\n    const subId = await this.sendReceive<SUBSCRIPTION_ID>(method, rpcParams);\n    const subscription = new Subscription({\n      channel: this,\n      method,\n      params: rpcParams,\n      id: subId,\n      maxBufferSize: this.maxBufferSize,\n    });\n    this.activeSubscriptions.set(subId, subscription);\n    return subscription;\n  }\n\n  /**\n   * Subscribes to new transaction receipts.\n   * @param {SubscribeNewTransactionReceiptsParams} params - The parameters for the subscription.\n   * @returns {Promise<Subscription<NewTransactionReceiptsEvent['result']>>} A Promise that resolves with a `Subscription` object for new transaction receipts.\n   */\n  public async subscribeNewTransactionReceipts(\n    params: SubscribeNewTransactionReceiptsParams = {}\n  ): Promise<SubscriptionNewTransactionReceiptsEvent> {\n    const method = 'starknet_subscribeNewTransactionReceipts';\n    const rpcParams = {\n      finality_status: params.finalityStatus,\n      sender_address:\n        params.senderAddress && bigNumberishArrayToHexadecimalStringArray(params.senderAddress),\n    };\n    const subId = await this.sendReceive<SUBSCRIPTION_ID>(method, rpcParams);\n    const subscription = new Subscription({\n      channel: this,\n      method,\n      params: rpcParams,\n      id: subId,\n      maxBufferSize: this.maxBufferSize,\n    });\n    this.activeSubscriptions.set(subId, subscription);\n    return subscription;\n  }\n\n  /**\n   * Subscribes to new transactions.\n   * @param {SubscribeNewTransactionsParams} params - The parameters for the subscription.\n   * @returns {Promise<Subscription<NewTransactionEvent['result']>>} A Promise that resolves with a `Subscription` object for new transactions.\n   */\n  public async subscribeNewTransactions(\n    params: SubscribeNewTransactionsParams = {}\n  ): Promise<SubscriptionNewTransactionEvent> {\n    const method = 'starknet_subscribeNewTransactions';\n    const rpcParams = {\n      finality_status: params.finalityStatus,\n      sender_address:\n        params.senderAddress && bigNumberishArrayToHexadecimalStringArray(params.senderAddress),\n    };\n    const subId = await this.sendReceive<SUBSCRIPTION_ID>(method, rpcParams);\n    const subscription = new Subscription({\n      channel: this,\n      method,\n      params: rpcParams,\n      id: subId,\n      maxBufferSize: this.maxBufferSize,\n    });\n    this.activeSubscriptions.set(subId, subscription);\n    return subscription;\n  }\n\n  /**\n   * Internal method to remove subscription from active map.\n   * @internal\n   */\n  public removeSubscription(id: SUBSCRIPTION_ID) {\n    this.activeSubscriptions.delete(id);\n  }\n\n  /**\n   * Adds a listener for a given event.\n   * @param event The event name.\n   * @param listener The listener function to add.\n   */\n  public on<K extends keyof WebSocketChannelEvents>(\n    event: K,\n    listener: (data: WebSocketChannelEvents[K]) => void\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  /**\n   * Removes a listener for a given event.\n   * @param event The event name.\n   * @param listener The listener function to remove.\n   */\n  public off<K extends keyof WebSocketChannelEvents>(\n    event: K,\n    listener: (data: WebSocketChannelEvents[K]) => void\n  ): void {\n    this.events.off(event, listener);\n  }\n}\n","/**\n * Map RPC Response to common interface response\n * Intersection (sequencer response ∩ (∪ rpc responses))\n */\nimport type {\n  ContractClassPayload,\n  ContractClassResponse,\n  GetBlockResponse,\n  GetTxReceiptResponseWithoutHelper,\n  RpcProviderOptions,\n  SimulateTransactionResponse,\n  BlockWithTxHashes,\n  SimulateTransactionOverheadResponse,\n  EstimateFeeResponseBulkOverhead,\n} from '../../provider/types/index.type';\nimport { isString } from '../typed';\nimport { toOverheadOverallFee, toOverheadResourceBounds } from '../stark';\nimport { ResponseParser } from './interface';\nimport {\n  ApiEstimateFeeResponse,\n  SimulateTransaction,\n  TransactionReceipt,\n} from '../../provider/types/spec.type';\n// import { TransactionReceipt } from '../../types/api/merge';\n\nexport class RPCResponseParser\n  implements\n    Omit<\n      ResponseParser,\n      | 'parseDeclareContractResponse'\n      | 'parseDeployContractResponse'\n      | 'parseInvokeFunctionResponse'\n      | 'parseGetTransactionReceiptResponse'\n      | 'parseGetTransactionResponse'\n      | 'parseCallContractResponse'\n    >\n{\n  private resourceBoundsOverhead: RpcProviderOptions['resourceBoundsOverhead'];\n\n  constructor(resourceBoundsOverhead?: RpcProviderOptions['resourceBoundsOverhead']) {\n    this.resourceBoundsOverhead = resourceBoundsOverhead;\n  }\n\n  public parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse {\n    return res as GetBlockResponse;\n  }\n\n  public parseTransactionReceipt(res: TransactionReceipt): GetTxReceiptResponseWithoutHelper {\n    return res as GetTxReceiptResponseWithoutHelper;\n  }\n\n  public parseFeeEstimateBulkResponse(\n    res: ApiEstimateFeeResponse\n  ): EstimateFeeResponseBulkOverhead {\n    return res.map((val) => ({\n      resourceBounds: toOverheadResourceBounds(val, this.resourceBoundsOverhead),\n      overall_fee: toOverheadOverallFee(val, this.resourceBoundsOverhead),\n      unit: val.unit,\n    }));\n  }\n\n  public parseSimulateTransactionResponse(\n    res: SimulateTransactionResponse\n  ): SimulateTransactionOverheadResponse {\n    return res.map((it: SimulateTransaction) => {\n      return {\n        transaction_trace: it.transaction_trace,\n        resourceBounds: toOverheadResourceBounds(it.fee_estimation, this.resourceBoundsOverhead),\n        overall_fee: toOverheadOverallFee(it.fee_estimation, this.resourceBoundsOverhead),\n        unit: it.fee_estimation.unit,\n      };\n    });\n  }\n\n  public parseContractClassResponse(res: ContractClassPayload): ContractClassResponse {\n    return {\n      ...(res as ContractClassResponse),\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi,\n    };\n  }\n\n  public parseL1GasPriceResponse(res: BlockWithTxHashes): string {\n    return res.l1_gas_price.price_in_wei;\n  }\n}\n","import { RANGE_FELT } from '../../global/constants';\nimport { logger } from '../../global/logger';\nimport type { ProviderInterface } from '..';\nimport { BlockTag, type BlockIdentifier, type RPC } from '../../types';\nimport type { BlockWithTxs } from '../../types/api';\nimport assert from '../../utils/assert';\nimport { LibraryError } from '../../utils/errors';\nimport { isNumber, isString } from '../../utils/typed';\n\n/**\n * Result of provider.getTipStatsFromBlocks().\n * @param {bigint} minTip - minimum tip encountered in the analyzed blocks.\n * @param {bigint} maxTip - maximum tip encountered in the analyzed blocks.\n * @param {bigint} averageTip - average tip encountered in the analyzed blocks.\n * @param {bigint} medianTip - median (middle value) tip encountered in the analyzed blocks.\n * @param {bigint} modeTip - mode (most frequent) tip encountered in the analyzed blocks.\n * @param {bigint} recommendedTip - suggested tip amount (median tip) for optimal inclusion probability.\n * @param {bigint} p90Tip - 90th percentile tip (90% of tips are below this value).\n * @param {bigint} p95Tip - 95th percentile tip (95% of tips are below this value).\n * @param {object} metrics - Optional performance metrics for the analysis.\n */\nexport type TipEstimate = {\n  minTip: bigint;\n  maxTip: bigint;\n  averageTip: bigint;\n  medianTip: bigint;\n  modeTip: bigint;\n  recommendedTip: bigint;\n  p90Tip: bigint;\n  p95Tip: bigint;\n  metrics?: {\n    blocksAnalyzed: number;\n    transactionsTipsFound: bigint[];\n  };\n};\n\nexport type TipType = Exclude<keyof TipEstimate, 'metrics'>;\n\n/**\n * Options for customizing tip analysis behavior.\n */\nexport type TipAnalysisOptions = {\n  /**\n   * Maximum number of blocks to analyze going backwards from the starting block.\n   * @default 3\n   */\n  maxBlocks?: number;\n  /**\n   * Minimum number of transactions required to generate reliable statistics.\n   * @default 10\n   */\n  minTxsNecessary?: number;\n  /**\n   * Whether to include transactions with zero tips in the analysis.\n   * @default true\n   */\n  includeZeroTips?: boolean;\n};\n\n/**\n * Type guard to check if a transaction is a V3 transaction with a tip.\n * Includes INVOKE, DECLARE, and DEPLOY_ACCOUNT transaction types.\n */\nfunction isV3TransactionWithTip(tx: RPC.TXN_WITH_HASH): tx is RPC.TXN_WITH_HASH & { tip: string } {\n  return (\n    tx.version === '0x3' &&\n    'tip' in tx &&\n    isString(tx.tip) &&\n    (tx.type === 'INVOKE' || tx.type === 'DECLARE' || tx.type === 'DEPLOY_ACCOUNT')\n  );\n}\n\n/**\n * Determines if the provider has batching enabled by checking for batchClient.\n * @param provider RPC provider to check\n * @returns true if batching is enabled, false otherwise\n */\nfunction isBatchingEnabled(provider: ProviderInterface): boolean {\n  // Type assertion needed because batchClient is a private property in RPC channel classes\n  // This checks if the channel has a batchClient property to determine if batching is enabled\n  const channel = provider.channel as unknown as { batchClient?: unknown };\n  return !!channel.batchClient;\n}\n\n/**\n * Extracts tip values from V3 transactions in a block.\n * @param blockData Block data containing transactions\n * @param includeZeroTips Whether to include transactions with zero tips\n * @returns Array of tip values as bigints\n */\nfunction extractTipsFromBlock(blockData: BlockWithTxs, includeZeroTips: boolean = true): bigint[] {\n  return blockData.transactions\n    .filter(isV3TransactionWithTip)\n    .map((tx) => BigInt(tx.tip))\n    .filter((tip) => includeZeroTips || tip > 0n);\n}\n\n/**\n * Creates a TipEstimate object with all zero values for insufficient data cases.\n * @param blocksAnalyzed Number of blocks that were analyzed\n * @param transactionsTipsFound Array of transaction tips found\n * @returns TipEstimate object with all zero values\n */\nfunction createZeroTipEstimate(\n  blocksAnalyzed: number,\n  transactionsTipsFound: bigint[]\n): TipEstimate {\n  return {\n    minTip: 0n,\n    maxTip: 0n,\n    averageTip: 0n,\n    medianTip: 0n,\n    modeTip: 0n,\n    recommendedTip: 0n,\n    p90Tip: 0n,\n    p95Tip: 0n,\n    metrics: {\n      blocksAnalyzed,\n      transactionsTipsFound,\n    },\n  };\n}\n\n/**\n * Calculates a specific percentile from a sorted array.\n * @param sortedArray Sorted array of values\n * @param percentile Percentile to calculate (0-100)\n * @returns The percentile value\n */\nfunction calculatePercentile(sortedArray: bigint[], percentile: number): bigint {\n  const index = (percentile / 100) * (sortedArray.length - 1);\n  const lower = Math.floor(index);\n  const upper = Math.ceil(index);\n\n  if (lower === upper) {\n    return sortedArray[lower];\n  }\n\n  // Interpolate between the two values\n  const weight = index - lower;\n  const lowerValue = sortedArray[lower];\n  const upperValue = sortedArray[upper];\n\n  // For bigint interpolation, we need to handle the fractional part carefully\n  const diff = upperValue - lowerValue;\n  const weightedDiff = (diff * BigInt(Math.round(weight * 1000))) / 1000n;\n\n  return lowerValue + weightedDiff;\n}\n\n/**\n * Calculates tip statistics from collected tip values.\n * @param tips Array of tip values\n * @returns TipEstimate object with min, max, average, median, mode, percentiles, and recommended tip\n */\nfunction calculateTipStats(tips: bigint[]): TipEstimate {\n  assert(tips.length > 0, 'Cannot calculate statistics from empty tip array');\n\n  const minTip = tips.reduce((min, tip) => (tip < min ? tip : min), RANGE_FELT.max);\n  const maxTip = tips.reduce((max, tip) => (tip > max ? tip : max), 0n);\n  const sumTip = tips.reduce((sum, tip) => sum + tip, 0n);\n  const averageTip = sumTip / BigInt(tips.length);\n\n  // Calculate median tip (middle value when sorted)\n  const sortedTips = [...tips].sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  const midIndex = Math.floor(sortedTips.length / 2);\n  let medianTip: bigint;\n  if (sortedTips.length % 2 === 0) {\n    medianTip = (sortedTips[midIndex - 1] + sortedTips[midIndex]) / 2n;\n  } else {\n    medianTip = sortedTips[midIndex];\n  }\n\n  // Calculate mode tip (most frequently occurring value)\n  const tipCounts = new Map<bigint, number>();\n  tips.forEach((tip) => {\n    tipCounts.set(tip, (tipCounts.get(tip) || 0) + 1);\n  });\n\n  const { modeTip } = Array.from(tipCounts.entries()).reduce(\n    (acc, [tip, count]) => {\n      if (count > acc.maxCount || (count === acc.maxCount && tip < acc.modeTip)) {\n        return { maxCount: count, modeTip: tip };\n      }\n      return acc;\n    },\n    { maxCount: 0, modeTip: 0n }\n  );\n\n  // Calculate percentiles\n  const p90Tip = calculatePercentile(sortedTips, 90);\n  const p95Tip = calculatePercentile(sortedTips, 95);\n\n  // Use median tip directly as recommended tip\n  const recommendedTip = medianTip;\n\n  return { minTip, maxTip, averageTip, medianTip, modeTip, recommendedTip, p90Tip, p95Tip };\n}\n\n/**\n * Determines the starting block number for analysis.\n * @param provider RPC provider for blockchain communication\n * @param blockIdentifier Block identifier to start from\n * @returns Block number to start analysis from\n */\nasync function getStartingBlockNumber(\n  provider: ProviderInterface,\n  blockIdentifier: BlockIdentifier\n): Promise<number> {\n  try {\n    const blockData = (await provider.getBlockWithTxs(blockIdentifier)) as BlockWithTxs;\n\n    if (isNumber(blockData.block_number)) {\n      return blockData.block_number;\n    }\n\n    // If block_number is undefined, fall back to latest accepted block number\n    const latestBlock = await provider.getBlockLatestAccepted();\n    return latestBlock.block_number;\n  } catch (error) {\n    throw new LibraryError(\n      `Failed to determine starting block number: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n\n/**\n * Fetches block data with error handling.\n * @param provider RPC provider for blockchain communication\n * @param blockNumber Block number to fetch\n * @returns Block data or null if failed\n */\nasync function fetchBlockSafely(\n  provider: ProviderInterface,\n  blockNumber: number\n): Promise<BlockWithTxs | null> {\n  try {\n    return (await provider.getBlockWithTxs(blockNumber)) as BlockWithTxs;\n  } catch (error) {\n    logger.warn(`Failed to fetch block ${blockNumber}:`, error);\n    return null;\n  }\n}\n\n/**\n * Generates an array of block numbers to analyze.\n * @param startingBlockNumber Starting block number\n * @param maxBlocks Maximum number of blocks to analyze\n * @returns Array of block numbers in descending order\n */\nfunction generateBlockNumbers(startingBlockNumber: number, maxBlocks: number): number[] {\n  const oldestBlockNumber = Math.max(0, startingBlockNumber - maxBlocks + 1);\n  const blockCount = startingBlockNumber - oldestBlockNumber + 1;\n\n  return Array.from({ length: blockCount }, (_, index) => startingBlockNumber - index);\n}\n\n/**\n * Fetches multiple blocks in parallel (uses batching if provider supports it).\n * @param provider RPC provider for blockchain communication\n * @param blockNumbers Array of block numbers to fetch\n * @returns Array of BlockWithTxs data (nulls for failed fetches)\n */\nasync function fetchBlocksInParallel(\n  provider: ProviderInterface,\n  blockNumbers: number[]\n): Promise<(BlockWithTxs | null)[]> {\n  const fetchPromises = blockNumbers.map(async (blockNumber) => {\n    try {\n      return (await provider.getBlockWithTxs(blockNumber)) as BlockWithTxs;\n    } catch (error) {\n      logger.warn(`Failed to fetch block ${blockNumber} in parallel:`, error);\n      return null;\n    }\n  });\n\n  return Promise.all(fetchPromises);\n}\n\n/**\n * Analyzes tip statistics from recent blocks using parallel requests.\n * This version fetches all blocks simultaneously, which is more efficient\n * when using a provider with batching enabled.\n *\n * @param provider RPC provider for blockchain communication\n * @param blockIdentifier Starting block for analysis\n * @param options Configuration options for the analysis\n * @returns Promise resolving to TipEstimate object (returns zero values if insufficient data)\n */\nasync function getTipStatsParallel(\n  provider: ProviderInterface,\n  blockIdentifier: BlockIdentifier,\n  options: TipAnalysisOptions\n): Promise<TipEstimate> {\n  const { maxBlocks = 3, minTxsNecessary = 10, includeZeroTips = true } = options;\n\n  try {\n    // Determine the starting block number\n    const startingBlockNumber = await getStartingBlockNumber(provider, blockIdentifier);\n    const blockNumbers = generateBlockNumbers(startingBlockNumber, maxBlocks);\n\n    // Fetch all blocks in parallel (automatically batched if provider supports it)\n    const blocks = await fetchBlocksInParallel(provider, blockNumbers);\n\n    // Extract tips from all successfully fetched blocks\n    const allTips: bigint[] = blocks\n      .filter((blockData) => blockData !== null)\n      // @ts-ignore - seems to be needed only for docs, check again after the doc dependencies are updated\n      .flatMap((blockData) => extractTipsFromBlock(blockData, includeZeroTips));\n\n    const analyzedBlocks = blocks.filter((b) => b !== null).length;\n\n    // Handle insufficient transaction data\n    if (allTips.length < minTxsNecessary) {\n      logger.error(\n        `Insufficient transaction data: found ${allTips.length} V3 transactions with tips in ${analyzedBlocks} blocks ` +\n          `(block range: ${Math.max(0, startingBlockNumber - maxBlocks + 1)}-${startingBlockNumber}). ` +\n          `Required: ${minTxsNecessary} transactions. Consider reducing minTxsNecessary or increasing maxBlocks.`\n      );\n      return createZeroTipEstimate(analyzedBlocks, allTips);\n    }\n\n    const tipStats = calculateTipStats(allTips);\n    return {\n      ...tipStats,\n      metrics: {\n        blocksAnalyzed: analyzedBlocks,\n        transactionsTipsFound: allTips,\n      },\n    };\n  } catch (error) {\n    throw new LibraryError(\n      `Failed to analyze tip statistics (parallel): ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n\n/**\n * Analyzes tip statistics from recent blocks using sequential requests with early exit.\n * This version processes blocks one by one and can exit early when enough\n * transactions are found, which may be more efficient when batching is not available.\n *\n * @param provider RPC provider for blockchain communication\n * @param blockIdentifier Starting block for analysis\n * @param options Configuration options for the analysis\n * @returns Promise resolving to TipEstimate object (returns zero values if insufficient data)\n */\nasync function getTipStatsSequential(\n  provider: ProviderInterface,\n  blockIdentifier: BlockIdentifier,\n  options: TipAnalysisOptions\n): Promise<TipEstimate> {\n  const { maxBlocks = 3, minTxsNecessary = 10, includeZeroTips = true } = options;\n\n  try {\n    // Determine the starting block number\n    const startingBlockNumber = await getStartingBlockNumber(provider, blockIdentifier);\n    const blockNumbers = generateBlockNumbers(startingBlockNumber, maxBlocks);\n\n    const allTips: bigint[] = [];\n    let blocksAnalyzed = 0;\n\n    // Process blocks sequentially to avoid overwhelming the RPC and enable early exit\n    // eslint-disable-next-line no-restricted-syntax\n    for (const blockNumber of blockNumbers) {\n      // eslint-disable-next-line no-await-in-loop\n      const blockData = await fetchBlockSafely(provider, blockNumber);\n\n      if (blockData) {\n        blocksAnalyzed += 1;\n        const tips = extractTipsFromBlock(blockData, includeZeroTips);\n        allTips.push(...tips);\n\n        // Early exit if we have enough transactions\n        if (allTips.length >= minTxsNecessary) {\n          break;\n        }\n      }\n    }\n\n    // Handle insufficient transaction data\n    if (allTips.length < minTxsNecessary) {\n      logger.error(\n        `Insufficient transaction data: found ${allTips.length} V3 transactions with tips in ${blocksAnalyzed} blocks ` +\n          `(block range: ${Math.max(0, startingBlockNumber - maxBlocks + 1)}-${startingBlockNumber}). ` +\n          `Required: ${minTxsNecessary} transactions. Consider reducing minTxsNecessary or increasing maxBlocks.`\n      );\n      return createZeroTipEstimate(blocksAnalyzed, allTips);\n    }\n\n    const tipStats = calculateTipStats(allTips);\n    return {\n      ...tipStats,\n      metrics: {\n        blocksAnalyzed,\n        transactionsTipsFound: allTips,\n      },\n    };\n  } catch (error) {\n    throw new LibraryError(\n      `Failed to analyze tip statistics (sequential): ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n\n/**\n * Analyzes tip statistics from recent blocks to help determine optimal tip amounts.\n *\n * This function examines V3 invoke transactions across multiple recent blocks to calculate\n * minimum, maximum, and average tip amounts. This data can be used to determine an\n * appropriate tip for new transactions.\n *\n * **Performance Notes:**\n * - Automatically detects if your provider has batching enabled\n * - When batching is enabled, all block requests are made in parallel and automatically\n *   batched into a single HTTP request for maximum efficiency\n * - When batching is not enabled, requests are made sequentially with early exit capability\n *\n * @param provider - RPC provider for blockchain communication\n * @param blockIdentifier - Starting block for analysis (goes backwards from this block)\n * @param options - Configuration options for the analysis\n * @returns Promise resolving to TipEstimate object\n *\n * @throws {Error} When invalid parameters are provided\n * @throws {LibraryError} When RPC calls fail, data is invalid, or insufficient transaction data is found\n *\n * @example\n * ```typescript\n * import { RpcProvider } from 'starknet';\n *\n * // Create provider with batching for optimal performance\n * const provider = new RpcProvider({\n *   nodeUrl: 'your_node_url',\n *   batch: 50  // 50ms batch interval - automatically detected and used\n * });\n *\n * // Basic usage - automatically uses best strategy\n * const tipStats = await getTipStatsFromBlocks(provider, 'latest');\n * console.log(`Recommended tip (median): ${tipStats.recommendedTip}`);\n * console.log(`90th percentile tip: ${tipStats.p90Tip}`);\n * console.log(`95th percentile tip: ${tipStats.p95Tip}`);\n *\n * // Advanced usage with custom options\n * const tipStats = await getTipStatsFromBlocks(\n *   provider,\n *   'latest',\n *   {\n *     maxBlocks: 10,\n *     minTxsNecessary: 5,\n *     includeZeroTips: true\n *   }\n * );\n *\n * // Check if we have sufficient data\n * if (tipStats.recommendedTip === 0n) {\n *   console.log('Insufficient transaction data for reliable tip estimation');\n * } else {\n *   console.log(`Recommended tip: ${tipStats.recommendedTip}`);\n *   console.log(`Average tip: ${tipStats.averageTip}`);\n *   console.log(`Median tip: ${tipStats.medianTip}`);\n *   console.log(`Mode tip: ${tipStats.modeTip}`);\n *   console.log(`Min tip: ${tipStats.minTip}, Max tip: ${tipStats.maxTip}`);\n *   console.log(`P90 tip: ${tipStats.p90Tip} (90% of tips are below this)`);\n *   console.log(`P95 tip: ${tipStats.p95Tip} (95% of tips are below this)`);\n *\n *   // Access performance metrics if available\n *   if (tipStats.metrics) {\n *     console.log(`Analyzed ${tipStats.metrics.transactionsFound} transactions`);\n *     console.log(`Across ${tipStats.metrics.blocksAnalyzed} blocks`);\n *   }\n * }\n *\n * // Using specific block number\n * const blockNumber = 650000;\n * const historicalTips = await getTipStatsFromBlocks(provider, blockNumber);\n * ```\n */\nexport async function getTipStatsFromBlocks(\n  provider: ProviderInterface,\n  blockIdentifier: BlockIdentifier = BlockTag.LATEST,\n  options: TipAnalysisOptions = {}\n): Promise<TipEstimate> {\n  const { maxBlocks = 3, minTxsNecessary = 10 } = options;\n\n  // Input validation\n  assert(Number.isInteger(maxBlocks), 'maxBlocks parameter must be an integer');\n  assert(maxBlocks >= 1, 'maxBlocks parameter must be greater than or equal to 1');\n  assert(maxBlocks <= 100, 'maxBlocks parameter must be less than or equal to 100 for performance');\n  assert(Number.isInteger(minTxsNecessary), 'minTxsNecessary parameter must be an integer');\n  assert(minTxsNecessary >= 1, 'minTxsNecessary parameter must be greater than or equal to 1');\n\n  // Automatically choose the best strategy based on batching capability\n  if (isBatchingEnabled(provider)) {\n    return getTipStatsParallel(provider, blockIdentifier, options);\n  }\n  return getTipStatsSequential(provider, blockIdentifier, options);\n}\n","/* eslint-disable no-nested-ternary */\nimport {\n  GetTxReceiptResponseWithoutHelper,\n  RevertedTransactionReceiptResponse,\n  SuccessfulTransactionReceiptResponse,\n  TransactionExecutionStatus,\n} from '../../types';\nimport type {\n  GetTransactionReceiptResponse,\n  SuccessfulTransactionReceiptResponseHelper,\n  RevertedTransactionReceiptResponseHelper,\n  ErrorReceiptResponseHelper,\n  TransactionReceiptCallbacks,\n  TransactionReceiptCallbacksDefault,\n  TransactionReceiptStatus,\n  TransactionReceiptValue,\n} from './transactionReceipt.type';\n\n/**\n * !! Main design decision:\n * Class can't extend GetTransactionReceiptResponse because it is union type\n * and it is not possible to extend union type in current typescript version\n * So we have to use factory function to create 'data' return type and inject constructor\n *\n * ERROR case left but in library flow it is not possible as fetch would throw on error before it could be read by Helper\n */\n\n/**\n * @deprecated Use `createTransactionReceipt` instead\n * Utility that analyses transaction receipt response and provides helpers to process it\n * @example\n * ```typescript\n * const responseTx = new ReceiptTx(receipt);\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   reverted: (txR: RevertedTransactionReceiptResponse) => { },\n *   error: (err: Error) => { },\n * });\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   _: () => { },\n * }\n * ```\n */\n// Legacy class for backward compatibility (defined first for prototype hack)\nexport class ReceiptTx {\n  public readonly statusReceipt!: TransactionReceiptStatus;\n\n  public readonly value!: TransactionReceiptValue;\n\n  constructor(receipt: GetTxReceiptResponseWithoutHelper) {\n    // Copy all receipt properties to this instance\n    Object.assign(this, receipt);\n\n    // Determine status and value\n    const [statusReceipt, value] = ReceiptTx.isSuccess(receipt)\n      ? ['SUCCEEDED', receipt]\n      : ReceiptTx.isReverted(receipt)\n        ? ['REVERTED', receipt]\n        : ['ERROR', new Error('Unknown response type')];\n\n    // Define statusReceipt and value as non-enumerable properties\n    Object.defineProperties(this, {\n      statusReceipt: {\n        value: statusReceipt,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n      value: {\n        value,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n      match: {\n        value(callbacks: TransactionReceiptCallbacks) {\n          return statusReceipt in callbacks\n            ? (callbacks as any)[statusReceipt]!(value)\n            : (callbacks as TransactionReceiptCallbacksDefault)._();\n        },\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n      isSuccess: {\n        value: () => statusReceipt === 'SUCCEEDED',\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n      isReverted: {\n        value: () => statusReceipt === 'REVERTED',\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n      isError: {\n        value: () => statusReceipt === 'ERROR',\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      },\n    });\n  }\n\n  match!: (callbacks: TransactionReceiptCallbacks) => void;\n\n  isSuccess!: () => this is SuccessfulTransactionReceiptResponseHelper;\n\n  isReverted!: () => this is RevertedTransactionReceiptResponseHelper;\n\n  isError!: () => this is ErrorReceiptResponseHelper;\n\n  static isSuccess(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is SuccessfulTransactionReceiptResponse {\n    return transactionReceipt.execution_status === TransactionExecutionStatus.SUCCEEDED;\n  }\n\n  static isReverted(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is RevertedTransactionReceiptResponse {\n    return transactionReceipt.execution_status === TransactionExecutionStatus.REVERTED;\n  }\n}\n\n// Receipt configuration mapping - data-driven approach\nconst RECEIPT_CONFIG = {\n  [TransactionExecutionStatus.SUCCEEDED]: {\n    statusReceipt: 'SUCCEEDED' as const,\n    getBaseData: (receipt: GetTxReceiptResponseWithoutHelper) => receipt,\n    getValue: (receipt: GetTxReceiptResponseWithoutHelper) =>\n      receipt as SuccessfulTransactionReceiptResponse,\n  },\n  [TransactionExecutionStatus.REVERTED]: {\n    statusReceipt: 'REVERTED' as const,\n    getBaseData: (receipt: GetTxReceiptResponseWithoutHelper) => receipt,\n    getValue: (receipt: GetTxReceiptResponseWithoutHelper) =>\n      receipt as RevertedTransactionReceiptResponse,\n  },\n} as const;\n\n/**\n * Creates a transaction receipt response object with helpers\n * @param receipt - The transaction receipt response from the provider\n * @returns A transaction receipt response object with helpers\n */\nexport function createTransactionReceipt(\n  receipt: GetTxReceiptResponseWithoutHelper\n): GetTransactionReceiptResponse {\n  const config = RECEIPT_CONFIG[receipt.execution_status];\n\n  let obj: any;\n\n  if (config) {\n    const { statusReceipt, getBaseData, getValue } = config;\n    const value = getValue(receipt);\n\n    obj = {\n      ...getBaseData(receipt),\n      statusReceipt,\n      value,\n      match(callbacks: TransactionReceiptCallbacks) {\n        return statusReceipt in callbacks\n          ? (callbacks as any)[statusReceipt]!(value)\n          : (callbacks as TransactionReceiptCallbacksDefault)._();\n      },\n      isSuccess(): this is SuccessfulTransactionReceiptResponseHelper {\n        return statusReceipt === 'SUCCEEDED';\n      },\n      isReverted(): this is RevertedTransactionReceiptResponseHelper {\n        return statusReceipt === 'REVERTED';\n      },\n      isError(): this is ErrorReceiptResponseHelper {\n        return false;\n      },\n    };\n  } else {\n    // Error case\n    const errorValue = new Error('Unknown response type');\n    obj = {\n      statusReceipt: 'ERROR' as const,\n      value: errorValue,\n      match(callbacks: TransactionReceiptCallbacks) {\n        return 'ERROR' in callbacks\n          ? callbacks.ERROR!(errorValue)\n          : (callbacks as TransactionReceiptCallbacksDefault)._();\n      },\n      isSuccess(): this is SuccessfulTransactionReceiptResponseHelper {\n        return false;\n      },\n      isReverted(): this is RevertedTransactionReceiptResponseHelper {\n        return false;\n      },\n      isError(): this is ErrorReceiptResponseHelper {\n        return true;\n      },\n    };\n  }\n\n  // 🔥 HACK: Make it look like ReceiptTx instance for instanceof checks\n  Object.setPrototypeOf(obj, ReceiptTx.prototype);\n  Object.defineProperty(obj, 'constructor', {\n    value: ReceiptTx,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  return obj as GetTransactionReceiptResponse;\n}\n","/* eslint-disable no-param-reassign */\nimport { PRIME, RANGE_FELT, RANGE_I128, RANGE_U128 } from '../global/constants';\nimport {\n  BigNumberish,\n  TypedDataRevision as Revision,\n  StarknetEnumType,\n  StarknetMerkleType,\n  StarknetType,\n  TypedData,\n  type Signature,\n} from '../types';\nimport assert from './assert';\nimport { byteArrayFromString } from './calldata/byteArray';\nimport { starkCurve } from './ec';\nimport {\n  computePedersenHash,\n  computePedersenHashOnElements,\n  computePoseidonHash,\n  computePoseidonHashOnElements,\n  getSelectorFromName,\n} from './hash';\nimport { MerkleTree } from './merkle';\nimport { isBigNumberish, isHex, toHex } from './num';\nimport { encodeShortString } from './shortString';\nimport { isBoolean, isString } from './typed';\n\ninterface Context {\n  parent?: string;\n  key?: string;\n}\n\ninterface Configuration {\n  domain: string;\n  hashMethod: (data: BigNumberish[]) => string;\n  hashMerkleMethod: (a: BigNumberish, b: BigNumberish) => string;\n  escapeTypeString: (s: string) => string;\n  presetTypes: TypedData['types'];\n}\n\nconst presetTypes: TypedData['types'] = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  ),\n};\n\nconst revisionConfiguration: Record<Revision, Configuration> = {\n  [Revision.ACTIVE]: {\n    domain: 'StarknetDomain',\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes,\n  },\n  [Revision.LEGACY]: {\n    domain: 'StarkNetDomain',\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {},\n  },\n};\n\nfunction assertRange(data: unknown, type: string, { min, max }: { min: bigint; max: bigint }) {\n  const value = BigInt(data as string);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\n\nfunction identifyRevision({ types, domain }: TypedData) {\n  if (\n    revisionConfiguration[Revision.ACTIVE].domain in types &&\n    domain.revision?.toString() === Revision.ACTIVE\n  )\n    return Revision.ACTIVE;\n\n  if (\n    revisionConfiguration[Revision.LEGACY].domain in types &&\n    (domain.revision ?? Revision.LEGACY) === Revision.LEGACY\n  )\n    return Revision.LEGACY;\n\n  return undefined;\n}\n\nfunction getHex(value: BigNumberish): string {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\n\n/**\n * Validates that `data` matches the EIP-712 JSON schema.\n */\nexport function validateTypedData(data: unknown): data is TypedData {\n  const typedData = data as TypedData;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\n\n/**\n * Prepares the selector for later use, if it's not already in correct format.\n * The selector in correct format is the starknet_keccak hash of the function name, encoded in ASCII.\n *\n * @param {string} selector - The selector to be prepared.\n * @returns {string} The prepared selector.\n *\n * @example\n * ```typescript\n * const result1 = prepareSelector('0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8');\n * // result1 = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n *\n * const result2 =  prepareSelector('myFunction');\n * // result2 = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n * ```\n */\nexport function prepareSelector(selector: string): string {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\n\n/**\n * Checks if the given Starknet type is a Merkle tree type.\n *\n * @param {StarknetType} type - The StarkNet type to check.\n *\n * @returns {boolean} - True if the type is a Merkle tree type, false otherwise.\n *\n * @example\n * ```typescript\n * const type = { name: 'test', type: 'merkletree',};\n * const result1 = isMerkleTreeType(type);\n * // result1 = true\n *\n * const type2 = {name: 'test', type: 'non-merkletree',};\n * const result2 =  isMerkleTreeType(type2);\n * // result2 = false\n * ```\n */\nexport function isMerkleTreeType(type: StarknetType): type is StarknetMerkleType {\n  return type.type === 'merkletree';\n}\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to get dependencies for.\n * @param {string[]} [dependencies=[]] - The array to store dependencies.\n * @param {string} [contains=''] - The type contained within the struct.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string[]} The array of dependencies.\n */\nexport function getDependencies(\n  types: TypedData['types'],\n  type: string,\n  dependencies: string[] = [],\n  contains: string = '',\n  revision: Revision = Revision.LEGACY\n): string[] {\n  let dependencyTypes: string[] = [type];\n\n  // Include pointers (struct arrays)\n  if (type[type.length - 1] === '*') {\n    dependencyTypes = [type.slice(0, -1)];\n  } else if (revision === Revision.ACTIVE) {\n    // enum base\n    if (type === 'enum') {\n      dependencyTypes = [contains];\n    }\n    // enum element types\n    else if (type.match(/^\\(.*\\)$/)) {\n      dependencyTypes = type\n        .slice(1, -1)\n        .split(',')\n        .map((depType) => (depType[depType.length - 1] === '*' ? depType.slice(0, -1) : depType));\n    }\n  }\n\n  return dependencyTypes\n    .filter((t) => !dependencies.includes(t) && types[t])\n    .reduce<string[]>(\n      // This comment prevents prettier from rolling everything here into a single line.\n      (p, depType) => [\n        ...p,\n        ...[\n          depType,\n          ...(types[depType] as StarknetEnumType[]).reduce<string[]>(\n            (previous, t) => [\n              ...previous,\n              ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n                (dependency) => !previous.includes(dependency)\n              ),\n            ],\n            []\n          ),\n        ].filter((dependency) => !p.includes(dependency)),\n      ],\n      []\n    );\n}\n\nfunction getMerkleTreeType(types: TypedData['types'], ctx: Context) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key)!;\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith('*')) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return 'raw';\n}\n\n/**\n * Encode a type to a string. All dependent types are alphabetically sorted.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The encoded string.\n *\n * @example\n * ```typescript\n * import typedDataExample from '../../__mocks__/typedData/baseExample.json';\n *\n * const result = encodeType(typedDataExample.types, 'Mail');\n * // result = \"Mail(from:Person,to:Person,contents:felt)Person(name:felt,wallet:felt)\";\n * ```\n */\nexport function encodeType(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  const allTypes =\n    revision === Revision.ACTIVE\n      ? { ...types, ...revisionConfiguration[revision].presetTypes }\n      : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    undefined,\n    undefined,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n\n  const esc = revisionConfiguration[revision].escapeTypeString;\n\n  return newTypes\n    .map((dependency) => {\n      const dependencyElements = allTypes[dependency].map((t) => {\n        const targetType =\n          t.type === 'enum' && revision === Revision.ACTIVE\n            ? (t as StarknetEnumType).contains\n            : t.type;\n        // parentheses handling for enum variant types\n        const typeString = targetType.match(/^\\(.*\\)$/)\n          ? `(${targetType\n              .slice(1, -1)\n              .split(',')\n              .map((e) => (e ? esc(e) : e))\n              .join(',')})`\n          : esc(targetType);\n        return `${esc(t.name)}:${typeString}`;\n      });\n      return `${esc(dependency)}(${dependencyElements})`;\n    })\n    .join('');\n}\n\n/**\n * Get a type string as hash.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to hash.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The hash.\n *\n * @example\n * ```typescript\n * import typedDataExample from '../../__mocks__/typedData/baseExample.json';\n *\n * const result = getTypeHash(typedDataExample.types, 'StarkNetDomain');\n * // result = \"0x1bfc207425a47a5dfa1a50a4f5241203f50624ca5fdf5e18755765416b8e288\";\n * ```\n */\nexport function getTypeHash(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as a tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {unknown} data - The data to encode.\n * @param {Context} [ctx={}] - The context of the encoding process.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {[string, string]} The ABI compatible type and corresponding value.\n *\n * @example\n * ```typescript\n * import { getSelectorFromName } from '../../src/utils/hash';\n *\n * const selector = 'transfer';\n * const selectorHash = getSelectorFromName(selector);\n * const result1 = encodeValue({}, 'felt', selectorHash);\n *\n * // result1 = ['felt', '0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e']\n * ```\n */\nexport function encodeValue(\n  types: TypedData['types'],\n  type: string,\n  data: unknown,\n  ctx: Context = {},\n  revision: Revision = Revision.LEGACY\n): [string, string] {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data as TypedData['message'], revision)];\n  }\n\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data as TypedData['message'],\n        revision\n      ),\n    ];\n  }\n\n  if (type.endsWith('*')) {\n    const hashes: string[] = (data as Array<TypedData['message']>).map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, undefined, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n\n  switch (type) {\n    case 'enum': {\n      if (revision === Revision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data as TypedData['message'])[0];\n\n        const parentType = types[ctx.parent as string].find((t) => t.name === ctx.key);\n        const enumType = types[(parentType as StarknetEnumType).contains];\n        const variantType = enumType.find((t) => t.name === variantKey) as StarknetType;\n        const variantIndex = enumType.indexOf(variantType);\n\n        const encodedSubtypes = variantType.type\n          .slice(1, -1)\n          .split(',')\n          .map((subtype, index) => {\n            if (!subtype) return subtype;\n            const subtypeData = (variantData as unknown[])[index];\n            return encodeValue(types, subtype, subtypeData, undefined, revision)[1];\n          });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes]),\n        ];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'merkletree': {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes: string[] = (data as Array<TypedData['message']>).map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, undefined, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes as string[],\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return ['felt', root];\n    }\n    case 'selector': {\n      return ['felt', prepareSelector(data as string)];\n    }\n    case 'string': {\n      if (revision === Revision.ACTIVE) {\n        const byteArray = byteArrayFromString(data as string);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len,\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'i128': {\n      if (revision === Revision.ACTIVE) {\n        const value = BigInt(data as string);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'timestamp':\n    case 'u128': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'felt':\n    case 'shortstring': {\n      // TODO: should 'shortstring' diverge into directly using encodeShortString()?\n      if (revision === Revision.ACTIVE) {\n        assertRange(getHex(data as string), type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'ClassHash':\n    case 'ContractAddress': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'bool': {\n      if (revision === Revision.ACTIVE) {\n        assert(isBoolean(data), `Type mismatch for ${type} ${data}`);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    default: {\n      if (revision === Revision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data as string)];\n    }\n  }\n}\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {TypedData['message']} data - The data to encode.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {[string[], string[]]} The ABI compatible types and corresponding values.\n */\nexport function encodeData<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n): [string[], string[]] {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce<[string[], string[]]>(\n    ([ts, vs], field) => {\n      if (\n        data[field.name as keyof T['message']] === undefined ||\n        (data[field.name as keyof T['message']] === null && field.type !== 'enum')\n      ) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name as keyof T['message']];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n\n      return [\n        [...ts, t],\n        [...vs, encodedValue],\n      ];\n    },\n    [['felt'], [getTypeHash(types, type, revision)]]\n  );\n\n  return [returnTypes, values];\n}\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to hash.\n * @param {TypedData['message']} data - The data to hash.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The hash of the encoded data.\n *\n * @example\n * ```typescript\n * import exampleBaseTypes from '../../__mocks__/typedData/example_baseTypes.json';\n *\n * const result = getStructHash(\n *    exampleBaseTypes.types,\n *    'StarknetDomain',\n *    exampleBaseTypes.domain as StarknetDomain,\n *    TypedDataRevision.ACTIVE\n *  );\n *  // result = \"0x555f72e550b308e50c1a4f8611483a174026c982a9893a05c185eeb85399657\";\n * ```\n */\nexport function getStructHash<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n): string {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\n\n/**\n * Get the SNIP-12 encoded message to sign, from the typedData object.\n *\n * @param {TypedData} typedData - The TypedData object.\n * @param {BigNumberish} accountAddress - The account address to sign the message.\n *\n * @returns {string} The hash of the message to sign.\n * @throws Will throw an error if the typedData does not match the JSON schema.\n *\n * @example\n * ```typescript\n * const exampleAddress = \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\";\n * const typedDataStringExample = {\n *  types: {\n *    StarkNetDomain: [\n *      { name: 'name', type: 'felt' },\n *      { name: 'version', type: 'felt' },\n *      { name: 'chainId', type: 'felt' },\n *    ],\n *    Person: [\n *      { name: 'name', type: 'felt' },\n *      { name: 'wallet', type: 'felt' },\n *    ],\n *    String: [\n *      { name: 'len', type: 'felt' },\n *      { name: 'data', type: 'felt*' },\n *    ],\n *    Mail: [\n *      { name: 'from', type: 'Person' },\n *      { name: 'to', type: 'Person' },\n *      { name: 'contents', type: 'String' },\n *    ],\n *  },\n *  primaryType: 'Mail',\n *  domain: {\n *    name: 'StarkNet Mail',\n *    version: '1',\n *    chainId: 1,\n *  },\n *  message: {\n *    from: {\n *      name: 'Cow',\n *      wallet: exampleAddress,\n *    },\n *    to: {\n *      name: 'Bob',\n *      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *    },\n *    contents: stringToStringStruct(\n *      'this is way longer than just 32 characters, to test if that is possible within a typedData struct.'\n *    ),\n *  },\n * };\n *\n * const result = getMessageHash(typedDataStringExample, exampleAddress);\n * // result = \"0x70338fb11b8f70b68b261de8a322bcb004bd85e88ac47d9147982c7f5ac66fd\"\n * ```\n */\nexport function getMessageHash(typedData: TypedData, accountAddress: BigNumberish): string {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const revision = identifyRevision(typedData) as Revision;\n  const { domain, hashMethod } = revisionConfiguration[revision];\n\n  const message = [\n    encodeShortString('StarkNet Message'),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    accountAddress,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision),\n  ];\n\n  return hashMethod(message);\n}\n\n/**\n * Checks if a signed EIP712 message is related to an account.\n * Valid for a standard Starknet signature.\n * @param {BigNumberish | TypedData} message a TypedMessage message, or the hash of an EIP712 message (SNIP-12).\n * @param {Signature} signature a WeierstrassSignatureType signature, or an array of 2 strings.\n * @param {BigNumberish} fullPublicKey a number coded on 520 bits (from ec.getFullPublicKey()).\n * @param {BigNumberish} [accountAddress] address of the account that has signed the message. Not needed with a message hash is provided in `message`\n * @returns {boolean} true if the message is verified.\n * @example\n * ```typescript\n * const myTypedMessage: TypedMessage = .... ;\n * const sign: Signature = [\"0x123...abc\", \"0x345...def\"];\n * const fullPubK = \"0x0400b730bd22358612b5a67f8ad52ce80f9e8e893639ade263537e6ef35852e5d3057795f6b090f7c6985ee143f798608a53b3659222c06693c630857a10a92acf\";\n * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n * const result1 = typedData.verifyMessage(myTypedMessage, sign, fullPubK, accountAddress);\n * const result2 = typedData.verifyMessage(messageHash, sign, fullPubK);\n * // result1 = result2 = true\n * ```\n */\nexport function verifyMessage(\n  message: TypedData,\n  signature: Signature,\n  fullPublicKey: BigNumberish,\n  accountAddress: BigNumberish\n): boolean;\nexport function verifyMessage(\n  message: BigNumberish,\n  signature: Signature,\n  fullPublicKey: BigNumberish\n): boolean;\nexport function verifyMessage(\n  message: BigNumberish | TypedData,\n  signature: Signature,\n  fullPublicKey: BigNumberish,\n  accountAddress?: BigNumberish\n): boolean {\n  const isTypedData = validateTypedData(message);\n  if (!isBigNumberish(message) && !isTypedData) {\n    throw new Error('message has a wrong format.');\n  }\n  if (isTypedData && accountAddress === undefined) {\n    throw new Error(\n      'When providing a TypedData in message parameter, the accountAddress parameter has to be provided.'\n    );\n  }\n  if (isTypedData && !isBigNumberish(accountAddress)) {\n    throw new Error('accountAddress shall be a BigNumberish');\n  }\n  const messageHash = isTypedData\n    ? getMessageHash(message, accountAddress as BigNumberish)\n    : toHex(message);\n  const sign = Array.isArray(signature)\n    ? new starkCurve.Signature(BigInt(signature[0]), BigInt(signature[1]))\n    : signature;\n  const fullPubKey = toHex(fullPublicKey);\n  const isValid = starkCurve.verify(sign, messageHash, fullPubKey);\n  return isValid;\n}\n","import { BigNumberish } from '../types';\nimport { computePedersenHash } from './hash';\n\nexport class MerkleTree {\n  public leaves: string[];\n\n  public branches: string[][] = [];\n\n  public root: string;\n\n  public hashMethod: (a: BigNumberish, b: BigNumberish) => string;\n\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(\n    leafHashes: string[],\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n\n  /** @ignore */\n  private build(leaves: string[]): string {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves: string[] = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(MerkleTree.hash(leaves[i], '0x0', this.hashMethod));\n      } else {\n        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(\n    a: BigNumberish,\n    b: BigNumberish,\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => (x >= y ? 1 : -1));\n    return hashMethod(aSorted, bSorted);\n  }\n\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  public getProof(leaf: string, branch = this.leaves, hashPath: string[] = []): string[] {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error('leaf not found');\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? '0x0';\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex =\n      this.leaves.length === branch.length\n        ? -1\n        : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n}\n\n/**\n * Tests a Merkle tree path\n *\n * @param root hex-string\n * @param leaf hex-string\n * @param path hex-string array\n * @param hashMethod hash method to use, default: Pedersen\n * @returns true if the path is valid, false otherwise\n * @example\n * ```typescript\n * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n * const tree = new MerkleTree(leaves);\n * const result = proofMerklePath(tree.root, '0x3', [\n *   '0x4',\n *   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n *   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n * ]);\n * // result = true\n * ```\n */\nexport function proofMerklePath(\n  root: string,\n  leaf: string,\n  path: string[],\n  hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n): boolean {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n","import type { ProviderInterface } from '..';\nimport type { BigNumberish, Signature, TypedData } from '../../types';\nimport { isBigNumberish, toBigInt, toHex } from '../../utils/num';\nimport { CallData } from '../../utils/calldata';\nimport { formatSignature } from '../../utils/stark';\nimport { getMessageHash, validateTypedData } from '../../utils/typedData';\n\n/**\n * Verify in Starknet a signature of a TypedData object or of a given hash.\n * @param {ProviderInterface} provider - The provider to use for the verification.\n * @param {BigNumberish | TypedData} message TypedData object to be verified, or message hash to be verified.\n * @param {Signature} signature signature of the message.\n * @param {BigNumberish} accountAddress address of the account that has signed the message.\n * @param {string} [signatureVerificationFunctionName] if account contract with non standard account verification function name.\n * @param { okResponse: string[]; nokResponse: string[]; error: string[] } [signatureVerificationResponse] if account contract with non standard response of verification function.\n * @returns\n * ```typescript\n * const myTypedMessage: TypedMessage = .... ;\n * const messageHash = typedData.getMessageHash(myTypedMessage,accountAddress);\n * const sign: WeierstrassSignatureType = ec.starkCurve.sign(messageHash, privateKey);\n * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n * const result1 = await myRpcProvider.verifyMessageInStarknet(myTypedMessage, sign, accountAddress);\n * const result2 = await myRpcProvider.verifyMessageInStarknet(messageHash, sign, accountAddress);\n * // result1 = result2 = true\n * ```\n */\nexport async function verifyMessageInStarknet(\n  provider: ProviderInterface,\n  message: BigNumberish | TypedData,\n  signature: Signature,\n  accountAddress: BigNumberish,\n  signatureVerificationFunctionName?: string,\n  signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n): Promise<boolean> {\n  const isTypedData = validateTypedData(message);\n  if (!isBigNumberish(message) && !isTypedData) {\n    throw new Error('message has a wrong format.');\n  }\n  if (!isBigNumberish(accountAddress)) {\n    throw new Error('accountAddress shall be a BigNumberish');\n  }\n  const messageHash = isTypedData ? getMessageHash(message, accountAddress) : toHex(message);\n  // HOTFIX: Accounts should conform to SNIP-6\n  // (https://github.com/starknet-io/SNIPs/blob/f6998f779ee2157d5e1dea36042b08062093b3c5/SNIPS/snip-6.md?plain=1#L61),\n  // but they don't always conform. Also, the SNIP doesn't standardize the response if the signature isn't valid.\n  const knownSigVerificationFName = signatureVerificationFunctionName\n    ? [signatureVerificationFunctionName]\n    : ['isValidSignature', 'is_valid_signature'];\n  const knownSignatureResponse = signatureVerificationResponse || {\n    okResponse: [\n      // any non-nok response is true\n    ],\n    nokResponse: [\n      '0x0', // Devnet\n      '0x00', // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n    ],\n    error: [\n      'argent/invalid-signature',\n      '0x617267656e742f696e76616c69642d7369676e6174757265', // ArgentX 0.3.0 to 0.3.1\n      'is invalid, with respect to the public key',\n      '0x697320696e76616c6964', // OpenZeppelin until 0.6.1, Braavos 0.0.11\n      'INVALID_SIG',\n      '0x494e56414c49445f534947', // Braavos 1.0.0\n    ],\n  };\n  let error: any;\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const SigVerificationFName of knownSigVerificationFName) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      const resp = await provider.callContract({\n        contractAddress: toHex(accountAddress),\n        entrypoint: SigVerificationFName,\n        calldata: CallData.compile({\n          hash: toBigInt(messageHash).toString(),\n          signature: formatSignature(signature),\n        }),\n      });\n      // Response NOK Signature\n      if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n        return false;\n      }\n      // Response OK Signature\n      // Empty okResponse assume all non-nok responses are valid signatures\n      // OpenZeppelin 0.7.0 to 0.9.0, ArgentX 0.3.0 to 0.3.1 & Braavos Cairo 0.0.11 to 1.0.0 valid signature\n      if (\n        knownSignatureResponse.okResponse.length === 0 ||\n        knownSignatureResponse.okResponse.includes(resp[0].toString())\n      ) {\n        return true;\n      }\n      throw Error('signatureVerificationResponse Error: response is not part of known responses');\n    } catch (err) {\n      // Known NOK Errors\n      if (\n        knownSignatureResponse.error.some((errMessage) =>\n          (err as Error).message.includes(errMessage)\n        )\n      ) {\n        return false;\n      }\n      // Unknown Error\n      error = err;\n    }\n  }\n\n  throw Error(`Signature verification Error: ${error}`);\n}\n","import type { RpcChannel } from '../../channel';\nimport type { BlockIdentifier, BlockWithTxHashes, GasPrices } from '../../types';\n\nexport async function getGasPrices(\n  channel: RpcChannel,\n  blockIdentifier: BlockIdentifier = channel.blockIdentifier\n): Promise<GasPrices> {\n  const bl = (await channel.getBlockWithTxHashes(blockIdentifier)) as BlockWithTxHashes;\n  return {\n    l1DataGasPrice: BigInt(bl.l1_data_gas_price.price_in_fri),\n    l1GasPrice: BigInt(bl.l1_gas_price.price_in_fri),\n    l2GasPrice: BigInt(bl.l2_gas_price.price_in_fri),\n  } as GasPrices;\n}\n","import { RPC08, RPC09 } from '../channel';\nimport { config } from '../global/config';\nimport { SupportedRpcVersion } from '../global/constants';\nimport { logger } from '../global/logger';\nimport {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  ContractClassIdentifier,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  type fastWaitForTransactionOptions,\n  type GasPrices,\n  GetBlockResponse,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  GetTransactionReceiptResponse,\n  GetTxReceiptResponseWithoutHelper,\n  Invocation,\n  Invocations,\n  InvocationsDetailsWithNonce,\n  PendingBlock,\n  PreConfirmedStateUpdate,\n  RPC,\n  RpcProviderOptions,\n  type Signature,\n  StateUpdate,\n  StateUpdateResponse,\n  type TypedData,\n  waitForTransactionOptions,\n} from '../types';\nimport { ETransactionType, RPCSPEC08, RPCSPEC09 } from '../types/api';\nimport assert from '../utils/assert';\nimport { getAbiContractVersion } from '../utils/calldata/cairo';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { LibraryError } from '../utils/errors';\nimport { solidityUint256PackedKeccak256 } from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { wait } from '../utils/provider';\nimport { isSupportedSpecVersion, isVersion } from '../utils/resolve';\nimport { RPCResponseParser } from '../utils/responseParser/rpc';\nimport { getTipStatsFromBlocks, TipAnalysisOptions, TipEstimate } from './modules/tip';\nimport { createTransactionReceipt } from '../utils/transactionReceipt/transactionReceipt';\nimport { ProviderInterface } from './interface';\nimport type {\n  DeclaredTransaction,\n  DeployedAccountTransaction,\n  InvokedTransaction,\n  L1_HANDLER_TXN,\n  TransactionWithHash,\n} from './types/spec.type';\nimport { verifyMessageInStarknet } from './modules/verifyMessageInStarknet';\nimport { getGasPrices } from './modules';\n\nexport class RpcProvider implements ProviderInterface {\n  public responseParser: RPCResponseParser;\n\n  public channel: RPC08.RpcChannel | RPC09.RpcChannel;\n\n  constructor(optionsOrProvider?: RpcProviderOptions | ProviderInterface | RpcProvider) {\n    if (optionsOrProvider && 'channel' in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser =\n        'responseParser' in optionsOrProvider\n          ? optionsOrProvider.responseParser\n          : new RPCResponseParser();\n    } else {\n      const options = optionsOrProvider as RpcProviderOptions | undefined;\n      if (options && options.specVersion) {\n        if (isVersion('0.8', options.specVersion)) {\n          this.channel = new RPC08.RpcChannel({ ...options, waitMode: false });\n        } else if (isVersion('0.9', options.specVersion)) {\n          this.channel = new RPC09.RpcChannel({ ...options, waitMode: false });\n        } else throw new Error(`unsupported channel for spec version: ${options.specVersion}`);\n      } else if (isVersion('0.8', config.get('rpcVersion'))) {\n        // default channel when unspecified\n        this.channel = new RPC08.RpcChannel({ ...options, waitMode: false });\n      } else if (isVersion('0.9', config.get('rpcVersion'))) {\n        // default channel when unspecified\n        this.channel = new RPC09.RpcChannel({ ...options, waitMode: false });\n      } else throw new Error('unable to define spec version for channel');\n\n      this.responseParser = new RPCResponseParser(options?.resourceBoundsOverhead);\n    }\n  }\n\n  /**\n   * auto configure channel based on provided node\n   * leave space for other async before constructor\n   */\n  // NOTE: the generic T and 'this' reference are used so that the expanded class is generated when a mixin is applied\n  static async create<T extends RpcProvider>(\n    this: { new (...args: ConstructorParameters<typeof RpcProvider>): T },\n    optionsOrProvider?: RpcProviderOptions\n  ): Promise<T> {\n    const channel = new RPC08.RpcChannel({ ...optionsOrProvider });\n    const spec = await channel.getSpecVersion();\n\n    // Optimistic Warning in case of the patch version\n    if (!isSupportedSpecVersion(spec)) {\n      logger.warn(`Using incompatible node spec version ${spec}`);\n    }\n\n    if (isVersion('0.8', spec)) {\n      return new this({\n        ...optionsOrProvider,\n        specVersion: SupportedRpcVersion.v0_8_1,\n      }) as T;\n    }\n    if (isVersion('0.9', spec)) {\n      return new this({\n        ...optionsOrProvider,\n        specVersion: SupportedRpcVersion.v0_9_0,\n      }) as T;\n    }\n\n    throw new LibraryError(\n      `Provided RPC node specification version ${spec} is not compatible with the SDK. SDK supported RPC versions ${Object.keys(SupportedRpcVersion).toString()}`\n    );\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n\n  public async getChainId() {\n    return this.channel.getChainId();\n  }\n\n  public readSpecVersion() {\n    return this.channel.readSpecVersion();\n  }\n\n  public async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n\n  public setUpSpecVersion() {\n    return this.channel.setUpSpecVersion();\n  }\n\n  public async getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n\n  public async getBlock(): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'pre_confirmed'): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public async getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;\n  public async getBlock(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseGetBlockResponse);\n  }\n\n  public async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n\n  public async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n\n  public async getBlockWithTxHashes(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n\n  public async getBlockWithTxs(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n\n  public async waitForBlock(\n    blockIdentifier: BlockIdentifier = BlockTag.LATEST,\n    retryInterval: number = 5000\n  ) {\n    if (blockIdentifier === BlockTag.LATEST) return;\n    if (blockIdentifier === 'pending') return; // For RPC 0.8.1\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock =\n      blockIdentifier === BlockTag.PRE_CONFIRMED\n        ? currentBlock + 1\n        : Number(toHex(blockIdentifier as BigNumberish));\n    if (targetBlock <= currentBlock) return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock: boolean = false;\n    while (!isTargetBlock) {\n      // eslint-disable-next-line no-await-in-loop\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        // eslint-disable-next-line no-await-in-loop\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n\n  public async getL1GasPrice(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseL1GasPriceResponse);\n  }\n\n  /**\n   * Get the gas prices related to a block.\n   * @param {BlockIdentifier} [blockIdentifier = this.identifier] - Optional. Can be 'pending', 'latest' or a block number (an integer type).\n   * @returns {Promise<GasPrices>} an object with l1DataGasPrice, l1GasPrice, l2GasPrice properties (all bigint type).\n   * @example\n   * ```ts\n   * const result = await myProvider.getGasPrices();\n   * // result = { l1DataGasPrice: 3039n, l1GasPrice: 55590341542890n, l2GasPrice: 8441845008n }\n   * ```\n   */\n  public async getGasPrices(\n    blockIdentifier: BlockIdentifier = this.channel.blockIdentifier\n  ): Promise<GasPrices> {\n    if (this.channel instanceof RPC09.RpcChannel)\n      return getGasPrices(this.channel, blockIdentifier);\n    throw new LibraryError('Unsupported method for RPC version');\n  }\n\n  public async getL1MessageHash(l2TxHash: BigNumberish): Promise<string> {\n    const transaction = (await this.channel.getTransactionByHash(l2TxHash)) as TransactionWithHash;\n    assert(transaction.type === 'L1_HANDLER', 'This L2 transaction is not a L1 message.');\n    const { calldata, contract_address, entry_point_selector, nonce } =\n      transaction as L1_HANDLER_TXN;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1),\n    ];\n    return solidityUint256PackedKeccak256(params);\n  }\n\n  public async getBlockWithReceipts(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n\n  public getStateUpdate = this.getBlockStateUpdate;\n\n  public async getBlockStateUpdate(): Promise<StateUpdate>;\n  public async getBlockStateUpdate(\n    blockIdentifier: 'pre_confirmed'\n  ): Promise<PreConfirmedStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n\n  public async getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n\n  public async getBlockTransactionCount(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n\n  public async getTransaction(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByHash(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n\n  public async getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse> {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified =\n      this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return createTransactionReceipt(txReceiptWoHelperModified);\n  }\n\n  public async getTransactionTrace(\n    txHash: BigNumberish\n  ): Promise<RPCSPEC08.TRANSACTION_TRACE | RPCSPEC09.TRANSACTION_TRACE> {\n    return this.channel.getTransactionTrace(txHash);\n  }\n\n  public async getTransactionStatus(transactionHash: BigNumberish) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n\n  public async getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ) {\n    // can't be named simulateTransaction because of argument conflict with account\n    return this.channel\n      .simulateTransaction(invocations, options)\n      .then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n\n  public async waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse> {\n    const receiptWoHelper = (await this.channel.waitForTransaction(\n      txHash,\n      options\n    )) as GetTxReceiptResponseWithoutHelper;\n\n    return createTransactionReceipt(receiptWoHelper);\n  }\n\n  /**\n   * Wait up until a new transaction is possible with same the account.\n   * This method is fast, but Events and transaction report are not yet\n   * available. Useful for gaming activity.\n   * - only rpc 0.9 and onwards.\n   * @param {BigNumberish} txHash - transaction hash\n   * @param {string} address - address of the account\n   * @param {BigNumberish} initNonce - initial nonce of the account (before the transaction).\n   * @param {fastWaitForTransactionOptions} [options={retries: 50, retryInterval: 500}] - options to scan the network for the next possible transaction. `retries` is the number of times to retry.\n   * @returns {Promise<boolean>} Returns true if the next transaction is possible,\n   * false if the timeout has been reached,\n   * throw an error in case of provider communication.\n   */\n  public async fastWaitForTransaction(\n    txHash: BigNumberish,\n    address: string,\n    initNonce: BigNumberish,\n    options?: fastWaitForTransactionOptions\n  ): Promise<boolean> {\n    if (this.channel instanceof RPC09.RpcChannel) {\n      const isSuccess = await this.channel.fastWaitForTransaction(\n        txHash,\n        address,\n        initNonce,\n        options\n      );\n      return isSuccess;\n    }\n    throw new Error('Unsupported channel type');\n  }\n\n  public async getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n\n  public async getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n\n  public async getClassByHash(classHash: BigNumberish) {\n    return this.getClass(classHash);\n  }\n\n  public async getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClass(classHash, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClassAt(contractAddress, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getContractVersion(\n    contractAddress: BigNumberish,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n  public async getContractVersion(\n    contractAddress: undefined,\n    classHash: BigNumberish,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  public async getContractVersion(\n    contractAddress?: BigNumberish,\n    classHash?: BigNumberish,\n    {\n      blockIdentifier = this.channel.blockIdentifier,\n      compiler = true,\n    }: getContractVersionOptions = {}\n  ): Promise<ContractVersion> {\n    let contractClass: ContractClassResponse;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error('getContractVersion require contractAddress or classHash');\n    }\n\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: '1', compiler: abiTest.compiler };\n      }\n      return { cairo: '1', compiler: undefined };\n    }\n    return { cairo: '0', compiler: '0' };\n  }\n\n  public async getInvokeEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return (\n      await this.getEstimateFeeBulk(\n        [{ type: ETransactionType.INVOKE, ...invocation, ...details }],\n        { blockIdentifier, skipValidate }\n      )\n    )[0]; // Return the first (and only) estimate\n  }\n\n  public async getDeclareEstimateFee(\n    invocation: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return (\n      await this.getEstimateFeeBulk(\n        [{ type: ETransactionType.DECLARE, ...invocation, ...details }],\n        { blockIdentifier, skipValidate }\n      )\n    )[0]; // Return the first (and only) estimate\n  }\n\n  public async getDeployAccountEstimateFee(\n    invocation: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return (\n      await this.getEstimateFeeBulk(\n        [{ type: ETransactionType.DEPLOY_ACCOUNT, ...invocation, ...details }],\n        { blockIdentifier, skipValidate }\n      )\n    )[0]; // Return the first (and only) estimate\n  }\n\n  public async getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options?: getEstimateFeeBulkOptions\n  ) {\n    return this.channel\n      .getEstimateFee(invocations, options)\n      .then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n\n  public async invokeFunction(\n    functionInvocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.invoke(functionInvocation, details) as Promise<InvokedTransaction>;\n  }\n\n  public async declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.declare(transaction, details) as Promise<DeclaredTransaction>;\n  }\n\n  public async deployAccountContract(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.deployAccount(transaction, details) as Promise<DeployedAccountTransaction>;\n  }\n\n  public async callContract(call: Call, blockIdentifier?: BlockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n\n  public async estimateMessageFee(\n    message: RPCSPEC09.L1Message, // same as spec08.L1Message\n    blockIdentifier?: BlockIdentifier\n  ): Promise<RPCSPEC08.FEE_ESTIMATE | RPCSPEC09.MESSAGE_FEE_ESTIMATE> {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n\n  public async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n\n  public async getEvents(\n    eventFilter: RPCSPEC08.EventFilter | RPCSPEC09.EventFilter\n  ): Promise<RPCSPEC08.EVENTS_CHUNK | RPCSPEC09.EVENTS_CHUNK> {\n    if (this.channel instanceof RPC08.RpcChannel) {\n      return this.channel.getEvents(eventFilter as RPCSPEC08.EventFilter);\n    }\n    if (this.channel instanceof RPC09.RpcChannel) {\n      return this.channel.getEvents(eventFilter as RPCSPEC09.EventFilter);\n    }\n    throw new Error('Unsupported channel type');\n  }\n\n  public async verifyMessageInStarknet(\n    message: BigNumberish | TypedData,\n    signature: Signature,\n    accountAddress: BigNumberish,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    return verifyMessageInStarknet(\n      this,\n      message,\n      signature,\n      accountAddress,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n\n  public async isClassDeclared(\n    contractClassIdentifier: ContractClassIdentifier,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    let classHash: string;\n    if (!contractClassIdentifier.classHash && 'contract' in contractClassIdentifier) {\n      const hashes = extractContractHashes(contractClassIdentifier);\n      classHash = hashes.classHash;\n    } else if (contractClassIdentifier.classHash) {\n      classHash = contractClassIdentifier.classHash;\n    } else {\n      throw Error('contractClassIdentifier type not satisfied');\n    }\n\n    try {\n      const result = await this.getClass(classHash, blockIdentifier);\n      return result instanceof Object;\n    } catch (error) {\n      if (error instanceof LibraryError) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  public async prepareInvocations(invocations: Invocations) {\n    const bulk: Invocations = [];\n    // Build new ordered array\n    // eslint-disable-next-line no-restricted-syntax\n    for (const invocation of invocations) {\n      if (invocation.type === ETransactionType.DECLARE) {\n        // Test if already declared\n        // eslint-disable-next-line no-await-in-loop\n        const isDeclared = await this.isClassDeclared(\n          'payload' in invocation ? invocation.payload : invocation\n        );\n        if (!isDeclared) {\n          bulk.unshift(invocation);\n        }\n      } else {\n        bulk.push(invocation);\n      }\n    }\n    return bulk;\n  }\n\n  public async getL1MessagesStatus(\n    transactionHash: BigNumberish\n  ): Promise<RPC.RPCSPEC08.L1L2MessagesStatus | RPC.RPCSPEC09.L1L2MessagesStatus> {\n    return this.channel.getMessagesStatus(transactionHash);\n  }\n\n  public async getStorageProof(\n    classHashes: BigNumberish[],\n    contractAddresses: BigNumberish[],\n    contractsStorageKeys: RPC.CONTRACT_STORAGE_KEYS[],\n    blockIdentifier?: BlockIdentifier\n  ): Promise<RPC.StorageProof> {\n    return this.channel.getStorageProof(\n      classHashes,\n      contractAddresses,\n      contractsStorageKeys,\n      blockIdentifier\n    );\n  }\n\n  public async getCompiledCasm(classHash: BigNumberish): Promise<RPC.CASM_COMPILED_CONTRACT_CLASS> {\n    return this.channel.getCompiledCasm(classHash);\n  }\n\n  public async getEstimateTip(\n    blockIdentifier?: BlockIdentifier,\n    options: TipAnalysisOptions = {}\n  ): Promise<TipEstimate> {\n    return getTipStatsFromBlocks(this, blockIdentifier, options);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { Mixin } from 'ts-mixer';\n\nimport { RpcProvider as BaseRpcProvider } from '../rpc';\nimport { StarknetId } from './starknetId';\nimport { BrotherId } from './brotherId';\n\nexport class RpcProvider extends Mixin(BaseRpcProvider, StarknetId, BrotherId) {}\n","import { StarknetChainId, ZERO } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport { tuple } from './calldata/cairo';\nimport { CairoCustomEnum } from './calldata/enum/CairoCustomEnum';\n/* eslint-disable no-param-reassign */\n\nconst basicAlphabet = 'abcdefghijklmnopqrstuvwxyz0123456789-';\nconst basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nconst bigAlphabet = '这来';\nconst basicAlphabetSize = BigInt(basicAlphabet.length);\nconst bigAlphabetSize = BigInt(bigAlphabet.length);\nconst bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\n\nfunction extractStars(str: string): [string, number] {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\n\n/**\n * Decodes an array of BigInts into a string using the given algorithm.\n * @param {bigint[]} encoded The encoded array of BigInts.\n * @return {string} The decoded string.\n * @example\n * ```typescript\n * const result = starknetId.useDecoded([3015206943634620n]);\n * // result = \"starknetjs.stark\"\n * ```\n */\nexport function useDecoded(encoded: bigint[]): string {\n  let decoded = '';\n\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded =\n        str +\n        (k % 2 === 0\n          ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) +\n            bigAlphabet[0] +\n            basicAlphabet[1]\n          : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += '.';\n  });\n\n  if (!decoded) {\n    return decoded;\n  }\n\n  return decoded.concat('stark');\n}\n\n/**\n * Encodes a string into a bigint value.\n *\n * @param {string} decoded The string to be encoded.\n * @returns {bigint} The encoded bigint value.\n * @example\n * ```typescript\n * const result = starknetId.useEncoded(\"starknet.js\");\n * // result = 3015206943634620n\n * ```\n */\nexport function useEncoded(decoded: string): bigint {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n\n    if (index !== -1) {\n      // add encoded + multiplier * index\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        // add 0\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      // add encoded + multiplier * (basicAlphabetSize)\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      // add encoded + multiplier * index\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n\n  return encoded;\n}\n\nexport const StarknetIdContract = {\n  MAINNET: '0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678',\n  TESTNET_SEPOLIA: '0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474',\n} as const;\n\n/**\n * Returns the Starknet ID contract address based on the provided chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID of the Starknet network.\n * @return {string} The Starknet ID contract address.\n * @throws {Error} Throws an error if the Starknet ID contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\"\n * ```\n */\nexport function getStarknetIdContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdIdentityContract = {\n  MAINNET: '0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af',\n  TESTNET_SEPOLIA: '0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda',\n} as const;\n\n/**\n * Returns the Starknet ID identity contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID for the specified network.\n *\n * @return {string} The Starknet ID identity contract address for the specified network.\n *\n * @throws {Error} If the Starknet ID verifier contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdIdentityContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\"\n * ```\n */\nexport function getStarknetIdIdentityContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdIdentityContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdIdentityContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdMulticallContract =\n  '0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970';\n\n/**\n * Returns the Starknet.id multicall contract address based on the provided chainId.\n *\n * @param {StarknetChainId} chainId - The chainId of the network.\n * @return {string} - The address of the Starknet.id multicall contract.\n * @throws {Error} - If the Starknet.id multicall contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdMulticallContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\"\n * ```\n */\nexport function getStarknetIdMulticallContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdMulticallContract;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdMulticallContract;\n\n    default:\n      throw new Error('Starknet.id multicall contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdVerifierContract = {\n  MAINNET: '0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf',\n  TESTNET_SEPOLIA: '0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566',\n} as const;\n\n/**\n * Returns the address of the Starknet ID Verifier contract based on the specified chain ID.\n *\n * @param {StarknetChainId} chainId - The ID of the Starknet chain.\n * @return {string} - The address of the Starknet ID Verifier contract.\n * @throws {Error} - If the Starknet ID Verifier contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdVerifierContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\"\n * ```\n */\nexport function getStarknetIdVerifierContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdVerifierContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdVerifierContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdPfpContract = {\n  MAINNET: '0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7',\n  TESTNET_SEPOLIA: '0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02',\n} as const;\n\n/**\n * Retrieves the contract address of the Starknet.id profile picture verifier contract based on the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the network.\n * @returns {string} - The contract address of the Starknet.id profile picture verifier contract.\n * @throws {Error} - Throws an error if the Starknet.id profile picture verifier contract is not yet deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPfpContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\"\n * ```\n */\nexport function getStarknetIdPfpContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPfpContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPfpContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id profile picture verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\nexport const StarknetIdPopContract = {\n  MAINNET: '0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4',\n  TESTNET_SEPOLIA: '0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a',\n} as const;\n\n/**\n * Retrieves the Starknet ID Proof of Personhood (IdPop) verifier contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the Starknet network.\n * @return {string} - The Starknet ID Pop contract address.\n * @throws {Error} - If the Starknet ID Pop contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPopContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\"\n * ```\n */\nexport function getStarknetIdPopContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPopContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPopContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id proof of personhood verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\n/**\n * Returns a CairoCustomEnum object.\n *\n * Functions to build CairoCustomEnum for multiCall contracts\n * @param {Object} [staticEx] An optional object defining the \"Static\" value of the CairoCustomEnum.\n * @param {number[]} [ifEqual] An optional array defining the \"IfEqual\" value of the CairoCustomEnum.\n * @param {number[]} [ifNotEqual] An optional array defining the \"IfNotEqual\" value of the CairoCustomEnum.\n * @return {CairoCustomEnum} - The created CairoCustomEnum object.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.execution(undefined, [1, 2, 3], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Static: undefined,\n * //     IfEqual: { '0': 1, '1': 2, '2': 3 },\n * //     IfNotEqual: undefined\n * //   }\n * // }\n * ```\n */\nexport function execution(\n  staticEx: {} | undefined,\n  ifEqual: number[] | undefined = undefined,\n  ifNotEqual: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : undefined,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum.\n *\n * @param {BigNumberish} [hardcoded] The hardcoded value for the CairoCustomEnum.\n * @param {number[]} [reference] The reference array for the CairoCustomEnum.\n * @returns {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicFelt(undefined, [1, 2]);\n * // result = CairoCustomEnum {\n * //  variant: { Hardcoded: undefined, Reference: { '0': 1, '1': 2 } }\n * // }\n * ```\n */\nexport function dynamicFelt(\n  hardcoded: BigNumberish | undefined,\n  reference: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum with the given parameters.\n * @param {BigNumberish} [hardcoded] The hardcoded value.\n * @param {BigNumberish[]} [reference] The reference value (optional).\n * @param {BigNumberish[]} [arrayReference] The array reference value (optional).\n * @return {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicCallData(undefined, [1, 2], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Hardcoded: undefined,\n * //     Reference: { '0': 1, '1': 2 },\n * //     ArrayReference: undefined\n * //   }\n * // }\n * ```\n */\nexport function dynamicCallData(\n  hardcoded: BigNumberish | undefined,\n  reference: BigNumberish[] | undefined = undefined,\n  arrayReference: BigNumberish[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : undefined,\n  });\n}\n\n/**\n * Check if a given string is a valid Starknet.id domain.\n *\n * @param {string} domain - The domain string to validate.\n * @returns {boolean} - True if the domain is a valid Starknet.id domain, false otherwise.\n * @example\n * ```typescript\n * const result = starknetId.isStarkDomain(\"example.stark\");\n * // result = true\n *\n * const result2 = starknetId.isStarkDomain(\"invalid-domain\");\n * // result2 = false\n * ```\n */\nexport function isStarkDomain(domain: string): boolean {\n  return /^(?:[a-z0-9-]{1,48}(?:[a-z0-9-]{1,48}[a-z0-9-])?\\.)*[a-z0-9-]{1,48}\\.stark$/.test(domain);\n}\n","import { BigNumberish, RawArgsArray, StarkProfile } from '../../types';\nimport { CallData } from '../../utils/calldata';\nimport { getSelectorFromName } from '../../utils/hash';\nimport { decodeShortString, encodeShortString } from '../../utils/shortString';\nimport {\n  dynamicCallData,\n  dynamicFelt,\n  execution,\n  getStarknetIdContract,\n  getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract,\n  getStarknetIdPfpContract,\n  getStarknetIdPopContract,\n  getStarknetIdVerifierContract,\n  isStarkDomain,\n  useDecoded,\n  useEncoded,\n} from '../../utils/starknetId';\nimport type { ProviderInterface } from '..';\n\nexport class StarknetId {\n  async getStarkName(address: BigNumberish, StarknetIdContract?: string) {\n    return StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract\n    );\n  }\n\n  public async getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string> {\n    return StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      name,\n      StarknetIdContract\n    );\n  }\n\n  async getStarkProfile(\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ) {\n    return StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract,\n      StarknetIdIdentityContract,\n      StarknetIdVerifierContract,\n      StarknetIdPfpContract,\n      StarknetIdPopContract,\n      StarknetIdMulticallContract\n    );\n  }\n\n  static async getStarkName(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'address_to_domain',\n        calldata: CallData.compile({\n          address,\n          hint: [],\n        }),\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n\n      const stringDomain = useDecoded(decimalDomain);\n\n      if (!stringDomain) {\n        throw Error('Starkname not found');\n      }\n\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Starkname not found') {\n        throw e;\n      }\n      throw Error('Could not get stark name');\n    }\n  }\n\n  static async getAddressFromStarkName(\n    provider: ProviderInterface,\n    name: string,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const starkName = name.endsWith('.stark') ? name : `${name}.stark`;\n\n    if (!isStarkDomain(starkName)) {\n      throw new Error('Invalid domain, must be a valid .stark domain');\n    }\n\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const encodedDomain = starkName\n        .replace('.stark', '')\n        .split('.')\n        .map((part) => useEncoded(part).toString(10));\n\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'domain_to_address',\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n      });\n\n      return addressData[0];\n    } catch {\n      throw Error('Could not get address from stark name');\n    }\n  }\n\n  static async getStarkProfile(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ): Promise<StarkProfile> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract ?? getStarknetIdMulticallContract(chainId);\n\n    try {\n      const calls: RawArgsArray = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName('address_to_domain')),\n          calldata: [dynamicCallData(address), dynamicCallData('0')],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName('domain_to_id')),\n          calldata: [dynamicCallData(undefined, undefined, [0, 0])],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('twitter')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('github')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('discord')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('proof_of_personhood')),\n            dynamicCallData(popContract),\n            dynamicCallData('0'),\n          ],\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_contract')),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_extended_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_id')),\n            dynamicCallData('2'),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution(undefined, undefined, [6, 0, 0]),\n          to: dynamicFelt(undefined, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName('tokenURI')),\n          calldata: [dynamicCallData(undefined, [7, 1]), dynamicCallData(undefined, [7, 2])],\n        },\n      ];\n\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: 'aggregate',\n        calldata: CallData.compile({\n          calls,\n        }),\n      });\n\n      if (Array.isArray(data)) {\n        // Format data\n        const size = parseInt(data[0], 16);\n        const finalArray: string[][] = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n\n        const twitter =\n          finalArray[2][0] !== '0x0' ? BigInt(finalArray[2][0]).toString() : undefined;\n        const github = finalArray[3][0] !== '0x0' ? BigInt(finalArray[3][0]).toString() : undefined;\n        const discord =\n          finalArray[4][0] !== '0x0' ? BigInt(finalArray[4][0]).toString() : undefined;\n        const proofOfPersonhood = finalArray[5][0] === '0x1'; // 10\n\n        const profilePictureMetadata =\n          data[0] === '0x9'\n            ? finalArray[8]\n                .slice(1)\n                .map((val: string) => decodeShortString(val))\n                .join('')\n            : undefined;\n\n        const profilePicture =\n          profilePictureMetadata ||\n          `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture,\n        };\n      }\n      throw Error('Error while calling aggregate function');\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error('Could not get user stark profile data from address');\n    }\n  }\n}\n","import { BigNumberish } from '../../types';\nimport { CallData } from '../../utils/calldata';\nimport type { ProviderInterface } from '..';\nimport { StarknetChainId } from '../../global/constants';\nimport { useEncoded, useDecoded } from '../../utils/starknetId';\n\n/**\n * Validates if a domain is a valid .brother domain\n * @param domain - Domain name to validate\n * @returns true if the domain is valid\n */\nexport function isBrotherDomain(domain: string): boolean {\n  return domain.endsWith('.brother');\n}\n\n/**\n * Encodes a Brother domain name into a bigint value.\n * This uses the same encoding logic as Starknet ID.\n * @param domain - The domain name without .brother suffix\n * @returns encoded bigint value\n * @example\n * ```typescript\n * const encoded = encodeBrotherDomain(\"myname.brother\");\n * // Returns a bigint value\n * ```\n */\nexport function encodeBrotherDomain(domain: string): bigint {\n  const brotherName = domain.endsWith('.brother') ? domain.replace('.brother', '') : domain;\n  return useEncoded(brotherName);\n}\n\n/**\n * Decodes a bigint value into a Brother domain name.\n * This uses the same decoding logic as Starknet ID but returns a .brother domain.\n * @param encoded - The encoded bigint value\n * @returns The decoded domain name with .brother suffix\n * @example\n * ```typescript\n * const domain = decodeBrotherDomain(1234567890n);\n * // Returns \"example.brother\"\n * ```\n */\nexport function decodeBrotherDomain(encoded: bigint): string {\n  const decoded = useDecoded([encoded]);\n  // Replace .stark with .brother\n  if (decoded.endsWith('.stark')) {\n    return decoded.replace('.stark', '.brother');\n  }\n  // If no suffix, add .brother\n  return decoded ? `${decoded}.brother` : decoded;\n}\n\n/**\n * Get the Brother ID contract address for the specified network\n * @param chainId - The Starknet chain ID\n * @returns The Brother ID contract address for the network\n */\nexport function getBrotherIdContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return '0x0212f1c57700f5a3913dd11efba540196aad4cf67772f7090c62709dd804fa74';\n    default:\n      return '0x0212f1c57700f5a3913dd11efba540196aad4cf67772f7090c62709dd804fa74'; // Default to mainnet address\n  }\n}\n\n/**\n * Interface representing a Brother domain profile\n * @property name - The domain name without .brother suffix\n * @property resolver - The address that resolves to this domain\n * @property tokenId - The unique identifier of the domain NFT\n * @property expiryDate - Unix timestamp when the domain expires\n * @property lastTransferTime - Unix timestamp of the last transfer\n */\nexport interface BrotherProfile {\n  name: string;\n  resolver: string;\n  tokenId: string;\n  expiryDate: number;\n  lastTransferTime: number;\n}\n\n/**\n * Class providing methods to interact with Brother Identity contracts.\n *\n * This implementation uses the same domain encoding and decoding logic as StarknetId,\n * allowing for consistent handling of domain names between the two systems.\n * The encoding/decoding functions (encodeBrotherDomain/decodeBrotherDomain) are direct\n * adaptations of StarknetId's useEncoded/useDecoded functions to work with .brother domains.\n */\nexport class BrotherId {\n  /**\n   * Gets the primary Brother domain name for an address\n   * @param address - The address to get the domain for\n   * @param BrotherIdContract - Optional contract address\n   * @returns The domain name with .brother suffix\n   */\n  async getBrotherName(address: BigNumberish, BrotherIdContract?: string) {\n    return BrotherId.getBrotherName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      BrotherIdContract\n    );\n  }\n\n  /**\n   * Gets the address associated with a Brother domain name\n   * @param name - The domain name (with or without .brother suffix)\n   * @param BrotherIdContract - Optional contract address\n   * @returns The resolver address for the domain\n   */\n  public async getAddressFromBrotherName(\n    name: string,\n    BrotherIdContract?: string\n  ): Promise<string> {\n    return BrotherId.getAddressFromBrotherName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      name,\n      BrotherIdContract\n    );\n  }\n\n  /**\n   * Gets the complete profile information for a Brother domain\n   * @param address - The address to get the profile for\n   * @param BrotherIdContract - Optional contract address\n   * @returns The complete Brother profile information\n   */\n  async getBrotherProfile(address: BigNumberish, BrotherIdContract?: string) {\n    return BrotherId.getBrotherProfile(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      BrotherIdContract\n    );\n  }\n\n  /**\n   * Static implementation of getBrotherName\n   * @param provider - The provider interface\n   * @param address - The address to get the domain for\n   * @param BrotherIdContract - Optional contract address\n   * @returns The domain name with .brother suffix\n   */\n  static async getBrotherName(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    BrotherIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = BrotherIdContract ?? getBrotherIdContract(chainId);\n\n    try {\n      const primaryDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'getPrimary',\n        calldata: CallData.compile({\n          user: address,\n        }),\n      });\n\n      if (!primaryDomain[0] || primaryDomain[0] === '0x0') {\n        throw Error('Brother name not found');\n      }\n\n      const encodedDomain = BigInt(primaryDomain[0]);\n      return decodeBrotherDomain(encodedDomain);\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Brother name not found') {\n        throw e;\n      }\n      throw Error('Could not get brother name');\n    }\n  }\n\n  /**\n   * Static implementation of getAddressFromBrotherName\n   * @param provider - The provider interface\n   * @param name - The domain name\n   * @param BrotherIdContract - Optional contract address\n   * @returns The resolver address\n   */\n  static async getAddressFromBrotherName(\n    provider: ProviderInterface,\n    name: string,\n    BrotherIdContract?: string\n  ): Promise<string> {\n    const brotherName = name.endsWith('.brother') ? name : `${name}.brother`;\n\n    if (!isBrotherDomain(brotherName)) {\n      throw new Error('Invalid domain, must be a valid .brother domain');\n    }\n\n    const chainId = await provider.getChainId();\n    const contract = BrotherIdContract ?? getBrotherIdContract(chainId);\n\n    try {\n      const domainDetails = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'get_details_by_domain',\n        calldata: CallData.compile({\n          domain: encodeBrotherDomain(brotherName),\n        }),\n      });\n\n      if (!domainDetails[0] || domainDetails[1] === '0x0') {\n        throw Error('Could not get address from brother name');\n      }\n\n      return domainDetails[1]; // resolver address\n    } catch {\n      throw Error('Could not get address from brother name');\n    }\n  }\n\n  /**\n   * Static implementation of getBrotherProfile\n   * @param provider - The provider interface\n   * @param address - The address to get the profile for\n   * @param BrotherIdContract - Optional contract address\n   * @returns The complete Brother profile\n   */\n  static async getBrotherProfile(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    BrotherIdContract?: string\n  ): Promise<BrotherProfile> {\n    const chainId = await provider.getChainId();\n    const contract = BrotherIdContract ?? getBrotherIdContract(chainId);\n\n    try {\n      const primaryDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'getPrimary',\n        calldata: CallData.compile({\n          user: address,\n        }),\n      });\n\n      if (!primaryDomain[0] || primaryDomain[0] === '0x0') {\n        throw Error('Brother profile not found');\n      }\n\n      const encodedDomain = BigInt(primaryDomain[0]);\n      const decodedDomain = decodeBrotherDomain(encodedDomain);\n      const domain = decodedDomain.replace('.brother', '');\n\n      const domainDetails = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'get_details_by_domain',\n        calldata: CallData.compile({\n          domain: encodeBrotherDomain(domain),\n        }),\n      });\n\n      return {\n        name: domain,\n        resolver: domainDetails[1],\n        tokenId: domainDetails[2],\n        expiryDate: parseInt(domainDetails[3], 16),\n        lastTransferTime: parseInt(domainDetails[4], 16),\n      };\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Brother profile not found') {\n        throw e;\n      }\n      throw Error('Could not get brother profile');\n    }\n  }\n}\n","import { RPC08, RPC09 } from '../channel';\nimport { StarknetChainId } from '../global/constants';\nimport type {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  Call,\n  CallContractResponse,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  EstimateFeeResponseOverhead,\n  EstimateFeeResponseBulkOverhead,\n  GetBlockResponse,\n  GetTransactionReceiptResponse,\n  GetTransactionResponse,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  InvokeFunctionResponse,\n  Nonce,\n  PendingBlock,\n  PreConfirmedStateUpdate,\n  StateUpdate,\n  StateUpdateResponse,\n  Storage,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n  SimulateTransactionOverheadResponse,\n  RPC,\n  ContractClassIdentifier,\n  Invocations,\n  Signature,\n  TypedData,\n} from '../types';\nimport { TipAnalysisOptions, TipEstimate } from './modules/tip';\nimport { RPCSPEC08, RPCSPEC09 } from '../types/api';\nimport { RPCResponseParser } from '../utils/responseParser/rpc';\n\nexport abstract class ProviderInterface {\n  public abstract channel: RPC08.RpcChannel | RPC09.RpcChannel;\n\n  public abstract responseParser: RPCResponseParser;\n\n  /**\n   * Gets the Starknet chain Id\n   *\n   * @returns the chain Id\n   */\n  public abstract getChainId(): Promise<StarknetChainId>;\n\n  /**\n   * Calls a function on the Starknet contract.\n   *\n   * @param call transaction to be called\n   * @param blockIdentifier block identifier\n   * @returns the result of the function on the smart contract.\n   */\n  public abstract callContract(\n    call: Call,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<CallContractResponse>;\n\n  /**\n   * Gets the block information\n   *\n   * @param blockIdentifier block identifier\n   * @returns the block object\n   */\n  public abstract getBlock(): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'pre_confirmed'): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;\n\n  /**\n   * Gets the contract class of the deployed contract.\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<ContractClassResponse>;\n\n  /**\n   * Gets the price of l1 gas in the block\n   *\n   * @param blockIdentifier block identifier\n   * @returns gas price of the block\n   */\n  public abstract getL1GasPrice(blockIdentifier?: BlockIdentifier): Promise<string>;\n\n  /**\n   * Get L1 message hash from L2 transaction hash\n   * @param {BigNumberish} l2TxHash L2 transaction hash\n   * @returns {string} Hex string of L1 message hash\n   * @example\n   * In Sepolia Testnet :\n   * ```typescript\n   * const result = provider.getL1MessageHash('0x28dfc05eb4f261b37ddad451ff22f1d08d4e3c24dc646af0ec69fa20e096819');\n   * // result = '0x55b3f8b6e607fffd9b4d843dfe8f9b5c05822cd94fcad8797deb01d77805532a'\n   * ```\n   */\n  public abstract getL1MessageHash(l2TxHash: BigNumberish): Promise<string>;\n\n  /**\n   * Returns the contract class hash in the given block for the contract deployed at the given address\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Class hash\n   */\n  public abstract getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<string>;\n\n  /**\n   * Returns the contract class deployed under the given class hash.\n   *\n   * @param classHash - class hash\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassByHash(classHash: BigNumberish): Promise<ContractClassResponse>;\n\n  /**\n   * Returns the nonce associated with the given address in the given block\n   *\n   * @param contractAddress - contract address\n   * @returns the hex nonce\n   */\n  public abstract getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Nonce>;\n\n  /**\n   * Get the value of the storage (contract's variable) at the given address and key\n   *\n   * @param contractAddress\n   * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)\n   * @param blockIdentifier - block identifier\n   * @returns the value of the storage variable\n   */\n  public abstract getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Storage>;\n\n  /**\n   * Gets the transaction information from a tx id.\n   *\n   * @param transactionHash\n   * @returns the transaction object \\{ transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? \\}\n   */\n  public abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets the transaction receipt from a tx hash.\n   *\n   * @param transactionHash\n   * @returns the transaction receipt object\n   */\n  public abstract getTransactionReceipt(\n    transactionHash: BigNumberish\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Deploys a given compiled Account contract (json) to starknet\n   *\n   * @param payload payload to be deployed containing:\n   * - compiled contract code\n   * - constructor calldata\n   * - address salt\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccountContract(\n    payload: DeployAccountContractPayload,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Invokes a function on starknet\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - (optional) the entrypoint of the contract\n   * - calldata - (optional, defaults to []) the calldata\n   * - signature - (optional, defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * - maxFee - optional maxFee\n   * @returns response from addTransaction\n   */\n  public abstract invokeFunction(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   * @param transaction transaction payload to be deployed containing:\n   * - compiled contract code\n   * - sender address\n   * - signature\n   * @param details Invocation Details containing:\n   * - nonce\n   * - optional version\n   * - optional maxFee\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - (optional) the entrypoint of the contract\n   * - calldata - (optional, defaults to []) the calldata\n   * - signature - (optional, defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   * @deprecated Consider using getEstimateFeeBulk for multiple transactions\n   * @example\n   * ```typescript\n   * const feeEstimate = await provider.getInvokeEstimateFee(invocation, details);\n   * // Equivalent to:\n   * const [feeEstimate] = await provider.getEstimateFeeBulk([{ type: ETransactionType.INVOKE, ...invocation, ...details }], options);\n   * ```\n   * @alias getEstimateFeeBulk - This method is an alias that calls getEstimateFeeBulk with a single transaction\n   */\n  public abstract getInvokeEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimates the fee for a given DECLARE transaction\n   *\n   * @param transaction transaction payload to be declared containing:\n   * - compiled contract code\n   * - sender address\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   * @deprecated Consider using getEstimateFeeBulk for multiple transactions\n   * @example\n   * ```typescript\n   * const feeEstimate = await provider.getDeclareEstimateFee(transaction, details);\n   * // Equivalent to:\n   * const [feeEstimate] = await provider.getEstimateFeeBulk([{ type: ETransactionType.DECLARE, ...transaction, ...details }], options);\n   * ```\n   * @alias getEstimateFeeBulk - This method is an alias that calls getEstimateFeeBulk with a single transaction\n   */\n  public abstract getDeclareEstimateFee(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimates the fee for a given DEPLOY_ACCOUNT transaction\n   *\n   * @param transaction transaction payload to be deployed containing:\n   * - classHash\n   * - constructorCalldata\n   * - addressSalt\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   * @deprecated Consider using getEstimateFeeBulk for multiple transactions\n   * @example\n   * ```typescript\n   * const feeEstimate = await provider.getDeployAccountEstimateFee(transaction, details);\n   * // Equivalent to:\n   * const [feeEstimate] = await provider.getEstimateFeeBulk([{ type: ETransactionType.DEPLOY_ACCOUNT, ...transaction, ...details }], options);\n   * ```\n   * @alias getEstimateFeeBulk - This method is an alias that calls getEstimateFeeBulk with a single transaction\n   */\n  public abstract getDeployAccountEstimateFee(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimates the fee for a list of INVOKE transaction\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options getEstimateFeeBulkOptions\n   * - (optional) blockIdentifier - BlockIdentifier\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options?: getEstimateFeeBulkOptions\n  ): Promise<EstimateFeeResponseBulkOverhead>;\n\n  /**\n   * Wait for the transaction to be accepted\n   * @param txHash - transaction hash\n   * @param options waitForTransactionOptions\n   * - (optional) retryInterval: number | undefined;\n   * - (optional) successStates: TransactionStatus[] | undefined;\n   * @return GetTransactionReceiptResponse\n   */\n  public abstract waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Simulates the transaction and returns the transaction trace and estimated fee.\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options - getSimulateTransactionOptions\n   *  - (optional) blockIdentifier - block identifier\n   *  - (optional) skipValidate - skip cairo __validate__ method\n   *  - (optional) skipExecute - skip cairo __execute__ method\n   * @returns an array of transaction trace and estimated fee\n   */\n  public abstract getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ): Promise<SimulateTransactionOverheadResponse>;\n\n  /**\n   * Gets the state changes in a specific block (result of executing the requested block)\n   *\n   * @param blockIdentifier - block identifier\n   * @returns StateUpdateResponse\n   */\n  public abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n\n  /**\n   * Gets the state changes in a specific block (result of executing the requested block)\n   * Alternative method name for getStateUpdate with specific overloads\n   *\n   * @param blockIdentifier - block identifier\n   * @returns StateUpdateResponse\n   */\n  public abstract getBlockStateUpdate(): Promise<StateUpdate>;\n  public abstract getBlockStateUpdate(\n    blockIdentifier: 'pre_confirmed'\n  ): Promise<PreConfirmedStateUpdate>;\n  public abstract getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;\n  public abstract getBlockStateUpdate(\n    blockIdentifier?: BlockIdentifier\n  ): Promise<StateUpdateResponse>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress string\n   * @param classHash undefined\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: BigNumberish,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress undefined\n   * @param classHash\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: undefined,\n    classHash: BigNumberish,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  // Block utility methods\n  /**\n   * Get the most recent accepted block hash and number\n   * @returns Object containing block hash and number\n   */\n  public abstract getBlockLatestAccepted(): Promise<{ block_hash: string; block_number: number }>;\n\n  /**\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */\n  public abstract getBlockNumber(): Promise<number>;\n\n  /**\n   * Get block information with transaction hashes\n   * @param blockIdentifier - block identifier\n   * @returns Block with transaction hashes\n   */\n  public abstract getBlockWithTxHashes(blockIdentifier?: BlockIdentifier): Promise<any>;\n\n  /**\n   * Get block information with full transactions\n   * @param blockIdentifier - block identifier\n   * @returns Block with full transactions\n   */\n  public abstract getBlockWithTxs(blockIdentifier?: BlockIdentifier): Promise<any>;\n\n  /**\n   * Get block information with transaction receipts\n   * @param blockIdentifier - block identifier\n   * @returns Block with transaction receipts\n   */\n  public abstract getBlockWithReceipts(blockIdentifier?: BlockIdentifier): Promise<any>;\n\n  /**\n   * Get transaction traces for all transactions in a block\n   * @param blockIdentifier - block identifier\n   * @returns Array of transaction traces\n   */\n  public abstract getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier): Promise<any>;\n\n  /**\n   * Get the number of transactions in a block\n   * @param blockIdentifier - block identifier\n   * @returns Transaction count\n   */\n  public abstract getBlockTransactionCount(blockIdentifier?: BlockIdentifier): Promise<number>;\n\n  /**\n   * Pause execution until a specified block is created\n   * @param blockIdentifier - block number or tag\n   * @param retryInterval - milliseconds between requests (default: 5000)\n   * @example\n   * ```typescript\n   * await provider.waitForBlock(12345);\n   * await provider.waitForBlock('latest');\n   * ```\n   */\n  public abstract waitForBlock(\n    blockIdentifier?: BlockIdentifier,\n    retryInterval?: number\n  ): Promise<void>;\n\n  // Transaction utility methods\n  /**\n   * Gets the transaction information from a tx hash (alias for getTransaction)\n   * @param txHash - transaction hash\n   * @returns Transaction information\n   */\n  public abstract getTransactionByHash(txHash: BigNumberish): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets transaction by block identifier and index\n   * @param blockIdentifier - block identifier\n   * @param index - transaction index in the block\n   * @returns Transaction information\n   */\n  public abstract getTransactionByBlockIdAndIndex(\n    blockIdentifier: BlockIdentifier,\n    index: number\n  ): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets the transaction trace\n   * @param txHash - transaction hash\n   * @returns Transaction trace\n   */\n  public abstract getTransactionTrace(\n    txHash: BigNumberish\n  ): Promise<RPCSPEC08.TRANSACTION_TRACE | RPCSPEC09.TRANSACTION_TRACE>;\n\n  /**\n   * Get the status of a transaction\n   * @param transactionHash - transaction hash\n   * @returns Transaction status\n   */\n  public abstract getTransactionStatus(transactionHash: BigNumberish): Promise<any>;\n\n  // Provider utility methods\n  /**\n   * Direct RPC method call\n   * @param method - RPC method name\n   * @param params - method parameters\n   * @param id - request ID\n   * @returns RPC response\n   */\n  public abstract fetch(method: string, params?: object, id?: string | number): Promise<any>;\n\n  /**\n   * Read channel spec version\n   * @returns Spec version string or undefined if not set\n   */\n  public abstract readSpecVersion(): string | undefined;\n\n  /**\n   * Get channel spec version\n   * @returns Promise resolving to spec version\n   */\n  public abstract getSpecVersion(): Promise<string>;\n\n  /**\n   * Setup channel spec version and return it\n   * @returns Promise resolving to spec version\n   */\n  public abstract setUpSpecVersion(): Promise<string>;\n\n  // Advanced methods\n  /**\n   * Get contract class by hash with optional block identifier\n   * @param classHash - class hash\n   * @param blockIdentifier - block identifier\n   * @returns Contract class\n   */\n  public abstract getClass(\n    classHash: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<ContractClassResponse>;\n\n  /**\n   * Estimate the fee for a message from L1\n   * @param message - L1 message\n   * @param blockIdentifier - block identifier\n   * @returns Fee estimate\n   */\n  public abstract estimateMessageFee(\n    message: RPCSPEC09.L1Message,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<RPCSPEC08.FEE_ESTIMATE | RPCSPEC09.MESSAGE_FEE_ESTIMATE>;\n\n  /**\n   * Get node synchronization status\n   * @returns Sync status or false if not syncing\n   */\n  public abstract getSyncingStats(): Promise<any>;\n\n  /**\n   * Get events matching the given filter\n   * @param eventFilter - event filter\n   * @returns Events and pagination info\n   */\n  public abstract getEvents(\n    eventFilter: RPCSPEC08.EventFilter | RPCSPEC09.EventFilter\n  ): Promise<RPCSPEC08.EVENTS_CHUNK | RPCSPEC09.EVENTS_CHUNK>;\n\n  /**\n   * Verify in Starknet a signature of a TypedData object or of a given hash.\n   * @param {BigNumberish | TypedData} message TypedData object to be verified, or message hash to be verified.\n   * @param {Signature} signature signature of the message.\n   * @param {BigNumberish} accountAddress address of the account that has signed the message.\n   * @param {string} [signatureVerificationFunctionName] if account contract with non standard account verification function name.\n   * @param { okResponse: string[]; nokResponse: string[]; error: string[] } [signatureVerificationResponse] if account contract with non standard response of verification function.\n   * @returns\n   * ```typescript\n   * const myTypedMessage: TypedMessage = .... ;\n   * const messageHash = typedData.getMessageHash(myTypedMessage,accountAddress);\n   * const sign: WeierstrassSignatureType = ec.starkCurve.sign(messageHash, privateKey);\n   * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n   * const result1 = await myRpcProvider.verifyMessageInStarknet(myTypedMessage, sign, accountAddress);\n   * const result2 = await myRpcProvider.verifyMessageInStarknet(messageHash, sign, accountAddress);\n   * // result1 = result2 = true\n   * ```\n   */\n  public abstract verifyMessageInStarknet(\n    message: BigNumberish | TypedData,\n    signature: Signature,\n    accountAddress: BigNumberish,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: {\n      okResponse: string[];\n      nokResponse: string[];\n      error: string[];\n    }\n  ): Promise<boolean>;\n\n  /**\n   * Test if class is already declared\n   * @param contractClassIdentifier - contract class identifier\n   * @param blockIdentifier - block identifier\n   * @returns true if class is declared\n   */\n  public abstract isClassDeclared(\n    contractClassIdentifier: ContractClassIdentifier,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<boolean>;\n\n  /**\n   * Build bulk invocations with auto-detect declared class\n   * @param invocations - array of invocations\n   * @returns Prepared invocations\n   */\n  public abstract prepareInvocations(invocations: Invocations): Promise<Invocations>;\n\n  /**\n   * Get L1 messages status for a transaction\n   * @param transactionHash - L1 transaction hash\n   * @returns L1 message status\n   */\n  public abstract getL1MessagesStatus(\n    transactionHash: BigNumberish\n  ): Promise<RPC.RPCSPEC08.L1L2MessagesStatus | RPC.RPCSPEC09.L1L2MessagesStatus>;\n\n  /**\n   * Get Merkle paths in state tries\n   * @param classHashes - class hashes\n   * @param contractAddresses - contract addresses\n   * @param contractsStorageKeys - storage keys\n   * @param blockIdentifier - block identifier\n   * @returns Storage proof\n   */\n  public abstract getStorageProof(\n    classHashes: BigNumberish[],\n    contractAddresses: BigNumberish[],\n    contractsStorageKeys: RPC.CONTRACT_STORAGE_KEYS[],\n    blockIdentifier?: BlockIdentifier\n  ): Promise<RPC.StorageProof>;\n\n  /**\n   * Get compiled CASM contract class\n   * @param classHash - class hash\n   * @returns Compiled CASM contract class\n   */\n  public abstract getCompiledCasm(\n    classHash: BigNumberish\n  ): Promise<RPC.CASM_COMPILED_CONTRACT_CLASS>;\n\n  /**\n   * Get transaction tip estimation based on network analysis\n   * @param blockIdentifier - block identifier to analyze from\n   * @param options - tip analysis options\n   * @returns Tip estimation with statistics\n   * @example\n   * ```typescript\n   * const tipEstimate = await provider.getEstimateTip('latest', {\n   *   maxBlocks: 10,\n   *   minTxsNecessary: 5\n   * });\n   * console.log('Recommended tip:', tipEstimate.recommendedTip);\n   * ```\n   */\n  public abstract getEstimateTip(\n    blockIdentifier?: BlockIdentifier,\n    options?: TipAnalysisOptions\n  ): Promise<TipEstimate>;\n}\n","import { RpcProvider } from './rpc';\n\nexport { RpcProvider as Provider } from './extensions/default'; // backward-compatibility\nexport { LibraryError, RpcError } from '../utils/errors';\nexport * from './interface';\nexport * from './extensions/default';\nexport * from './modules';\n\nexport const defaultProvider = new RpcProvider({ default: true });\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n} from '../types';\n\nexport abstract class SignerInterface {\n  /**\n   * Method to get the public key of the signer\n   *\n   * @returns {Promise<string>} hex-string public key\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const result = await mySigner.getPubKey();\n   * // result = \"0x566d69d8c99f62bc71118399bab25c1f03719463eab8d6a444cd11ece131616\"\n   * ```\n   */\n  public abstract getPubKey(): Promise<string>;\n\n  /**\n   * Signs a JSON object for off-chain usage with the private key and returns the signature.\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param {TypedData} typedData - JSON object to be signed\n   * @param {string} accountAddress - Hex string of the account's address\n   * @returns {Promise<Signature>} the signature of the message\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myTypedData: TypedData = {\n   *   domain: {\n   *     name: \"Example DApp\",\n   *     chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *     version: \"0.0.3\"\n   *   },\n   *   types: {\n   *     StarkNetDomain: [\n   *       { name: \"name\", type: \"string\" },\n   *       { name: \"chainId\", type: \"felt\" },\n   *       { name: \"version\", type: \"string\" }\n   *     ],\n   *     Message: [{ name: \"message\", type: \"felt\" }]\n   *   },\n   *   primaryType: \"Message\",\n   *   message: { message: \"1234\" }\n   * };\n   * const result = await mySigner.signMessage(myTypedData, \"0x5d08a4e9188429da4e993c9bf25aafe5cd491ee2b501505d4d059f0c938f82d\");\n   * // result = Signature {r: 684915484701699003335398790608214855489903651271362390249153620883122231253n,\n   * // s: 1399150959912500412309102776989465580949387575375484933432871778355496929189n, recovery: 1}\n   * ```\n   */\n  public abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;\n\n  /**\n   * Signs INVOKE transactions with the private key and returns the signature\n   *\n   * @param {Call[]} transactions - Array of Call objects representing the transactions\n   * @param {InvocationsSignerDetails} transactionsDetail - Transaction details including V3 fields\n   * @returns {Promise<Signature>} the signature of the transaction\n   * @remarks Only supports V3 transactions. V0, V1, and V2 transactions will throw an error.\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const calls: Call[] = [{\n   *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n   *   entrypoint: \"transfer\",\n   *   calldata: [\"0xRecipient\", \"1000\", \"0\"]\n   * }];\n   * const transactionsDetail: InvocationsSignerDetails = {\n   *   walletAddress: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e',\n   *   chainId: constants.StarknetChainId.SN_MAIN,\n   *   cairoVersion: \"1\",\n   *   version: \"0x3\",\n   *   nonce: 1,\n   *   resourceBounds: {\n   *     l1_gas: { amount: \"0x1000\", price: \"0x20\" },\n   *     l2_gas: { amount: \"0x200\", price: \"0x5\" },\n   *     l1_data_gas: { amount: \"0x500\", price: \"0x10\" }\n   *   },\n   *   tip: 0,\n   *   paymasterData: [],\n   *   accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1\n   * };\n   * const result = await mySigner.signTransaction(calls, transactionsDetail);\n   * // result = Signature {r: 304910226421970384958146916800275294114105560641204815169249090836676768876n,\n   * //   s: 1072798866000813654190523783606274062837012608648308896325315895472901074693n, recovery: 0}\n   * ```\n   */\n  public abstract signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DEPLOY_ACCOUNT transaction with the private key and returns the signature\n   *\n   * @param {DeployAccountSignerDetails} transaction - Transaction details to deploy an account contract\n   * @returns {Promise<Signature>} the signature of the transaction to deploy an account\n   * @remarks Only supports V3 transactions. V0, V1, and V2 transactions will throw an error.\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeployAcc: DeployAccountSignerDetails = {\n   *   contractAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   version: \"0x3\",\n   *   chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   constructorCalldata: [\"0x123\", \"0x456\"],\n   *   addressSalt: \"0x789\",\n   *   nonce: 0,\n   *   resourceBounds: {\n   *     l1_gas: { amount: \"0x1000\", price: \"0x20\" },\n   *     l2_gas: { amount: \"0x200\", price: \"0x5\" },\n   *     l1_data_gas: { amount: \"0x500\", price: \"0x10\" }\n   *   },\n   *   tip: 0,\n   *   paymasterData: [],\n   *   accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1\n   * };\n   * const result = await mySigner.signDeployAccountTransaction(myDeployAcc);\n   * // result = Signature {r: 2871311234341436528393212130310036951068553852419934781736214693308640202748n,\n   * //  s: 1746271646048888422437132495446973163454853863041370993384284773665861377605n, recovery: 1}\n   * ```\n   */\n  public abstract signDeployAccountTransaction(\n    transaction: DeployAccountSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DECLARE transaction with the private key and returns the signature\n   *\n   * @param {DeclareSignerDetails} transaction - Transaction details to declare a contract class\n   * @returns {Promise<Signature>} the signature of the transaction to declare a class\n   * @remarks Only supports V3 transactions. V0, V1, and V2 transactions will throw an error.\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeclare: DeclareSignerDetails = {\n   *   version: \"0x3\",\n   *   chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   senderAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   compiledClassHash: \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n   *   nonce: 45,\n   *   resourceBounds: {\n   *     l1_gas: { amount: \"0x1000\", price: \"0x20\" },\n   *     l2_gas: { amount: \"0x200\", price: \"0x5\" },\n   *     l1_data_gas: { amount: \"0x500\", price: \"0x10\" }\n   *   },\n   *   tip: 0,\n   *   paymasterData: [],\n   *   accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1\n   * };\n   * const result = await mySigner.signDeclareTransaction(myDeclare);\n   * // result = Signature {r: 2432056944313955951711774394836075930010416436707488863728289188289211995670n,\n   * //  s: 3407649393310177489888603098175002856596469926897298636282244411990343146307n, recovery: 1}\n   * ```\n   */\n  public abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;\n}\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { starkCurve } from '../utils/ec';\nimport { buf2hex } from '../utils/encode';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { SignerInterface } from './interface';\n\nexport class Signer implements SignerInterface {\n  protected pk: Uint8Array | string;\n\n  constructor(pk: Uint8Array | string = starkCurve.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n\n  public async getPubKey(): Promise<string> {\n    return starkCurve.getStarkKey(this.pk);\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    return starkCurve.sign(msgHash, this.pk);\n  }\n}\n","import type { RecoveredSignatureType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport {\n  ArraySignatureType,\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  Uint256,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from '../utils/encode';\nimport { ethRandomPrivateKey } from '../utils/eth';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { bnToUint256 } from '../utils/uint256';\nimport { SignerInterface } from './interface';\n\n/**\n * Signer for accounts using Ethereum signature\n */\nexport class EthSigner implements SignerInterface {\n  protected pk: string; // hex string without 0x and with an odd number of characters\n\n  constructor(pk: Uint8Array | string = ethRandomPrivateKey()) {\n    this.pk =\n      pk instanceof Uint8Array\n        ? buf2hex(pk).padStart(64, '0')\n        : removeHexPrefix(toHex(pk)).padStart(64, '0');\n  }\n\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  public async getPubKey(): Promise<string> {\n    return addHexPrefix(\n      buf2hex(secp256k1.getPublicKey(this.pk, false)).padStart(130, '0').slice(2)\n    );\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  protected formatEthSignature(ethSignature: RecoveredSignatureType): ArraySignatureType {\n    const r: Uint256 = bnToUint256(ethSignature.r);\n    const s: Uint256 = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery),\n    ] as ArraySignatureType;\n  }\n}\n","/* eslint-disable no-bitwise */\nimport { BigNumberish, Uint256 } from '../types';\nimport { CairoUint256 } from './cairoDataTypes/uint256';\n\n/**\n * Convert Uint256 to bigint\n * Legacy support Export\n * @param {Uint256} uint256 Uint256 value to convert to bigint\n * @returns {bigint} BigInt representation of the input Uint256\n * @example\n * ```typescript\n * const uint256Value: Uint256 = {low: 1234567890, high: 1};\n * const result = uint256.uint256ToBN(uint256Value);\n * // result = 340282366920938463463374607433002779346n\n * ```\n */\nexport function uint256ToBN(uint256: Uint256): bigint {\n  return new CairoUint256(uint256).toBigInt();\n}\n\n/**\n * Test BigNumberish is in the range[0, 2**256-1]\n * Legacy support Export\n * @param {BigNumberish} bn value to test\n * @returns {boolean} True if the input value is in the range[0, 2**256-1], false otherwise\n * @example\n * ```typescript\n * const result = uint256.isUint256(12345n);\n * // result = true\n * const result1 = uint256.isUint256(-1);\n * // result1 = false\n * ```\n */\nexport function isUint256(bn: BigNumberish): boolean {\n  return CairoUint256.is(bn);\n}\n\n/**\n * Convert BigNumberish (string | number | bigint) to Uint256\n * Legacy support Export\n * @param {BigNumberish} bn value to convert to Uint256\n * @returns {Uint256} Uint256 object representing the BigNumberish value\n * @example\n * ```typescript\n * const result = uint256.bnToUint256(1000000000n);\n * // result = {\"low\": \"0x3b9aca00\", \"high\": \"0x0\"}\n * ```\n */\nexport function bnToUint256(bn: BigNumberish): Uint256 {\n  return new CairoUint256(bn).toUint256HexString();\n}\n","/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\nimport type {\n  InvocationsSignerDetails,\n  V3InvocationsSignerDetails,\n  DeployAccountSignerDetails,\n  V3DeployAccountSignerDetails,\n  DeclareSignerDetails,\n  V3DeclareSignerDetails,\n  TypedData,\n  Call,\n  Signature,\n  LedgerPathCalculation,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport Buffer from '../utils/connect/buffer';\nimport type { SignerInterface } from './interface';\nimport { MASK_31 } from '../global/constants';\nimport { getMessageHash } from '../utils/typedData';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { intDAM } from '../utils/stark';\nimport { addHexPrefix, buf2hex, concatenateArrayBuffer, removeHexPrefix } from '../utils/encode';\nimport { hexToBytes, stringToSha256ToArrayBuff4, toHex } from '../utils/num';\nimport { starkCurve } from '../utils/ec';\nimport { ETransactionVersion3 } from '../types/api';\n\n// import type _Transport from '@ledgerhq/hw-transport';\n// NOTE: the preceding line was substituted because of the '@ledgerhq/hw-transport' module bug listed in\n// the following issue https://github.com/LedgerHQ/ledger-live/issues/7448\n// if required for development, the line can be uncommented and '@ledgerhq/hw-transport' temporarily added as a dev dependency\ntype _Transport = any;\n\n/**\n * Signer for accounts using a Ledger Nano S+/X signature (Starknet Ledger APP version 1.1.1)\n *\n * The Ledger has to be connected, unlocked and the Starknet APP has to be selected prior of use of this class.\n */\nexport class LedgerSigner111<Transport extends Record<any, any> = any> implements SignerInterface {\n  readonly transporter: Transport;\n\n  // this is a hack to allow the '@ledgerhq/hw-transport' type to be used as a dev dependency but not exposed in the production build\n  protected _transporter: _Transport;\n\n  readonly accountID: number;\n\n  readonly eip2645applicationName: string;\n\n  readonly pathBuffer: Uint8Array;\n\n  protected appVersion: string;\n\n  protected pubKey: string;\n\n  protected fullPubKey: string;\n\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items),\n   * and one item is the `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer111]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer111` is selected.\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner111(myNodeTransport, 0);\n   * ```\n   */\n  constructor(\n    transport: Transport,\n    accountID: number,\n    eip2645application: string = 'LedgerW',\n    pathFunction: LedgerPathCalculation = getLedgerPathBuffer111\n  ) {\n    assert(accountID >= 0, 'Ledger account ID shall not be a negative number.');\n    assert(accountID <= MASK_31, 'Ledger account ID shall be < 2**31.');\n    assert(!!eip2645application, 'Ledger application name shall not be empty.');\n    this.transporter = transport;\n    this._transporter = this.transporter as any;\n    this.accountID = accountID;\n    this.pubKey = '';\n    this.fullPubKey = '';\n    this.eip2645applicationName = eip2645application;\n    this.appVersion = '';\n    this.pathBuffer = pathFunction(this.accountID, this.eip2645applicationName);\n  }\n\n  /**\n   * provides the Starknet public key\n   * @returns an hex string : 64 characters are Point X coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getPubKey();\n   * // result= \"0x03681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e\"\n   * ```\n   */\n  public async getPubKey(): Promise<string> {\n    if (!this.pubKey) await this.getPublicKeys();\n    return this.pubKey;\n  }\n\n  /**\n   * provides the full public key (with parity prefix)\n   * @returns an hex string : 2 first characters are the parity, the 64 following characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getFullPubKey();\n   * // result= \"0x0403681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e03cbc86f805dcfcb0c1922dd4daf181afa289d86223a18bc856276615bcc7787\"\n   * ```\n   */\n  public async getFullPubKey(): Promise<string> {\n    if (!this.fullPubKey) await this.getPublicKeys();\n    return this.fullPubKey;\n  }\n\n  /**\n   * Returns the version of the Starknet APP implemented in the Ledger.\n   * @returns {string} version.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getAppVersion();\n   * // result= \"1.1.1\"\n   * ```\n   */\n  public async getAppVersion(): Promise<string> {\n    if (!this.appVersion) {\n      const resp = await this._transporter.send(Number('0x5a'), 0, 0, 0);\n      this.appVersion = `${resp[0]}.${resp[1]}.${resp[2]}`;\n    }\n    return this.appVersion;\n  }\n\n  /**\n   * Sign a TypedData message (SNIP-12) in a Ledger.\n   * @param {typedDataToHash} typedDataToHash A TypedData message compatible with SNIP-12.\n   * @param {string} accountAddress Signer account address (Hex or num string)\n   * @returns {Signature} The signed message.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signMessage(snip12Message, account0.address);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signMessage(typedDataToHash: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedDataToHash, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. This is a blind sign on the Ledger screen.\n   * @param {Call1[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Sign in a Ledger the deployment of a new account. This is a blind sign on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Sign in a Ledger the declaration of a new class. This is a blind sign on the Ledger screen.\n   * @param {DeclareSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V3DeclareSignerDetails` or `V2DeclareSignerDetails` types.\n   * @returns {Signature} The declare Signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeclareTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Internal function to sign a hash in a Ledger Nano.\n   * This is a blind sign in the Ledger ; no display of what you are signing.\n   */\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    addHexPrefix(\n      buf2hex(await this._transporter.send(Number('0x5a'), 2, 0, 0, Buffer.from(this.pathBuffer)))\n    );\n    // eslint-disable-next-line no-bitwise\n    const shiftedHash = toHex(BigInt(msgHash) << 4n);\n    const buff2 = hexToBytes(shiftedHash);\n    const respSign2 = Uint8Array.from(\n      await this._transporter.send(Number('0x5a'), 2, 1, 0, Buffer.from(buff2))\n    );\n    const r = BigInt(addHexPrefix(buf2hex(respSign2.subarray(1, 33))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign2.subarray(33, 65))));\n    const v = respSign2[65];\n    const sign0 = new starkCurve.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return sign1;\n  }\n\n  /** internal function to get both the Starknet public key and the full public key */\n  protected async getPublicKeys() {\n    const pathBuff = this.pathBuffer;\n    const respGetPublic = Uint8Array.from(\n      await this._transporter.send(Number('0x5a'), 1, 0, 0, Buffer.from(pathBuff))\n    );\n    this.pubKey = addHexPrefix(buf2hex(respGetPublic.subarray(1, 33)));\n    this.fullPubKey = addHexPrefix(buf2hex(respGetPublic.subarray(0, 65)));\n  }\n}\n\n/**\n * Format the Ledger wallet path to an Uint8Array\n * for a Ledger Starknet DAPP v1.1.1.\n *\n * EIP2645 path = 2645'/starknet/application/0/accountId/0\n * @param {number} accountId Id of account. < 2**31.\n * @param {string} [applicationName='LedgerW'] utf8 string of application name.\n * @returns an Uint8array of 24 bytes.\n * @example\n * ```typescript\n * const result = getLedgerPathBuffer111(0);\n * // result = Uint8Array(24) [\n *   128,   0,  10,  85,  71, 65, 233, 201,\n *    43, 206, 231, 219,   0,  0,   0,   0,\n *     0,   0,   0,   0,   0,  0,   0,   0\n * ]\n * ```\n */\nexport function getLedgerPathBuffer111(\n  accountId: number,\n  applicationName: string = 'LedgerW'\n): Uint8Array {\n  const path0buff = new Uint8Array([128, 0, 10, 85]); // \"0x80000A55\" EIP2645;\n  const path1buff = new Uint8Array([71, 65, 233, 201]); // \"starknet\"\n  const path2buff =\n    applicationName === 'LedgerW'\n      ? new Uint8Array([43, 206, 231, 219])\n      : stringToSha256ToArrayBuff4(applicationName);\n  const path3buff = new Uint8Array([0, 0, 0, 0]);\n  const hex = toHex(accountId);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, '0'));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff,\n  ]);\n  return pathBuff;\n}\n","/* eslint-disable no-bitwise */\nimport { hexToBytes } from '@noble/curves/abstract/utils';\n\nimport { ADDR_BOUND, ZERO } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { keccakBn } from './hash';\nimport { assertInRange, toHex } from './num';\nimport { isString } from './typed';\n\n/**\n * Format a hex number to '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string: 0x followed by 64 characters. No upper case characters in the response.\n * @example\n * ```typescript\n * const result = [31, 0x1f, '31', '0x1f', '0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf'].map(addAddressPadding);\n * // result = [\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x0000000000000000000000000000000000000000000000000000000000000031',\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf'\n * // ]\n * ```\n */\nexport function addAddressPadding(address: BigNumberish): string {\n  const hex = toHex(isString(address) ? addHexPrefix(address) : address);\n  const padded = removeHexPrefix(hex).padStart(64, '0');\n  return addHexPrefix(padded);\n}\n\n/**\n * Check the validity of a Starknet address, and format it as a hex number: '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string: 0x followed by 64 characters. No upper case characters in the response.\n * @throws address argument must be a valid address inside the address range bound\n * @example\n * ```typescript\n * const result = [31, 0x1f, '31', '0x1f', '0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf'].map(addAddressPadding);\n * // result = [\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x0000000000000000000000000000000000000000000000000000000000000031',\n * //   '0x000000000000000000000000000000000000000000000000000000000000001f',\n * //   '0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf'\n * // ]\n * ```\n */\nexport function validateAndParseAddress(address: BigNumberish): string {\n  const result = addAddressPadding(address);\n\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid Address Format');\n  }\n\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, 'Starknet Address');\n\n  return result;\n}\n\n/**\n * Convert an address to her checksum representation which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. Mix of uppercase and lowercase\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = getChecksumAddress(address);\n * // result = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\"\n * ```\n */\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nexport function getChecksumAddress(address: BigNumberish): string {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split('');\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = hexToBytes(hex.padStart(64, '0'));\n\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return addHexPrefix(chars.join(''));\n}\n\n/**\n * If the casing of an address is mixed, it is a Checksum Address, which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n *\n * @param address string\n * @returns true if the ChecksumAddress is valid\n * @example\n * ```typescript\n * const address = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\";\n * const result = validateChecksumAddress(address);\n * // result = true\n * ```\n */\nexport function validateChecksumAddress(address: string): boolean {\n  return getChecksumAddress(address) === address;\n}\n","/* eslint-disable no-await-in-loop */\n/* eslint-disable no-bitwise */\n/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\nimport type {\n  InvocationsSignerDetails,\n  Call,\n  Signature,\n  Calldata,\n  BigNumberish,\n  V3InvocationsSignerDetails,\n  LedgerPathCalculation,\n  DeployAccountSignerDetails,\n  V3DeployAccountSignerDetails,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport Buffer from '../utils/connect/buffer';\nimport type { SignerInterface } from './interface';\nimport { HARDENING_4BYTES, HARDENING_BYTE } from '../global/constants';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport {\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n  getSelector,\n} from '../utils/hash';\nimport { intDAM } from '../utils/stark';\nimport { addHexPrefix, buf2hex, concatenateArrayBuffer, removeHexPrefix } from '../utils/encode';\nimport { hexToBytes, stringToSha256ToArrayBuff4, toBigInt, toHex } from '../utils/num';\nimport { starkCurve } from '../utils/ec';\nimport { EDAMode, EDataAvailabilityMode, ETransactionVersion3 } from '../types/api';\nimport { addAddressPadding } from '../utils/address';\nimport {\n  encodeResourceBoundsL1,\n  encodeResourceBoundsL2,\n  hashDAMode,\n} from '../utils/hash/transactionHash/v3';\nimport { LedgerSigner111 } from './ledgerSigner111';\n\n/**\n * Signer for accounts using a Ledger Nano S+/X signature (Starknet Ledger APP version 2.2.1).\n *\n * The Ledger has to be connected, unlocked and the Starknet APP has to be selected prior of use of this class.\n */\nexport class LedgerSigner221<Transport extends Record<any, any> = any>\n  extends LedgerSigner111\n  implements SignerInterface\n{\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items).\n   * One item is called `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer221]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer221` is selected.\n   *\n   * If you are using APP v2.2.1 with an account created with the v1.1.1, you need to use :\n   * ```typescript\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0, undefined, getLedgerPathBuffer111);\n   * ```\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0);\n   * ```\n   */\n  constructor(\n    transport: Transport,\n    accountID: number,\n    eip2645application: string = 'LedgerW',\n    pathFunction: LedgerPathCalculation = getLedgerPathBuffer221\n  ) {\n    super(transport, accountID, eip2645application, pathFunction);\n  }\n\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. The details are displayed on the Ledger screen.\n   * @param {Call[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    if (Object.values(ETransactionVersion3).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V3InvocationsSignerDetails;\n      const msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n      const ledgerResponse = await this.signTxV3(det, transactions);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The V3 transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    throw Error('unsupported signTransaction version');\n  }\n\n  /**\n   * Sign in a Ledger the deployment of a new account. The details are displayed on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n      const ledgerResponse = await this.signDeployAccountV3(det);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    throw Error('unsupported signDeployAccountTransaction version');\n  }\n\n  /**\n   * Internal function to convert a bigNumberish to an Uint8array of 256 bits\n   * @param {BigNumberish} input input value\n   * @returns {Uint8Array} a Uint8Array containing 32 bytes.\n   */\n  protected convertBnToLedger(input: BigNumberish): Uint8Array {\n    return hexToBytes(addAddressPadding(toHex(input)));\n  }\n\n  /**\n   * Internal function to decode the response of the Ledger signature\n   * @param {Uint8Array} respSign the Buffer response of the Ledger\n   * @returns { hash: bigint; signature: Signature } transaction hash & signature\n   */\n  protected decodeSignatureLedger(respSign: Uint8Array): { hash: bigint; signature: Signature } {\n    const h = BigInt(addHexPrefix(buf2hex(respSign.subarray(0, 32))));\n    const r = BigInt(addHexPrefix(buf2hex(respSign.subarray(33, 65))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign.subarray(65, 97))));\n    const v = respSign[97];\n    const sign0 = new starkCurve.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return { hash: h, signature: sign1 };\n  }\n\n  /** Internal function to convert a Call to an array of Uint8Array.\n   * @param {Call} call A Call to convert.\n   * @return {Uint8Array[]} Call encoded in an array of Uint8Array (each containing 7 u256).\n   */\n  protected encodeCall(call: Call): Uint8Array[] {\n    const toBuf: Uint8Array = this.convertBnToLedger(call.contractAddress);\n    const selectorBuf: Uint8Array = hexToBytes(addAddressPadding(getSelector(call.entrypoint)));\n    let calldataBuf: Uint8Array = new Uint8Array([]);\n    if (call.calldata) {\n      const compiledCalldata: Calldata = CallData.compile(call.calldata);\n\n      calldataBuf = concatenateArrayBuffer(\n        compiledCalldata.map((parameter: string): Uint8Array => {\n          const a = this.convertBnToLedger(parameter);\n          return a;\n        })\n      );\n    }\n    const callBuf: Uint8Array = concatenateArrayBuffer([toBuf, selectorBuf, calldataBuf]);\n    // slice data into chunks of 7 * 32 bytes\n    const calldatas: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < callBuf.length; i += chunkSize)\n      calldatas.push(callBuf.subarray(i, i + chunkSize));\n    return calldatas;\n  }\n\n  /**\n   * Ask to the Ledger Nano to display and sign a Starknet V3 transaction.\n   * @param {V3InvocationsSignerDetails} txDetails All the details needed for a txV3.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   *   chainId: constants.StarknetChainId.SN_MAIN,\n   *   nonce: \"28\", accountDeploymentData: [],\n   *   paymasterData: [], cairoVersion: \"1\",\n   *   feeDataAvailabilityMode: \"L1\", nonceDataAvailabilityMode: \"L1\",\n   *   resourceBounds: {\n   *     l1_gas: { max_amount: \"0x2a00\", max_price_per_unit: \"0x5c00000\"\n   *     },\n   *     l2_gas: { max_amount: \"0x00\", max_price_per_unit: \"0x00\"},\n   *   }, tip: 0, version: \"0x3\", walletAddress: account0.address\n   *  };\n   * const res = await myLedgerSigner.signTxV3(txDetailsV3, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signTxV3(\n    txDetails: V3InvocationsSignerDetails,\n    calls: Call[]\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    assert(txDetails.paymasterData.length <= 7, 'Paymaster data includes more than 7 items.');\n    assert(\n      txDetails.accountDeploymentData.length <= 7,\n      'accountDeploymentData includes more than 7 items'\n    );\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 3, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      accountAddress (32 bytes) +\n      tip (32 bytes) +\n      l1_gas_bounds (32 bytes) +\n      l2_gas_bounds (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) +\n      data_availability_mode (32 bytes)\n    */\n    const accountAddressBuf = this.convertBnToLedger(txDetails.walletAddress);\n    const tipBuf = this.convertBnToLedger(txDetails.tip);\n    const chainIdBuf = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf = this.convertBnToLedger(txDetails.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        txDetails.nonceDataAvailabilityMode === EDataAvailabilityMode.L1 ? EDAMode.L1 : EDAMode.L2,\n        txDetails.feeDataAvailabilityMode === EDataAvailabilityMode.L1 ? EDAMode.L1 : EDAMode.L2\n      )\n    );\n    const l1_gasBuf = this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds));\n    const l2_gasBuf = this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds));\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      tipBuf,\n      l1_gasBuf,\n      l2_gasBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 3, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 2, 0, Buffer.from(paymasterBuf));\n    //  APDU 3 = account deployment data\n    const accountDeployDataBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 3, 0, Buffer.from(accountDeployDataBuf));\n    // APDU 4 = Nb of calls\n    const nbCallsBuf: Uint8Array = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number('0x5a'), 3, 4, 0, Buffer.from(nbCallsBuf));\n    // APDU 5 = Calls\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const call of calls) {\n      const calldatas: Uint8Array[] = this.encodeCall(call);\n      await this._transporter.send(Number('0x5a'), 3, 5, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part: Uint8Array) => {\n          await this._transporter.send(Number('0x5a'), 3, 5, 1, Buffer.from(part));\n        });\n      }\n      respSign = await this._transporter.send(Number('0x5a'), 3, 5, 2);\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /**\n   *Ask the Ledger Nano to display and sign a Starknet V3 account deployment.\n   * @param {V3DeployAccountSignerDetails} deployAccountDetail All the details needed for a V3 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V3DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x226', max_price_per_unit: '0x22ecb25c00' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '3571125127744830445572285574469842579401255431821644822726857471463672199621'\n   *  ],\n   *  contractAddress: '0x4ca062add1cf12a107be1107af17981cf6e544a24d987693230ea481d3d5e34',\n   *  addressSalt: '0x07e52f68e3160e1ef698211cdf6d3792368fe347e7e2d4a8ace14d9b248f39c5',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 0,\n   *  version: '0x3', nonce: 0n\n   *}\n   * const res = await myLedgerSigner.signDeployAccountV3(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signDeployAccountV3(\n    deployAccountDetail: V3DeployAccountSignerDetails\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 5, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      contract_address (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) +\n      data_availability_mode (32 bytes) +\n      class_hash (32 bytes) +\n      contract_address_salt (32 bytes)\n    */\n    const accountAddressBuf: Uint8Array = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const chainIdBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        deployAccountDetail.nonceDataAvailabilityMode === EDataAvailabilityMode.L1\n          ? EDAMode.L1\n          : EDAMode.L2,\n        deployAccountDetail.feeDataAvailabilityMode === EDataAvailabilityMode.L1\n          ? EDAMode.L1\n          : EDAMode.L2\n      )\n    );\n    const classHashBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n      classHashBuf,\n      saltBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 5, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = fees\n    const tipBuf = this.convertBnToLedger(deployAccountDetail.tip);\n    const l1_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL1(deployAccountDetail.resourceBounds)\n    );\n    const l2_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL2(deployAccountDetail.resourceBounds)\n    );\n    const feeBuf: Uint8Array = concatenateArrayBuffer([tipBuf, l1_gasBuf, l2_gasBuf]);\n    await this._transporter.send(Number('0x5a'), 5, 2, 0, Buffer.from(feeBuf));\n    // APDU 3 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      deployAccountDetail.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 5, 3, 0, Buffer.from(paymasterBuf));\n    // APDU 4 = constructor length\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf: Uint8Array = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number('0x5a'), 5, 4, 0, Buffer.from(constructorLengthBuf));\n    // APDU 4 = constructor\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter: string): Uint8Array => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number('0x5a'), 5, 5, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n}\n\n/**\n * Format the Ledger wallet path to an Uint8Array.\n * for a Ledger Starknet DAPP v2.2.0\n * EIP2645 path = 2645'/starknet'/application'/0'/accountId'/0\n * @param {number} accountId Id of account. < 2**31.\n * @param {string} [applicationName='LedgerW'] utf8 string of application name.\n * @returns an Uint8array of 24 bytes.\n * @example\n * ```typescript\n * const result = getLedgerPathBuffer211(0);\n * // result = Uint8Array(24) [\n *   128,   0,  10,  85, 199, 65, 233, 201,\n *   171, 206, 231, 219, 128,  0,   0,   0,\n *   128,   0,   0,   0,   0,  0,   0,   0\n * ]\n * ```\n */\nexport function getLedgerPathBuffer221(\n  accountId: number,\n  applicationName: string = 'LedgerW'\n): Uint8Array {\n  const path0buff = new Uint8Array([HARDENING_BYTE, 0, 10, 85]); // \"0x80000A55\" EIP2645;\n  const path1buff = new Uint8Array([71 | HARDENING_BYTE, 65, 233, 201]); // \"starknet'\"\n  const path2Base =\n    applicationName === 'LedgerW'\n      ? new Uint8Array([43, 206, 231, 219])\n      : stringToSha256ToArrayBuff4(applicationName);\n  const path2buff = concatenateArrayBuffer([\n    new Uint8Array([path2Base[0] | HARDENING_BYTE]),\n    path2Base.subarray(1),\n  ]);\n  const path3buff = new Uint8Array([HARDENING_BYTE, 0, 0, 0]);\n  const hex = toHex(BigInt(accountId) | HARDENING_4BYTES);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, '0'));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff,\n  ]);\n  return pathBuff;\n}\n","/* eslint-disable @typescript-eslint/no-loop-func */\n/* eslint-disable no-await-in-loop */\n/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\n\nimport {\n  isRPC08Plus_ResourceBoundsBN,\n  type BigNumberish,\n  type Call,\n  type Calldata,\n  type LedgerPathCalculation,\n  type Signature,\n  type V3DeployAccountSignerDetails,\n  type V3InvocationsSignerDetails,\n} from '../types';\nimport { CallData } from '../utils/calldata';\nimport Buffer from '../utils/connect/buffer';\nimport type { SignerInterface } from './interface';\nimport { getSelector } from '../utils/hash';\nimport { concatenateArrayBuffer } from '../utils/encode';\nimport { hexToBytes } from '../utils/num';\nimport { addAddressPadding } from '../utils/address';\nimport { getLedgerPathBuffer221, LedgerSigner221 } from './ledgerSigner221';\nimport assert from '../utils/assert';\nimport {\n  encodeDataResourceBoundsL1,\n  encodeResourceBoundsL1,\n  encodeResourceBoundsL2,\n  hashDAMode,\n} from '../utils/hash/transactionHash/v3';\nimport { intDAM } from '../utils/stark';\n\n/**\n * Signer for accounts using a Ledger Nano S+/X signature (Starknet Ledger APP version 2.3.1).\n *\n * The Ledger has to be connected, unlocked and the Starknet APP has to be selected prior of use of this class.\n */\nexport class LedgerSigner231<Transport extends Record<any, any> = any>\n  extends LedgerSigner221\n  implements SignerInterface\n{\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano account (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items).\n   * One item is called `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer221]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer221` is selected.\n   *\n   * If you are using APP v2.3.1 with an account created with the v1.1.1, you need to use :\n   * ```typescript\n   * const myLedgerSigner = new LedgerSigner231(myNodeTransport, 0, undefined, getLedgerPathBuffer111);\n   * ```\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner231(myNodeTransport, 0);\n   * ```\n   */\n  constructor(\n    transport: Transport,\n    accountID: number,\n    eip2645application: string = 'LedgerW',\n    pathFunction: LedgerPathCalculation = getLedgerPathBuffer221\n  ) {\n    super(transport, accountID, eip2645application, pathFunction);\n  }\n\n  /**\n   * Ask to the Ledger Nano to display and sign a Starknet V3 transaction (Rpc 0.7 & Rpc 0.8).\n   * @param {V3InvocationsSignerDetails} txDetails All the details needed for a txV3.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   *   chainId: constants.StarknetChainId.SN_MAIN,\n   *   nonce: \"28\", accountDeploymentData: [],\n   *   paymasterData: [], cairoVersion: \"1\",\n   *   feeDataAvailabilityMode: \"L1\", nonceDataAvailabilityMode: \"L1\",\n   *   resourceBounds: {\n   *     l1_gas: { max_amount: \"0x2a00\", max_price_per_unit: \"0x5c00000\"\n   *     },\n   *     l2_gas: { max_amount: \"0x00\", max_price_per_unit: \"0x00\"},\n   *   }, tip: 0, version: \"0x3\", walletAddress: account0.address\n   *  }; // Rpc 0.7 transaction.\n   * const res = await myLedgerSigner.signTxV3(txDetailsV3, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signTxV3(\n    txDetails: V3InvocationsSignerDetails,\n    calls: Call[]\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    assert(txDetails.paymasterData.length <= 7, 'Paymaster data includes more than 7 items.');\n    assert(\n      txDetails.accountDeploymentData.length <= 7,\n      'accountDeploymentData includes more than 7 items'\n    );\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 3, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      accountAddress (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) +\n      data_availability_mode (32 bytes)\n    */\n    const accountAddressBuf = this.convertBnToLedger(txDetails.walletAddress);\n    const chainIdBuf = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf = this.convertBnToLedger(txDetails.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        intDAM(txDetails.nonceDataAvailabilityMode),\n        intDAM(txDetails.feeDataAvailabilityMode)\n      )\n    );\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 3, 1, 0, Buffer.from(dataBuf));\n\n    // APDU 2 = fees\n    if (isRPC08Plus_ResourceBoundsBN(txDetails.resourceBounds)) {\n      const tipBuf = this.convertBnToLedger(txDetails.tip);\n      const l1_gasBuf = this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds));\n      const l2_gasBuf = this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds));\n      const l1_data_gasBuf = this.convertBnToLedger(\n        encodeDataResourceBoundsL1(txDetails.resourceBounds)\n      );\n      const feeBuf: Uint8Array = concatenateArrayBuffer([\n        tipBuf,\n        l1_gasBuf,\n        l2_gasBuf,\n        l1_data_gasBuf,\n      ]);\n      await this._transporter.send(Number('0x5a'), 3, 2, 0, Buffer.from(feeBuf));\n    }\n\n    // APDU 3 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 3, 0, Buffer.from(paymasterBuf));\n\n    //  APDU 4 = account deployment data\n    const accountDeployDataBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 4, 0, Buffer.from(accountDeployDataBuf));\n\n    // APDU 5 = Nb of calls\n    const nbCallsBuf: Uint8Array = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number('0x5a'), 3, 5, 0, Buffer.from(nbCallsBuf));\n\n    // APDU 6 = Calls\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const call of calls) {\n      const calldatas: Uint8Array[] = this.encodeCall(call);\n      respSign = await this._transporter.send(Number('0x5a'), 3, 6, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part: Uint8Array) => {\n          respSign = await this._transporter.send(Number('0x5a'), 3, 6, 1, Buffer.from(part));\n        });\n      }\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /**\n   *Ask the Ledger Nano to display and sign a Starknet V3 account deployment (Rpc 0.7 & Rpc 0.8).\n   * @param {V3DeployAccountSignerDetails} deployAccountDetail All the details needed for a V3 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V3DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x226', max_price_per_unit: '0x22ecb25c00' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '3571125127744830445572285574469842579401255431821644822726857471463672199621'\n   *  ],\n   *  contractAddress: '0x4ca062add1cf12a107be1107af17981cf6e544a24d987693230ea481d3d5e34',\n   *  addressSalt: '0x07e52f68e3160e1ef698211cdf6d3792368fe347e7e2d4a8ace14d9b248f39c5',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 0,\n   *  version: '0x3', nonce: 0n\n   *} // Rpc 0.7 transaction.\n   * const res = await myLedgerSigner.signDeployAccountV3(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signDeployAccountV3(\n    deployAccountDetail: V3DeployAccountSignerDetails\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 5, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n        contract_address (32 bytes) +\n        chain_id (32 bytes) +\n        nonce (32 bytes) +\n        data_availability_mode (32 bytes) +\n        class_hash (32 bytes) +\n        contract_address_salt (32 bytes)\n      */\n    const accountAddressBuf: Uint8Array = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const chainIdBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        intDAM(deployAccountDetail.nonceDataAvailabilityMode),\n        intDAM(deployAccountDetail.feeDataAvailabilityMode)\n      )\n    );\n    const classHashBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n      classHashBuf,\n      saltBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 5, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = fees\n    if (isRPC08Plus_ResourceBoundsBN(deployAccountDetail.resourceBounds)) {\n      const tipBuf = this.convertBnToLedger(deployAccountDetail.tip);\n      const l1_gasBuf = this.convertBnToLedger(\n        encodeResourceBoundsL1(deployAccountDetail.resourceBounds)\n      );\n      const l2_gasBuf = this.convertBnToLedger(\n        encodeResourceBoundsL2(deployAccountDetail.resourceBounds)\n      );\n      const l1_data_gasBuf = this.convertBnToLedger(\n        encodeDataResourceBoundsL1(deployAccountDetail.resourceBounds)\n      );\n      const feeBuf: Uint8Array = concatenateArrayBuffer([\n        tipBuf,\n        l1_gasBuf,\n        l2_gasBuf,\n        l1_data_gasBuf,\n      ]);\n      await this._transporter.send(Number('0x5a'), 5, 2, 0, Buffer.from(feeBuf));\n    }\n    // APDU 3 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      deployAccountDetail.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 5, 3, 0, Buffer.from(paymasterBuf));\n    // APDU 4 = constructor length\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf: Uint8Array = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number('0x5a'), 5, 4, 0, Buffer.from(constructorLengthBuf));\n    // APDU 5_ = constructor\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter: string): Uint8Array => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number('0x5a'), 5, 5, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /** Internal function to convert a Call to an array of Uint8Array.\n   * @param {Call} call A Call to convert.\n   * @return {Uint8Array[]} Call encoded in an array of Uint8Array (each containing 7 u256).\n   */\n  protected encodeCall(call: Call): Uint8Array[] {\n    const toBuf: Uint8Array = this.convertBnToLedger(call.contractAddress);\n    const selectorBuf: Uint8Array = hexToBytes(addAddressPadding(getSelector(call.entrypoint)));\n    let calldataBuf: Uint8Array = new Uint8Array([]);\n    if (call.calldata) {\n      const compiledCalldata: Calldata = CallData.compile(call.calldata);\n      const calldataSizeBuf: Uint8Array = this.convertBnToLedger(compiledCalldata.length);\n\n      calldataBuf = concatenateArrayBuffer([\n        calldataSizeBuf,\n        ...compiledCalldata.map((parameter: string): Uint8Array => {\n          const a = this.convertBnToLedger(parameter);\n          return a;\n        }),\n      ]);\n    } else {\n      calldataBuf = this.convertBnToLedger('0x00');\n    }\n    const callBuf: Uint8Array = concatenateArrayBuffer([toBuf, selectorBuf, calldataBuf]);\n    // slice data into chunks of 7 * 32 bytes\n    const calldatas: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < callBuf.length; i += chunkSize)\n      calldatas.push(callBuf.subarray(i, i + chunkSize));\n    return calldatas;\n  }\n}\n","import { CallData } from './calldata';\nimport { Call, type AllowArray, type BigNumberish, type Calldata } from '../types/lib';\nimport {\n  OutsideExecutionTypesV1,\n  OutsideExecutionTypesV2,\n  OutsideExecutionVersion,\n  type OutsideCall,\n  type OutsideExecutionOptions,\n  type OutsideTransaction,\n  type TypedData,\n} from '../types';\nimport { getSelectorFromName } from './hash/selector';\nimport { formatSignature } from './stark';\nimport { toHex } from './num';\nimport type { OutsideCallV1, OutsideCallV2 } from '../types/api';\n\nexport function toOutsideCallV2(call: OutsideCallV1 | OutsideCallV2): OutsideCallV2 {\n  if ('calldata_len' in call) {\n    return {\n      To: call.to,\n      Selector: call.selector,\n      Calldata: call.calldata,\n    };\n  }\n  return call;\n}\n\n/**\n * Converts a Call object to an OutsideCall object that can be used for an Outside Execution.\n * @param {Call} call transaction to proceed.\n * @returns {OutsideCall} transaction formatted in conformity to SNIP-9\n * @example\n * ```typescript\n * const call1: Call = {\n *    contractAddress: '0x0123',\n *    entrypoint: 'transfer',\n *    calldata: { recipient: '0xabcd', amount: cairo.uint256(10) },\n *  };\n *  const result = outsideExecution.getOutsideCall(call1);\n *  // result = {\n *  //  to: '0x0123',\n *  //  selector: getSelectorFromName(call1.entrypoint),\n *  //  calldata: ['43981', '10', '0'],\n *  //}\n * ```\n */\nexport function getOutsideCall(call: Call): OutsideCall {\n  const callData = call.calldata ?? [];\n  const callDataCompiled = Array.isArray(callData) ? callData : CallData.compile(callData);\n  return {\n    to: call.contractAddress,\n    selector: getSelectorFromName(call.entrypoint),\n    calldata: callDataCompiled,\n  };\n}\n\n/**  represents a call object as a typed data, supporting both v1 and v2 versions */\nfunction callToTypedData(call: Call, version: OutsideExecutionVersion) {\n  const outsideCall = getOutsideCall(call);\n  if (version === '1') {\n    return {\n      ...outsideCall,\n      calldata_len: outsideCall.calldata.length,\n      calldata: outsideCall.calldata,\n    };\n  }\n  return {\n    To: outsideCall.to,\n    Selector: outsideCall.selector,\n    Calldata: outsideCall.calldata,\n  };\n}\n\nfunction getDomain(chainId: string, version: OutsideExecutionVersion) {\n  return {\n    name: 'Account.execute_from_outside',\n    version,\n    chainId,\n    ...(version === '2' ? { revision: '1' } : {}),\n  };\n}\n\n/**\n * Build a TypedData message that will be used for an Outside execution.\n * @param {string} chainId  The encoded string of the name of network.\n * @param {OutsideExecutionOptions} options Parameters related to an Outside Execution.\n * @param {BigNumberish} nonce Outside execution nonce (not to confuse with normal transaction nonce).\n * @param {Call[]} myCalls transaction(s) to proceed.\n * @param {OutsideExecutionVersion} version SNIP-9 V1 or V2.\n * @returns {TypedData} SNIP-12 message conform to SNIP-9.\n * @example\n * ```typescript\n * const callOptions: OutsideExecutionOptions = {\n *    caller: '0x1234',\n *    execute_after: 100,\n *    execute_before: 200,\n *  };\n *  const result: TypedData = outsideExecution.getTypedData(\n *    constants.StarknetChainId.SN_SEPOLIA,\n *    callOptions,\n *    21,\n *    [call1],\n *    EOutsideExecutionVersion.V2\n *  );\n *  // result = {\n *  //  domain: {\n *  //    chainId: '0x534e5f5345504f4c4941',\n *  //    name: 'Account.execute_from_outside',\n *  //    revision: '1',\n *  //    version: '2',\n *  //  },\n *  //  message: {\n *  //    Caller: '0x1234',\n *  //  ...\n * ```\n */\nexport function getTypedData(\n  chainId: string,\n  options: OutsideExecutionOptions,\n  nonce: BigNumberish,\n  myCalls: Call[],\n  version: OutsideExecutionVersion\n): TypedData {\n  if (version === '1') {\n    return {\n      types: OutsideExecutionTypesV1,\n      primaryType: 'OutsideExecution',\n      domain: getDomain(chainId, version),\n      message: {\n        ...options,\n        nonce,\n        calls_len: myCalls.length,\n        calls: myCalls.map((call) => callToTypedData(call, version)),\n      },\n    };\n  }\n  return {\n    types: OutsideExecutionTypesV2,\n    primaryType: 'OutsideExecution',\n    domain: getDomain(chainId, version),\n    message: {\n      Caller: options.caller,\n      Nonce: nonce,\n      'Execute After': options.execute_after,\n      'Execute Before': options.execute_before,\n      Calls: myCalls.map((call) => callToTypedData(call, version)),\n    },\n  };\n}\n\n/**\n * Builds a Calldata for the execute_from_outside() entrypoint.\n * @param {OutsideTransaction} outsideTransaction an object that contains all the data for a Outside Execution.\n * @returns {Calldata} The Calldata related to this Outside transaction\n * @example\n * ```typescript\n * const outsideTransaction: OutsideTransaction = {\n *     outsideExecution: {\n *      caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n *      nonce: '0x7d0b4b4fce4b236e63d2bb5fc321935d52935cd3b268248cf9cf29c496bd0ae',\n *      execute_after: 500, execute_before: 600,\n *      calls: [{ to: '0x678', selector: '0x890', calldata: [12, 13] }],\n *    },\n *    signature: ['0x123', '0x456'],\n *    signerAddress: '0x3b278ebae434f283f9340587a7f2dd4282658ac8e03cb9b0956db23a0a83657',\n *    version: EOutsideExecutionVersion.V2,\n *  };\n *\n *  const result: Calldata = outsideExecution.buildExecuteFromOutsideCallData(outsideTransaction);\n * // result =      ['2846891009026995430665703316224827616914889274105712248413538305735679628945',\n * //   '3534941323322368687588030484849371698982661160919690922146419787802417549486',\n * //   '500', '600', '1', '1656', '2192', '2', '12', '13', '2', '291', '1110']\n * ```\n */\nexport function buildExecuteFromOutsideCallData(outsideTransaction: OutsideTransaction): Calldata {\n  const execution = outsideTransaction.outsideExecution;\n  const formattedSignature = formatSignature(outsideTransaction.signature);\n  return CallData.compile({\n    outside_execution: execution,\n    signature: formattedSignature,\n  });\n}\n\n/**\n * Builds a Call for execute(), estimateFee() and simulateTransaction() functions.\n * @param {AllowArray<OutsideTransaction>} outsideTransaction an object that contains all the data for an Outside Execution.\n * @returns {Call[]} The Call related to this Outside transaction\n * @example\n * ```typescript\n * const outsideTransaction: OutsideTransaction = {\n *     outsideExecution: {\n *      caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n *      nonce: '0x7d0b4b4fce4b236e63d2bb5fc321935d52935cd3b268248cf9cf29c496bd0ae',\n *      execute_after: 500, execute_before: 600,\n *      calls: [{ to: '0x678', selector: '0x890', calldata: [12, 13] }],\n *    },\n *    signature: ['0x123', '0x456'],\n *    signerAddress: '0x3b278ebae434f283f9340587a7f2dd4282658ac8e03cb9b0956db23a0a83657',\n *    version: EOutsideExecutionVersion.V2,\n *  };\n *\n *  const result: Call[] = outsideExecution.buildExecuteFromOutsideCall(outsideTransaction);\n * // result = [{contractAddress: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n * //   entrypoint: 'execute_from_outside_v2',\n * //   calldata: [ ... ],\n * // }]\n * ```\n */\nexport function buildExecuteFromOutsideCall(\n  outsideTransaction: AllowArray<OutsideTransaction>\n): Call[] {\n  const myOutsideTransactions = Array.isArray(outsideTransaction)\n    ? outsideTransaction\n    : [outsideTransaction];\n  const multiCall: Call[] = myOutsideTransactions.map((outsideTx: OutsideTransaction) => {\n    let entrypoint: string;\n    if (outsideTx.version === OutsideExecutionVersion.V1) {\n      entrypoint = 'execute_from_outside';\n    } else if (outsideTx.version === OutsideExecutionVersion.V2) {\n      entrypoint = 'execute_from_outside_v2';\n    } else {\n      throw new Error('Unsupported OutsideExecution version');\n    }\n    return {\n      contractAddress: toHex(outsideTx.signerAddress),\n      entrypoint,\n      calldata: buildExecuteFromOutsideCallData(outsideTx),\n    };\n  });\n  return multiCall;\n}\n","import { RpcProvider } from '../provider';\nimport type { BigNumberish } from '../types';\nimport { toHex } from './num';\n\n/**\n * Implementation of ERC165 introspection.\n * Verify if a contract has implemented some standard functionalities.\n * @param {RpcProvider} provider the provider to access to Starknet.\n * @param {BigNumberish} contractAddress the address of the contract to check.\n * @param {BigNumberish} interfaceId the hash of the functionality to check.\n * @returns {boolean} true if the interfaceId is implemented in this contract.\n * @example\n * ```typescript\n * const snip9InterfaceV2Id = constants.SNIP9_V2_INTERFACE_ID;\n * const result = src5.supportsInterface(myProvider, accountContractAddress, snip9InterfaceV2Id);\n * // result = true\n * ```\n */\nexport async function supportsInterface(\n  provider: RpcProvider,\n  contractAddress: BigNumberish,\n  interfaceId: BigNumberish\n): Promise<boolean> {\n  const call = {\n    contractAddress: toHex(contractAddress),\n    entrypoint: 'supports_interface',\n    calldata: [toHex(interfaceId)],\n  };\n  try {\n    const resp = await provider.callContract(call);\n    return BigInt(resp[0]) !== 0n;\n  } catch {\n    // account not compatible with ERC165 (introspection)\n    return false;\n  }\n}\n","import { NetworkName, PAYMASTER_RPC_NODES } from '../global/constants';\nimport { logger } from '../global/logger';\nimport { BigNumberish, PaymasterDetails, PreparedTransaction, Call } from '../types';\nimport assert from './assert';\nimport { CallData } from './calldata';\nimport { toOutsideCallV2 } from './outsideExecution';\nimport { getSelectorFromName } from './hash';\nimport { toBigInt } from './num';\nimport type { OutsideCallV1, OutsideCallV2 } from '../types/api';\n\n/**\n * Return randomly select available public paymaster node url\n * @param {NetworkName} networkName NetworkName\n * @param {boolean} mute mute public node warning\n * @returns {string} default node url\n */\nexport const getDefaultPaymasterNodeUrl = (\n  networkName?: NetworkName,\n  mute: boolean = false\n): string => {\n  if (!mute) {\n    logger.info('Using default public node url, please provide nodeUrl in provider options!');\n  }\n  const nodes = PAYMASTER_RPC_NODES[networkName ?? NetworkName.SN_SEPOLIA];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\n\n/**\n * Assert gas fee from unsafe calls is equal to the provided gas fees\n * @param {Call[]} unsafeCalls - The unsafe calls.\n * @param {BigNumberish} fees - The fees in gas token.\n * @throws {Error} Throws an error if the gas token value is not equal to the provided gas fees.\n */\nconst assertGasFeeFromUnsafeCalls = (\n  unsafeCalls: (OutsideCallV1 | OutsideCallV2)[],\n  fees: BigNumberish\n) => {\n  const unsafeCall = toOutsideCallV2(unsafeCalls[unsafeCalls.length - 1]);\n  const unsafeGasTokenCalldata = CallData.toCalldata(unsafeCall.Calldata);\n  const unsafeGasTokenValue = unsafeGasTokenCalldata[1];\n  // Assert gas token to signed is stricly equal to the provided gas fees\n  assert(\n    BigInt(unsafeGasTokenValue) === BigInt(fees),\n    'Gas token value is not equal to the provided gas fees'\n  );\n};\n\nconst assertGasTokenFromUnsafeCalls = (\n  unsafeCalls: (OutsideCallV1 | OutsideCallV2)[],\n  gasToken: string\n) => {\n  const unsafeCall = toOutsideCallV2(unsafeCalls[unsafeCalls.length - 1]);\n  // Assert gas token to signed is stricly equal to the provided gas fees\n  assert(\n    BigInt(unsafeCall.To) === BigInt(gasToken),\n    'Gas token address is not equal to the provided gas token'\n  );\n};\n\n/**\n * Asserts that the given calls are strictly equal, otherwise throws an error.\n * @param {Call[]} originalCalls - The original calls.\n * @param {Call[]} unsafeCalls - The unsafe calls.\n * @throws {Error} Throws an error if the calls are not strictly equal.\n */\nexport function assertCallsAreStrictlyEqual(\n  originalCalls: Call[],\n  unsafeCalls: (OutsideCallV1 | OutsideCallV2)[]\n) {\n  const baseError = 'Provided calls are not strictly equal to the returned calls';\n\n  // Unsafe calls always include one additional call (gas token transfer)\n  assert(\n    unsafeCalls.length - 1 === originalCalls.length,\n    `${baseError}: Expected ${originalCalls.length + 1} calls, got ${unsafeCalls.length}`\n  );\n\n  // Compare each original call with the corresponding unsafe call\n  for (let callIndex = 0; callIndex < originalCalls.length; callIndex += 1) {\n    // Originals calls are not given as outside calls by user, ans is treated as Call[]\n    const originalCall = originalCalls[callIndex];\n    // Unsafe calls are given as outside calls by paymaster\n    const unsafeCall = toOutsideCallV2(unsafeCalls[callIndex]);\n\n    // Normalize addresses by removing leading zeros and converting to lowercase\n    const normalizeAddress = (address: string): string => {\n      return toBigInt(address).toString(16).toLowerCase();\n    };\n\n    // Check contract addresses (normalize to handle leading zeros)\n    const originalAddress = normalizeAddress(originalCall.contractAddress);\n    const unsafeAddress = normalizeAddress(unsafeCall.To);\n\n    assert(\n      originalAddress === unsafeAddress,\n      `${baseError}: Contract address mismatch at call ${callIndex}. ` +\n        `Expected: ${originalCall.contractAddress}, Got: ${unsafeCall.To}`\n    );\n\n    // Check entrypoints (should be exact string match)\n    assert(\n      getSelectorFromName(originalCall.entrypoint) === unsafeCall.Selector,\n      `${baseError}: Entrypoint mismatch at call ${callIndex}. ` +\n        `Expected: ${originalCall.entrypoint}, Got: ${unsafeCall.Selector}`\n    );\n\n    // Convert calldata to normalized arrays for comparison\n    const originalCalldata = CallData.toCalldata(originalCall.calldata);\n    const unsafeCalldata = CallData.toCalldata(unsafeCall.Calldata);\n\n    // Check calldata length\n    assert(\n      originalCalldata.length === unsafeCalldata.length,\n      `${baseError}: Calldata length mismatch at call ${callIndex}. ` +\n        `Expected length: ${originalCalldata.length}, Got length: ${unsafeCalldata.length}`\n    );\n\n    // Compare each calldata element (normalize using BigInt to handle leading zeros)\n    for (let dataIndex = 0; dataIndex < originalCalldata.length; dataIndex += 1) {\n      const originalValue = BigInt(originalCalldata[dataIndex]);\n      const unsafeValue = BigInt(unsafeCalldata[dataIndex]);\n\n      assert(\n        originalValue === unsafeValue,\n        `${baseError}: Calldata value mismatch at call ${callIndex}, parameter ${dataIndex}. ` +\n          `Expected: ${originalCalldata[dataIndex]}, Got: ${unsafeCalldata[dataIndex]}`\n      );\n    }\n  }\n}\n\nexport const assertPaymasterTransactionSafety = (\n  preparedTransaction: PreparedTransaction,\n  calls: Call[],\n  paymasterDetails: PaymasterDetails,\n  maxFeeInGasToken?: BigNumberish\n) => {\n  // If tx is not sponsored, we can skip safety checks\n  if (paymasterDetails.feeMode.mode !== 'sponsored') {\n    // We only check the calls if user effectively has to pay something\n    if (preparedTransaction.type === 'invoke' || preparedTransaction.type === 'deploy_and_invoke') {\n      // extract unsafe calls to verify\n      const unsafeCalls: (OutsideCallV1 | OutsideCallV2)[] =\n        'calls' in preparedTransaction.typed_data.message\n          ? (preparedTransaction.typed_data.message as any).calls\n          : (preparedTransaction.typed_data.message as any).Calls;\n\n      // Assert calls provided and unsafe calls are strictly equal\n      assertCallsAreStrictlyEqual(calls, unsafeCalls);\n\n      // Assert gas token address from unsafe calls is equal to the provided gas token\n      assertGasTokenFromUnsafeCalls(unsafeCalls, paymasterDetails.feeMode.gasToken);\n\n      // If maxFeeInGasToken is provided, do all safety checks\n      if (maxFeeInGasToken) {\n        // Check if the gas token price is too high\n        assert(\n          preparedTransaction.fee.suggested_max_fee_in_gas_token <= maxFeeInGasToken,\n          'Gas token price is too high'\n        );\n\n        // Assert gas fee from unsafe calls is equal to the provided gas fees(the value used to display the gas fee to the user)\n        assertGasFeeFromUnsafeCalls(\n          unsafeCalls,\n          preparedTransaction.fee.suggested_max_fee_in_gas_token\n        );\n      }\n    }\n  }\n};\n","import type { JRPC, PAYMASTER_API, TIME_BOUNDS } from '../types/api';\nimport type {\n  Call,\n  ExecutableUserTransaction,\n  ExecutionParameters,\n  FeeMode,\n  PaymasterFeeEstimate,\n  PaymasterTimeBounds,\n  PreparedTransaction,\n  RPC_ERROR,\n  RpcProviderOptions,\n  UserTransaction,\n  PaymasterOptions,\n  TokenData,\n} from '../types';\nimport { getDefaultPaymasterNodeUrl } from '../utils/paymaster';\nimport fetch from '../utils/connect/fetch';\nimport { LibraryError, RpcError } from '../utils/errors';\nimport { PaymasterInterface } from './interface';\nimport { NetworkName } from '../global/constants';\nimport { stringify } from '../utils/json';\nimport { CallData } from '../utils/calldata';\nimport { getSelectorFromName } from '../utils/hash';\nimport { signatureToHexArray } from '../utils/stark';\n\nconst convertCalls = (calls: Call[]): PAYMASTER_API.CALL[] =>\n  calls.map((call) => ({\n    to: call.contractAddress,\n    selector: getSelectorFromName(call.entrypoint),\n    calldata: CallData.toHex(call.calldata),\n  }));\n\nconst convertFeeMode = (feeMode: FeeMode): PAYMASTER_API.FEE_MODE => {\n  if (feeMode.mode === 'sponsored') {\n    return { mode: 'sponsored' };\n  }\n  return { mode: 'default', gas_token: feeMode.gasToken };\n};\n\nconst convertFEE_MODE = (feeMode: PAYMASTER_API.FEE_MODE): FeeMode => {\n  if (feeMode.mode === 'sponsored') {\n    return { mode: 'sponsored' };\n  }\n  return { mode: 'default', gasToken: feeMode.gas_token };\n};\n\nconst convertTimeBounds = (timeBounds?: PaymasterTimeBounds): TIME_BOUNDS | undefined =>\n  timeBounds\n    ? {\n        execute_after: timeBounds.executeAfter || 1, // If executeAfter is not provided, set it to 1, meaning the transaction can be executed immediately\n        execute_before: timeBounds.executeBefore,\n      }\n    : undefined;\n\nconst convertTIME_BOUNDS = (timeBounds?: TIME_BOUNDS): PaymasterTimeBounds | undefined =>\n  timeBounds\n    ? {\n        executeAfter: timeBounds.execute_after,\n        executeBefore: timeBounds.execute_before,\n      }\n    : undefined;\n\nconst convertEXECUTION_PARAMETERS = (\n  parameters: PAYMASTER_API.EXECUTION_PARAMETERS\n): ExecutionParameters => ({\n  version: parameters.version,\n  feeMode: convertFEE_MODE(parameters.fee_mode),\n  timeBounds: convertTIME_BOUNDS(parameters.time_bounds),\n});\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n};\n\nexport class PaymasterRpc implements PaymasterInterface {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public readonly baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  public requestId: number;\n\n  constructor(options?: PaymasterOptions | PaymasterInterface | PaymasterRpc) {\n    if (options instanceof PaymasterRpc) {\n      this.nodeUrl = options.nodeUrl;\n      this.headers = { ...defaultOptions.headers, ...options.headers };\n      this.baseFetch = options.baseFetch;\n      this.requestId = options.requestId;\n      return;\n    }\n\n    if (options && 'nodeUrl' in options && 'headers' in options && 'baseFetch' in options) {\n      this.nodeUrl = options.nodeUrl ?? getDefaultPaymasterNodeUrl(undefined);\n      this.headers = { ...defaultOptions.headers, ...options.headers };\n      this.baseFetch = options.baseFetch ?? fetch;\n      this.requestId = 0;\n      return;\n    }\n\n    const { nodeUrl, headers, baseFetch } = options || {};\n    if (nodeUrl && Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultPaymasterNodeUrl(nodeUrl as NetworkName, options?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultPaymasterNodeUrl(undefined, options?.default);\n    }\n    this.baseFetch = baseFetch ?? fetch;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.requestId = 0;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      throw new RpcError(rpcError as RPC_ERROR, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof PAYMASTER_API.Methods>(\n    method: T,\n    params?: PAYMASTER_API.Methods[T]['params']\n  ): Promise<PAYMASTER_API.Methods[T]['result']> {\n    try {\n      this.requestId += 1;\n      const rawResult = await this.fetch(method, params, this.requestId);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as PAYMASTER_API.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async isAvailable(): Promise<boolean> {\n    return this.fetchEndpoint('paymaster_isAvailable');\n  }\n\n  public async buildTransaction(\n    transaction: UserTransaction,\n    parameters: ExecutionParameters\n  ): Promise<PreparedTransaction> {\n    let userTransaction: PAYMASTER_API.USER_TRANSACTION;\n    switch (transaction.type) {\n      case 'invoke':\n        userTransaction = {\n          ...transaction,\n          invoke: {\n            user_address: transaction.invoke.userAddress,\n            calls: convertCalls(transaction.invoke.calls),\n          },\n        };\n        break;\n\n      case 'deploy_and_invoke':\n        userTransaction = {\n          ...transaction,\n          invoke: {\n            user_address: transaction.invoke.userAddress,\n            calls: convertCalls(transaction.invoke.calls),\n          },\n        };\n        break;\n\n      case 'deploy':\n      default:\n        userTransaction = transaction;\n        break;\n    }\n    const executionParameters: PAYMASTER_API.EXECUTION_PARAMETERS = {\n      version: parameters.version,\n      fee_mode: convertFeeMode(parameters.feeMode),\n      time_bounds: convertTimeBounds(parameters.timeBounds),\n    };\n\n    const response = await this.fetchEndpoint('paymaster_buildTransaction', {\n      transaction: userTransaction,\n      parameters: executionParameters,\n    });\n\n    const fee: PaymasterFeeEstimate = {\n      gas_token_price_in_strk: BigInt(response.fee.gas_token_price_in_strk),\n      estimated_fee_in_strk: BigInt(response.fee.estimated_fee_in_strk),\n      estimated_fee_in_gas_token: BigInt(response.fee.estimated_fee_in_gas_token),\n      suggested_max_fee_in_strk: BigInt(response.fee.suggested_max_fee_in_strk),\n      suggested_max_fee_in_gas_token: BigInt(response.fee.suggested_max_fee_in_gas_token),\n    };\n\n    switch (response.type) {\n      case 'invoke':\n        return {\n          type: 'invoke',\n          typed_data: response.typed_data,\n          parameters: convertEXECUTION_PARAMETERS(response.parameters),\n          fee,\n        };\n      case 'deploy_and_invoke':\n        return {\n          type: 'deploy_and_invoke',\n          deployment: response.deployment,\n          typed_data: response.typed_data,\n          parameters: convertEXECUTION_PARAMETERS(response.parameters),\n\n          fee,\n        };\n      case 'deploy':\n      default:\n        return {\n          type: 'deploy',\n          deployment: response.deployment,\n          parameters: convertEXECUTION_PARAMETERS(response.parameters),\n          fee,\n        };\n    }\n  }\n\n  public async executeTransaction(\n    transaction: ExecutableUserTransaction,\n    parameters: ExecutionParameters\n  ): Promise<PAYMASTER_API.ExecuteResponse> {\n    let user_transaction: PAYMASTER_API.EXECUTABLE_USER_TRANSACTION;\n    switch (transaction.type) {\n      case 'invoke':\n        user_transaction = {\n          ...transaction,\n          invoke: {\n            user_address: transaction.invoke.userAddress,\n            typed_data: transaction.invoke.typedData,\n            signature: signatureToHexArray(transaction.invoke.signature),\n          },\n        };\n        break;\n\n      case 'deploy_and_invoke':\n        user_transaction = {\n          ...transaction,\n          invoke: {\n            user_address: transaction.invoke.userAddress,\n            typed_data: transaction.invoke.typedData,\n            signature: signatureToHexArray(transaction.invoke.signature),\n          },\n        };\n        break;\n\n      case 'deploy':\n      default:\n        user_transaction = transaction;\n        break;\n    }\n    const executionParameters: PAYMASTER_API.EXECUTION_PARAMETERS = {\n      version: parameters.version,\n      fee_mode: convertFeeMode(parameters.feeMode),\n      time_bounds: convertTimeBounds(parameters.timeBounds),\n    };\n    return this.fetchEndpoint('paymaster_executeTransaction', {\n      transaction: user_transaction,\n      parameters: executionParameters,\n    });\n  }\n\n  public async getSupportedTokens(): Promise<TokenData[]> {\n    return this.fetchEndpoint('paymaster_getSupportedTokens').then((tokens) =>\n      tokens.map((token) => ({\n        token_address: token.token_address,\n        decimals: token.decimals,\n        priceInStrk: BigInt(token.price_in_strk),\n      }))\n    );\n  }\n}\n","import {\n  PreparedTransaction,\n  RpcProviderOptions,\n  TokenData,\n  UserTransaction,\n  ExecutableUserTransaction,\n  ExecutionParameters,\n  RPC,\n} from '../types';\n\nexport abstract class PaymasterInterface {\n  public abstract nodeUrl: string;\n\n  public abstract headers: object;\n\n  public abstract readonly baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  /**\n   * Returns the status of the paymaster service\n   *\n   * @returns If the paymaster service is correctly functioning, return true. Else, return false\n   */\n  public abstract isAvailable(): Promise<boolean>;\n\n  /**\n   * Receives the transaction the user wants to execute. Returns the typed data along with\n   * the estimated gas cost and the maximum gas cost suggested to ensure execution\n   *\n   * @param transaction Transaction to be executed by the paymaster\n   * @param parameters Execution parameters to be used when executing the transaction\n   * @returns The transaction data required for execution along with an estimation of the fee\n   */\n  public abstract buildTransaction(\n    transaction: UserTransaction,\n    parameters: ExecutionParameters\n  ): Promise<PreparedTransaction>;\n\n  /**\n   * Sends the signed typed data to the paymaster service for execution\n   *\n   * @param transaction Typed data build by calling paymaster_buildTransaction signed by the user to be executed by the paymaster service\n   * @param parameters Execution parameters to be used when executing the transaction\n   * @returns The hash of the transaction broadcasted by the paymaster and the tracking ID corresponding to the user `execute` request\n   */\n  public abstract executeTransaction(\n    transaction: ExecutableUserTransaction,\n    parameters: ExecutionParameters\n  ): Promise<RPC.PAYMASTER_API.ExecuteResponse>;\n\n  /**\n   * Get a list of the tokens that the paymaster supports, together with their prices in STRK\n   *\n   * @returns An array of token data\n   */\n  public abstract getSupportedTokens(): Promise<TokenData[]>;\n}\n","import { PaymasterRpc } from './rpc';\n\nexport * from './rpc';\nexport * from './interface';\n\nexport const defaultPaymaster = new PaymasterRpc({ default: true });\n","import { UDC } from '../global/constants';\nimport {\n  ValidateType,\n  type BigNumberish,\n  type DeployContractUDCResponse,\n  type InvokeTransactionReceiptResponse,\n  type UniversalDeployerContractPayload,\n} from '../types';\nimport { CallData } from '../utils/calldata';\nimport { starkCurve } from '../utils/ec';\nimport { calculateContractAddressFromHash } from '../utils/hash';\nimport { cleanHex, toCairoBool, toHex } from '../utils/num';\nimport { randomAddress } from '../utils/stark';\nimport { getCompiledCalldata } from '../utils/transaction/getCompiledCalldata';\nimport type { DeployerInterface } from './interface';\nimport type { DeployerCall } from './types/index.type';\n\nexport class Deployer implements DeployerInterface {\n  public readonly address: BigNumberish;\n\n  public readonly entryPoint: string;\n\n  constructor(address?: BigNumberish, entryPoint?: string) {\n    this.address = address ?? UDC.ADDRESS;\n    this.entryPoint = entryPoint ?? UDC.ENTRYPOINT;\n  }\n\n  public buildDeployerCall(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    address: string\n  ): DeployerCall {\n    const params = [].concat(payload as []).map((it) => {\n      const {\n        classHash,\n        salt,\n        unique = true, // not_from_zero on v.2.0.0 but same function. When false v.1 address != v.2 address\n        constructorCalldata = [],\n        abi,\n      } = it as UniversalDeployerContractPayload;\n\n      const compiledConstructorCallData = getCompiledCalldata(constructorCalldata, () => {\n        // compile with abi\n        if (abi) {\n          const calldataClass = new CallData(abi);\n          // Convert object based raw js arguments to ...args array\n          const rawArgs = Object.values(constructorCalldata);\n          calldataClass.validate(ValidateType.DEPLOY, 'constructor', rawArgs);\n          return calldataClass.compile('constructor', rawArgs);\n        }\n        // compile without abi\n        return CallData.compile(constructorCalldata);\n      });\n\n      const deploySalt = salt ?? randomAddress();\n\n      return {\n        call: {\n          contractAddress: toHex(this.address),\n          entrypoint: this.entryPoint,\n          calldata: [\n            classHash,\n            deploySalt,\n            toCairoBool(unique),\n            compiledConstructorCallData.length,\n            ...compiledConstructorCallData,\n          ],\n        },\n        address: calculateContractAddressFromHash(\n          unique ? starkCurve.pedersen(address, deploySalt) : deploySalt,\n          classHash,\n          compiledConstructorCallData,\n          unique ? this.address : 0\n        ),\n      };\n    });\n\n    return {\n      calls: params.map((it) => it.call),\n      addresses: params.map((it) => it.address),\n    };\n  }\n\n  public parseDeployerEvent(\n    txReceipt: InvokeTransactionReceiptResponse\n  ): DeployContractUDCResponse {\n    if (!txReceipt.events?.length) {\n      throw new Error('Deployer emitted event is empty');\n    }\n    const event = txReceipt.events.find(\n      (it: any) => cleanHex(it.from_address) === cleanHex(toHex(this.address))\n    ) || {\n      data: [],\n    };\n    return {\n      transaction_hash: txReceipt.transaction_hash,\n      contract_address: event.data[0],\n      address: event.data[0],\n      deployer: event.data[1],\n      unique: event.data[2],\n      classHash: event.data[3],\n      calldata_len: event.data[4],\n      calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n      salt: event.data[event.data.length - 1],\n    };\n  }\n}\n","import type {\n  BigNumberish,\n  DeployContractUDCResponse,\n  InvokeTransactionReceiptResponse,\n  UniversalDeployerContractPayload,\n} from '../types/index';\nimport type { DeployerCall } from './types/index.type';\n\nexport abstract class DeployerInterface {\n  /** address of the deployer contract */\n  abstract readonly address: BigNumberish;\n\n  /** ascii name of the function that deploy a contract */\n  abstract readonly entryPoint: string;\n\n  /**\n   * Build a Deployer Call with payload and address\n   * @param {UniversalDeployerContractPayload | UniversalDeployerContractPayload[]} payload the payload data for the deployer Call. Can be a single payload object or an array of payload objects.\n   * @param {string} address the address to be used in the deployer Call\n   * @returns {DeployerCall} an object with Calls & addresses\n   */\n  public abstract buildDeployerCall(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    address: string\n  ): DeployerCall;\n\n  /**\n   * Parse Transaction Receipt Event from a Deployer contract transaction and\n   * create DeployContractResponse compatible response with addition of the Deployer Event data\n   * @param {InvokeTransactionReceiptResponse} txReceipt Transaction receipt\n   * @param {DeployerDefinition} deployer Deployer contract definition\n   *\n   * @returns {DeployContractUDCResponse} parsed Deployer event data\n   */\n  public abstract parseDeployerEvent(\n    txReceipt: InvokeTransactionReceiptResponse\n  ): DeployContractUDCResponse;\n}\n","import { LegacyUDC, UDC } from '../global/constants';\nimport { Deployer } from './default';\n\nexport * from './default';\nexport * from './interface';\nexport const defaultDeployer = new Deployer(UDC.ADDRESS, UDC.ENTRYPOINT);\nexport const legacyDeployer = new Deployer(LegacyUDC.ADDRESS, LegacyUDC.ENTRYPOINT);\n","import { config } from '../global/config';\nimport {\n  OutsideExecutionCallerAny,\n  SNIP9_V1_INTERFACE_ID,\n  SNIP9_V2_INTERFACE_ID,\n  SYSTEM_MESSAGES,\n  ZERO,\n} from '../global/constants';\nimport { logger } from '../global/logger';\nimport { LibraryError, Provider } from '../provider';\nimport { BlockTag, ETransactionVersion, ETransactionVersion3 } from '../provider/types/spec.type';\nimport { Signer, type SignerInterface } from '../signer';\nimport {\n  // Runtime values\n  OutsideExecutionVersion,\n} from '../types';\nimport type {\n  AccountInvocations,\n  AccountInvocationsFactoryDetails,\n  AccountOptions,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  DeployTransactionReceiptResponse,\n  EstimateFeeResponseOverhead,\n  EstimateFeeBulk,\n  ExecutableUserTransaction,\n  ExecutionParameters,\n  Invocation,\n  Invocations,\n  InvocationsDetailsWithNonce,\n  InvocationsSignerDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  OutsideExecution,\n  OutsideExecutionOptions,\n  OutsideTransaction,\n  PaymasterDetails,\n  PaymasterFeeEstimate,\n  PreparedTransaction,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionOverheadResponse,\n  TypedData,\n  UniversalDeployerContractPayload,\n  UniversalDetails,\n  UserTransaction,\n  waitForTransactionOptions,\n  fastWaitForTransactionOptions,\n  fastExecuteResponse,\n} from '../types';\nimport { ETransactionType } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { calculateContractAddressFromHash } from '../utils/hash';\nimport { isHex, toBigInt, toHex } from '../utils/num';\nimport {\n  buildExecuteFromOutsideCall,\n  getOutsideCall,\n  getTypedData,\n} from '../utils/outsideExecution';\nimport { parseContract } from '../utils/provider';\nimport { supportsInterface } from '../utils/src5';\nimport {\n  randomAddress,\n  resourceBoundsToEstimateFeeResponse,\n  signatureToHexArray,\n  toFeeVersion,\n  toTransactionVersion,\n  v3Details,\n} from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction/transaction';\nimport { isString, isUndefined } from '../utils/typed';\nimport { getMessageHash } from '../utils/typedData';\nimport { type AccountInterface } from './interface';\nimport { defaultPaymaster, type PaymasterInterface, PaymasterRpc } from '../paymaster';\nimport { assertPaymasterTransactionSafety } from '../utils/paymaster';\nimport assert from '../utils/assert';\nimport { defaultDeployer, Deployer } from '../deployer';\nimport type { TipType } from '../provider/modules/tip';\nimport { RPC09 } from '../channel';\n\nexport class Account extends Provider implements AccountInterface {\n  public signer: SignerInterface;\n\n  public address: string;\n\n  public cairoVersion: CairoVersion;\n\n  readonly transactionVersion: typeof ETransactionVersion.V3;\n\n  public paymaster: PaymasterInterface;\n\n  public deployer: Deployer;\n\n  public defaultTipType: TipType;\n\n  constructor(options: AccountOptions) {\n    const {\n      provider,\n      address,\n      signer,\n      cairoVersion,\n      transactionVersion,\n      paymaster,\n      defaultTipType,\n    } = options;\n    super(provider);\n    this.address = address.toLowerCase();\n    this.signer = isString(signer) || signer instanceof Uint8Array ? new Signer(signer) : signer;\n\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString() as CairoVersion;\n    }\n    this.transactionVersion = transactionVersion ?? config.get('transactionVersion');\n    this.paymaster = paymaster ? new PaymasterRpc(paymaster) : defaultPaymaster;\n    this.deployer = options.deployer ?? defaultDeployer;\n    this.defaultTipType = defaultTipType ?? config.get('defaultTipType');\n\n    logger.debug('Account setup', {\n      transactionVersion: this.transactionVersion,\n      cairoVersion: this.cairoVersion,\n      channel: this.channel.id,\n    });\n  }\n\n  /** @deprecated @hidden */\n  // The deprecation tag is meant to discourage use, not to signal future removal\n  // it should only be removed if the relationship with the corresponding Provider.create(...) method changes\n  static async create(): Promise<never> {\n    throw new LibraryError('Not supported');\n  }\n\n  public async getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce> {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n\n  protected async getNonceSafe(nonce?: BigNumberish) {\n    // Patch DEPLOY_ACCOUNT: RPC getNonce for non-existing address will result in error\n    try {\n      return toBigInt(nonce ?? (await this.getNonce()));\n    } catch (error) {\n      return 0n;\n    }\n  }\n\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  public async getCairoVersion(classHash?: string) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash\n        ? await super.getContractVersion(undefined, classHash)\n        : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  } // TODO: TT Cairo version is still needed for invoke on existing contracts\n\n  public async estimateInvokeFee(\n    calls: AllowArray<Call>,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeResponseOverhead> {\n    // Transform all calls into a single invocation\n    const invocations = [{ type: ETransactionType.INVOKE, payload: [calls].flat() }];\n    const estimateBulk = await this.estimateFeeBulk(invocations, details);\n    return estimateBulk[0]; // Get the first (and only) estimate\n  }\n\n  public async estimateDeclareFee(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeResponseOverhead> {\n    assert(\n      isSierra(payload.contract),\n      'Declare fee estimation is not supported for Cairo0 contracts'\n    );\n    // Transform into invocations for bulk estimation\n    const invocations = [\n      { type: ETransactionType.DECLARE, payload: extractContractHashes(payload) },\n    ];\n    const estimateBulk = await this.estimateFeeBulk(invocations, details);\n    return estimateBulk[0]; // Get the first (and only) estimate\n  }\n\n  public async estimateAccountDeployFee(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeResponseOverhead> {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddressFinal =\n      contractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    // Transform into invocations for bulk estimation\n    const invocations = [\n      {\n        type: ETransactionType.DEPLOY_ACCOUNT,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress: contractAddressFinal,\n        },\n      },\n    ];\n    const estimateBulk = await this.estimateFeeBulk(invocations, details);\n    return estimateBulk[0]; // Get the first (and only) estimate\n  }\n\n  public async estimateDeployFee(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeResponseOverhead> {\n    const { calls } = this.deployer.buildDeployerCall(payload, this.address);\n    return this.estimateInvokeFee(calls, details);\n  }\n\n  public async estimateFeeBulk(\n    invocations: Invocations,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeBulk> {\n    if (!invocations.length) throw TypeError('Invocations should be non-empty array');\n    // skip estimating bounds if user provide bounds\n    if (details.resourceBounds)\n      return [resourceBoundsToEstimateFeeResponse(details.resourceBounds)];\n\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const detailsWithTip = await this.resolveDetailsWithTip(details);\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(detailsWithTip),\n      versions: [\n        toTransactionVersion(\n          toFeeVersion(this.transactionVersion) || ETransactionVersion3.F3,\n          version\n        ), // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n    });\n  }\n\n  public async simulateTransaction(\n    invocations: Invocations,\n    details: SimulateTransactionDetails = {}\n  ): Promise<SimulateTransactionOverheadResponse> {\n    if (!invocations.length) throw TypeError('Invocations should be non-empty array');\n    const {\n      nonce,\n      blockIdentifier,\n      skipValidate = true,\n      skipExecute,\n      version: providedVersion,\n    } = details;\n    const detailsWithTip = await this.resolveDetailsWithTip(details);\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(detailsWithTip),\n      versions: [this.resolveTransactionVersion(providedVersion)],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute,\n    });\n  }\n\n  public async execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<InvokeFunctionResponse> {\n    const calls = [transactions].flat();\n    const detailsWithTip = await this.resolveDetailsWithTip(transactionsDetail);\n\n    // Estimate resource bounds if not provided\n    const { resourceBounds: providedResourceBounds } = transactionsDetail;\n    let resourceBounds = providedResourceBounds;\n    if (!resourceBounds) {\n      const estimateResponse = await this.estimateInvokeFee(calls, detailsWithTip);\n      resourceBounds = estimateResponse.resourceBounds;\n    }\n\n    const accountInvocations = await this.accountInvocationsFactory(\n      [{ type: ETransactionType.INVOKE, payload: calls }],\n      {\n        ...v3Details(detailsWithTip),\n        resourceBounds,\n        versions: [this.resolveTransactionVersion(transactionsDetail.version)],\n        nonce: transactionsDetail.nonce,\n        skipValidate: false,\n      }\n    );\n\n    const invocation = accountInvocations[0];\n\n    return this.invokeFunction(\n      {\n        contractAddress: invocation.contractAddress,\n        calldata: invocation.calldata,\n        signature: invocation.signature,\n      },\n      {\n        ...v3Details(detailsWithTip),\n        resourceBounds: invocation.resourceBounds,\n        nonce: invocation.nonce,\n        version: invocation.version,\n      }\n    );\n  }\n\n  /**\n   * Execute one or multiple calls through the account contract,\n   * responding as soon as a new transaction is possible with the same account.\n   * Useful for gaming usage.\n   * - This method requires the provider to be initialized with `pre_confirmed` blockIdentifier option.\n   * - Rpc 0.9 minimum.\n   * - In a normal myAccount.execute() call, followed by myProvider.waitForTransaction(), you have an immediate access to the events and to the transaction report. Here, we are processing consecutive transactions faster, but events & transaction reports are not available immediately.\n   * - As a consequence of the previous point, do not use contract/account deployment with this method.\n   * @param {AllowArray<Call>} transactions - Single call or array of calls to execute\n   * @param {UniversalDetails} [transactionsDetail] - Transaction execution options\n   * @param {fastWaitForTransactionOptions} [waitDetail={retries: 50, retryInterval: 500}] - options to scan the network for the next possible transaction. `retries` is the number of times to retry, `retryInterval` is the time in ms between retries.\n   * @returns {Promise<fastExecuteResponse>} Response containing the transaction result and status for the next transaction. If `isReady` is true, you can execute the next transaction. If false, timeout has been reached before the next transaction was possible.\n   * @example\n   * ```typescript\n   * const myProvider = new RpcProvider({ nodeUrl: url, blockIdentifier: BlockTag.PRE_CONFIRMED });\n   * const myAccount = new Account({ provider: myProvider, address: accountAddress0, signer: privateKey0 });\n   * const resp = await myAccount.fastExecute(\n   *     call, { tip: recommendedTip},\n   *     { retries: 30, retryInterval: 500 });\n   * // if resp.isReady is true, you can launch immediately a new tx.\n   * ```\n   */\n  public async fastExecute(\n    transactions: AllowArray<Call>,\n    transactionsDetail: UniversalDetails = {},\n    waitDetail: fastWaitForTransactionOptions = {}\n  ): Promise<fastExecuteResponse> {\n    assert(\n      this.channel instanceof RPC09.RpcChannel,\n      'Wrong Rpc version in Provider. At least Rpc v0.9 required.'\n    );\n    assert(\n      this.channel.blockIdentifier === BlockTag.PRE_CONFIRMED,\n      'Provider needs to be initialized with `pre_confirmed` blockIdentifier option.'\n    );\n    const initNonce = BigInt(\n      transactionsDetail.nonce ??\n        (await this.getNonceForAddress(this.address, BlockTag.PRE_CONFIRMED))\n    );\n    const details = { ...transactionsDetail, nonce: initNonce };\n    const resultTx: InvokeFunctionResponse = await this.execute(transactions, details);\n    const resultWait = await this.fastWaitForTransaction(\n      resultTx.transaction_hash,\n      this.address,\n      initNonce,\n      waitDetail\n    );\n    return { txResult: resultTx, isReady: resultWait } as fastExecuteResponse;\n  }\n\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  public async declareIfNot(\n    payload: DeclareContractPayload,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: '',\n      class_hash: declareContractPayload.classHash,\n    };\n  }\n\n  public async declare(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    assert(isSierra(payload.contract), SYSTEM_MESSAGES.declareNonSierra);\n\n    const declareContractPayload = extractContractHashes(payload);\n    const detailsWithTip = await this.resolveDetailsWithTip(details);\n\n    // Estimate resource bounds if not provided\n    const { resourceBounds: providedResourceBounds } = details;\n    let resourceBounds = providedResourceBounds;\n    if (!resourceBounds) {\n      const estimateResponse = await this.estimateDeclareFee(payload, detailsWithTip);\n      resourceBounds = estimateResponse.resourceBounds;\n    }\n\n    const accountInvocations = await this.accountInvocationsFactory(\n      [{ type: ETransactionType.DECLARE, payload: declareContractPayload }],\n      {\n        ...v3Details(detailsWithTip),\n        resourceBounds,\n        versions: [this.resolveTransactionVersion(details.version)],\n        nonce: details.nonce,\n        skipValidate: false,\n      }\n    );\n\n    const declaration = accountInvocations[0];\n\n    return super.declareContract(\n      {\n        senderAddress: declaration.senderAddress,\n        signature: declaration.signature,\n        contract: declaration.contract,\n        compiledClassHash: declaration.compiledClassHash,\n      },\n      {\n        ...v3Details(detailsWithTip),\n        nonce: declaration.nonce,\n        resourceBounds: declaration.resourceBounds,\n        version: declaration.version,\n      }\n    );\n  }\n\n  public async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = this.deployer.buildDeployerCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, details);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  public async deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails & waitForTransactionOptions = {}\n  ): Promise<DeployContractUDCResponse> {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash, details);\n    return this.deployer.parseDeployerEvent(\n      txReceipt as unknown as DeployTransactionReceiptResponse\n    );\n  }\n\n  public async declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details: UniversalDetails & waitForTransactionOptions = {}\n  ): Promise<DeclareDeployUDCResponse> {\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== '') {\n      const tx = await this.waitForTransaction(declare.transaction_hash, details);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { ...payload, classHash: declare.class_hash },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n\n  public deploySelf = this.deployAccount;\n\n  public async deployAccount(\n    {\n      classHash,\n      constructorCalldata = [],\n      addressSalt = 0,\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeployContractResponse> {\n    const compiledCalldata = CallData.compile(constructorCalldata); // TODO: TT check if we should add abi here to safe compile\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const detailsWithTip = await this.resolveDetailsWithTip(details);\n\n    // Estimate resource bounds if not provided\n    const { resourceBounds: providedResourceBounds } = details;\n    let resourceBounds = providedResourceBounds;\n    if (!resourceBounds) {\n      const estimateResponse = await this.estimateAccountDeployFee(\n        {\n          classHash,\n          constructorCalldata,\n          addressSalt,\n          contractAddress,\n        },\n        detailsWithTip\n      );\n      resourceBounds = estimateResponse.resourceBounds;\n    }\n\n    const accountInvocations = await this.accountInvocationsFactory(\n      [\n        {\n          type: ETransactionType.DEPLOY_ACCOUNT,\n          payload: {\n            classHash,\n            constructorCalldata: compiledCalldata,\n            addressSalt,\n            contractAddress,\n          },\n        },\n      ],\n      {\n        ...v3Details(detailsWithTip),\n        resourceBounds,\n        versions: [this.resolveTransactionVersion(details.version)],\n        nonce: ZERO, // DEPLOY_ACCOUNT always uses nonce 0\n        skipValidate: false,\n      }\n    );\n\n    const deployment = accountInvocations[0];\n\n    return super.deployAccountContract(\n      {\n        classHash: deployment.classHash,\n        addressSalt: deployment.addressSalt,\n        constructorCalldata: deployment.constructorCalldata,\n        signature: deployment.signature,\n      },\n      {\n        ...v3Details(detailsWithTip),\n        nonce: deployment.nonce,\n        resourceBounds: deployment.resourceBounds,\n        version: deployment.version,\n      }\n    );\n  }\n\n  public async signMessage(typedData: TypedData): Promise<Signature> {\n    return this.signer.signMessage(typedData, this.address);\n  }\n\n  public async hashMessage(typedData: TypedData): Promise<string> {\n    return getMessageHash(typedData, this.address);\n  }\n\n  /**\n   * Verify if an account is compatible with SNIP-9 outside execution, and with which version of this standard.\n   * @returns {OutsideExecutionVersion} Not compatible, V1, V2.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Version();\n   * // result = \"V1\"\n   * ```\n   */\n  public async getSnip9Version(): Promise<OutsideExecutionVersion> {\n    if (await supportsInterface(this, this.address, SNIP9_V2_INTERFACE_ID)) {\n      return OutsideExecutionVersion.V2;\n    }\n    if (await supportsInterface(this, this.address, SNIP9_V1_INTERFACE_ID)) {\n      return OutsideExecutionVersion.V1;\n    }\n    // Account does not support either version 2 or version 1\n    return OutsideExecutionVersion.UNSUPPORTED;\n  }\n\n  /**\n   * Verify if a SNIP-9 nonce has not yet been used by the account.\n   * @param {BigNumberish} nonce SNIP-9 nonce to test.\n   * @returns  {boolean} true if SNIP-9 nonce not yet used.\n   * @example\n   * ```typescript\n   * const result = myAccount.isValidSnip9Nonce(1234);\n   * // result = true\n   * ```\n   */\n  public async isValidSnip9Nonce(nonce: BigNumberish): Promise<boolean> {\n    try {\n      const call: Call = {\n        contractAddress: this.address,\n        entrypoint: 'is_valid_outside_execution_nonce',\n        calldata: [toHex(nonce)],\n      };\n      const resp = await this.callContract(call);\n      return BigInt(resp[0]) !== 0n;\n    } catch (error) {\n      throw new Error(`Failed to check if nonce is valid: ${error}`);\n    }\n  }\n\n  /**\n   * Outside transaction needs a specific SNIP-9 nonce, that we get in this function.\n   * A SNIP-9 nonce can be any number not yet used ; no ordering is needed.\n   * @returns  {string} an Hex string of a SNIP-9 nonce.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Nonce();\n   * // result = \"0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55\"\n   * ```\n   */\n  public async getSnip9Nonce(): Promise<string> {\n    const nonce = randomAddress();\n    const isValidNonce = await this.isValidSnip9Nonce(nonce);\n    if (!isValidNonce) {\n      return this.getSnip9Nonce();\n    }\n    return nonce;\n  }\n\n  /**\n   * Creates an object containing transaction(s) that can be executed by an other account with` Account.executeFromOutside()`, called Outside Transaction.\n   * @param {OutsideExecutionOptions} options Parameters of the transaction(s).\n   * @param {AllowArray<Call>} calls Transaction(s) to execute.\n   * @param {OutsideExecutionVersion} [version] SNIP-9 version of the Account that creates the outside transaction.\n   * @param {BigNumberish} [nonce] Outside Nonce.\n   * @returns {OutsideTransaction} and object that can be used in `Account.executeFromOutside()`\n   * @example\n   * ```typescript\n   * const now_seconds = Math.floor(Date.now() / 1000);\n   * const callOptions: OutsideExecutionOptions = {\n      caller: executorAccount.address, execute_after: now_seconds - 3600, execute_before: now_seconds + 3600 };\n   * const call1: Call = { contractAddress: ethAddress, entrypoint: 'transfer', calldata: {\n   *     recipient: recipientAccount.address, amount: cairo.uint256(100) } };\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call3);\n   * // result = {\n   * // outsideExecution: {\n   * // caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n   * // nonce: '0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55',\n   * // execute_after: 1723650229, execute_before: 1723704229, calls: [[Object]] },\n   * // signature: Signature {\n   * // r: 67518627037915514985321278857825384106482999609634873287406612756843916814n,\n   * // s: 737198738569840639192844101690009498983611654458636624293579534560862067709n, recovery: 0 },\n   * // signerAddress: '0x655f8fd7c4013c07cf12a92184aa6c314d181443913e21f7e209a18f0c78492',\n   * // version: '2'\n   * // }\n   * ```\n   */\n  public async getOutsideTransaction(\n    options: OutsideExecutionOptions,\n    calls: AllowArray<Call>,\n    version?: OutsideExecutionVersion,\n    nonce?: BigNumberish\n  ): Promise<OutsideTransaction> {\n    if (!isHex(options.caller) && options.caller !== 'ANY_CALLER') {\n      throw new Error(`The caller ${options.caller} is not valid.`);\n    }\n    const codedCaller: string = isHex(options.caller) ? options.caller : OutsideExecutionCallerAny;\n    const myCalls: Call[] = [calls].flat();\n    const supportedVersion = version ?? (await this.getSnip9Version());\n    if (!supportedVersion) {\n      throw new Error('This account is not handling outside transactions.');\n    }\n    const myNonce = nonce ? toHex(nonce) : await this.getSnip9Nonce();\n    const message = getTypedData(\n      await this.getChainId(),\n      {\n        caller: codedCaller,\n        execute_after: options.execute_after,\n        execute_before: options.execute_before,\n      },\n      myNonce,\n      myCalls,\n      supportedVersion\n    );\n    const sign: Signature = await this.signMessage(message);\n    const toExecute: OutsideExecution = {\n      caller: codedCaller,\n      nonce: myNonce,\n      execute_after: options.execute_after,\n      execute_before: options.execute_before,\n      calls: myCalls.map(getOutsideCall),\n    };\n    return {\n      outsideExecution: toExecute,\n      signature: sign,\n      signerAddress: this.address,\n      version: supportedVersion,\n    };\n  }\n\n  /**\n   * An account B executes a transaction that has been signed by an account A.\n   * Fees are paid by B.\n   * @param {AllowArray<OutsideTransaction>} outsideTransaction the signed transaction generated by `Account.getOutsideTransaction()`.\n   * @param {UniversalDetails} [opts] same options than `Account.execute()`.\n   * @returns {InvokeFunctionResponse} same response than `Account.execute()`.\n   * @example\n   * ```typescript\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call1);\n   * const outsideTransaction2: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions4, call4);\n   * const result = await myAccount.executeFromOutside([\n      outsideTransaction1,\n      outsideTransaction2,\n    ]);\n   * // result = { transaction_hash: '0x11233...`}\n   * ```\n   */\n  public async executeFromOutside(\n    outsideTransaction: AllowArray<OutsideTransaction>,\n    opts?: UniversalDetails\n  ): Promise<InvokeFunctionResponse> {\n    const multiCall = buildExecuteFromOutsideCall(outsideTransaction);\n    return this.execute(multiCall, opts);\n  }\n\n  /*\n   * Support methods\n   */\n\n  /**\n   * Helper method to resolve details with tip estimation\n   * @private\n   */\n  private async resolveDetailsWithTip(\n    details: UniversalDetails\n  ): Promise<UniversalDetails & { tip: BigNumberish }> {\n    return {\n      ...details,\n      tip: details.tip ?? (await this.getEstimateTip())[this.defaultTipType],\n    };\n  }\n\n  /**\n   * Helper method to resolve transaction version\n   * @private\n   */\n  private resolveTransactionVersion(providedVersion?: BigNumberish) {\n    return toTransactionVersion(\n      this.transactionVersion || ETransactionVersion3.V3,\n      providedVersion\n    );\n  }\n\n  public async buildInvocation(\n    call: Array<Call>,\n    details: InvocationsSignerDetails\n  ): Promise<Invocation> {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature,\n    };\n  }\n\n  public async buildDeclarePayload(\n    payload: DeclareContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeclareContractTransaction> {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n\n    assert(\n      !isUndefined(compiledClassHash) &&\n        (details.version === ETransactionVersion3.F3 ||\n          details.version === ETransactionVersion3.V3),\n      'V3 Transaction work with Cairo1 Contracts and require compiledClassHash'\n    );\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeclareTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          compiledClassHash,\n          senderAddress: details.walletAddress,\n        })\n      : [];\n\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash,\n    };\n  }\n\n  public async buildAccountDeployPayload(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeployAccountContractTransaction> {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeployAccountTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          contractAddress,\n          addressSalt,\n          constructorCalldata: compiledCalldata,\n        })\n      : [];\n\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature,\n    };\n  }\n\n  /**\n   * Build account invocations with proper typing based on transaction type\n   * @private\n   */\n  public async accountInvocationsFactory(\n    invocations: [{ type: typeof ETransactionType.INVOKE; payload: AllowArray<Call> }],\n    details: AccountInvocationsFactoryDetails\n  ): Promise<\n    [({ type: typeof ETransactionType.INVOKE } & Invocation) & InvocationsDetailsWithNonce]\n  >;\n  public async accountInvocationsFactory(\n    invocations: [{ type: typeof ETransactionType.DECLARE; payload: DeclareContractPayload }],\n    details: AccountInvocationsFactoryDetails\n  ): Promise<\n    [\n      ({ type: typeof ETransactionType.DECLARE } & DeclareContractTransaction) &\n        InvocationsDetailsWithNonce,\n    ]\n  >;\n  public async accountInvocationsFactory(\n    invocations: [\n      { type: typeof ETransactionType.DEPLOY_ACCOUNT; payload: DeployAccountContractPayload },\n    ],\n    details: AccountInvocationsFactoryDetails\n  ): Promise<\n    [\n      ({ type: typeof ETransactionType.DEPLOY_ACCOUNT } & DeployAccountContractTransaction) &\n        InvocationsDetailsWithNonce,\n    ]\n  >;\n  public async accountInvocationsFactory(\n    invocations: Invocations,\n    details: AccountInvocationsFactoryDetails\n  ): Promise<AccountInvocations>;\n  public async accountInvocationsFactory(\n    invocations: Invocations,\n    details: AccountInvocationsFactoryDetails\n  ): Promise<AccountInvocations> {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n\n    // BULK ACTION FROM NEW ACCOUNT START WITH DEPLOY_ACCOUNT\n    const tx0Payload: any = 'payload' in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion =\n      invocations[0].type === ETransactionType.DEPLOY_ACCOUNT\n        ? await this.getCairoVersion(tx0Payload.classHash)\n        : await this.getCairoVersion();\n\n    return Promise.all(\n      ([] as Invocations).concat(invocations).map(async (transaction, index: number) => {\n        const txPayload: any = 'payload' in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          chainId,\n          cairoVersion,\n          version: versions[0],\n          skipValidate,\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: versions[0],\n        };\n\n        if (transaction.type === ETransactionType.INVOKE) {\n          const payload = await this.buildInvocation(\n            ([] as Call[]).concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        if (transaction.type === ETransactionType.DEPLOY) {\n          const { calls } = this.deployer.buildDeployerCall(txPayload, this.address);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n            type: ETransactionType.INVOKE,\n          };\n        }\n        if (transaction.type === ETransactionType.DECLARE) {\n          assert(\n            isSierra(txPayload.contract),\n            'Declare fee estimation is not supported for Cairo0 contracts'\n          );\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        if (transaction.type === ETransactionType.DEPLOY_ACCOUNT) {\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    ) as Promise<AccountInvocations>;\n  }\n\n  /*\n   * SNIP-29 Paymaster\n   */\n\n  public async buildPaymasterTransaction(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails\n  ): Promise<PreparedTransaction> {\n    // If the account isn't deployed, we can't call the supportsInterface function to know if the account is compatible with SNIP-9\n    if (!paymasterDetails.deploymentData) {\n      const snip9Version = await this.getSnip9Version();\n      if (snip9Version === OutsideExecutionVersion.UNSUPPORTED) {\n        throw Error('Account is not compatible with SNIP-9');\n      }\n    }\n    const parameters: ExecutionParameters = {\n      version: '0x1',\n      feeMode: paymasterDetails.feeMode,\n      timeBounds: paymasterDetails.timeBounds,\n    };\n    let transaction: UserTransaction;\n    if (paymasterDetails.deploymentData) {\n      if (calls.length > 0) {\n        transaction = {\n          type: 'deploy_and_invoke',\n          invoke: { userAddress: this.address, calls },\n          deployment: paymasterDetails.deploymentData,\n        };\n      } else {\n        transaction = {\n          type: 'deploy',\n          deployment: paymasterDetails.deploymentData,\n        };\n      }\n    } else {\n      transaction = {\n        type: 'invoke',\n        invoke: { userAddress: this.address, calls },\n      };\n    }\n    return this.paymaster.buildTransaction(transaction, parameters);\n  }\n\n  public async estimatePaymasterTransactionFee(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails\n  ): Promise<PaymasterFeeEstimate> {\n    const preparedTransaction = await this.buildPaymasterTransaction(calls, paymasterDetails);\n    return preparedTransaction.fee;\n  }\n\n  public async preparePaymasterTransaction(\n    preparedTransaction: PreparedTransaction\n  ): Promise<ExecutableUserTransaction> {\n    let transaction: ExecutableUserTransaction;\n    switch (preparedTransaction.type) {\n      case 'deploy_and_invoke': {\n        const signature = await this.signMessage(preparedTransaction.typed_data);\n        transaction = {\n          type: 'deploy_and_invoke',\n          invoke: {\n            userAddress: this.address,\n            typedData: preparedTransaction.typed_data,\n            signature: signatureToHexArray(signature),\n          },\n          deployment: preparedTransaction.deployment,\n        };\n        break;\n      }\n      case 'invoke': {\n        const signature = await this.signMessage(preparedTransaction.typed_data);\n        transaction = {\n          type: 'invoke',\n          invoke: {\n            userAddress: this.address,\n            typedData: preparedTransaction.typed_data,\n            signature: signatureToHexArray(signature),\n          },\n        };\n        break;\n      }\n      case 'deploy': {\n        transaction = {\n          type: 'deploy',\n          deployment: preparedTransaction.deployment,\n        };\n        break;\n      }\n      default:\n        throw Error('Invalid transaction type');\n    }\n    return transaction;\n  }\n\n  public async executePaymasterTransaction(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails,\n    maxFeeInGasToken?: BigNumberish\n  ): Promise<InvokeFunctionResponse> {\n    // Build the transaction\n    const preparedTransaction = await this.buildPaymasterTransaction(calls, paymasterDetails);\n\n    // Check the transaction is safe\n    // Check gas fee value & gas token address\n    // Check that provided calls and builded calls are strictly equal\n    assertPaymasterTransactionSafety(\n      preparedTransaction,\n      calls,\n      paymasterDetails,\n      maxFeeInGasToken\n    );\n\n    // Prepare the transaction, tx is safe here\n    const transaction: ExecutableUserTransaction =\n      await this.preparePaymasterTransaction(preparedTransaction);\n\n    // Execute the transaction\n    return this.paymaster\n      .executeTransaction(transaction, preparedTransaction.parameters)\n      .then((response) => ({ transaction_hash: response.transaction_hash }));\n  }\n\n  /*\n   * External methods\n   */\n\n  /**\n   * Get the Starknet ID for an address\n   * @param address - The address to get the Starknet ID for\n   * @param StarknetIdContract - The Starknet ID contract address (optional)\n   * @returns The Starknet ID for the address\n   */\n  public async getStarkName(\n    address: BigNumberish = this.address, // default to the wallet address\n    StarknetIdContract?: string\n  ): Promise<string> {\n    return super.getStarkName(address, StarknetIdContract);\n  }\n}\n","import { ProviderInterface } from '../provider/interface';\nimport type { SignerInterface } from '../signer';\nimport type { DeployerInterface } from '../deployer/index';\nimport type {\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeployAccountContractPayload,\n  DeployContractResponse,\n  Invocations,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n  Nonce,\n  Signature,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types/index';\nimport type {\n  DeclareDeployUDCResponse,\n  MultiDeployContractResponse,\n  PaymasterDetails,\n  UniversalDetails,\n} from './types/index.type';\nimport type {\n  EstimateFeeResponseBulkOverhead,\n  EstimateFeeResponseOverhead,\n} from '../provider/types/index.type';\nimport type { PaymasterFeeEstimate, PreparedTransaction } from '../paymaster/types/index.type';\nimport type { DeployContractUDCResponse } from '../deployer/types/index.type';\n\n/**\n * Interface for interacting with Starknet account contracts\n *\n * Extends ProviderInterface to provide account-specific functionality including:\n * - Transaction execution and signing\n * - Fee estimation for various transaction types\n * - Contract deployment through UDC (Universal Deployer Contract)\n * - Paymaster support for sponsored transactions\n * - EIP-712 message signing\n *\n * @remarks\n * Implementations of this interface typically handle the complexities of:\n * - Nonce management\n * - Transaction signing with the account's private key\n * - Interaction with the account contract's __execute__ entrypoint\n */\nexport abstract class AccountInterface extends ProviderInterface {\n  /**\n   * The address of the account contract on Starknet\n   */\n  public abstract address: string;\n\n  /**\n   * Signer instance for signing transactions and messages\n   */\n  public abstract signer: SignerInterface;\n\n  /**\n   * Cairo version of the account contract implementation\n   */\n  public abstract cairoVersion: CairoVersion;\n\n  /**\n   * Optional deployer instance for custom contract deployment logic\n   * @default Uses default UDC (Universal Deployer Contract) if not specified\n   */\n  public abstract deployer?: DeployerInterface;\n\n  /**\n   * Estimate fee for executing an INVOKE transaction on Starknet\n   *\n   * @param calls - Single call or array of calls to estimate fees for\n   * @param calls.contractAddress - The address of the contract to invoke\n   * @param calls.entrypoint - The function selector of the contract method\n   * @param calls.calldata - The serialized function parameters (defaults to [])\n   *\n   * @param estimateFeeDetails - Optional details for fee estimation\n   * @param estimateFeeDetails.blockIdentifier - Block to estimate against\n   * @param estimateFeeDetails.nonce - Account nonce (defaults to current nonce)\n   * @param estimateFeeDetails.skipValidate - Skip account validation (default: true)\n   * @param estimateFeeDetails.tip - Priority fee tip in fri/wei for faster inclusion\n   * @param estimateFeeDetails.accountDeploymentData - Include account deployment\n   * @param estimateFeeDetails.paymasterData - Paymaster sponsorship data\n   * @param estimateFeeDetails.nonceDataAvailabilityMode - DA mode for nonce\n   * @param estimateFeeDetails.feeDataAvailabilityMode - DA mode for fee\n   * @param estimateFeeDetails.version - Transaction version (v3 uses fri, v1/v2 use wei)\n   * @param estimateFeeDetails.resourceBounds - Resource limits for v3 transactions\n   *\n   * @returns Fee estimation including overall_fee and resourceBounds\n   * @example\n   * ```typescript\n   * const fee = await account.estimateInvokeFee({\n   *   contractAddress: '0x123...',\n   *   entrypoint: 'transfer',\n   *   calldata: [recipient, amount]\n   * });\n   * ```\n   */\n  public abstract estimateInvokeFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails?: UniversalDetails\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimate fee for executing a DECLARE transaction on Starknet\n   *\n   * @param contractPayload - Contract declaration payload\n   * @param contractPayload.contract - Compiled contract (Sierra JSON)\n   * @param contractPayload.casm - Compiled Cairo assembly (required for Cairo 1)\n   * @param contractPayload.classHash - Pre-computed class hash (optional optimization)\n   * @param contractPayload.compiledClassHash - Pre-computed CASM hash (alternative to casm)\n   *\n   * @param estimateFeeDetails - Optional details for fee estimation\n   * @param estimateFeeDetails.blockIdentifier - Block to estimate against\n   * @param estimateFeeDetails.nonce - Account nonce (defaults to current nonce)\n   * @param estimateFeeDetails.skipValidate - Skip account validation (default: true)\n   * @param estimateFeeDetails.tip - Priority fee tip for faster inclusion\n   * @param estimateFeeDetails.version - Transaction version (v3 uses fri, v1/v2 use wei)\n   *\n   * @returns Fee estimation including overall_fee and resourceBounds\n   * @example\n   * ```typescript\n   * const fee = await account.estimateDeclareFee({\n   *   contract: compiledContract,\n   *   casm: compiledCasm\n   * });\n   * ```\n   */\n  public abstract estimateDeclareFee(\n    contractPayload: DeclareContractPayload,\n    estimateFeeDetails?: UniversalDetails\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimate fee for executing a DEPLOY_ACCOUNT transaction on Starknet\n   *\n   * @param contractPayload - Account deployment payload\n   * @param contractPayload.classHash - Class hash of the account contract\n   * @param contractPayload.constructorCalldata - Constructor parameters\n   * @param contractPayload.contractAddress - Pre-computed account address\n   * @param contractPayload.addressSalt - Salt for address generation\n   *\n   * @param estimateFeeDetails - Optional details for fee estimation\n   * @inheritdoc estimateInvokeFee\n   *\n   * @returns Fee estimation including overall_fee and resourceBounds\n   * @example\n   * ```typescript\n   * const fee = await account.estimateAccountDeployFee({\n   *   classHash: accountClassHash,\n   *   constructorCalldata: { publicKey },\n   *   addressSalt: publicKey\n   * });\n   * ```\n   */\n  public abstract estimateAccountDeployFee(\n    contractPayload: DeployAccountContractPayload,\n    estimateFeeDetails?: UniversalDetails\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimate fee for deploying contract(s) through the Universal Deployer Contract (UDC)\n   *\n   * @param deployContractPayload - Single or array of deployment payloads\n   * @param deployContractPayload.classHash - Class hash of contract to deploy\n   * @param deployContractPayload.salt - Deployment salt (optional)\n   * @param deployContractPayload.unique - Ensure unique deployment address\n   * @param deployContractPayload.constructorCalldata - Constructor parameters\n   *\n   * @param estimateFeeDetails - Optional details for fee estimation\n   * @inheritdoc estimateInvokeFee\n   *\n   * @returns Fee estimation for the deployment transaction\n   * @example\n   * ```typescript\n   * const fee = await account.estimateDeployFee({\n   *   classHash: contractClassHash,\n   *   constructorCalldata: [param1, param2],\n   *   unique: true\n   * });\n   * ```\n   */\n  public abstract estimateDeployFee(\n    deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    estimateFeeDetails?: UniversalDetails\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Estimate fees for executing multiple transactions in a single request\n   *\n   * @param invocations - Array of transactions to estimate\n   * @param invocations.type - Transaction type: DECLARE, DEPLOY, INVOKE, DEPLOY_ACCOUNT\n   * @param invocations.payload - Transaction-specific payload\n   *\n   * @param details - Optional details for fee estimation\n   * @inheritdoc estimateInvokeFee\n   *\n   * @returns Array of fee estimations for each transaction\n   * @example\n   * ```typescript\n   * const fees = await account.estimateFeeBulk([\n   *   { type: 'INVOKE', payload: { contractAddress, entrypoint, calldata } },\n   *   { type: 'DECLARE', payload: { contract, casm } }\n   * ]);\n   * ```\n   */\n  public abstract estimateFeeBulk(\n    invocations: Invocations,\n    details?: UniversalDetails\n  ): Promise<EstimateFeeResponseBulkOverhead>;\n\n  /**\n   * Execute one or multiple calls through the account contract\n   *\n   * @param transactions - Single call or array of calls to execute\n   * @param transactions.contractAddress - Target contract address\n   * @param transactions.entrypoint - Function to invoke on the contract\n   * @param transactions.calldata - Function parameters\n   *\n   * @param transactionsDetail - Transaction execution options\n   * @param transactionsDetail.nonce - Override account nonce\n   * @param transactionsDetail.maxFee - Maximum fee for v1/v2 transactions\n   * @param transactionsDetail.resourceBounds - Resource limits for v3 transactions\n   * @param transactionsDetail.tip - Priority fee tip\n   * @param transactionsDetail.version - Force specific transaction version\n   *\n   * @returns Transaction hash and response\n   * @example\n   * ```typescript\n   * const result = await account.execute([\n   *   { contractAddress: token, entrypoint: 'transfer', calldata: [to, amount] },\n   *   { contractAddress: nft, entrypoint: 'mint', calldata: [recipient] }\n   * ]);\n   * ```\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Estimate fees for a paymaster-sponsored transaction\n   *\n   * @param calls - Array of calls to be sponsored\n   * @param calls.contractAddress - Target contract address\n   * @param calls.entrypoint - Function to invoke\n   * @param calls.calldata - Function parameters\n   *\n   * @param paymasterDetails - Paymaster configuration\n   * @param paymasterDetails.feeMode - Sponsorship mode: 'sponsored' or gas token\n   * @param paymasterDetails.deploymentData - Account deployment data if needed\n   * @param paymasterDetails.timeBounds - Valid execution time window\n   *\n   * @returns Fee estimates in both STRK and gas token\n   * @example\n   * ```typescript\n   * const fees = await account.estimatePaymasterTransactionFee(\n   *   [{ contractAddress, entrypoint, calldata }],\n   *   { feeMode: { mode: 'sponsored' } }\n   * );\n   * ```\n   */\n  public abstract estimatePaymasterTransactionFee(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails\n  ): Promise<PaymasterFeeEstimate>;\n\n  /**\n   * Build a transaction for paymaster execution\n   *\n   * @param calls - Array of calls to be sponsored\n   * @param paymasterDetails - Paymaster configuration\n   * @inheritdoc estimatePaymasterTransactionFee\n   *\n   * @returns Prepared transaction with typed data for signing\n   * @example\n   * ```typescript\n   * const prepared = await account.buildPaymasterTransaction(\n   *   calls,\n   *   { feeMode: { mode: 'default', gasToken: ETH_ADDRESS } }\n   * );\n   * ```\n   */\n  public abstract buildPaymasterTransaction(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails\n  ): Promise<PreparedTransaction>;\n\n  /**\n   * Execute a paymaster-sponsored transaction\n   *\n   * @param calls - Array of calls to execute\n   * @param paymasterDetails - Paymaster configuration\n   * @param paymasterDetails.feeMode - 'sponsored' or gas token payment\n   * @param paymasterDetails.deploymentData - Deploy account if needed\n   * @param paymasterDetails.timeBounds - Execution validity window (UNIX timestamps)\n   *\n   * @param maxFeeInGasToken - Maximum acceptable fee in gas token\n   *\n   * @returns Transaction hash if successful\n   * @throws {Error} If gas token price exceeds maxFeeInGasToken\n   * @throws {Error} If transaction parameters are modified by paymaster\n   * @example\n   * ```typescript\n   * const txHash = await account.executePaymasterTransaction(\n   *   calls,\n   *   { feeMode: { mode: 'sponsored' }, timeBounds: { executeBefore: Date.now()/1000 + 3600 } },\n   *   maxFeeETH\n   * );\n   * ```\n   */\n  public abstract executePaymasterTransaction(\n    calls: Call[],\n    paymasterDetails: PaymasterDetails,\n    maxFeeInGasToken?: BigNumberish\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declare a contract class on Starknet\n   *\n   * @param contractPayload - Contract declaration payload\n   * @param contractPayload.contract - Compiled Sierra contract\n   * @param contractPayload.classHash - Pre-computed class hash (optional)\n   * @param contractPayload.casm - Compiled CASM (required for Cairo 1)\n   * @param contractPayload.compiledClassHash - Pre-computed CASM hash\n   *\n   * @param transactionsDetail - Transaction execution options\n   * @inheritdoc execute\n   *\n   * @returns Declaration transaction hash and class hash\n   * @example\n   * ```typescript\n   * const declareResult = await account.declare({\n   *   contract: compiledSierra,\n   *   casm: compiledCasm\n   * });\n   * ```\n   */\n  public abstract declare(\n    contractPayload: DeclareContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Deploy contract(s) using the Universal Deployer Contract (UDC)\n   *\n   * @param payload - Single or multiple deployment configurations\n   * @param payload.classHash - Class hash of declared contract\n   * @param payload.constructorCalldata - Constructor parameters\n   * @param payload.salt - Deployment salt (random if not specified)\n   * @param payload.unique - Modify salt for unique address (default: true)\n   *\n   * @param details - Transaction execution options\n   * @inheritdoc execute\n   *\n   * @returns Deployed contract addresses and transaction hash\n   * @example\n   * ```typescript\n   * const deployment = await account.deploy([\n   *   { classHash: erc20ClassHash, constructorCalldata: [name, symbol] },\n   *   { classHash: nftClassHash, unique: true }\n   * ]);\n   * ```\n   */\n  public abstract deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<MultiDeployContractResponse>;\n\n  /**\n   * Deploy and wait for a contract deployment to complete\n   *\n   * @param payload - Deployment configuration(s)\n   * @inheritdoc deploy\n   *\n   * @param details - Transaction execution options\n   * @inheritdoc execute\n   *\n   * @returns Deployment result with contract address and UDC event details\n   * @remarks\n   * This method waits for transaction confirmation before returning\n   * @example\n   * ```typescript\n   * const result = await account.deployContract({\n   *   classHash: contractClassHash,\n   *   constructorCalldata: params\n   * });\n   * console.log('Deployed at:', result.address);\n   * ```\n   */\n  public abstract deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<DeployContractUDCResponse>;\n\n  /**\n   * Declare and deploy a contract in a single method\n   *\n   * @param payload - Combined declare and deploy configuration\n   * @param payload.contract - Compiled Sierra contract\n   * @param payload.casm - Compiled CASM (required for Cairo 1)\n   * @param payload.compiledClassHash - Pre-computed CASM hash\n   * @param payload.classHash - Pre-computed class hash\n   * @param payload.constructorCalldata - Constructor parameters\n   * @param payload.salt - Deployment salt\n   * @param payload.unique - Ensure unique deployment address\n   *\n   * @param details - Transaction execution options\n   * @inheritdoc execute\n   *\n   * @returns Declaration and deployment results\n   * @remarks\n   * - Automatically skips declaration if contract is already declared\n   * - Waits for both transactions to complete\n   * - Does not support batch operations\n   * @example\n   * ```typescript\n   * const result = await account.declareAndDeploy({\n   *   contract: compiledContract,\n   *   casm: compiledCasm,\n   *   constructorCalldata: [param1, param2]\n   * });\n   * ```\n   */\n  public abstract declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details?: InvocationsDetails\n  ): Promise<DeclareDeployUDCResponse>;\n\n  /**\n   * Deploy the account contract itself on Starknet\n   *\n   * @param contractPayload - Account deployment configuration\n   * @param contractPayload.classHash - Account contract class hash\n   * @param contractPayload.constructorCalldata - Constructor parameters\n   * @param contractPayload.addressSalt - Salt for address generation\n   * @param contractPayload.contractAddress - Pre-computed address\n   *\n   * @param transactionsDetail - Transaction execution options\n   * @inheritdoc execute\n   *\n   * @returns Deployment transaction hash and contract address\n   * @remarks\n   * Used for deploying the account contract when using a pre-funded address\n   * @example\n   * ```typescript\n   * const deployment = await account.deployAccount({\n   *   classHash: accountClassHash,\n   *   constructorCalldata: { publicKey: pubKey },\n   *   addressSalt: pubKey\n   * });\n   * ```\n   */\n  public abstract deployAccount(\n    contractPayload: DeployAccountContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Sign a typed data message for off-chain verification\n   *\n   * @param typedData - EIP-712 style typed data structure\n   * @returns Signature array [r, s]\n   * @remarks\n   * - Includes domain separation to prevent signature reuse\n   * - Compatible with Starknet's signature verification\n   * - Cannot be used to sign transactions\n   * @example\n   * ```typescript\n   * const signature = await account.signMessage({\n   *   domain: { name: 'MyDapp', chainId: 'SN_MAIN' },\n   *   types: { ... },\n   *   primaryType: 'Message',\n   *   message: { content: 'Hello Starknet!' }\n   * });\n   * ```\n   */\n  public abstract signMessage(typedData: TypedData): Promise<Signature>;\n\n  /**\n   * Hash a typed data message using Pedersen hash\n   *\n   * @param typedData - EIP-712 style typed data structure\n   * @returns Message hash as hex string\n   * @remarks\n   * - Uses Pedersen hash function (not Keccak)\n   * - Includes domain separation\n   * - Result can be used for signature verification\n   * @example\n   * ```typescript\n   * const messageHash = await account.hashMessage(typedData);\n   * ```\n   */\n  public abstract hashMessage(typedData: TypedData): Promise<string>;\n\n  /**\n   * Get the current nonce of the account\n   *\n   * @param blockIdentifier - Block to query nonce at (default: 'pending')\n   * @returns Account nonce as hex string\n   * @example\n   * ```typescript\n   * const nonce = await account.getNonce();\n   * const historicalNonce = await account.getNonce('latest');\n   * ```\n   */\n  public abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;\n\n  /**\n   * Declare a contract class if not already declared\n   *\n   * @param contractPayload - Contract declaration payload\n   * @param transactionsDetail - Transaction execution options\n   * @returns Declaration result (with empty transaction_hash if already declared)\n   * @example\n   * ```typescript\n   * const result = await account.declareIfNot({\n   *   contract: compiledContract,\n   *   casm: compiledCasm\n   * });\n   * ```\n   */\n  public abstract declareIfNot(\n    contractPayload: DeclareContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeclareContractResponse>;\n}\n","import {\n  Address,\n  AddStarknetChainParameters,\n  ChainId,\n  AccountDeploymentData,\n  AddInvokeTransactionParameters,\n  AddInvokeTransactionResult,\n  AddDeclareTransactionParameters,\n  AddDeclareTransactionResult,\n  Permission,\n  StarknetWindowObject,\n  WatchAssetParameters,\n  TypedData,\n  Signature,\n  SpecVersion,\n  AccountChangeEventHandler,\n  NetworkChangeEventHandler,\n} from '../types/api';\n\n/**\n * Request Permission for wallet account, return addresses that are allowed by user\n * @param {boolean} [silent_mode=false] false: request user interaction allowance. true: return only pre-allowed\n * @returns allowed accounts addresses\n */\nexport function requestAccounts(\n  swo: StarknetWindowObject,\n  silent_mode: boolean = false\n): Promise<Address[]> {\n  return swo.request({\n    type: 'wallet_requestAccounts',\n    params: { silent_mode },\n  });\n}\n\n/**\n * Request Permission for wallet account\n * @returns allowed accounts addresses\n */\nexport function getPermissions(swo: StarknetWindowObject): Promise<Permission[]> {\n  return swo.request({ type: 'wallet_getPermissions' });\n}\n\n/**\n * Request adding ERC20 Token to Wallet List\n * @param asset WatchAssetParameters\n * @returns boolean\n */\nexport function watchAsset(\n  swo: StarknetWindowObject,\n  asset: WatchAssetParameters\n): Promise<boolean> {\n  return swo.request({ type: 'wallet_watchAsset', params: asset });\n}\n\n/**\n * Request adding custom Starknet chain\n * @param chain AddStarknetChainParameters\n * @returns boolean\n */\nexport function addStarknetChain(\n  swo: StarknetWindowObject,\n  chain: AddStarknetChainParameters\n): Promise<boolean> {\n  // TODO: This should set custom RPC endpoint ?\n  return swo.request({ type: 'wallet_addStarknetChain', params: chain });\n}\n\n/**\n * Request Wallet Network change\n * @param chainId StarknetChainId\n * @returns boolean\n */\nexport function switchStarknetChain(swo: StarknetWindowObject, chainId: ChainId): Promise<boolean> {\n  return swo.request({\n    type: 'wallet_switchStarknetChain',\n    params: { chainId },\n  });\n}\n\n/**\n * Request the current chain ID from the wallet.\n * @returns The current Starknet chain ID.\n */\nexport function requestChainId(swo: StarknetWindowObject): Promise<ChainId> {\n  return swo.request({ type: 'wallet_requestChainId' });\n}\n\n/**\n * Get deployment data for a contract.\n * @returns The deployment data result.\n */\nexport function deploymentData(swo: StarknetWindowObject): Promise<AccountDeploymentData> {\n  return swo.request({ type: 'wallet_deploymentData' });\n}\n\n/**\n * Add an invoke transaction to the wallet.\n * @param params The parameters required for the invoke transaction.\n * @returns The result of adding the invoke transaction.\n */\nexport function addInvokeTransaction(\n  swo: StarknetWindowObject,\n  params: AddInvokeTransactionParameters\n): Promise<AddInvokeTransactionResult> {\n  return swo.request({ type: 'wallet_addInvokeTransaction', params });\n}\n\n/**\n * Add a declare transaction to the wallet.\n * @param params The parameters required for the declare transaction.\n * @returns The result of adding the declare transaction.\n */\nexport function addDeclareTransaction(\n  swo: StarknetWindowObject,\n  params: AddDeclareTransactionParameters\n): Promise<AddDeclareTransactionResult> {\n  return swo.request({ type: 'wallet_addDeclareTransaction', params });\n}\n\n/**\n * Sign typed data using the wallet.\n * @param swo the starknet (wallet) window object to request the signature.\n * @param typedData The typed data to sign.\n * @returns An array of signatures as strings.\n */\nexport function signMessage(swo: StarknetWindowObject, typedData: TypedData): Promise<Signature> {\n  return swo.request({ type: 'wallet_signTypedData', params: typedData });\n}\n\n/**\n * Get the list of supported specifications.\n * @returns An array of supported specification strings.\n */\nexport function supportedSpecs(swo: StarknetWindowObject): Promise<SpecVersion[]> {\n  return swo.request({ type: 'wallet_supportedSpecs' });\n}\n\n/**\n * Attaches an event handler function to the \"accountsChanged\" event of a StarknetWindowObject.\n * When the accounts are changed, the specified callback function will be called.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject to attach the event handler to.\n * @param {AccountChangeEventHandler} callback - The function to be called when the accounts are changed.\n *                                              It will receive the changed accounts as a parameter.\n * @returns {void}\n */\nexport function onAccountChange(\n  swo: StarknetWindowObject,\n  callback: AccountChangeEventHandler\n): void {\n  swo.on('accountsChanged', callback);\n}\n\n/**\n * Register a callback function to be called when the network is changed.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject instance.\n * @param {NetworkChangeEventHandler} callback - The callback function to be called when the network is changed.\n * @return {void}\n */\nexport function onNetworkChanged(\n  swo: StarknetWindowObject,\n  callback: NetworkChangeEventHandler\n): void {\n  swo.on('networkChanged', callback);\n}\n","import { Account, AccountInterface } from '../account';\nimport { StarknetChainId } from '../global/constants';\nimport { ProviderInterface } from '../provider';\nimport type {\n  AllowArray,\n  CairoVersion,\n  Call,\n  CompiledSierra,\n  DeclareContractPayload,\n  MultiDeployContractResponse,\n  ProviderOptions,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\nimport { extractContractHashes } from '../utils/contract';\nimport { stringify } from '../utils/json';\nimport {\n  addDeclareTransaction,\n  addInvokeTransaction,\n  addStarknetChain,\n  getPermissions,\n  onAccountChange,\n  onNetworkChanged,\n  requestAccounts,\n  signMessage,\n  switchStarknetChain,\n  watchAsset,\n} from './connect';\nimport type { StarknetWalletProvider, WalletAccountOptions } from './types/index.type';\nimport type { PaymasterOptions } from '../paymaster/types/index.type';\nimport type { PaymasterInterface } from '../paymaster';\nimport {\n  AccountChangeEventHandler,\n  NetworkChangeEventHandler,\n  WatchAssetParameters,\n  AddStarknetChainParameters,\n  Signature,\n} from '../types/api';\n\n// Represent 'Selected Active' Account inside Connected Wallet\nexport class WalletAccount extends Account implements AccountInterface {\n  public walletProvider: StarknetWalletProvider;\n\n  constructor(options: WalletAccountOptions) {\n    super({ ...options, signer: '' }); // At this point unknown address\n    this.walletProvider = options.walletProvider;\n\n    // Update Address on change\n    this.walletProvider.on('accountsChanged', (res) => {\n      if (!res) return;\n      this.address = res[0].toLowerCase();\n    });\n\n    // Update Channel chainId on Network change\n    this.walletProvider.on('networkChanged', (res) => {\n      if (!res) return;\n      // Determine is it better to set chainId or replace channel with new one\n      // At the moment channel is stateless but it could change\n      this.channel.setChainId(res as StarknetChainId);\n    });\n  }\n\n  /**\n   * WALLET EVENTS\n   */\n  public onAccountChange(callback: AccountChangeEventHandler): void {\n    onAccountChange(this.walletProvider, callback);\n  }\n\n  public onNetworkChanged(callback: NetworkChangeEventHandler): void {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  public requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n\n  public getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n\n  public switchStarknetChain(chainId: StarknetChainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n\n  public watchAsset(asset: WatchAssetParameters) {\n    return watchAsset(this.walletProvider, asset);\n  }\n\n  public addStarknetChain(chain: AddStarknetChainParameters) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n\n  /**\n   * ACCOUNT METHODS\n   */\n  override execute(calls: AllowArray<Call>) {\n    const txCalls = [].concat(calls as any).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata,\n      };\n    });\n\n    const params = {\n      calls: txCalls,\n    };\n\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n\n  override declare(payload: DeclareContractPayload) {\n    const declareContractPayload = extractContractHashes(payload);\n\n    // DISCUSS: HOTFIX: Adapt Abi format\n    const pContract = payload.contract as CompiledSierra;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify(pContract.abi),\n    };\n\n    // Check FIx\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error('compiledClassHash is required');\n    }\n\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract,\n    };\n\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n\n  override async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = this.deployer.buildDeployerCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  override signMessage(typedData: TypedData): Promise<Signature> {\n    return signMessage(this.walletProvider, typedData);\n  }\n\n  static async connect(\n    provider: ProviderOptions | ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion,\n    paymaster?: PaymasterOptions | PaymasterInterface,\n    silentMode: boolean = false\n  ) {\n    const [accountAddress] = await requestAccounts(walletProvider, silentMode);\n    return new WalletAccount({\n      provider,\n      walletProvider,\n      address: accountAddress,\n      cairoVersion,\n      paymaster,\n    });\n  }\n\n  static async connectSilent(\n    provider: ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion,\n    paymaster?: PaymasterOptions | PaymasterInterface\n  ) {\n    return WalletAccount.connect(provider, walletProvider, cairoVersion, paymaster, true);\n  }\n\n  // TODO: MISSING ESTIMATES\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiEvents,\n  AbiStructs,\n  CairoEvent,\n  AbiEvent,\n  LegacyEvent,\n  ParsedEvent,\n  ParsedEvents,\n  RPC,\n  type CairoEventDefinition,\n  type CairoEventVariant,\n  type AbiEntry,\n} from '../../types';\nimport assert from '../assert';\nimport { isCairo1Abi } from '../calldata/cairo';\nimport { AbiParserInterface } from '../calldata/parser/interface';\nimport responseParser from '../calldata/responseParser';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { isUndefined, isObject } from '../typed';\n\n/**\n * Check if an ABI entry is related to events.\n * @param {AbiEntry} object an Abi entry\n * @returns {boolean} true if this Abi Entry is related to an event\n * @example\n * ```typescript\n * // use of a transaction receipt\n * ```\n */\nexport function isAbiEvent(object: AbiEntry): boolean {\n  return object.type === 'event';\n}\n\n/**\n * Retrieves the events from the given Cairo 0 ABI.\n * @param {Abi} abi - The Cairo 0 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo0AbiEvents(abi0);\n * // result = {\n  '0x35ea10b06d74221d24a134672e9f776a3088ba6b9829e53b9a10abd8817a211': {\n    data: [{ name: 'admin_requester', type: 'felt' }, { name: 'new_requester', type: 'felt' }],\n    keys: [],\n    name: 'AddAdmin',\n    type: 'event'\n  }\n * ```\n */\nfunction getCairo0AbiEvents(abi: Abi): AbiEvents {\n  return abi\n    .filter((abiEntry) => abiEntry.type === 'event')\n    .reduce((acc, abiEntry) => {\n      const entryName = abiEntry.name;\n      const abiEntryMod = { ...abiEntry };\n      abiEntryMod.name = entryName;\n      return {\n        ...acc,\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod,\n      };\n    }, {});\n}\n\n/**\n * Retrieves the events from the given Cairo 1 ABI.\n *\n * Is able to handle events nested in Cairo components.\n * @param {Abi} abi - The Cairo 1 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo1AbiEvents(abi1);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':\n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nfunction getCairo1AbiEvents(abi: Abi): AbiEvents {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'struct');\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'enum');\n  const abiEventsData: AbiEvents = abiEventsStructs.reduce((acc: CairoEvent, event: CairoEvent) => {\n    let nameList: string[] = [];\n    let { name } = event;\n    let flat: boolean = false;\n    const findName = (variant: CairoEventVariant) => variant.type === name;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (isUndefined(eventEnum)) break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === 'flat') flat = true;\n      name = eventEnum.name;\n    }\n\n    if (nameList.length === 0) {\n      throw new Error('inconsistency in ABI events definition.');\n    }\n\n    if (flat) nameList = [nameList[nameList.length - 1]];\n\n    const final = nameList.pop();\n    let result: AbiEvents = {\n      [addHexPrefix(starkCurve.keccak(utf8ToArray(final!)).toString(16))]: event,\n    };\n\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop()!)).toString(16))]: result,\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\n\n/**\n * Retrieves the events from the given ABI (from Cairo 0 or Cairo 1 contract).\n *\n * Is able to handle Cairo 1 events nested in Cairo components.\n * @param {Abi} abi - The ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getAbiEvents(abi);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':\n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nexport function getAbiEvents(abi: Abi): AbiEvents {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\n\n/**\n * internal function to deep merge 2 event description objects\n */\nfunction mergeAbiEvents(target: any, source: any): Object {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key as keyof typeof source])) {\n        if (!(key in target)) Object.assign(output, { [key]: source[key as keyof typeof source] });\n        else\n          output[key] = mergeAbiEvents(\n            target[key as keyof typeof target],\n            source[key as keyof typeof source]\n          );\n      } else {\n        Object.assign(output, { [key]: source[key as keyof typeof source] });\n      }\n    });\n  }\n  return output;\n}\n\n/**\n * Parse raw events and structure them into response object based on a contract structs and defined events\n * @param {RPC.Event[]} providerReceivedEvents Array of raw events\n * @param {AbiEvents} abiEvents Events defined in the abi\n * @param {AbiStructs} abiStructs Structs defined in the abi\n * @param {AbiEnums} abiEnums Enums defined in the abi\n * @returns {ParsedEvents} parsed events corresponding to the abi\n * @example\n * ```typescript\n * const abiEvents = events.getAbiEvents(sierra.abi);\n * const abiStructs =  CallData.getAbiStruct(sierra.abi);\n * const abiEnums = CallData.getAbiEnum(sierra.abi);\n * const result = events.parseEvents(myEvents, abiEvents, abiStructs, abiEnums);\n * // result = [{test::ExCh::ex_ch::Trade: {\n      maker: 7548613724711489396448209137n,\n      taker: 6435850562375218974960297344n,\n      router_maker: 0n,\n    }}]\n * ```\n */\nexport function parseEvents(\n  providerReceivedEvents: RPC.EmittedEvent[],\n  abiEvents: AbiEvents,\n  abiStructs: AbiStructs,\n  abiEnums: AbiEnums,\n  parser: AbiParserInterface\n): ParsedEvents {\n  const ret = providerReceivedEvents\n    .flat()\n    .reduce((acc, recEvent: RPC.EmittedEvent | RPC.Event) => {\n      const currentEvent: RPC.EmittedEvent | RPC.Event = JSON.parse(JSON.stringify(recEvent));\n      let abiEvent: AbiEvent | AbiEvents = abiEvents[currentEvent.keys.shift() ?? 0];\n      if (!abiEvent) {\n        return acc;\n      }\n      while (!abiEvent.name) {\n        const hashName = currentEvent.keys.shift();\n        assert(!!hashName, 'Not enough data in \"keys\" property of this event.');\n        abiEvent = (abiEvent as AbiEvents)[hashName];\n      }\n      // Create our final event object\n      const parsedEvent: ParsedEvent = {};\n      parsedEvent[abiEvent.name as string] = {};\n      // Remove the event's name hashed from the keys array\n      const keysIter = currentEvent.keys[Symbol.iterator]();\n      const dataIter = currentEvent.data[Symbol.iterator]();\n\n      const abiEventKeys =\n        (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'key') ||\n        (abiEvent as LegacyEvent).keys;\n      const abiEventData =\n        (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'data') ||\n        (abiEvent as LegacyEvent).data;\n\n      abiEventKeys.forEach((key) => {\n        parsedEvent[abiEvent.name as string][key.name] = responseParser({\n          responseIterator: keysIter,\n          output: key,\n          structs: abiStructs,\n          enums: abiEnums,\n          parser,\n          parsedResult: parsedEvent[abiEvent.name as string],\n        });\n      });\n\n      abiEventData.forEach((data) => {\n        parsedEvent[abiEvent.name as string][data.name] = responseParser({\n          responseIterator: dataIter,\n          output: data,\n          structs: abiStructs,\n          enums: abiEnums,\n          parser,\n          parsedResult: parsedEvent[abiEvent.name as string],\n        });\n      });\n      if ('block_hash' in currentEvent) parsedEvent.block_hash = currentEvent.block_hash;\n      if ('block_number' in currentEvent) parsedEvent.block_number = currentEvent.block_number;\n      if ('transaction_hash' in currentEvent)\n        parsedEvent.transaction_hash = currentEvent.transaction_hash;\n      acc.push(parsedEvent);\n      return acc;\n    }, [] as ParsedEvents);\n  return ret;\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\nimport {\n  Abi,\n  AbiEvents,\n  AbiStruct,\n  ArgsOrCalldata,\n  AsyncContractFunction,\n  Call,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractOptions,\n  FunctionAbi,\n  InvokeFunctionResponse,\n  GetTransactionReceiptResponse,\n  ParsedEvents,\n  RawArgs,\n  CallResult,\n  ValidateType,\n  type SuccessfulTransactionReceiptResponse,\n  EstimateFeeResponseOverhead,\n  ExecuteOptions,\n  ProviderOrAccount,\n  isAccount,\n  WithOptions,\n  FactoryParams,\n  UniversalDetails,\n  DeclareAndDeployContractPayload,\n  SuccessfulTransactionReceiptResponseHelper,\n} from '../types';\nimport type { AccountInterface } from '../account/interface';\nimport assert from '../utils/assert';\nimport { cairo, CallData } from '../utils/calldata';\nimport { createAbiParser, ParsingStrategy } from '../utils/calldata/parser';\nimport { getAbiEvents, parseEvents as parseRawEvents } from '../utils/events/index';\nimport { cleanHex } from '../utils/num';\nimport { ContractInterface } from './interface';\nimport { logger } from '../global/logger';\nimport { defaultProvider } from '../provider';\nimport { getCompiledCalldata } from '../utils/transaction';\nimport { extractAbi, parseContract } from '../utils/provider';\n\nexport type TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & Contract;\n\n/**\n * Adds call methods to the contract\n */\nfunction buildCall(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: ArgsOrCalldata): Promise<any> {\n    const options = { ...contract.withOptionsProps };\n    // eslint-disable-next-line no-param-reassign\n    contract.withOptionsProps = undefined;\n    return contract.call(functionAbi.name, args, {\n      parseRequest: contract.parseRequest,\n      parseResponse: contract.parseResponse,\n      ...options,\n    });\n  };\n}\n\n/**\n * Adds invoke methods to the contract\n */\nfunction buildInvoke(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: ArgsOrCalldata): Promise<any> {\n    const options = { ...contract.withOptionsProps };\n    // eslint-disable-next-line no-param-reassign\n    contract.withOptionsProps = undefined;\n    return contract.invoke(functionAbi.name, args, {\n      parseRequest: contract.parseRequest,\n      ...options,\n    });\n  };\n}\n\n/**\n * Adds call/invoke methods to the contract\n */\nfunction buildDefault(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  if (functionAbi.stateMutability === 'view' || functionAbi.state_mutability === 'view') {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\n\n/**\n * Adds populate for methods to the contract\n */\nfunction buildPopulate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.populate(functionAbi.name, args);\n  };\n}\n\n/**\n * Adds estimateFee for methods to the contract\n */\nfunction buildEstimate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    const options = { ...contract.withOptionsProps };\n    // eslint-disable-next-line no-param-reassign\n    contract.withOptionsProps = undefined;\n    return contract.estimate(functionAbi.name, args, options);\n  };\n}\nexport class Contract implements ContractInterface {\n  abi: Abi;\n\n  address: string;\n\n  providerOrAccount: ProviderOrAccount;\n\n  classHash?: string;\n\n  parseRequest: boolean;\n\n  parseResponse: boolean;\n\n  private structs: { [name: string]: AbiStruct };\n\n  private events: AbiEvents;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  private callData: CallData;\n\n  public withOptionsProps?: WithOptions;\n\n  private parsingStrategy?: ParsingStrategy;\n\n  /**\n   * @param options\n   *  - abi: Abi of the contract object (required)\n   *  - address: address to connect to (required)\n   *  - providerOrAccount?: Provider or Account to attach to (fallback to defaultProvider)\n   *  - parseRequest?: compile and validate arguments (optional, default true)\n   *  - parseResponse?: Parse elements of the response array and structuring them into response object (optional, default true)\n   *  - parser?: Abi parser (optional, default createAbiParser(options.abi))\n   */\n  constructor(options: ContractOptions) {\n    // TODO: REFACTOR: move from legacy format and add support for legacy format\n    // Must have params\n    this.parsingStrategy = options.parsingStrategy;\n    const parser = createAbiParser(options.abi, options.parsingStrategy);\n    this.abi = parser.getLegacyFormat();\n    this.address = options.address && options.address.toLowerCase();\n    this.providerOrAccount = options.providerOrAccount ?? defaultProvider;\n\n    // Optional params\n    this.parseRequest = options.parseRequest ?? true;\n    this.parseResponse = options.parseResponse ?? true;\n    this.classHash = options.classHash;\n\n    // Init\n    this.callData = new CallData(options.abi, options.parsingStrategy);\n    this.structs = CallData.getAbiStruct(options.abi);\n    this.events = getAbiEvents(options.abi);\n\n    // Define methods properties\n    const methodTypes = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false },\n    });\n\n    // Define methods\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== 'function') return;\n      const methodSignature = abiElement.name;\n      if (!this[methodSignature]) {\n        Object.defineProperty(this, methodSignature, {\n          ...methodTypes,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.functions[methodSignature]) {\n        Object.defineProperty(this.functions, methodSignature, {\n          ...methodTypes,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.callStatic[methodSignature]) {\n        Object.defineProperty(this.callStatic, methodSignature, {\n          ...methodTypes,\n          value: buildCall(this, abiElement),\n        });\n      }\n      if (!this.populateTransaction[methodSignature]) {\n        Object.defineProperty(this.populateTransaction, methodSignature, {\n          ...methodTypes,\n          value: buildPopulate(this, abiElement),\n        });\n      }\n      if (!this.estimateFee[methodSignature]) {\n        Object.defineProperty(this.estimateFee, methodSignature, {\n          ...methodTypes,\n          value: buildEstimate(this, abiElement),\n        });\n      }\n    });\n  }\n\n  public withOptions(options: WithOptions): this {\n    this.withOptionsProps = options;\n    return this;\n  }\n\n  public attach(address: string, abi?: Abi): void {\n    // TODO: if changing address, probably changing abi also !? Also nonsense method as if you change abi and address, you need to create a new contract instance.\n    this.address = address;\n    if (abi) {\n      const parser = createAbiParser(abi, this.parsingStrategy);\n      this.abi = parser.getLegacyFormat();\n      this.callData = new CallData(abi, this.parsingStrategy);\n      this.structs = CallData.getAbiStruct(abi);\n      this.events = getAbiEvents(abi);\n    }\n  }\n\n  public async isDeployed(): Promise<this> {\n    try {\n      await this.providerOrAccount.getClassHashAt(this.address);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Contract not deployed at address ${this.address}: ${errorMessage}`);\n    }\n\n    return this;\n  }\n\n  public async call(\n    method: string,\n    args: ArgsOrCalldata = [],\n    {\n      parseRequest = true,\n      parseResponse = true,\n      formatResponse = undefined,\n      blockIdentifier = undefined,\n    }: CallOptions = {}\n  ): Promise<CallResult> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCompiledCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.CALL, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    return this.providerOrAccount\n      .callContract(\n        {\n          contractAddress: this.address,\n          calldata,\n          entrypoint: method,\n        },\n        blockIdentifier\n      )\n      .then((it) => {\n        if (!parseResponse) {\n          return it;\n        }\n        if (formatResponse) {\n          return this.callData.format(method, it, formatResponse);\n        }\n        return this.callData.parse(method, it);\n      });\n  }\n\n  public async invoke(\n    method: string,\n    args: ArgsOrCalldata,\n    options: ExecuteOptions & { waitForTransaction: true }\n  ): Promise<SuccessfulTransactionReceiptResponseHelper>;\n  public async invoke(\n    method: string,\n    args: ArgsOrCalldata,\n    options: ExecuteOptions & { waitForTransaction: false }\n  ): Promise<InvokeFunctionResponse>;\n  public async invoke(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: ExecuteOptions\n  ): Promise<InvokeFunctionResponse>;\n  public async invoke(\n    method: string,\n    args: ArgsOrCalldata = [],\n    options: ExecuteOptions = {}\n  ): Promise<SuccessfulTransactionReceiptResponseHelper | InvokeFunctionResponse> {\n    const { parseRequest = true, signature, waitForTransaction, ...RestInvokeOptions } = options;\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCompiledCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.INVOKE, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn('Invoke skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method,\n    };\n    if (isAccount(this.providerOrAccount)) {\n      const result: InvokeFunctionResponse = await this.providerOrAccount.execute(invocation, {\n        ...RestInvokeOptions,\n      });\n      if (waitForTransaction) {\n        const result2: GetTransactionReceiptResponse =\n          await this.providerOrAccount.waitForTransaction(result.transaction_hash);\n        if (result2.isSuccess()) {\n          return result2;\n        }\n        throw new Error('Transaction failed', { cause: result2 });\n      }\n      return result;\n    }\n\n    if (!RestInvokeOptions.nonce)\n      throw new Error(`Manual nonce is required when invoking a function without an account`);\n    logger.warn(`Invoking ${method} without an account.`);\n\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature,\n      },\n      {\n        ...RestInvokeOptions,\n        nonce: RestInvokeOptions.nonce,\n      }\n    );\n  }\n\n  public async estimate(\n    method: string,\n    args: ArgsOrCalldata = [],\n    estimateDetails: UniversalDetails = {}\n  ): Promise<EstimateFeeResponseOverhead> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    if (!getCompiledCalldata(args, () => false)) {\n      this.callData.validate(ValidateType.INVOKE, method, args);\n    }\n\n    const invocation = this.populate(method, args);\n    if (isAccount(this.providerOrAccount)) {\n      return this.providerOrAccount.estimateInvokeFee(invocation, estimateDetails);\n    }\n    throw Error('Contract must be connected to the account contract to estimate');\n  }\n\n  public populate(method: string, args: RawArgs = []): Call {\n    const calldata: Calldata = getCompiledCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata,\n    };\n  }\n\n  // TODO: Demistify what is going on here ???\n  // TODO: receipt status filtering test and fix this do not look right\n  public parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents {\n    let parsed: ParsedEvents = [] as unknown as ParsedEvents;\n    receipt.match({\n      SUCCEEDED: (txR: SuccessfulTransactionReceiptResponse) => {\n        const emittedEvents =\n          txR.events\n            ?.map((event) => {\n              return {\n                // TODO: this do not check that block is production and block_hash and block_number actually exists\n                // TODO: second issue is that ts do not complains about it\n                block_hash: txR.block_hash,\n                block_number: txR.block_number,\n                transaction_hash: txR.transaction_hash,\n                ...event,\n              };\n            })\n            .filter((event) => cleanHex(event.from_address) === cleanHex(this.address), []) || []; // TODO: what data is in this that is cleaned out ?\n        parsed = parseRawEvents(\n          emittedEvents,\n          this.events,\n          this.structs,\n          CallData.getAbiEnum(this.abi),\n          this.callData.parser\n        ) as ParsedEvents;\n      },\n      _: () => {\n        throw Error('This transaction was not successful.');\n      },\n    });\n\n    // Add getByPath method to the specific instance (non-enumerable)\n    Object.defineProperty(parsed, 'getByPath', {\n      value: (path: string) => {\n        const event = parsed.find((ev) => Object.keys(ev).some((key) => key.includes(path)));\n        const eventKey = Object.keys(event || {}).find((key) => key.includes(path));\n        return eventKey && event ? event[eventKey] : null;\n      },\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    return parsed;\n  }\n\n  public isCairo1(): boolean {\n    return cairo.isCairo1Abi(this.abi);\n  }\n\n  public async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n\n  public typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi> {\n    return this as unknown as TypedContractV2<typeof tAbi>;\n  }\n\n  /**\n   * Factory method to declare and/or deploy a contract creating a new Contract instance\n   *\n   * It handles the entire lifecycle: compiles constructor calldata, optionally declares the contract class,\n   * deploys an instance, and returns a ready-to-use Contract object.\n   *\n   * When classHash is provided, it will only deploy the contract without declaring.\n   * When contract is provided without classHash, it will declare and deploy.\n   *\n   * @param params - Factory parameters containing Contract Class details and deployment options\n   * @returns Promise that resolves to a deployed Contract instance with address and transaction hash\n   * @throws Error if deployment fails or contract_address is not returned\n   * @example\n   * ```typescript\n   * // Declare and deploy an ERC20 contract\n   * const contract = await Contract.factory({\n   *   contract: erc20CompiledContract,\n   *   account: myAccount,\n   *   casm: erc20Casm,\n   *   constructorCalldata: {\n   *     name: 'MyToken',\n   *     symbol: 'MTK',\n   *     decimals: 18,\n   *     initial_supply: { low: 1000000, high: 0 },\n   *     recipient: myAccount.address\n   *   }\n   * });\n   *\n   * // Deploy-only mode with existing classHash (ABI will be fetched from network)\n   * const contract2 = await Contract.factory({\n   *   classHash: '0x1234...',\n   *   account: myAccount,\n   *   constructorCalldata: {\n   *     name: 'AnotherToken',\n   *     symbol: 'ATK',\n   *     decimals: 18,\n   *     initial_supply: { low: 2000000, high: 0 },\n   *     recipient: myAccount.address\n   *   }\n   * });\n   *\n   * // Deploy-only mode with provided ABI (faster, no network call)\n   * const contract3 = await Contract.factory({\n   *   classHash: '0x1234...',\n   *   abi: erc20Abi,\n   *   account: myAccount,\n   *   constructorCalldata: {\n   *     name: 'ThirdToken',\n   *     symbol: 'TTK',\n   *     decimals: 18,\n   *     initial_supply: { low: 3000000, high: 0 },\n   *     recipient: myAccount.address\n   *   }\n   * });\n   *\n   * console.log('Contract deployed at:', contract.address);\n   * ```\\\n   */\n  static async factory(params: FactoryParams, details: UniversalDetails = {}): Promise<Contract> {\n    const { account, parseRequest = true } = params;\n    let abi: Abi;\n    let classHash: string;\n    let contract_address: string;\n\n    // Check if only deploying (classHash provided and no contract)\n    if ('classHash' in params && params.classHash && !('contract' in params)) {\n      // Deploy-only mode: use provided classHash\n      const deployParams = params as FactoryParams & { classHash: string; abi?: Abi };\n      classHash = deployParams.classHash.toString();\n\n      // If ABI is not provided, fetch it from the network using the classHash\n      if (!deployParams.abi) {\n        const contractClass = await account.getClass(classHash);\n        abi = contractClass.abi;\n      } else {\n        abi = deployParams.abi;\n      }\n\n      // Deploy the contract using the provided classHash\n      const deployResult = await account.deployContract(\n        {\n          classHash,\n          constructorCalldata: deployParams.constructorCalldata,\n          salt: deployParams.salt,\n          unique: deployParams.unique,\n          abi: parseRequest ? abi : undefined,\n        },\n        details\n      );\n      contract_address = deployResult.contract_address;\n    } else {\n      // Declare and deploy mode: original behavior\n      const declareParams = params as DeclareAndDeployContractPayload & {\n        account: AccountInterface;\n        parseRequest?: boolean;\n      };\n      const contract = parseContract(declareParams.contract);\n      abi = declareParams.abi ? declareParams.abi : extractAbi(contract);\n\n      const {\n        declare: { class_hash },\n        deploy: { contract_address: deployed_address },\n      } = await account.declareAndDeploy(\n        {\n          ...declareParams,\n          abi: parseRequest ? abi : undefined,\n        },\n        details\n      );\n      classHash = class_hash.toString();\n      contract_address = deployed_address;\n    }\n\n    // Common contract creation logic\n    assert(Boolean(contract_address), 'Deployment of the contract failed');\n\n    return new Contract({\n      abi,\n      address: contract_address,\n      providerOrAccount: account,\n      classHash,\n      parseRequest: params.parseRequest,\n      parseResponse: params.parseResponse,\n      parsingStrategy: params.parsingStrategy,\n    });\n  }\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport type {\n  Abi,\n  BigNumberish,\n  BlockIdentifier,\n  Calldata,\n  ContractVersion,\n  Invocation,\n  InvokeFunctionResponse,\n  RawArgs,\n  Uint256,\n} from '../types';\nimport type {\n  ArgsOrCalldata,\n  AsyncContractFunction,\n  CallOptions,\n  CallResult,\n  ContractFunction,\n  ExecuteOptions,\n  ParsedEvents,\n  ProviderOrAccount,\n  WithOptions,\n} from './types/index.type';\nimport type { EstimateFeeResponseOverhead } from '../provider/types/index.type';\nimport { CairoCustomEnum } from '../utils/calldata/enum/CairoCustomEnum';\nimport { CairoOption } from '../utils/calldata/enum/CairoOption';\nimport { CairoResult } from '../utils/calldata/enum/CairoResult';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt/transactionReceipt.type';\n\ndeclare module 'abi-wan-kanabi' {\n  export interface Config<OptionT = any, ResultT = any, ErrorT = any> {\n    FeltType: BigNumberish;\n    U256Type: number | bigint | Uint256;\n    U512Type: BigNumberish;\n    Secp256k1PointType: BigNumberish;\n    Option: CairoOption<OptionT>;\n    Tuple: Record<number, BigNumberish | object | boolean>;\n    Result: CairoResult<ResultT, ErrorT>;\n    Enum: CairoCustomEnum;\n    Calldata: RawArgs | Calldata;\n    CallOptions: CallOptions;\n    InvokeOptions: ExecuteOptions;\n    InvokeFunctionResponse: InvokeFunctionResponse;\n  }\n}\n\ntype TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & ContractInterface;\n\n/**\n * Interface for interacting with Starknet smart contracts\n *\n * Provides methods for calling contract functions, estimating fees, and managing contract state.\n * Supports both read-only calls and state-changing invocations.\n *\n * @remarks\n * The interface provides multiple ways to interact with contracts:\n * - Direct method calls for convenience\n * - Generic call/invoke methods for flexibility\n * - Fee estimation and transaction population\n * - Event parsing and contract validation\n */\nexport abstract class ContractInterface {\n  /**\n   * Contract ABI (Application Binary Interface)\n   */\n  public abstract abi: Abi;\n\n  /**\n   * Contract address on Starknet\n   */\n  public abstract address: string;\n\n  /**\n   * Provider for read operations or Account for write operations\n   */\n  public abstract providerOrAccount: ProviderOrAccount;\n\n  /**\n   * Optional contract class hash for optimization\n   */\n  public abstract classHash?: string;\n\n  /**\n   * Contract methods that return promises (async operations)\n   */\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  /**\n   * Contract methods for read-only calls (state queries)\n   */\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  /**\n   * Contract methods that return populated transactions for batching\n   */\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  /**\n   * Contract methods for fee estimation\n   */\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  /**\n   * Dynamic method access - allows calling contract methods directly\n   */\n  readonly [key: string]: AsyncContractFunction | any;\n\n  /**\n   * Attach the contract to a different address with optional new ABI\n   *\n   * @param address - New contract address to interact with\n   * @param abi - Optional new ABI to use (defaults to current ABI)\n   * @example\n   * ```typescript\n   * contract.attach('0x123...', newAbi);\n   * // Now contract.address === '0x123...' and uses newAbi\n   * ```\n   */\n  public abstract attach(address: string, abi?: Abi): void;\n\n  /**\n   * Verify that a contract is deployed at the current address\n   *\n   * @returns Promise resolving to this contract instance if deployed\n   * @throws {Error} If no contract is found at the address\n   * @example\n   * ```typescript\n   * try {\n   *   await contract.isDeployed();\n   *   console.log('Contract is deployed');\n   * } catch (error) {\n   *   console.log('Contract not found at address');\n   * }\n   * ```\n   */\n  public abstract isDeployed(): Promise<ContractInterface>;\n\n  /**\n   * Call a read-only contract method (view function)\n   *\n   * @param method - Name of the contract method to call\n   * @param args - Method arguments as array or calldata\n   * @param options - Call options including block identifier and parsing settings\n   * @returns Parsed result from the contract method\n   * @example\n   * ```typescript\n   * const balance = await contract.call('balanceOf', [userAddress]);\n   * const name = await contract.call('name', [], { blockIdentifier: 'latest' });\n   * ```\n   */\n  public abstract call(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: CallOptions\n  ): Promise<CallResult>;\n\n  /**\n   * Invoke a state-changing contract method (external function)\n   *\n   * @param method - Name of the contract method to invoke\n   * @param args - Method arguments as array or calldata\n   * @param options - Execution options including transaction details\n   * @returns Transaction response with hash\n   * @example\n   * ```typescript\n   * const tx = await contract.invoke('transfer', [recipient, amount]);\n   * const receipt = await provider.waitForTransaction(tx.transaction_hash);\n   * ```\n   */\n  public abstract invoke(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: ExecuteOptions\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Estimate fee for invoking a contract method\n   *\n   * @param method - Name of the contract method to estimate\n   * @param args - Method arguments as array or calldata\n   * @param options - Estimation options including block identifier\n   * @returns Fee estimation details\n   * @example\n   * ```typescript\n   * const feeEstimate = await contract.estimate('transfer', [recipient, amount]);\n   * console.log('Estimated fee:', feeEstimate.overall_fee);\n   * ```\n   */\n  public abstract estimate(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: {\n      blockIdentifier?: BlockIdentifier;\n    }\n  ): Promise<EstimateFeeResponseOverhead>;\n\n  /**\n   * Populate transaction data for a contract method call\n   *\n   * @param method - Name of the contract method\n   * @param args - Method arguments as array or calldata\n   * @returns Invocation object for batching or inspection\n   * @example\n   * ```typescript\n   * const invocation = contract.populate('transfer', [recipient, amount]);\n   * // Use in account.execute([invocation1, invocation2, ...])\n   * ```\n   */\n  public abstract populate(method: string, args?: ArgsOrCalldata): Invocation;\n\n  /**\n   * Parse events from a transaction receipt using the contract's ABI\n   *\n   * @param receipt - Transaction receipt from waitForTransaction\n   * @returns Array of parsed events with decoded data\n   * @example\n   * ```typescript\n   * const receipt = await provider.waitForTransaction(txHash);\n   * const events = contract.parseEvents(receipt);\n   * events.forEach(event => {\n   *   console.log('Event:', event.name, event.data);\n   * });\n   * ```\n   */\n  public abstract parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;\n\n  /**\n   * Check if the contract is implemented in Cairo 1\n   *\n   * @returns True if the contract uses Cairo 1, false for Cairo 0 (legacy)\n   * @example\n   * ```typescript\n   * if (contract.isCairo1()) {\n   *   console.log('Using Cairo 1 features');\n   * }\n   * ```\n   */\n  public abstract isCairo1(): boolean;\n\n  /**\n   * Get the Cairo and compiler version of the contract\n   *\n   * @returns Object containing cairo version and compiler version\n   * @example\n   * ```typescript\n   * const version = await contract.getVersion();\n   * console.log(`Cairo ${version.cairo}, Compiler ${version.compiler}`);\n   * ```\n   */\n  public abstract getVersion(): Promise<ContractVersion>;\n\n  /**\n   * Create a typed contract instance with full TypeScript support\n   *\n   * @param tAbi - The typed ABI interface for compile-time type checking\n   * @returns Typed contract instance with IntelliSense support\n   * @example\n   * ```typescript\n   * const typedContract = contract.typedv2(erc20Abi);\n   * // Now typedContract.transfer() has full type safety\n   * ```\n   */\n  public abstract typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi>;\n\n  /**\n   * Set execution options for subsequent contract interactions\n   *\n   * @param options - Options to override for contract interactions\n   * @returns This contract instance with the specified options applied\n   * @example\n   * ```typescript\n   * contract.withOptions({\n   *   blockIdentifier: 'latest',\n   *   parseResponse: false\n   * });\n   * // Now all subsequent calls use these options\n   * ```\n   */\n  public abstract withOptions(options: WithOptions): ContractInterface;\n}\n","import {\n  CallContractResponse,\n  DeclareContractResponse,\n  DeployContractResponse,\n  GetBlockResponse,\n  GetTransactionResponse,\n  InvokeFunctionResponse,\n  BlockWithTxHashes,\n  SimulateTransactionOverheadResponse,\n} from '../../types';\nimport type { GetTransactionReceiptResponse } from '../transactionReceipt/transactionReceipt.type';\n\nexport abstract class ResponseParser {\n  abstract parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse;\n\n  abstract parseGetTransactionResponse(res: any): GetTransactionResponse;\n\n  abstract parseGetTransactionReceiptResponse(res: any): GetTransactionReceiptResponse;\n\n  abstract parseCallContractResponse(res: any): CallContractResponse;\n\n  abstract parseInvokeFunctionResponse(res: any): InvokeFunctionResponse;\n\n  abstract parseDeployContractResponse(res: any): DeployContractResponse;\n\n  abstract parseDeclareContractResponse(res: any): DeclareContractResponse;\n\n  abstract parseSimulateTransactionResponse(res: any): SimulateTransactionOverheadResponse;\n}\n","import { isHex } from './num';\nimport { isBigInt, isString } from './typed';\n\n/**\n * Convert strk to fri or fri to strk\n * @example\n * ```typescript\n * units(1000n, 'fri') // '0.000000000000001' strk\n * units('1', 'strk') // '1000000000000000000' fri\n * ```\n */\nexport function units(amount: string | bigint, simbol: 'fri' | 'strk' = 'fri') {\n  if (simbol === 'strk') {\n    let numStr = '';\n    if (isBigInt(amount)) numStr = amount.toString();\n    else if (isString(amount)) {\n      if (isHex(amount)) {\n        numStr = BigInt(amount).toString();\n      } else {\n        numStr = amount;\n      }\n    }\n\n    const [integer, decimal = '0'] = numStr.split('.');\n    const pdec = decimal.padEnd(18, '0');\n    return `${integer}${pdec}`.replace(/\\b0+/g, '');\n  }\n\n  const bis = BigInt(amount).toString();\n  let strk;\n  if (bis.length <= 18) {\n    strk = `0.${bis.padStart(18, '0')}`;\n  } else {\n    strk = `${bis.slice(0, bis.length - 18)}.${bis.slice(bis.length - 18)}`;\n  }\n\n  return strk.replace(/(\\.[0-9]*[1-9])0+$|\\.0*$/, '$1');\n}\n"],"mappings":"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","names":["cleanHex","ETransactionVersion","ETransactionVersion2","parse","stringify","stringify","isHexString","isInteger","isHexString","isDecimalString","isDecimalString","stringify","isInteger","listTypeVariant","parsedParameter","parseBaseTypes","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateInvokeTransactionHash","computeHashOnElements","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateTransactionHashCommon","calculateTransactionHashCommon","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateInvokeTransactionHash","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","poseidonHashMany","computeHashOnElements","poseidonHashMany","json","stringify","parse","stringify","base64","parse","ETransactionVersion","parse","ETransactionVersion","stringify","parse","isDecimalString","ETransactionVersion","stringify","error","result","RpcChannel","defaultOptions","RpcChannel","stringify","error","result","stringify","config","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdMulticallContract","RpcProvider","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","secp256k1","uint256","secp256k1","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","hexToBytes","hexToBytes","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","execution","defaultOptions","stringify","RpcProvider","StarknetIdContract","stringify"]}