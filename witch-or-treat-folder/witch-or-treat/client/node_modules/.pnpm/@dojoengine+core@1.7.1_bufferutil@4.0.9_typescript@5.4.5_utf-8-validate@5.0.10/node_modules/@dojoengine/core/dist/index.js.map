{"version":3,"sources":["../src/provider/DojoProvider.ts","../src/constants/index.ts","../src/logger/logger.ts","../src/types/index.ts","../src/utils/index.ts","../src/provider/provider.ts","../src/config/index.ts","../src/manifest/index.ts"],"sourcesContent":["import {\n    type Account,\n    type AccountInterface,\n    type AllowArray,\n    type ArgsOrCalldata,\n    type Call,\n    type CallContractResponse,\n    CallResult,\n    Contract,\n    type InvokeFunctionResponse,\n    RpcProvider,\n    shortString,\n    type UniversalDetails,\n} from \"starknet\";\n\nimport { LOCAL_KATANA } from \"../constants\";\nimport { ConsoleLogger, type LogLevel } from \"../logger/logger\";\nimport { type DojoCall, WorldEntryPoints } from \"../types\";\nimport { getContractByName, parseDojoCall } from \"../utils\";\nimport { Provider } from \"./provider\";\n\n/**\n * DojoProvider: The DojoProvider is an execution provider for dojo worlds. It allows you to easily interact with a dojo world via the Starknet.js library.\n * ```ts\n * import { DojoProvider } from \"@dojoengine/core\";\n *\n * const provider = new DojoProvider(\n *      manifest\n * );\n * ```\n */\nexport class DojoProvider extends Provider {\n    public provider: RpcProvider;\n    public contract: Contract;\n    public manifest: any;\n    public logger: ConsoleLogger;\n\n    /**\n     * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.\n     *\n     * @param {string} world_address - Address of the world.\n     * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).\n     */\n    constructor(\n        manifest?: any,\n        url: string = LOCAL_KATANA,\n        logLevel: LogLevel = \"none\"\n    ) {\n        super(manifest.world.address);\n        this.provider = new RpcProvider({\n            nodeUrl: url,\n        });\n\n        this.contract = new Contract({\n            abi: manifest.world.abi,\n            address: this.getWorldAddress(),\n            providerOrAccount: this.provider,\n        });\n        this.manifest = manifest;\n        this.logger = new ConsoleLogger({ level: logLevel });\n    }\n\n    /**\n     * Retrieves a single entity's details.\n     *\n     * @param {string} model - The component to query.\n     * @param {Array<string>} keys - The keys to query.\n     * @param {number} [offset=0] - Starting offset (defaults to 0).\n     * @param {number} [length=0] - Length to retrieve (defaults to 0).\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.\n     */\n    public async entity(\n        model: string,\n        keys: Array<string>,\n        offset: number = 0,\n        length: number = 0,\n        layout: Array<number>\n    ): Promise<Array<bigint>> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.get, [\n                shortString.encodeShortString(model),\n                keys.length,\n                ...(keys as any),\n                offset,\n                length,\n                layout.length,\n                layout,\n            ])) as unknown as Array<bigint>;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves multiple entities' details.\n     *\n     * @param {string} model - The component to query.\n     * @param {number} index - The index to query.\n     * @param {Array<string>} values - The values to query.\n     * @param {number} valuesLength - The values length to query.\n     * @param {Array<number>} valuesLayout - The values layout to query.\n     */\n    public async entities(\n        model: string,\n        index: string,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.entities, [\n                shortString.encodeShortString(model),\n                index,\n                values,\n                valuesLength,\n                valuesLayout,\n            ])) as unknown as Promise<Array<Array<bigint>>>;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a models\n     *\n     * @param {string} name - Name of the model.\n     * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.\n     */\n    public async model(name: string): Promise<bigint> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.model, [\n                shortString.encodeShortString(name),\n            ])) as unknown as bigint;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves current uuid from the world contract.\n     *\n     * @returns {Promise<number>} - A promise that resolves to the world uuid\n     * @throws {Error} - Throws an error if the call fails.\n     *\n     * @example\n     * const uuid = await provider.uuid();\n     * console.log(uuid);\n     * // => 6\n     *\n     */\n    public async uuid(): Promise<number> {\n        try {\n            const result = await this.provider.callContract({\n                contractAddress: this.getWorldAddress(),\n                entrypoint: WorldEntryPoints.uuid,\n                calldata: [],\n            });\n            if (result && result.length === 1) {\n                return parseInt(result[0]);\n            }\n            throw new Error(\"Contract did not return expected uuid\");\n        } catch (error) {\n            this.logger.error(`Failed to fetch uuid: ${error}`);\n            throw new Error(`Failed to fetch uuid: ${error}`);\n        }\n    }\n\n    /**\n     * Executes a function with the given parameters.\n     * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.\n     *\n     * ```ts\n     * await provider.execute(signer, { contractName, entrypoint, calldata });\n     * await provider.execute(signer, { contractAddress, entrypoint, calldata });\n     * await provider.execute(signer, [{ contractName, entrypoint, calldata }, { contractAddress, entrypoint, calldata }]);\n     * ```\n     * @param {Account} account - The account to use.\n     * @param {AllowArray<DojoCall | Call>} call - The call or calls\n     * @param {UniversalDetails} details - https://github.com/starknet-io/starknet.js/blob/5efa196017ee8f761ae837ecac9c059da8f3e09a/src/types/account.ts#L26\n     * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.\n     */\n    public async execute(\n        account: Account | AccountInterface,\n        call: AllowArray<DojoCall | Call>,\n        nameSpace: string,\n        details: UniversalDetails = {}\n    ): Promise<InvokeFunctionResponse> {\n        const dojoCalls = Array.isArray(call) ? call : [call];\n        const calls = dojoCalls.map((i) =>\n            parseDojoCall(this.manifest, nameSpace, i)\n        );\n\n        try {\n            return await account?.execute(calls, details);\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Calls a function with the given parameters and return parsed results for a DojoCall.\n     *\n     * ```ts\n     * let parsedResult = await provider.call({ contractName, entrypoint, calldata });\n     * ```\n     * @param {DojoCall | Call} call - The dojoCall or call\n     * @returns {Promise<Result>} - A promise that resolves to the response of the function call.\n     */\n    public async call(\n        nameSpace: string,\n        call: DojoCall | Call\n    ): Promise<CallResult> {\n        if (\"contractName\" in call) {\n            try {\n                const contractInfos = getContractByName(\n                    this.manifest,\n                    nameSpace,\n                    call.contractName\n                );\n                const contract = new Contract({\n                    abi: contractInfos.abi,\n                    address: contractInfos.address,\n                    providerOrAccount: this.provider,\n                });\n                return await contract.call(\n                    call.entrypoint,\n                    call.calldata as ArgsOrCalldata\n                );\n            } catch (error) {\n                this.logger.error(\n                    `Failed to callContract ${call.contractName}: ${error}`\n                );\n                throw new Error(\n                    `Failed to callContract ${call.contractName}: ${error}`\n                );\n            }\n        } else {\n            return this.callRaw(nameSpace, call);\n        }\n    }\n\n    /**\n     * Calls a function with the given parameters.\n     *\n     * @param {string} nameSpace - The namespace of the contract within the world\n     * @param {DojoCall | Call} call - The dojoCall or call\n     * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.\n     * @throws {Error} - Throws an error if the call fails.\n     *\n     * @example\n     * const result = await provider.callRaw(\"namespace\", { contractAddress, entrypoint, calldata });\n     */\n    async callRaw(\n        nameSpace: string,\n        call: DojoCall | Call\n    ): Promise<CallContractResponse> {\n        const parsedCall = parseDojoCall(this.manifest, nameSpace, call);\n        try {\n            return await this.provider.callContract(parsedCall);\n        } catch (error) {\n            this.logger.error(\n                `Failed to call ${parsedCall.contractAddress}: ${error}`\n            );\n            throw new Error(\n                `Failed to call ${parsedCall.contractAddress}: ${error}`\n            );\n        }\n    }\n}\n","export const LOCAL_KATANA = \"http://127.0.0.1:5050\";\nexport const LOCAL_RELAY = \"/ip4/127.0.0.1/tcp/9090\";\nexport const LOCAL_TORII = \"http://127.0.0.1:8080\";\nexport const KATANA_PREFUNDED_ADDRESS =\n    \"0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec\";\nexport const KATANA_PREFUNDED_PRIVATE_KEY =\n    \"0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912\";\nexport const KATANA_CLASS_HASH =\n    \"0x07dc7899aa655b0aae51eadff6d801a58e97dd99cf4666ee59e704249e51adf2\";\nexport const KATANA_ETH_CONTRACT_ADDRESS =\n    \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\n","/** Signature of a logging function */\nexport interface LogFn {\n    (message?: any, ...optionalParams: any[]): void;\n}\n\n/** Basic logger interface */\nexport interface Logger {\n    info: LogFn;\n    warn: LogFn;\n    error: LogFn;\n}\n\n/** Log levels */\nexport type LogLevel = \"info\" | \"warn\" | \"error\" | \"none\";\n\n/* tslint:disable:no-unused-variable */\nconst NO_OP: LogFn = (_message?: any, ..._optionalParams: any[]) => {};\n\n/** Logger which outputs to the browser console */\nexport class ConsoleLogger implements Logger {\n    readonly info: LogFn;\n    readonly warn: LogFn;\n    readonly error: LogFn;\n\n    constructor(options?: { level?: LogLevel }) {\n        const { level } = options || {};\n\n        this.error = console.error.bind(console);\n\n        if (level === \"none\") {\n            this.error = NO_OP;\n            this.warn = NO_OP;\n            this.info = NO_OP;\n        }\n\n        if (level === \"error\") {\n            this.warn = NO_OP;\n            this.info = NO_OP;\n\n            return;\n        }\n\n        this.warn = console.warn.bind(console);\n\n        if (level === \"warn\") {\n            this.info = NO_OP;\n\n            return;\n        }\n\n        this.info = console.log.bind(console);\n    }\n}\n","import { Calldata, RawArgs } from \"starknet\";\n\n/**\n * Enumeration representing various entry points or functions available in the World.\n */\nexport enum WorldEntryPoints {\n    get = \"entity\", // Retrieve a single entity\n    set = \"set_entity\", // Set or update a single entity\n    entities = \"entities\", // Retrieve multiple entities\n    execute = \"execute\", // Execute a specific command\n    registerSystem = \"register_system\", // Register a new system\n    registerComponent = \"register_model\", // Register a new component\n    model = \"model\", // Access a component\n    system = \"system\", // Access a system\n    metadataUri = \"metadata_uri\", // Retrieve metadata URI for a resource\n    setMetadataUri = \"set_metadata_uri\", // Set metadata URI for a resource\n    registerModel = \"register_model\", // Register a new model\n    deployContract = \"deploy_contract\", // Deploy a contract and return its address\n    upgradeContract = \"upgrade_contract\", // Upgrade a contract\n    uuid = \"uuid\", // Retrieve the UUID of the world\n    emit = \"emit\", // Emit an event\n    entityIds = \"entity_ids\", // Retrieve entity IDs for a model\n    setExecutor = \"set_executor\", // Set executor for the world\n    executor = \"executor\", // Retrieve the executor's address\n    base = \"base\", // Retrieve base class hash\n    deleteEntity = \"delete_entity\", // Delete an entity\n    isOwner = \"is_owner\", // Check if an address is an owner of a resource\n    grantOwner = \"grant_owner\", // Grant ownership of a resource\n    revokeOwner = \"revoke_owner\", // Revoke ownership of a resource\n    isWriter = \"is_writer\", // Check if a system is a writer for a model\n    grantWriter = \"grant_writer\", // Grant writer permission\n    revokeWriter = \"revoke_writer\", // Revoke writer permission\n}\n\n/**\n * World interface: An interface that defines the methods that a world must implement.\n * Dojo v0.4.0\n */\n\nexport interface IWorld {\n    // Retrieve metadata URI for a resource\n    metadataUri?(resource: string): Promise<Array<string>>;\n\n    // Set metadata URI for a resource\n    setMetadataUri?(resource: string, uri: Array<string>): Promise<void>;\n\n    // Retrieve model class hash by name\n    model?(name: string): Promise<string>;\n\n    // Register a new model\n    registerModel?(classHash: string): Promise<void>;\n\n    // Deploy a contract and return its address\n    deployContract?(salt: string, classHash: string): Promise<string>;\n\n    // Upgrade a contract and return its new class hash\n    upgradeContract?(address: string, classHash: string): Promise<string>;\n\n    // Retrieve the UUID of the world\n    uuid?(): Promise<string>;\n\n    // Retrieve entity details\n    entity?(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        length: number,\n        layout: Array<number>\n    ): Promise<Array<bigint>>;\n\n    // Set entity details\n    setEntity?(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        values: Array<string>,\n        layout: Array<number>\n    ): Promise<void>;\n\n    // Retrieve multiple entities' details\n    entities?(\n        model: string,\n        index: string | null,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>>;\n\n    // Retrieve entity IDs for a model\n    entityIds?(model: string): Promise<Array<string>>;\n\n    // Set executor for the world\n    setExecutor?(contractAddress: string): Promise<void>;\n\n    // Retrieve the executor's address\n    executor?(): Promise<string>;\n\n    // Retrieve base class hash\n    base?(): Promise<string>;\n\n    // Delete an entity\n    deleteEntity?(\n        model: string,\n        keys: Array<string>,\n        layout: Array<number>\n    ): Promise<void>;\n\n    // Check if an address is an owner of a resource\n    isOwner?(address: string, resource: string): Promise<boolean>;\n\n    // Grant ownership of a resource to an address\n    grantOwner?(address: string, resource: string): Promise<void>;\n\n    // Revoke ownership of a resource from an address\n    revokeOwner?(address: string, resource: string): Promise<void>;\n\n    // Check if a system is a writer for a model\n    isWriter?(model: string, system: string): Promise<boolean>;\n\n    // Grant writer permission to a system for a model\n    grantWriter?(model: string, system: string): Promise<void>;\n\n    // Revoke writer permission from a system for a model\n    revokeWriter?(model: string, system: string): Promise<void>;\n\n    // Get the age or duration since the World was created\n    worldAge?(): Promise<bigint>;\n}\n\nexport type DojoCall = {\n    contractName: string;\n    entrypoint: string;\n    calldata: RawArgs | Calldata;\n};\n\n/**\n * Cairo to TypeScript type mappings\n */\ntype CairoToTsTypeMap = {\n    \"core::felt252\": string;\n    \"core::integer::u8\": number;\n    \"core::integer::u16\": number;\n    \"core::integer::u32\": number;\n    \"core::integer::u64\": bigint;\n    \"core::integer::u128\": bigint;\n    \"core::integer::u256\": bigint;\n    \"core::integer::i8\": number;\n    \"core::integer::i16\": number;\n    \"core::integer::i32\": number;\n    \"core::integer::i64\": bigint;\n    \"core::integer::i128\": bigint;\n    \"core::bool\": boolean;\n    \"core::starknet::contract_address::ContractAddress\": string;\n    \"core::starknet::class_hash::ClassHash\": string;\n    \"core::byte_array::ByteArray\": string;\n    \"()\": void;\n};\n\n/**\n * Map Cairo type to TypeScript type with ABI context\n */\nexport type MapCairoType<\n    T extends string,\n    ABI extends readonly any[] = never,\n> = T extends keyof CairoToTsTypeMap\n    ? CairoToTsTypeMap[T]\n    : T extends `core::array::Array::<${infer Inner}>`\n      ? MapCairoType<Inner, ABI>[]\n      : T extends `core::array::Span::<${infer Inner}>`\n        ? MapCairoType<Inner, ABI>[]\n        : T extends `@core::array::Array::<${infer Inner}>`\n          ? MapCairoType<Inner, ABI>[]\n          : T extends `(${infer Types})`\n            ? MapTupleTypes<Types, ABI>\n            : ABI extends never\n              ? unknown\n              : T extends ExtractStructNames<ABI>\n                ? ExtractStructType<T, ABI>\n                : T extends ExtractEnumNames<ABI>\n                  ? ExtractEnumType<T, ABI>\n                  : unknown;\n\n/**\n * Extract all struct names from ABI\n */\ntype ExtractStructNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"struct\"; name: string }\n>[\"name\"];\n\n/**\n * Find the first struct with a specific name in the ABI\n * This prevents duplicate struct definitions from creating union types\n */\ntype FindFirstStructByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"struct\"; name: Name }\n        ? First\n        : FindFirstStructByName<Rest, Name>\n    : never;\n\n/**\n * Extract a specific struct type by name from ABI\n * Only uses the first occurrence of a struct with the given name\n */\ntype ExtractStructType<\n    Name extends string,\n    ABI extends readonly any[],\n> = FindFirstStructByName<ABI, Name> extends {\n    type: \"struct\";\n    name: Name;\n    members: infer M;\n}\n    ? M extends readonly { name: string; type: string }[]\n        ? {\n              [P in M[number] as P[\"name\"]]: MapCairoType<P[\"type\"], ABI>;\n          }\n        : never\n    : never;\n\n/**\n * Map tuple types\n */\ntype MapTupleTypes<\n    T extends string,\n    ABI extends readonly any[] = never,\n> = T extends `${infer First}, ${infer Rest}`\n    ? [MapCairoType<First, ABI>, ...MapTupleTypes<Rest, ABI>]\n    : T extends \"\"\n      ? []\n      : [MapCairoType<T, ABI>];\n\n// ========================\n// ABI Type Extraction\n// ========================\n\n/**\n * Extract function signature from a function item\n */\ntype ExtractFunctionSignature<\n    F,\n    ABI extends readonly any[] = never,\n> = F extends {\n    type: \"function\";\n    name: string;\n    inputs: infer I;\n    outputs: infer O;\n}\n    ? {\n          inputs: I extends readonly {\n              name: string;\n              type: string;\n          }[]\n              ? {\n                    [P in I[number] as P[\"name\"]]: MapCairoType<P[\"type\"], ABI>;\n                }\n              : never;\n          outputs: O extends readonly { type: string }[]\n              ? O[\"length\"] extends 0\n                  ? void\n                  : O[\"length\"] extends 1\n                    ? MapCairoType<O[0][\"type\"], ABI>\n                    : {\n                          [Index in keyof O]: O[Index] extends {\n                              type: string;\n                          }\n                              ? MapCairoType<O[Index][\"type\"], ABI>\n                              : never;\n                      }\n              : void;\n      }\n    : never;\n\n/**\n * Extract all types from ABI array\n */\nexport type ExtractAbiTypesFromArray<ABI> = ABI extends readonly any[]\n    ? {\n          structs: ExtractStructs<ABI>;\n          enums: ExtractEnums<ABI>;\n          functions: ExtractFunctions<ABI>;\n          interfaces: ExtractInterfaces<ABI>;\n      }\n    : never;\n\n/**\n * Helper type to extract structs from ABI\n */\ntype ExtractStructs<ABI extends readonly any[]> = {\n    [StructName in ExtractStructNames<ABI>]: ExtractStructType<StructName, ABI>;\n};\n\n/**\n * Find the first enum with a specific name in the ABI\n * This prevents duplicate enum definitions from creating union types\n */\ntype FindFirstEnumByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"enum\"; name: Name }\n        ? First\n        : FindFirstEnumByName<Rest, Name>\n    : never;\n\n/**\n * Extract all enum names from ABI\n */\ntype ExtractEnumNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"enum\"; name: string }\n>[\"name\"];\n\n/**\n * Extract just the type union of an enum by name\n * This is used for type mapping in function parameters\n */\ntype ExtractEnumType<\n    Name extends string,\n    ABI extends readonly any[],\n> = FindFirstEnumByName<ABI, Name> extends {\n    type: \"enum\";\n    name: Name;\n    variants: infer V;\n}\n    ? V extends readonly { name: string; type: string }[]\n        ? V[number][\"name\"]\n        : never\n    : never;\n\n/**\n * Helper type to extract enums from ABI\n */\ntype ExtractEnums<ABI extends readonly any[]> = {\n    [EnumName in ExtractEnumNames<ABI>]: FindFirstEnumByName<\n        ABI,\n        EnumName\n    > extends {\n        type: \"enum\";\n        name: EnumName;\n        variants: infer V;\n    }\n        ? V extends readonly { name: string; type: string }[]\n            ? {\n                  variants: {\n                      [P in V[number] as P[\"name\"]]: MapCairoType<\n                          P[\"type\"],\n                          ABI\n                      >;\n                  };\n                  type: V[number][\"name\"];\n              }\n            : never\n        : never;\n};\n\n/**\n * Find the first function with a specific name in the ABI\n * This prevents duplicate function definitions from creating union types\n */\ntype FindFirstFunctionByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"function\"; name: Name }\n        ? First\n        : FindFirstFunctionByName<Rest, Name>\n    : never;\n\n/**\n * Extract all function names from ABI\n */\ntype ExtractFunctionNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"function\"; name: string }\n>[\"name\"];\n\n/**\n * Helper type to extract functions from ABI\n */\ntype ExtractFunctions<ABI extends readonly any[]> = {\n    [FunctionName in ExtractFunctionNames<ABI>]: ExtractFunctionSignature<\n        FindFirstFunctionByName<ABI, FunctionName>,\n        ABI\n    >;\n};\n\n/**\n * Find the first interface with a specific name in the ABI\n * This prevents duplicate interface definitions from creating union types\n */\ntype FindFirstInterfaceByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"interface\"; name: Name }\n        ? First\n        : FindFirstInterfaceByName<Rest, Name>\n    : never;\n\n/**\n * Extract all interface names from ABI\n */\ntype ExtractInterfaceNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"interface\"; name: string }\n>[\"name\"];\n\n/**\n * Helper type to extract interfaces from ABI\n */\ntype ExtractInterfaces<ABI extends readonly any[]> = {\n    [InterfaceName in ExtractInterfaceNames<ABI>]: FindFirstInterfaceByName<\n        ABI,\n        InterfaceName\n    > extends {\n        type: \"interface\";\n        name: InterfaceName;\n        items: infer Items;\n    }\n        ? Items extends readonly any[]\n            ? {\n                  [F in Items[number] as F extends {\n                      type: \"function\";\n                      name: infer FN;\n                  }\n                      ? FN extends string\n                          ? FN\n                          : never\n                      : never]: ExtractFunctionSignature<F, ABI>;\n              }\n            : {}\n        : never;\n};\n\n/**\n * Main exported type for extracting ABI types\n * Usage:\n * - Compiled ABI: type MyAbi = ExtractAbiTypes<typeof compiledAbi>\n * - Raw ABI array: type MyAbi = ExtractAbiTypes<typeof abi>\n */\nexport type ExtractAbiTypes<T> = T extends { abi: infer ABI }\n    ? ABI extends readonly any[]\n        ? ExtractAbiTypesFromArray<ABI>\n        : never\n    : T extends readonly any[]\n      ? ExtractAbiTypesFromArray<T>\n      : never;\n","import { Call, CallData, TypedData } from \"starknet\";\n\nimport { DojoCall } from \"../types\";\n\n/**\n * Gets a contract from a manifest by name.\n *\n * @param {any} manifest - The manifest object.\n * @param {string} name - The name of the contract.\n * @returns {any} The contract object.\n *\n */\nexport const getContractByName = (\n    manifest: any,\n    nameSpace: string,\n    name: string\n) => {\n    return manifest.contracts.find((contract: any) => {\n        return contract.tag === nameSpace + \"-\" + name;\n    });\n};\n\n/**\n * Convert a DojoCall to a Call replacing contractName with contractAddress\n *\n * @param {any} manifest - The manifest object.\n * @param {DojoCall | Call} call - A DojoCall or Call\n * @returns {Call} The contract object.\n *\n */\nexport const parseDojoCall = (\n    manifest: any,\n    nameSpace: string,\n    call: DojoCall | Call\n): Call => {\n    if (\"contractName\" in call) {\n        const contract = getContractByName(\n            manifest,\n            nameSpace,\n            call.contractName\n        );\n\n        return {\n            contractAddress: contract.address,\n            calldata: new CallData(contract.abi).compile(\n                call.entrypoint,\n                call.calldata\n            ),\n            entrypoint: call.entrypoint,\n        };\n    }\n\n    return call;\n};\n\n/**\n * Parses a model name into a class name.\n *\n * @param {any} model - The model object.\n * @returns {string} The class name.\n *\n */\nexport const parseModelName = (model: any) => {\n    // Define a set of known acronyms\n    const acronyms = new Set([\"ERC\"]);\n\n    return model.name\n        .split(\"::\")\n        .pop()\n        .split(\"_\")\n        .map((part: string) => {\n            // If the part is a known acronym, keep it in uppercase\n            if (acronyms.has(part.toUpperCase())) {\n                return part.toUpperCase();\n            }\n            // If the part is fully numeric, keep it as is\n            if (!isNaN(parseInt(part))) {\n                return part;\n            }\n            // Capitalize the first letter and make the rest lowercase\n            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n        })\n        .join(\"\");\n};\n\n/**\n * Creates a model typed data object.\n *\n * @param {any} model - The model object.\n * @returns {any} The model typed data object.\n *\n */\nexport const createModelTypedData = (name: string, model: any): TypedData => {\n    const typesFromSchema = (\n        name: string,\n        schema: any,\n        types: { [typeName: string]: { name: string; type: string }[] }\n    ) => {\n        Object.entries(schema).forEach(([key, value]) => {\n            let typeName = value?.constructor.name;\n            switch (typeName) {\n                case \"Object\":\n                    typesFromSchema(key, value, types);\n                    break;\n                case \"BigInt\":\n                    types[name].push({ name: key, type: \"felt\" });\n                    break;\n                case \"String\":\n                    types[name].push({ name: key, type: \"shortstring\" });\n                    break;\n                case \"Number\":\n                    types[name].push({ name: key, type: \"u128\" });\n                    break;\n                case \"Boolean\":\n                    types[name].push({ name: key, type: \"bool\" });\n                    break;\n                default:\n                    throw new Error(`Unsupported type: ${typeName}`);\n            }\n        });\n        return types;\n    };\n\n    return {\n        types: typesFromSchema(\"Model\", model, {\n            StarknetDomain: [\n                { name: \"name\", type: \"shortstring\" },\n                { name: \"version\", type: \"shortstring\" },\n                { name: \"chainId\", type: \"shortstring\" },\n                { name: \"revision\", type: \"shortstring\" },\n            ],\n            OffchainMessage: [\n                { name: \"model\", type: \"shortstring\" },\n                { name: name, type: \"Model\" },\n            ],\n            Model: [],\n        }),\n        primaryType: \"OffchainMessage\",\n        domain: {\n            name: \"Dojo\",\n            version: \"1\",\n            chainId: \"1\",\n            revision: \"1\",\n        },\n        message: {\n            model: name,\n            [name]: Object.fromEntries(\n                Object.entries(model).map(([k, v]) => {\n                    if (typeof v === \"bigint\") {\n                        return [k, \"0x\" + v.toString(16)];\n                    }\n\n                    return [k, v];\n                })\n            ),\n        },\n    };\n};\n","import { IWorld } from \"../types\";\n\n/**\n * Provider class: An abstract base class for all providers.\n * It implements the ICommands interface, ensuring that any class deriving from Provider\n * will have implementations for the entity and entities methods.\n */\nexport abstract class Provider implements IWorld {\n    // Store the address of the world.\n    private readonly worldAddress: string;\n\n    /**\n     * Constructor: Initializes the Provider with a given world address.\n     *\n     * @param {string} worldAddress - The address of the world.\n     */\n    constructor(worldAddress: string) {\n        this.worldAddress = worldAddress;\n    }\n\n    /**\n     * Abstract method to retrieve a single entity's details.\n     * Classes extending Provider should provide a concrete implementation for this method.\n     *\n     * @param {string} component - The component to query.\n     * @param {Query} query - The query details.\n     * @param {number} offset - Starting offset.\n     * @param {number} length - Length to retrieve.\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.\n     */\n    public abstract entity(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        length: number,\n        layout: Array<number>\n    ): Promise<Array<bigint>>;\n\n    /**\n     * Abstract method to retrieve multiple entities' details.\n     * Classes extending Provider should provide a concrete implementation for this method.\n     *\n     * @param {string} component - The component to query.\n     * @param {number} length - Number of entities to retrieve.\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entities' details.\n     */\n    public abstract entities(\n        model: string,\n        index: string | null,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>>;\n\n    /**\n     * Retrieves the stored world address.\n     *\n     * @returns {string} - The address of the world.\n     */\n    public getWorldAddress(): string {\n        return this.worldAddress;\n    }\n}\n","import {\n    KATANA_CLASS_HASH,\n    KATANA_ETH_CONTRACT_ADDRESS,\n    KATANA_PREFUNDED_ADDRESS,\n    KATANA_PREFUNDED_PRIVATE_KEY,\n    LOCAL_KATANA,\n    LOCAL_TORII,\n} from \"../constants\";\n\nexport type DojoConfig = ReturnType<typeof createDojoConfig>;\n\ninterface DojoConfigParams {\n    rpcUrl?: string;\n    toriiUrl?: string;\n    masterAddress?: string;\n    masterPrivateKey?: string;\n    accountClassHash?: string;\n    feeTokenAddress?: string;\n    manifest: any;\n}\n\n/**\n * Create Dojo Config: Creates a Dojo Config object. If no parameters are passed, it will use the default values of the current Dojo version.\n */\nexport function createDojoConfig({ manifest, ...config }: DojoConfigParams) {\n    return {\n        rpcUrl: config.rpcUrl ?? LOCAL_KATANA,\n        toriiUrl: config.toriiUrl ?? LOCAL_TORII,\n        masterAddress: config.masterAddress ?? KATANA_PREFUNDED_ADDRESS,\n        masterPrivateKey:\n            config.masterPrivateKey ?? KATANA_PREFUNDED_PRIVATE_KEY,\n        accountClassHash: config.accountClassHash ?? KATANA_CLASS_HASH,\n        feeTokenAddress: config.feeTokenAddress ?? KATANA_ETH_CONTRACT_ADDRESS,\n        manifest,\n    };\n}\n","import { z } from \"zod\";\n\nconst abiItem = z.union([\n    z.object({\n        type: z.literal(\"impl\"),\n        name: z.string(),\n        interface_name: z.string(),\n    }),\n    z.object({\n        type: z.literal(\"struct\"),\n        name: z.string(),\n        members: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"enum\"),\n        name: z.string(),\n        variants: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"interface\"),\n        name: z.string(),\n        items: z.array(\n            z.object({\n                type: z.literal(\"function\"),\n                name: z.string(),\n                inputs: z.array(\n                    z.object({ name: z.string(), type: z.string() })\n                ),\n                outputs: z.array(z.object({ type: z.string() })),\n                state_mutability: z.string(),\n            })\n        ),\n    }),\n    z.object({\n        type: z.literal(\"constructor\"),\n        name: z.string(),\n        inputs: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"event\"),\n        name: z.string(),\n        kind: z.literal(\"struct\"),\n        members: z.array(\n            z.object({ name: z.string(), type: z.string(), kind: z.string() })\n        ),\n    }),\n    z.object({\n        type: z.literal(\"event\"),\n        name: z.string(),\n        kind: z.literal(\"enum\"),\n        variants: z.array(\n            z.object({ name: z.string(), type: z.string(), kind: z.string() })\n        ),\n    }),\n]);\n\nconst generalFields = z.object({\n    class_hash: z.string(),\n    name: z.string(),\n    abi: z.array(abiItem),\n});\n\nconst world = generalFields.extend({\n    kind: z.literal(\"WorldContract\"),\n    address: z.string(),\n    transaction_hash: z.string(),\n    block_number: z.number(),\n    seed: z.string(),\n    metadata: z.object({\n        rpc_url: z.string(),\n    }),\n});\n\nconst base = generalFields.extend({\n    kind: z.literal(\"Class\"),\n    abi: z.literal(null),\n});\n\nconst contract = generalFields.extend({\n    kind: z.literal(\"DojoContract\"),\n    address: z.string(),\n    reads: z.array(z.unknown()),\n    writes: z.array(z.unknown()),\n    computed: z.array(z.unknown()),\n});\n\nconst model = generalFields.extend({\n    kind: z.literal(\"DojoModel\"),\n    members: z.array(\n        z.object({\n            name: z.string(),\n            type: z.string(),\n            key: z.boolean(),\n        })\n    ),\n});\n\nconst manifestSchema = z.object({\n    world: world,\n    base,\n    contracts: z.array(contract),\n    models: z.array(model),\n});\n\nexport type Manifest = z.infer<typeof manifestSchema>;\n\nexport const createManifestFromJson = (content: any): Manifest => {\n    try {\n        return manifestSchema.parse(content);\n    } catch (error) {\n        console.error(error);\n        throw new Error(\"Invalid Dojo manifest.json\");\n    }\n};\n"],"mappings":"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","names":["WorldEntryPoints","contract","model","name","model","contract"]}