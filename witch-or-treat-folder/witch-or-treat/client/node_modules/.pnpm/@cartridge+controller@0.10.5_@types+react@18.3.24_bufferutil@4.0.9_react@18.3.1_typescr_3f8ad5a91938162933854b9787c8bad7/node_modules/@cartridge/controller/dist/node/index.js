import { stark, ec, encode, WalletAccount, hash, typedData, TypedDataRevision, CallData, addAddressPadding } from 'starknet';
import { signerToGuid } from '@cartridge/controller-wasm';
import { CartridgeSessionAccount } from '@cartridge/controller-wasm/session';
import { Permission } from '@starknet-io/types-js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as http from 'http';

// src/node/provider.ts
function normalizeCalls(calls) {
  return toArray(calls).map((call) => {
    return {
      entrypoint: call.entrypoint,
      contractAddress: addAddressPadding(call.contractAddress),
      calldata: CallData.toHex(call.calldata)
    };
  });
}
function toWasmPolicies(policies) {
  return [
    ...Object.entries(policies.contracts ?? {}).flatMap(
      ([target, { methods }]) => toArray(methods).map((m) => ({
        target,
        method: hash.getSelectorFromName(m.entrypoint),
        authorized: m.authorized
      }))
    ),
    ...(policies.messages ?? []).map((p) => {
      const domainHash = typedData.getStructHash(
        p.types,
        "StarknetDomain",
        p.domain,
        TypedDataRevision.ACTIVE
      );
      const typeHash = typedData.getTypeHash(
        p.types,
        p.primaryType,
        TypedDataRevision.ACTIVE
      );
      return {
        scope_hash: hash.computePoseidonHash(domainHash, typeHash),
        authorized: p.authorized
      };
    })
  ];
}
function toArray(val) {
  return Array.isArray(val) ? val : [val];
}

// src/errors.ts
var NotReadyToConnect = class _NotReadyToConnect extends Error {
  constructor() {
    super("Not ready to connect");
    Object.setPrototypeOf(this, _NotReadyToConnect.prototype);
  }
};

// src/node/account.ts
var SessionAccount = class extends WalletAccount {
  controller;
  constructor(provider, {
    rpcUrl,
    privateKey,
    address,
    ownerGuid,
    chainId,
    expiresAt,
    policies,
    guardianKeyGuid,
    metadataHash,
    sessionKeyGuid
  }) {
    super({
      provider: { nodeUrl: rpcUrl },
      walletProvider: provider,
      address
    });
    this.address = address;
    this.controller = CartridgeSessionAccount.newAsRegistered(
      rpcUrl,
      privateKey,
      address,
      ownerGuid,
      chainId,
      {
        expiresAt,
        policies,
        guardianKeyGuid,
        metadataHash,
        sessionKeyGuid
      }
    );
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   *
   * @returns response from addTransaction
   */
  async execute(calls) {
    try {
      const res = await this.controller.executeFromOutside(
        normalizeCalls(calls)
      );
      return res;
    } catch (e) {
      return this.controller.execute(normalizeCalls(calls));
    }
  }
};

// src/constants.ts
var KEYCHAIN_URL = "https://x.cartridge.gg";

// package.json
var package_default = {
  version: "0.10.5"};

// src/icon.ts
var icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K";

// src/mutex.ts
function releaseStub() {
}
var Mutex = class {
  m_lastPromise = Promise.resolve();
  /**
   * Acquire lock
   * @param [bypass=false] option to skip lock acquisition
   */
  async obtain(bypass = false) {
    let release = releaseStub;
    if (bypass) return release;
    const lastPromise = this.m_lastPromise;
    this.m_lastPromise = new Promise((resolve) => release = resolve);
    await lastPromise;
    return release;
  }
};

// src/provider.ts
var mutex = new Mutex();
var BaseProvider = class {
  id = "controller";
  name = "Controller";
  version = package_default.version;
  icon = icon;
  account;
  subscriptions = [];
  _probePromise = null;
  async safeProbe() {
    if (this.account) {
      return this.account;
    }
    if (this._probePromise) {
      return this._probePromise;
    }
    const release = await mutex.obtain();
    return await new Promise(async (resolve) => {
      try {
        this._probePromise = this.probe();
        const result = await this._probePromise;
        resolve(result);
      } finally {
        this._probePromise = null;
      }
    }).finally(() => {
      release();
    });
  }
  request = async (call) => {
    switch (call.type) {
      case "wallet_getPermissions":
        await this.safeProbe();
        if (this.account) {
          return [Permission.ACCOUNTS];
        }
        return [];
      case "wallet_requestAccounts": {
        if (this.account) {
          return [this.account.address];
        }
        const silentMode = call.params && call.params.silent_mode;
        this.account = await this.safeProbe();
        if (!this.account && !silentMode) {
          this.account = await this.connect();
        }
        if (this.account) {
          return [this.account.address];
        }
        return [];
      }
      case "wallet_watchAsset":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_watchAsset not implemented"
        };
      case "wallet_addStarknetChain": {
        let params2 = call.params;
        return this.addStarknetChain(params2);
      }
      case "wallet_switchStarknetChain": {
        let params2 = call.params;
        return this.switchStarknetChain(params2.chainId);
      }
      case "wallet_requestChainId":
        if (!this.account) {
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        }
        return await this.account.getChainId();
      case "wallet_deploymentData":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_deploymentData not implemented"
        };
      case "wallet_addInvokeTransaction":
        if (!this.account) {
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        }
        let params = call.params;
        return await this.account.execute(
          params.calls.map((call2) => ({
            contractAddress: call2.contract_address,
            entrypoint: call2.entry_point,
            calldata: call2.calldata
          }))
        );
      case "wallet_addDeclareTransaction":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_addDeclareTransaction not implemented"
        };
      case "wallet_signTypedData": {
        if (!this.account) {
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        }
        return await this.account.signMessage(call.params);
      }
      case "wallet_supportedSpecs":
        return [];
      case "wallet_supportedWalletApi":
        return [];
      default:
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: `Unknown RPC call type: ${call.type}`
        };
    }
  };
  on = (event, handler) => {
    if (event !== "accountsChanged" && event !== "networkChanged") {
      throw new Error(`Unknown event: ${event}`);
    }
    this.subscriptions.push({ type: event, handler });
  };
  off = (event, handler) => {
    if (event !== "accountsChanged" && event !== "networkChanged") {
      throw new Error(`Unknown event: ${event}`);
    }
    const idx = this.subscriptions.findIndex(
      (sub) => sub.type === event && sub.handler === handler
    );
    if (idx >= 0) {
      this.subscriptions.splice(idx, 1);
    }
  };
  emitNetworkChanged(chainId) {
    this.subscriptions.filter((sub) => sub.type === "networkChanged").forEach((sub) => {
      sub.handler(chainId);
    });
  }
  emitAccountsChanged(accounts) {
    this.subscriptions.filter((sub) => sub.type === "accountsChanged").forEach((sub) => {
      sub.handler(accounts);
    });
  }
};
var CallbackServer = class {
  server;
  resolveCallback;
  rejectCallback;
  timeoutId;
  constructor() {
    this.server = http.createServer(this.handleRequest.bind(this));
    this.server.on("error", (error) => {
      console.error("Server error:", error);
      if (this.rejectCallback) {
        this.rejectCallback(error);
      }
    });
  }
  cleanup() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.server.close();
  }
  handleRequest(req, res) {
    if (!req.url?.startsWith("/callback")) {
      res.writeHead(404);
      res.end();
      return;
    }
    const params = new URLSearchParams(req.url.split("?")[1]);
    const session = params.get("startapp");
    if (!session) {
      console.warn("Received callback without session data");
      res.writeHead(400);
      res.end("Missing session data");
      return;
    }
    if (this.resolveCallback) {
      this.resolveCallback(session);
    }
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(
      "<html><body><script>window.close();</script>Session registered successfully. You can close this window.</body></html>"
    );
    this.cleanup();
  }
  async listen() {
    return new Promise((resolve, reject) => {
      this.server.listen(0, "localhost", () => {
        const address = this.server.address();
        const url = `http://localhost:${address.port}/callback`;
        resolve(url);
      });
      this.server.on("error", reject);
    });
  }
  async waitForCallback() {
    return new Promise((resolve, reject) => {
      this.resolveCallback = resolve;
      this.rejectCallback = reject;
      this.timeoutId = setTimeout(
        () => {
          console.warn("Callback timeout reached");
          reject(new Error("Callback timeout after 5 minutes"));
          this.cleanup();
        },
        5 * 60 * 1e3
      );
    });
  }
};

// src/node/backend.ts
var NodeBackend = class {
  basePath;
  sessionFile;
  data = {};
  callbackServer;
  constructor(basePath) {
    if (!basePath) {
      throw new Error("basePath is required for NodeBackend");
    }
    this.basePath = basePath;
    this.sessionFile = path.join(this.basePath, "session.json");
  }
  async ensureDirectoryExists() {
    try {
      await fs.access(this.basePath);
    } catch {
      try {
        await fs.mkdir(this.basePath, { recursive: true });
      } catch (error) {
        throw new Error(
          `Failed to create directory ${this.basePath}: ${error.message}`
        );
      }
    }
  }
  async loadData() {
    try {
      const content = await fs.readFile(this.sessionFile, "utf-8");
      const parsed = JSON.parse(content);
      if (typeof parsed !== "object" || parsed === null) {
        throw new Error("Invalid session data format");
      }
      this.data = parsed;
    } catch (error) {
      if (error instanceof Error) {
        if (error.code !== "ENOENT") {
          throw new Error(`Failed to load session data: ${error.message}`);
        }
      }
      this.data = {};
    }
  }
  async saveData() {
    try {
      await this.ensureDirectoryExists();
      await fs.writeFile(
        this.sessionFile,
        JSON.stringify(this.data, null, 2),
        "utf-8"
      );
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to save session data: ${error.message}`);
      }
      throw error;
    }
  }
  async get(key) {
    if (!key) {
      throw new Error("Key is required");
    }
    await this.loadData();
    return this.data[key] ? JSON.stringify(this.data[key]) : null;
  }
  async set(key, value) {
    if (!key) {
      throw new Error("Key is required");
    }
    if (!value) {
      throw new Error("Value is required");
    }
    await this.loadData();
    try {
      this.data[key] = JSON.parse(value);
      await this.saveData();
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to set ${key}: ${error.message}`);
      }
      throw error;
    }
  }
  async delete(key) {
    if (!key) {
      throw new Error("Key is required");
    }
    await this.loadData();
    delete this.data[key];
    await this.saveData();
  }
  async getRedirectUri() {
    try {
      this.callbackServer = new CallbackServer();
      return await this.callbackServer.listen();
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to start callback server: ${error.message}`);
      }
      throw error;
    }
  }
  async waitForCallback() {
    if (!this.callbackServer) {
      throw new Error("Callback server not initialized");
    }
    return await this.callbackServer.waitForCallback();
  }
  openLink(url) {
    if (!url) {
      throw new Error("URL is required");
    }
    console.log(`
	 Open url to authorize session: ${url}`);
  }
};

// src/node/provider.ts
var SessionProvider = class extends BaseProvider {
  id = "controller_session";
  name = "Controller Session";
  _chainId;
  _rpcUrl;
  _username;
  _policies;
  _keychainUrl;
  _backend;
  constructor({
    rpc,
    chainId,
    policies,
    basePath,
    keychainUrl
  }) {
    super();
    this._policies = {
      verified: false,
      contracts: policies.contracts ? Object.fromEntries(
        Object.entries(policies.contracts).map(([address, contract]) => [
          address,
          {
            ...contract,
            methods: contract.methods.map((method) => ({
              ...method,
              authorized: true
            }))
          }
        ])
      ) : void 0,
      messages: policies.messages?.map((message) => ({
        ...message,
        authorized: true
      }))
    };
    this._rpcUrl = rpc;
    this._chainId = chainId;
    this._keychainUrl = keychainUrl || KEYCHAIN_URL;
    this._backend = new NodeBackend(basePath);
  }
  async username() {
    const sessionStr = await this._backend.get("session");
    if (sessionStr) {
      const session = JSON.parse(sessionStr);
      return session.username;
    }
    return void 0;
  }
  async probe() {
    if (this.account) {
      return this.account;
    }
    const [sessionStr, signerStr] = await Promise.all([
      this._backend.get("session"),
      this._backend.get("signer")
    ]);
    if (!sessionStr || !signerStr) {
      return void 0;
    }
    const session = JSON.parse(sessionStr);
    const signer = JSON.parse(signerStr);
    const expirationTime = parseInt(session.expiresAt) * 1e3;
    if (Date.now() >= expirationTime) {
      await this.disconnect();
      return void 0;
    }
    this._username = session.username;
    this.account = new SessionAccount(this, {
      rpcUrl: this._rpcUrl,
      privateKey: signer.privKey,
      address: session.address,
      ownerGuid: session.ownerGuid,
      chainId: this._chainId,
      expiresAt: parseInt(session.expiresAt),
      policies: toWasmPolicies(this._policies),
      guardianKeyGuid: session.guardianKeyGuid,
      metadataHash: session.metadataHash,
      sessionKeyGuid: session.sessionKeyGuid
    });
    return this.account;
  }
  async connect() {
    if (this.account) {
      return this.account;
    }
    const account = await this.probe();
    if (account) {
      return account;
    }
    const pk = stark.randomAddress();
    const publicKey = ec.starkCurve.getStarkKey(pk);
    await this._backend.set(
      "signer",
      JSON.stringify({
        privKey: pk,
        pubKey: publicKey
      })
    );
    const redirectUri = await this._backend.getRedirectUri();
    const url = `${this._keychainUrl}/session?public_key=${encodeURIComponent(publicKey)}&redirect_uri=${encodeURIComponent(
      redirectUri
    )}&redirect_query_name=startapp&policies=${encodeURIComponent(
      JSON.stringify(this._policies)
    )}&rpc_url=${encodeURIComponent(this._rpcUrl)}`;
    this._backend.openLink(url);
    const sessionData = await this._backend.waitForCallback();
    if (sessionData) {
      const sessionRegistration = JSON.parse(atob(sessionData));
      const formattedPk = encode.addHexPrefix(publicKey);
      sessionRegistration.address = sessionRegistration.address.toLowerCase();
      sessionRegistration.ownerGuid = sessionRegistration.ownerGuid.toLowerCase();
      sessionRegistration.guardianKeyGuid = "0x0";
      sessionRegistration.metadataHash = "0x0";
      sessionRegistration.sessionKeyGuid = signerToGuid({
        starknet: { privateKey: formattedPk }
      });
      await this._backend.set("session", JSON.stringify(sessionRegistration));
      return this.probe();
    }
    return void 0;
  }
  async disconnect() {
    await this._backend.delete("signer");
    await this._backend.delete("session");
    this.account = void 0;
    this._username = void 0;
  }
  switchStarknetChain(_chainId) {
    throw new Error("switchStarknetChain not implemented");
  }
  addStarknetChain(_chain) {
    throw new Error("addStarknetChain not implemented");
  }
};

export { NotReadyToConnect, SessionProvider as default };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map