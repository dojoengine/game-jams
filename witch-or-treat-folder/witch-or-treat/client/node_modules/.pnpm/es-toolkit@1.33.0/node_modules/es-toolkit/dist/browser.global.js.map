{"version":3,"file":"browser.global.js","sources":["../src/array/at.ts","../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/array/flatten.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/array/last.ts","../src/array/pull.ts","../src/array/sample.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/uniq.ts","../src/array/uniqBy.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/unzip.ts","../src/array/zip.ts","../src/error/AbortError.ts","../src/error/TimeoutError.ts","../src/function/after.ts","../src/function/ary.ts","../src/function/debounce.ts","../src/function/flow.ts","../src/function/identity.ts","../src/function/noop.ts","../src/function/partial.ts","../src/function/partialRight.ts","../src/promise/delay.ts","../src/promise/semaphore.ts","../src/promise/timeout.ts","../src/function/retry.ts","../src/math/mean.ts","../src/math/sum.ts","../src/math/median.ts","../src/math/range.ts","../src/predicate/isPrimitive.ts","../src/predicate/isTypedArray.ts","../src/object/clone.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/compat/_internal/tags.ts","../src/object/cloneDeepWith.ts","../src/object/cloneDeep.ts","../src/object/findKey.ts","../src/predicate/isPlainObject.ts","../src/object/flattenObject.ts","../src/object/mapKeys.ts","../src/object/mapValues.ts","../src/object/merge.ts","../src/compat/predicate/isObjectLike.ts","../src/predicate/isBlob.ts","../src/predicate/isBuffer.ts","../src/compat/util/eq.ts","../src/predicate/isEqualWith.ts","../src/predicate/isJSONValue.ts","../src/predicate/isLength.ts","../src/predicate/isNil.ts","../src/predicate/isNull.ts","../src/predicate/isSymbol.ts","../src/predicate/isUndefined.ts","../src/string/capitalize.ts","../src/string/words.ts","../src/string/deburr.ts","../src/string/escape.ts","../src/string/trimEnd.ts","../src/string/trimStart.ts","../src/string/trim.ts","../src/string/unescape.ts","../src/compat/_internal/toArray.ts","../src/compat/predicate/isArrayLike.ts","../src/compat/predicate/isArrayLikeObject.ts","../src/compat/array/last.ts","../src/compat/_internal/flattenArrayLike.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/_internal/toKey.ts","../src/compat/util/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/predicate/isObject.ts","../src/compat/predicate/isMatch.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeepWith.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/util/iteratee.ts","../src/compat/predicate/isSymbol.ts","../src/compat/util/toNumber.ts","../src/compat/util/toFinite.ts","../src/compat/util/toInteger.ts","../src/compat/_internal/isIterateeCall.ts","../src/compat/predicate/isString.ts","../src/compat/predicate/isArray.ts","../src/compat/array/flatten.ts","../src/compat/array/forEach.ts","../src/compat/array/head.ts","../src/array/head.ts","../src/compat/array/uniq.ts","../src/compat/array/intersectionWith.ts","../src/compat/_internal/compareValues.ts","../src/compat/_internal/isKey.ts","../src/compat/array/orderBy.ts","../src/compat/predicate/isNaN.ts","../src/compat/predicate/isNil.ts","../src/compat/array/sortedIndexBy.ts","../src/compat/predicate/isNumber.ts","../src/compat/object/set.ts","../src/compat/function/attempt.ts","../src/compat/function/bind.ts","../src/compat/function/bindKey.ts","../src/compat/function/curry.ts","../src/compat/function/curryRight.ts","../src/compat/function/debounce.ts","../src/compat/_internal/decimalAdjust.ts","../src/compat/math/clamp.ts","../src/math/clamp.ts","../src/compat/util/toString.ts","../src/compat/math/sumBy.ts","../src/compat/_internal/isPrototype.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/util/times.ts","../src/compat/object/keysIn.ts","../src/compat/object/assignIn.ts","../src/compat/object/defaults.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/object/mergeWith.ts","../src/compat/object/unset.ts","../src/compat/predicate/conformsTo.ts","../src/compat/predicate/isMap.ts","../src/predicate/isMap.ts","../src/compat/_internal/normalizeForCase.ts","../src/compat/string/escape.ts","../src/compat/string/template.ts","../src/compat/util/invoke.ts","../src/compat/_internal/MAX_SAFE_INTEGER.ts","../src/compat/util/uniqueId.ts","../src/promise/mutex.ts","../src/compat/math/add.ts","../src/compat/function/after.ts","../src/compat/function/ary.ts","../src/function/asyncNoop.ts","../src/compat/function/before.ts","../src/compat/string/camelCase.ts","../src/string/camelCase.ts","../src/compat/array/castArray.ts","../src/compat/math/ceil.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/compat/array/compact.ts","../src/array/compact.ts","../src/compat/array/concat.ts","../src/compat/predicate/conforms.ts","../src/compat/util/constant.ts","../src/string/constantCase.ts","../src/array/countBy.ts","../src/compat/string/deburr.ts","../src/compat/util/defaultTo.ts","../src/compat/function/defer.ts","../src/compat/function/delay.ts","../src/compat/array/difference.ts","../src/compat/array/differenceBy.ts","../src/compat/array/differenceWith.ts","../src/compat/math/divide.ts","../src/compat/array/drop.ts","../src/array/drop.ts","../src/compat/array/dropRight.ts","../src/array/dropRight.ts","../src/compat/array/dropRightWhile.ts","../src/compat/array/dropWhile.ts","../src/compat/string/endsWith.ts","../src/compat/string/escapeRegExp.ts","../src/string/escapeRegExp.ts","../src/compat/array/every.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/filter.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/compat/object/findKey.ts","../src/compat/array/findLast.ts","../src/compat/array/findLastIndex.ts","../src/array/flatMap.ts","../src/array/flatMapDeep.ts","../src/array/flattenDeep.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/flattenDepth.ts","../src/compat/function/flip.ts","../src/compat/math/floor.ts","../src/compat/function/flow.ts","../src/compat/function/flowRight.ts","../src/function/flowRight.ts","../src/array/forEachRight.ts","../src/compat/object/fromPairs.ts","../src/array/groupBy.ts","../src/compat/util/gt.ts","../src/compat/util/gte.ts","../src/compat/math/inRange.ts","../src/math/inRange.ts","../src/compat/array/includes.ts","../src/compat/array/indexOf.ts","../src/array/initial.ts","../src/compat/array/intersection.ts","../src/compat/array/intersectionBy.ts","../src/util/invariant.ts","../src/object/invert.ts","../src/compat/object/invertBy.ts","../src/compat/predicate/isArrayBuffer.ts","../src/predicate/isArrayBuffer.ts","../src/compat/predicate/isBoolean.ts","../src/compat/predicate/isBuffer.ts","../src/compat/predicate/isDate.ts","../src/predicate/isDate.ts","../src/compat/predicate/isElement.ts","../src/compat/predicate/isEmpty.ts","../src/predicate/isEqual.ts","../src/compat/predicate/isEqualWith.ts","../src/compat/predicate/isError.ts","../src/predicate/isFile.ts","../src/compat/predicate/isFinite.ts","../src/predicate/isFunction.ts","../src/compat/predicate/isInteger.ts","../src/predicate/isJSON.ts","../src/predicate/isNotNil.ts","../src/predicate/isPromise.ts","../src/compat/predicate/isRegExp.ts","../src/predicate/isRegExp.ts","../src/compat/predicate/isSafeInteger.ts","../src/compat/predicate/isSet.ts","../src/predicate/isSet.ts","../src/array/isSubset.ts","../src/array/isSubsetWith.ts","../src/compat/predicate/isWeakMap.ts","../src/predicate/isWeakMap.ts","../src/compat/predicate/isWeakSet.ts","../src/predicate/isWeakSet.ts","../src/compat/array/join.ts","../src/compat/string/kebabCase.ts","../src/string/kebabCase.ts","../src/array/keyBy.ts","../src/compat/object/keys.ts","../src/compat/array/lastIndexOf.ts","../src/compat/string/lowerCase.ts","../src/string/lowerCase.ts","../src/compat/string/lowerFirst.ts","../src/string/lowerFirst.ts","../src/compat/util/lt.ts","../src/compat/util/lte.ts","../src/compat/array/map.ts","../src/compat/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/compat/math/max.ts","../src/compat/math/maxBy.ts","../src/array/maxBy.ts","../src/math/meanBy.ts","../src/math/medianBy.ts","../src/function/memoize.ts","../src/compat/object/merge.ts","../src/compat/util/method.ts","../src/compat/util/methodOf.ts","../src/compat/math/min.ts","../src/array/minBy.ts","../src/compat/math/multiply.ts","../src/compat/function/negate.ts","../src/compat/util/now.ts","../src/compat/array/nth.ts","../src/compat/function/nthArg.ts","../src/compat/object/omit.ts","../src/object/omitBy.ts","../src/function/once.ts","../src/compat/string/pad.ts","../src/string/pad.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/compat/math/parseInt.ts","../src/array/partition.ts","../src/string/pascalCase.ts","../src/compat/object/pick.ts","../src/compat/object/pickBy.ts","../src/compat/object/propertyOf.ts","../src/compat/array/pull.ts","../src/compat/array/pullAll.ts","../src/compat/array/pullAllBy.ts","../src/array/pullAt.ts","../src/compat/math/random.ts","../src/compat/math/range.ts","../src/compat/math/rangeRight.ts","../src/compat/function/rearg.ts","../src/compat/array/reduce.ts","../src/compat/array/reduceRight.ts","../src/compat/array/remove.ts","../src/array/remove.ts","../src/compat/string/repeat.ts","../src/compat/string/replace.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/compat/array/reverse.ts","../src/string/reverseString.ts","../src/compat/math/round.ts","../src/compat/array/sample.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/array/size.ts","../src/compat/array/slice.ts","../src/compat/string/snakeCase.ts","../src/string/snakeCase.ts","../src/compat/array/some.ts","../src/compat/array/sortBy.ts","../src/compat/array/sortedIndex.ts","../src/compat/function/spread.ts","../src/compat/string/startCase.ts","../src/compat/string/startsWith.ts","../src/compat/util/stubArray.ts","../src/compat/util/stubFalse.ts","../src/compat/util/stubObject.ts","../src/compat/util/stubString.ts","../src/compat/util/stubTrue.ts","../src/compat/math/subtract.ts","../src/compat/math/sum.ts","../src/compat/array/tail.ts","../src/array/tail.ts","../src/compat/array/take.ts","../src/array/take.ts","../src/compat/array/takeRight.ts","../src/array/takeRight.ts","../src/compat/array/takeRightWhile.ts","../src/function/negate.ts","../src/array/takeWhile.ts","../src/compat/function/throttle.ts","../src/compat/util/toArray.ts","../src/compat/object/toDefaulted.ts","../src/array/toFilled.ts","../src/compat/util/toLength.ts","../src/compat/_internal/MAX_ARRAY_LENGTH.ts","../src/compat/string/toLower.ts","../src/object/toMerged.ts","../src/compat/util/toPlainObject.ts","../src/compat/util/toSafeInteger.ts","../src/compat/string/toUpper.ts","../src/compat/string/trim.ts","../src/compat/string/trimEnd.ts","../src/compat/string/trimStart.ts","../src/function/unary.ts","../src/compat/string/unescape.ts","../src/compat/array/union.ts","../src/compat/array/uniqBy.ts","../src/compat/array/unzip.ts","../src/array/unzipWith.ts","../src/compat/string/upperCase.ts","../src/string/upperCase.ts","../src/compat/string/upperFirst.ts","../src/string/upperFirst.ts","../src/compat/object/values.ts","../src/compat/object/valuesIn.ts","../src/array/windowed.ts","../src/promise/withTimeout.ts","../src/compat/array/without.ts","../src/array/without.ts","../src/compat/string/words.ts","../src/array/xor.ts","../src/array/union.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/compat/array/zip.ts","../src/array/zipObject.ts","../src/compat/array/zipObjectDeep.ts","../src/array/zipWith.ts"],"sourcesContent":["/**\n * Retrieves elements from an array at the specified indices.\n *\n * This function supports negative indices, which count from the end of the array.\n *\n * @template T\n * @param {readonly T[]} arr - The array to retrieve elements from.\n * @param {number[]} indices - An array of indices specifying the positions of elements to retrieve.\n * @returns {Array<T | undefined>} A new array containing the elements at the specified indices.\n *\n * @example\n * const numbers = [10, 20, 30, 40, 50];\n * const result = at(numbers, [1, 3, 4]);\n * console.log(result); // [20, 40, 50]\n */\nexport function at<T>(arr: readonly T[], indices: number[]): T[] {\n  const result = new Array<T>(indices.length);\n  const length = arr.length;\n\n  for (let i = 0; i < indices.length; i++) {\n    let index = indices[i];\n\n    index = Number.isInteger(index) ? index : Math.trunc(index) || 0;\n\n    if (index < 0) {\n      index += length;\n    }\n\n    result[i] = arr[index];\n  }\n\n  return result;\n}\n","/**\n * Computes the difference between two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements\n * that are present in the first array but not in the second array. It effectively\n * filters out any elements from the first array that also appear in the second array.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\n * from which elements will be compared and filtered.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * Each element in this array will be checked against the first array, and if a match is found,\n * that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the first array but not\n * in the second array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const result = difference(array1, array2);\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\n */\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => !secondSet.has(item));\n}\n","/**\n * Computes the difference between two arrays after mapping their elements through a provided function.\n *\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\n * that are present in the first array but not in the second array, based on the identity calculated\n * by the mapper function.\n *\n * Essentially, it filters out any elements from the first array that, when\n * mapped, match an element in the mapped version of the second array.\n *\n * @template T, U\n * @param {T[]} firstArr - The primary array from which to derive the difference.\n * @param {U[]} secondArr - The array containing elements to be excluded from the first array.\n * @param {(value: T | U) => unknown} mapper - The function to map the elements of both arrays. This function\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\n * mapped identity in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since 2 is present in both arrays after mapping, and is excluded from the result.\n */\nexport function differenceBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (value: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\n\n  return firstArr.filter(item => {\n    return !mappedSecondSet.has(mapper(item));\n  });\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T, U\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {U[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the element with id 2 is considered equal to the second array's element and is excluded from the result.\n */\nexport function differenceWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array from the end and drops elements until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element from the end,\n * and dropping continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRightWhile(array, x => x > 3);\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\n */\nexport function dropRightWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!canContinueDropping(arr[i], i, arr)) {\n      return arr.slice(0, i + 1);\n    }\n  }\n\n  return [];\n}\n","/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  const dropEndIndex = arr.findIndex((item, index, arr) => !canContinueDropping(item, index, arr));\n\n  if (dropEndIndex === -1) {\n    return [];\n  }\n\n  return arr.slice(dropEndIndex);\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n","/**\n * Returns the intersection of two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements that are\n * present in both arrays. It effectively filters out any elements from the first array that\n * are not found in the second array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @returns {T[]} A new array containing the elements that are present in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => {\n    return secondSet.has(item);\n  });\n}\n","/**\n * Returns the intersection of two arrays based on a mapping function.\n *\n * This function takes two arrays and a mapping function. It returns a new array containing\n * the elements from the first array that, when mapped using the provided function, have matching\n * mapped elements in the second array. It effectively filters out any elements from the first array\n * that do not have corresponding mapped values in the second array.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(item: T | U) => unknown} mapper - A function to map the elements of both arrays for comparison.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2, name: 'amy' }] since only this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (item: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(mapper));\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2, name: 'amy' }] since this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {[...T[], T]} arr - The array from which to get the last element.\n * @returns {T} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly [...T[], T]): T;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n","/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T, U\n * @param {T[]} arr - The array to modify.\n * @param {unknown[]} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pull(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pull<T>(arr: T[], valuesToRemove: readonly unknown[]): T[] {\n  const valuesSet = new Set(valuesToRemove);\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (valuesSet.has(arr[i])) {\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return arr;\n}\n","/**\n * Returns a random element from an array.\n *\n * This function takes an array and returns a single element selected randomly from the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to sample from.\n * @returns {T} A random element from the array.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const randomElement = sample(array);\n * // randomElement will be one of the elements from the array, selected randomly.\n */\nexport function sample<T>(arr: readonly T[]): T {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n","/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result1 = random(5); // Returns a random number between 0 and 5.\n * const result2 = random(0); // If the `maximum` is less than or equal to 0, an error is thrown.\n */\nexport function random(maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum?: number): number {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\n  }\n\n  return Math.random() * (maximum - minimum) + minimum;\n}\n","import { random } from './random.ts';\n\n/**\n * Generates a random integer between 0 (inclusive) and the given maximum (exclusive).\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between 0 (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result = randomInt(5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n */\nexport function randomInt(maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum?: number): number {\n  return Math.floor(random(minimum, maximum!));\n}\n","/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: readonly T[]): T[] {\n  return Array.from(new Set(arr));\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the mapper function.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr - The array to process.\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\n *\n * @example\n * ```ts\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\n * ```\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' },\n * ];\n * uniqBy(array, item => item.category).length\n * // 2\n * ```\n */\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","import { uniqBy } from './uniqBy.ts';\n\n/**\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for numbers (modulo comparison)\n * const moduloMapper = (x) => x % 3;\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\n * // Returns [1, 2, 3]\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = (obj) => obj.id;\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\n */\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  return uniqBy(arr1.concat(arr2), mapper);\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { uniqWith } from './uniqWith.ts';\n\n/**\n * Creates an array of unique values from two given arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\n * a new array containing only the unique values as determined by the custom equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array of unique values based on the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }];\n * const array2 = [{ id: 2 }, { id: 3 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = unionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\n */\nexport function unionWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areItemsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\n}\n","/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {Array<[...T]>} zipped - The nested array to unzip.\n * @returns {Unzip<T>} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T extends unknown[]>(zipped: ReadonlyArray<[...T]>): Unzip<T> {\n  // For performance reasons, use this implementation instead of\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\n  let maxLen = 0;\n\n  for (let i = 0; i < zipped.length; i++) {\n    if (zipped[i].length > maxLen) {\n      maxLen = zipped[i].length;\n    }\n  }\n\n  const result = new Array(maxLen) as Unzip<T>;\n\n  for (let i = 0; i < maxLen; i++) {\n    result[i] = new Array(zipped.length);\n    for (let j = 0; j < zipped.length; j++) {\n      result[i][j] = zipped[j][i];\n    }\n  }\n\n  return result;\n}\n\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\n","/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {T[]} arr1 - The first array to zip.\n * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = zip(arr1);\n * // result will be [[1], [2], [3]]\n */\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @returns {Array<[T, U]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @returns {Array<[T, U, V]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @param {W[]} arr4 - The fourth array to zip.\n * @returns {Array<[T, U, V, W]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const result = zip(arr1, arr2, arr3, arr4);\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\n */\nexport function zip<T, U, V, W>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[]\n): Array<[T, U, V, W]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\n  // For performance reasons, use this implementation instead of\n  // const rowCount = Math.max(...arrs.map(x => x.length));\n  let rowCount = 0;\n\n  for (let i = 0; i < arrs.length; i++) {\n    if (arrs[i].length > rowCount) {\n      rowCount = arrs[i].length;\n    }\n  }\n  const columnCount = arrs.length;\n  const result = Array(rowCount);\n\n  for (let i = 0; i < rowCount; ++i) {\n    const row = Array(columnCount);\n    for (let j = 0; j < columnCount; ++j) {\n      row[j] = arrs[j][i];\n    }\n    result[i] = row;\n  }\n  return result;\n}\n","/**\n * An error class representing an aborted operation.\n * @augments Error\n */\nexport class AbortError extends Error {\n  constructor(message = 'The operation was aborted') {\n    super(message);\n    this.name = 'AbortError';\n  }\n}\n","/**\n * An error class representing an timeout operation.\n * @augments Error\n */\nexport class TimeoutError extends Error {\n  constructor(message = 'The operation was timed out') {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n","/**\n * Creates a function that only executes starting from the `n`-th call.\n * The provided function will be invoked starting from the `n`-th call.\n *\n * This is particularly useful for scenarios involving events or asynchronous operations\n * where an action should occur only after a certain number of invocations.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of calls required for `func` to execute.\n * @param {F} func - The function to be invoked.\n * @returns {(...args: Parameters<F>) => ReturnType<F> | undefined} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` starting from the `n`-th call.\n * - Returns `undefined` if fewer than `n` calls have been made.\n * @throws {Error} - Throws an error if `n` is negative.\n * @example\n *\n * const afterFn = after(3, () => {\n *  console.log(\"called\")\n * });\n *\n * // Will not log anything.\n * afterFn()\n * // Will not log anything.\n * afterFn()\n * // Will log 'called'.\n * afterFn()\n */\n\nexport function after<F extends (...args: any[]) => any>(\n  n: number,\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> | undefined {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new Error(`n must be a non-negative integer.`);\n  }\n\n  let counter = 0;\n  return (...args: Parameters<F>) => {\n    if (++counter >= n) {\n      return func(...args);\n    }\n    return undefined;\n  };\n}\n","/**\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * ary(fn, 0)(1, 2, 3) // []\n * ary(fn, 1)(1, 2, 3) // [1]\n * ary(fn, 2)(1, 2, 3) // [1, 2]\n * ary(fn, 3)(1, 2, 3) // [1, 2, 3]\n */\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: Parameters<F>) {\n    return func.apply(this, args.slice(0, n));\n  };\n}\n","interface DebounceOptions {\n  /**\n   * An optional AbortSignal to cancel the debounced function.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.\n   * If `edges` includes \"leading\", the function will be invoked at the start of the delay period.\n   * If `edges` includes \"trailing\", the function will be invoked at the end of the delay period.\n   * If both \"leading\" and \"trailing\" are included, the function will be invoked at both the start and end of the delay period.\n   * @default [\"trailing\"]\n   */\n  edges?: Array<'leading' | 'trailing'>;\n}\n\nexport interface DebouncedFunction<F extends (...args: any[]) => void> {\n  (...args: Parameters<F>): void;\n\n  /**\n   * Schedules the execution of the debounced function after the specified debounce delay.\n   * This method resets any existing timer, ensuring that the function is only invoked\n   * after the delay has elapsed since the last call to the debounced function.\n   * It is typically called internally whenever the debounced function is invoked.\n   *\n   * @returns {void}\n   */\n  schedule: () => void;\n\n  /**\n   * Cancels any pending execution of the debounced function.\n   * This method clears the active timer and resets any stored context or arguments.\n   */\n  cancel: () => void;\n\n  /**\n   * Immediately invokes the debounced function if there is a pending execution.\n   * This method also cancels the current timer, ensuring that the function executes right away.\n   */\n  flush: () => void;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal, edges }: DebounceOptions = {}\n): DebouncedFunction<F> {\n  let pendingThis: any = undefined;\n  let pendingArgs: Parameters<F> | null = null;\n\n  const leading = edges != null && edges.includes('leading');\n  const trailing = edges == null || edges.includes('trailing');\n\n  const invoke = () => {\n    if (pendingArgs !== null) {\n      func.apply(pendingThis, pendingArgs);\n      pendingThis = undefined;\n      pendingArgs = null;\n    }\n  };\n\n  const onTimerEnd = () => {\n    if (trailing) {\n      invoke();\n    }\n\n    cancel();\n  };\n\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const schedule = () => {\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n\n      onTimerEnd();\n    }, debounceMs);\n  };\n\n  const cancelTimer = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  const cancel = () => {\n    cancelTimer();\n    pendingThis = undefined;\n    pendingArgs = null;\n  };\n\n  const flush = () => {\n    cancelTimer();\n    invoke();\n  };\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (signal?.aborted) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    pendingThis = this;\n    pendingArgs = args;\n\n    const isFirstCall = timeoutId == null;\n\n    schedule();\n\n    if (leading && isFirstCall) {\n      invoke();\n    }\n  };\n\n  debounced.schedule = schedule;\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n\n  signal?.addEventListener('abort', cancel, { once: true });\n\n  return debounced;\n}\n","/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *  return 42;\n * }\n *\n * const combined = flow(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flow<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *   return a * 2;\n * }\n *\n * const combined = flow(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flow<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flow(add, square, double, toStr);\n * console.log(combined(1, 2)); // '18'\n */\nexport function flow<A extends any[], R1, R2, R3, R4>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flow(add, square, double, toStr, split);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\n  return function (this: any, ...args: any[]) {\n    let result = funcs.length ? funcs[0].apply(this, args) : args[0];\n\n    for (let i = 1; i < funcs.length; i++) {\n      result = funcs[i].call(this, result);\n    }\n\n    return result;\n  };\n}\n","/**\n * Returns the input value unchanged.\n *\n * @template T - The type of the input value.\n * @param {T} x - The value to be returned.\n * @returns {T} The input value.\n *\n * @example\n * // Returns 5\n * identity(5);\n *\n * @example\n * // Returns 'hello'\n * identity('hello');\n *\n * @example\n * // Returns { key: 'value' }\n * identity({ key: 'value' });\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","type Placeholder = typeof partialPlaceholder;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(): R} A new function that takes no arguments and returns the result of the original function.\n *\n * @example\n * const addOne = (x: number) => x + 1;\n * const addOneToFive = partial(addOne, 5);\n * console.log(addOneToFive()); // => 6\n */\nexport function partial<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number) => x * y;\n * const double = partial(multiply, 2);\n * console.log(double(5)); // => 10\n */\nexport function partial<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {Placeholder} placeholder The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithHello = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithHello('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, R>(\n  func: (arg1: T1, arg2: T2) => R,\n  placeholder: Placeholder,\n  arg2: T2\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2, arg3: T3): R} A new function that takes the second and third arguments and returns the result of the original function.\n *\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const addFive = partial(sumThree, 5);\n * console.log(addFive(3, 2)); // => 10\n */\nexport function partial<T1, T2, T3, R>(func: (arg1: T1, arg2: T2, arg3: T3) => R, arg1: T1): (arg2: T2, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithPlaceholder('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: T2\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number) => x * y * z;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2);\n * console.log(multiplyWithPlaceholders(3, 4)); // => 24\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The first argument to apply.\n * @param {T2} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  plc1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const double = partial(multiply, 2);\n * console.log(double(5, 4, 3)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg3: T3, arg4: T4): R} A new function that takes the third and fourth arguments and returns the result of the original function.\n *\n * @example\n * const sumFour = (a: number, b: number, c: number, d: number) => a + b + c + d;\n * const addOneAndTwo = partial(sumFour, 1, 2);\n * console.log(addOneAndTwo(3, 4)); // => 10\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2, arg4: T4): R} A new function that takes the second and fourth arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder, '!');\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholder = partial(multiply, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholder(4)); // => 24\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg4: T4): R} A new function that takes the fourth argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): (arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg3: T3): R} A new function that takes the third argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template R The return type of the function.\n * @param {function(...args: TS): R} func The function to partially apply.\n * @returns {function(...args: TS): R} A new function that takes the same arguments as the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<TS extends any[], R>(func: (...args: TS) => R): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, ...names: string[]) => `${greeting}, ${names.join(', ')}!`;\n * const greetHello = partial(greet, 'Hello');\n * console.log(greetHello('Alice', 'Bob')); // => 'Hello, Alice, Bob!'\n */\nexport function partial<TS extends any[], T1, R>(func: (arg1: T1, ...args: TS) => R, arg1: T1): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', '!');\n * console.log(greetWithHello('John')); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, R>(\n  func: (arg1: T1, arg2: T2, ...args: TS) => R,\n  t1: T1,\n  arg2: T2\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, T4, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply.\n * @param {...any[]} partialArgs The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F>;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const sayHelloTo = partial(greet, 'hello');\n * sayHelloTo('fred');\n * // => 'hello fred'\n *\n * // Partially applied with placeholders.\n * const greetFred = partial(greet, partial.placeholder, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    let startIndex = 0;\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partial.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialPlaceholder: unique symbol = Symbol('partial.placeholder');\npartial.placeholder = partialPlaceholder;\n","type Placeholder = typeof partialRightPlaceholder;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template R The return type of the function.\n * @param {() => R} func The function to invoke.\n * @returns {() => R} Returns the new function.\n * @example\n * const getValue = () => 42;\n * const getValueFunc = partialRight(getValue);\n * console.log(getValueFunc()); // => 42\n */\nexport function partialRight<R>(func: () => R): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const addOne = (num: number) => num + 1;\n * const addOneFunc = partialRight(addOne, 1);\n * console.log(addOneFunc()); // => 2\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const multiplyBy = (factor: number) => (num: number) => num * factor;\n * const double = partialRight(multiplyBy(2));\n * console.log(double(5)); // => 10\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const greet = (name: string) => `Hello, ${name}!`;\n * const greetJohn = partialRight(greet, 'John');\n * console.log(greetJohn()); // => 'Hello, John!'\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const subtract = (a: number, b: number) => a - b;\n * const subtractFive = partialRight(subtract);\n * console.log(subtractFive(10, 5)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const concat = (a: string, b: string) => a + b;\n * const concatWithHello = partialRight(concat, 'Hello', partialRight.placeholder);\n * console.log(concatWithHello(' World!')); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: Placeholder): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const divide = (a: number, b: number) => a / b;\n * const divideByTwo = partialRight(divide, 2);\n * console.log(divideByTwo(10)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg2: T2): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const multiply = (a: number, b: number) => a * b;\n * const multiplyByThreeAndFour = partialRight(multiply, 3, 4);\n * console.log(multiplyByThreeAndFour()); // => 12\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: T2): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const sumWithFive = partialRight(sumThree);\n * console.log(sumWithFive(1, 2, 5)); // => 8\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const formatDate = (day: number, month: number, year: number) => `${day}/${month}/${year}`;\n * const formatDateWithDay = partialRight(formatDate, 1, partialRight.placeholder, partialRight.placeholder);\n * console.log(formatDateWithDay(12, 2023)); // => '1/12/2023'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg1: T1, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const createUser = (name: string, age: number, country: string) => `${name}, ${age} years old from ${country}`;\n * const createUserFromUSA = partialRight(createUser, 'USA', partialRight.placeholder);\n * console.log(createUserFromUSA('John', 30)); // => 'John, 30 years old from USA'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: Placeholder\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const logMessage = (level: string, message: string, timestamp: string) => `[${level}] ${message} at ${timestamp}`;\n * const logError = partialRight(logMessage, 'ERROR', '2023-10-01');\n * console.log(logError('Something went wrong!')); // => '[ERROR] Something went wrong! at 2023-10-01'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const calculateArea = (length: number, width: number) => length * width;\n * const calculateAreaWithWidth = partialRight(calculateArea, 5);\n * console.log(calculateAreaWithWidth(10)); // => 50\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const formatCurrency = (amount: number, currency: string) => `${amount} ${currency}`;\n * const formatUSD = partialRight(formatCurrency, 100, partialRight.placeholder);\n * console.log(formatUSD('USD')); // => '100 USD'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const createProfile = (name: string, age: number, country: string) => `${name}, ${age} from ${country}`;\n * const createProfileFromCanada = partialRight(createProfile, 'Canada', 'John');\n * console.log(createProfileFromCanada(30)); // => 'John, 30 from Canada'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): () => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes four arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes the second, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg3: T3, arg4: T4) => R} Returns a new function that takes the first, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg1: T1, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg3: T3, arg4: T4) => R} Returns a new function that takes the third and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg2: T2, arg4: T4) => R} Returns a new function that takes the first, second, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with the first argument, a placeholder for the second argument,\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg4: T4) => R} Returns a new function that takes the second and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: Placeholder\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg4: T4) => R} Returns a new function that takes the first and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg4: T4) => R} Returns a new function that takes the fourth argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns a new function that takes the first, second, and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg4: T4\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2, arg3: T3) => R} Returns a new function that takes the second and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: T4\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg3: T3) => R} Returns a new function that takes the first and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg3: T3) => R} Returns a new function that takes the third argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns a new function that takes the first and second arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns a new function that takes the second argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns a new function that takes the first argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const concatenate = (a: string, b: string, c: string, d: string) => a + b + c + d;\n * const concatenateHelloWorld = partialRight(concatenate, 'Hello', ' ', 'World', '!');\n * console.log(concatenateHelloWorld()); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {...any[]} args The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} Returns the new partially applied function.\n * @example\n * const log = (...messages: string[]) => console.log(...messages);\n * const logError = partialRight(log, 'Error:');\n * logError('Something went wrong!'); // => 'Error: Something went wrong!'\n */\nexport function partialRight(func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n *\n * // Partially applied with placeholders.\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\n * sayHelloTo('fred');\n * // => 'hello fred'\n */\nexport function partialRight<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...providedArgs: any[]) {\n    const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n    const args: any[] = [];\n\n    let providedIndex = 0;\n    for (let i = 0; i < rangeLength; i++) {\n      args.push(providedArgs[providedIndex++]);\n    }\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partialRight.placeholder) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialRightPlaceholder: unique symbol = Symbol('partialRight.placeholder');\npartialRight.placeholder = partialRightPlaceholder;\n","import { AbortError } from '../error/AbortError.ts';\n\ninterface DelayOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n *\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\n * with async/await to pause execution.\n *\n * @param {number} ms - The number of milliseconds to delay.\n * @param {DelayOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\n *\n * @example\n * async function foo() {\n *   console.log('Start');\n *   await delay(1000); // Delays execution for 1 second\n *   console.log('End');\n * }\n *\n * foo();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const { signal } = controller;\n *\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\n * try {\n *   await delay(100, { signal });\n *  } catch (error) {\n *   console.error(error); // Will log 'AbortError'\n *  }\n * }\n */\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const abortError = () => {\n      reject(new AbortError());\n    };\n\n    const abortHandler = () => {\n      clearTimeout(timeoutId);\n      abortError();\n    };\n\n    if (signal?.aborted) {\n      return abortError();\n    }\n\n    const timeoutId = setTimeout(() => {\n      signal?.removeEventListener('abort', abortHandler);\n      resolve();\n    }, ms);\n\n    signal?.addEventListener('abort', abortHandler, { once: true });\n  });\n}\n","/**\n * A counting semaphore for async functions that manages available permits.\n * Semaphores are mainly used to limit the number of concurrent async tasks.\n *\n * Each `acquire` operation takes a permit or waits until one is available.\n * Each `release` operation adds a permit, potentially allowing a waiting task to proceed.\n *\n * The semaphore ensures fairness by maintaining a FIFO (First In, First Out) order for acquirers.\n *\n * @example\n * const sema = new Semaphore(2);\n *\n * async function task() {\n *   await sema.acquire();\n *   try {\n *     // This code can only be executed by two tasks at the same time\n *   } finally {\n *     sema.release();\n *   }\n * }\n *\n * task();\n * task();\n * task(); // This task will wait until one of the previous tasks releases the semaphore.\n */\nexport class Semaphore {\n  /**\n   * The maximum number of concurrent operations allowed.\n   * @type {number}\n   */\n  public capacity: number;\n\n  /**\n   * The number of available permits.\n   * @type {number}\n   */\n  public available: number;\n  private deferredTasks: Array<() => void> = [];\n\n  /**\n   * Creates an instance of Semaphore.\n   * @param {number} capacity - The maximum number of concurrent operations allowed.\n   *\n   * @example\n   * const sema = new Semaphore(3); // Allows up to 3 concurrent operations.\n   */\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.available = capacity;\n  }\n\n  /**\n   * Acquires a semaphore, blocking if necessary until one is available.\n   * @returns {Promise<void>} A promise that resolves when the semaphore is acquired.\n   *\n   * @example\n   * const sema = new Semaphore(1);\n   *\n   * async function criticalSection() {\n   *   await sema.acquire();\n   *   try {\n   *     // This code section cannot be executed simultaneously\n   *   } finally {\n   *     sema.release();\n   *   }\n   * }\n   */\n  async acquire(): Promise<void> {\n    if (this.available > 0) {\n      this.available--;\n      return;\n    }\n\n    return new Promise<void>(resolve => {\n      this.deferredTasks.push(resolve);\n    });\n  }\n\n  /**\n   * Releases a semaphore, allowing one more operation to proceed.\n   *\n   * @example\n   * const sema = new Semaphore(1);\n   *\n   * async function task() {\n   *   await sema.acquire();\n   *   try {\n   *     // This code can only be executed by two tasks at the same time\n   *   } finally {\n   *     sema.release(); // Allows another waiting task to proceed.\n   *   }\n   * }\n   */\n  release(): void {\n    const deferredTask = this.deferredTasks.shift();\n\n    if (deferredTask != null) {\n      deferredTask();\n      return;\n    }\n\n    if (this.available < this.capacity) {\n      this.available++;\n    }\n  }\n}\n","import { delay } from './delay.ts';\nimport { TimeoutError } from '../error/TimeoutError.ts';\n\n/**\n * Returns a promise that rejects with a `TimeoutError` after a specified delay.\n *\n * @param {number} ms - The delay duration in milliseconds.\n * @returns {Promise<never>} A promise that rejects with a `TimeoutError` after the specified delay.\n * @throws {TimeoutError} Throws a `TimeoutError` after the specified delay.\n *\n * @example\n * try {\n *   await timeout(1000); // Timeout exception after 1 second\n * } catch (error) {\n *   console.error(error); // Will log 'The operation was timed out'\n * }\n */\nexport async function timeout(ms: number): Promise<never> {\n  await delay(ms);\n  throw new TimeoutError();\n}\n","import { delay as delayToolkit } from '../promise';\n\ninterface RetryOptions {\n  /**\n   * The number of milliseconds to interval delay.\n   * @default 0\n   */\n  delay?: number;\n\n  /**\n   * The number of retries to attempt.\n   * @default Number.POSITIVE_INFINITY\n   */\n  retries?: number;\n\n  /**\n   * An AbortSignal to cancel the retry operation.\n   */\n  signal?: AbortSignal;\n}\n\nconst DEFAULT_DELAY = 0;\nconst DEFAULT_RETRIES = Number.POSITIVE_INFINITY;\n\n/**\n * Retries a function that returns a promise until it resolves successfully.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Basic usage with default retry options\n * retry(() => fetchData()).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>): Promise<T>;\n\n/**\n * Retries a function that returns a promise a specified number of times.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {number} retries - The number of retries to attempt. Default is Infinity.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Retry a function up to 3 times\n * retry(() => fetchData(), 3).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>, retries: number): Promise<T>;\n\n/**\n * Retries a function that returns a promise with specified options.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {RetryOptions} options - Options to configure the retry behavior.\n * @param {number} [options.delay=0] - The number of milliseconds to wait between retries.\n * @param {number} [options.retries=Infinity] - The number of retries to attempt.\n * @param {AbortSignal} [options.signal] - An AbortSignal to cancel the retry operation.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Retry a function with a delay of 1000ms between attempts\n * retry(() => fetchData(), { delay: 1000, times: 5 }).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>, options: RetryOptions): Promise<T>;\n\n/**\n * Retries a function that returns a promise with specified options.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {number | RetryOptions} [_options] - Either the number of retries or an options object.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n */\nexport async function retry<T>(func: () => Promise<T>, _options?: number | RetryOptions): Promise<T> {\n  let delay: number;\n  let retries: number;\n  let signal: AbortSignal | undefined;\n\n  if (typeof _options === 'number') {\n    delay = DEFAULT_DELAY;\n    retries = _options;\n    signal = undefined;\n  } else {\n    delay = _options?.delay ?? DEFAULT_DELAY;\n    retries = _options?.retries ?? DEFAULT_RETRIES;\n    signal = _options?.signal;\n  }\n\n  let error;\n\n  for (let i = 0; i < retries; i++) {\n    if (signal?.aborted) {\n      throw error ?? new Error(`The retry operation was aborted due to an abort signal.`);\n    }\n\n    try {\n      return await func();\n    } catch (err) {\n      error = err;\n      await delayToolkit(delay);\n    }\n  }\n\n  throw error;\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = mean(numbers);\n * // result will be 3\n */\nexport function mean(nums: readonly number[]): number {\n  return sum(nums) / nums.length;\n}\n","/**\n * Calculates the sum of an array of numbers.\n *\n * This function takes an array of numbers and returns the sum of all the elements in the array.\n *\n * @param {number[]} nums - An array of numbers to be summed.\n * @returns {number} The sum of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = sum(numbers);\n * // result will be 15\n */\nexport function sum(nums: readonly number[]): number {\n  let result = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    result += nums[i];\n  }\n\n  return result;\n}\n","/**\n * Calculates the median of an array of numbers.\n *\n * The median is the middle value of a sorted array.\n * If the array has an odd number of elements, the median is the middle value.\n * If the array has an even number of elements, it returns the average of the two middle values.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the median.\n * @returns {number} The median of all the numbers in the array.\n *\n * @example\n * const arrayWithOddNumberOfElements = [1, 2, 3, 4, 5];\n * const result = median(arrayWithOddNumberOfElements);\n * // result will be 3\n *\n * @example\n * const arrayWithEvenNumberOfElements = [1, 2, 3, 4];\n * const result = median(arrayWithEvenNumberOfElements);\n * // result will be 2.5\n */\nexport function median(nums: readonly number[]): number {\n  if (nums.length === 0) {\n    return NaN;\n  }\n\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const middleIndex = Math.floor(sorted.length / 2);\n\n  if (sorted.length % 2 === 0) {\n    return (sorted[middleIndex - 1] + sorted[middleIndex]) / 2;\n  } else {\n    return sorted[middleIndex];\n  }\n}\n","/**\n * Returns an array of numbers from `0` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `0` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n */\nexport function range(end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [1, 2, 3]\n * range(1, 4);\n */\nexport function range(start: number, end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n */\nexport function range(start: number, end: number, step: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n */\nexport function range(start: number, end?: number, step = 1): number[] {\n  if (end == null) {\n    end = start;\n    start = 0;\n  }\n\n  if (!Number.isInteger(step) || step === 0) {\n    throw new Error(`The step value must be a non-zero integer.`);\n  }\n\n  const length = Math.max(Math.ceil((end - start) / step), 0);\n  const result = new Array<number>(length);\n\n  for (let i = 0; i < length; i++) {\n    result[i] = start + i * step;\n  }\n\n  return result;\n}\n","/**\n * Checks whether a value is a JavaScript primitive.\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\n *\n * @param {unknown} value The value to check.\n * @returns {value is\n *     null\n *   | undefined\n *   | string\n *   | number\n *   | boolean\n *   | symbol\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\n *\n * @example\n * isPrimitive(null); // true\n * isPrimitive(undefined); // true\n * isPrimitive('123'); // true\n * isPrimitive(false); // true\n * isPrimitive(true); // true\n * isPrimitive(Symbol('a')); // true\n * isPrimitive(123n); // true\n * isPrimitive({}); // false\n * isPrimitive(new Date()); // false\n * isPrimitive(new Map()); // false\n * isPrimitive(new Set()); // false\n * isPrimitive([1, 2, 3]); // false\n */\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n","/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *     Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(\n  x: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Creates a shallow clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n */\nexport function clone<T>(obj: T): T {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n\n  if (\n    Array.isArray(obj) ||\n    isTypedArray(obj) ||\n    obj instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)\n  ) {\n    return obj.slice(0) as T;\n  }\n\n  const prototype = Object.getPrototypeOf(obj);\n  const Constructor = prototype.constructor;\n\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n    return new Constructor(obj);\n  }\n\n  if (obj instanceof RegExp) {\n    const newRegExp = new Constructor(obj);\n    newRegExp.lastIndex = obj.lastIndex;\n\n    return newRegExp;\n  }\n\n  if (obj instanceof DataView) {\n    return new Constructor(obj.buffer.slice(0));\n  }\n\n  if (obj instanceof Error) {\n    const newError = new Constructor(obj.message);\n\n    newError.stack = obj.stack;\n    newError.name = obj.name;\n    newError.cause = obj.cause;\n\n    return newError;\n  }\n\n  if (typeof File !== 'undefined' && obj instanceof File) {\n    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n    return newFile;\n  }\n\n  if (typeof obj === 'object') {\n    const newObject = Object.create(prototype);\n    return Object.assign(newObject, obj);\n  }\n\n  return obj;\n}\n","export function getSymbols(object: any) {\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\n  );\n}\n","/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {T} value The value to query.\n * @returns {string} Returns the `Object.prototype.toString.call` result.\n */\nexport function getTag<T>(value: T) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n  return Object.prototype.toString.call(value);\n}\n","export const regexpTag = '[object RegExp]';\nexport const stringTag = '[object String]';\nexport const numberTag = '[object Number]';\nexport const booleanTag = '[object Boolean]';\nexport const argumentsTag = '[object Arguments]';\nexport const symbolTag = '[object Symbol]';\nexport const dateTag = '[object Date]';\nexport const mapTag = '[object Map]';\nexport const setTag = '[object Set]';\nexport const arrayTag = '[object Array]';\nexport const functionTag = '[object Function]';\nexport const arrayBufferTag = '[object ArrayBuffer]';\nexport const objectTag = '[object Object]';\nexport const errorTag = '[object Error]';\nexport const dataViewTag = '[object DataView]';\nexport const uint8ArrayTag = '[object Uint8Array]';\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nexport const uint16ArrayTag = '[object Uint16Array]';\nexport const uint32ArrayTag = '[object Uint32Array]';\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\nexport const int8ArrayTag = '[object Int8Array]';\nexport const int16ArrayTag = '[object Int16Array]';\nexport const int32ArrayTag = '[object Int32Array]';\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\nexport const float32ArrayTag = '[object Float32Array]';\nexport const float64ArrayTag = '[object Float64Array]';\n","import { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Deeply clones the given object.\n *\n * You can customize the deep cloning process using the `cloneValue` function.\n * The function takes the current value `value`, the property name `key`, and the entire object `obj` as arguments.\n * If the function returns a value, that value is used;\n * if it returns `undefined`, the default cloning method is used.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(\n  obj: T,\n  cloneValue: (value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any\n): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\n\nexport function cloneDeepWithImpl<T>(\n  valueToClone: any,\n  keyToClone: PropertyKey | undefined,\n  objectToClone: T,\n  stack = new Map<any, any>(),\n  cloneValue: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined = undefined\n): T {\n  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n\n  if (cloned != null) {\n    return cloned;\n  }\n\n  if (isPrimitive(valueToClone)) {\n    return valueToClone as T;\n  }\n\n  if (stack.has(valueToClone)) {\n    return stack.get(valueToClone) as T;\n  }\n\n  if (Array.isArray(valueToClone)) {\n    const result: any = new Array(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    // For RegExpArrays\n    if (Object.hasOwn(valueToClone, 'index')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.index = valueToClone.index;\n    }\n    if (Object.hasOwn(valueToClone, 'input')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.input = valueToClone.input;\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Date) {\n    return new Date(valueToClone.getTime()) as T;\n  }\n\n  if (valueToClone instanceof RegExp) {\n    const result = new RegExp(valueToClone.source, valueToClone.flags);\n\n    result.lastIndex = valueToClone.lastIndex;\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Map) {\n    const result = new Map();\n    stack.set(valueToClone, result);\n\n    for (const [key, value] of valueToClone) {\n      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Set) {\n    const result = new Set();\n    stack.set(valueToClone, result);\n\n    for (const value of valueToClone) {\n      result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return valueToClone.subarray() as T;\n  }\n\n  if (isTypedArray(valueToClone)) {\n    const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    return result as T;\n  }\n\n  if (\n    valueToClone instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)\n  ) {\n    return valueToClone.slice(0) as T;\n  }\n\n  if (valueToClone instanceof DataView) {\n    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  // For legacy NodeJS support\n  if (typeof File !== 'undefined' && valueToClone instanceof File) {\n    const result = new File([valueToClone], valueToClone.name, {\n      type: valueToClone.type,\n    });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Blob) {\n    const result = new Blob([valueToClone], { type: valueToClone.type });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Error) {\n    const result = new (valueToClone.constructor as { new (): Error })();\n    stack.set(valueToClone, result);\n\n    result.message = valueToClone.message;\n    result.name = valueToClone.name;\n    result.stack = valueToClone.stack;\n    result.cause = valueToClone.cause;\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n    const result = Object.create(Object.getPrototypeOf(valueToClone));\n\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  return valueToClone;\n}\n\nexport function copyProperties<T>(\n  target: any,\n  source: any,\n  objectToClone: T = target,\n  stack?: Map<any, any> | undefined,\n  cloneValue?: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined\n): void {\n  const keys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(target, key);\n\n    if (descriptor == null || descriptor.writable) {\n      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n    }\n  }\n}\n\nfunction isCloneableObject(object: object) {\n  switch (getTag(object)) {\n    case argumentsTag:\n    case arrayTag:\n    case arrayBufferTag:\n    case dataViewTag:\n    case booleanTag:\n    case dateTag:\n    case float32ArrayTag:\n    case float64ArrayTag:\n    case int8ArrayTag:\n    case int16ArrayTag:\n    case int32ArrayTag:\n    case mapTag:\n    case numberTag:\n    case objectTag:\n    case regexpTag:\n    case setTag:\n    case stringTag:\n    case symbolTag:\n    case uint8ArrayTag:\n    case uint8ClampedArrayTag:\n    case uint16ArrayTag:\n    case uint32ArrayTag: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n","import { cloneDeepWithImpl } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), undefined);\n}\n","/**\n * Finds the key of the first element in the object that satisfies the provided testing function.\n *\n * @param {T} obj - The object to search.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean} predicate - The function to execute on each value in the object. It takes three arguments:\n *   - value: The current value being processed in the object.\n *   - key: The key of the current value being processed in the object.\n *   - obj: The object that findKey was called upon.\n * @returns {keyof T | undefined} The key of the first element in the object that passes the test, or undefined if no element passes.\n *\n * @example\n * const users = {\n *   'barney':  { 'age': 36, 'active': true },\n *   'fred':    { 'age': 40, 'active': false },\n *   'pebbles': { 'age': 1,  'active': true }\n * };\n * findKey(users, function(o) { return o.age < 40; }); => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T, obj: T) => boolean\n): keyof T | undefined {\n  const keys = Object.keys(obj) as Array<keyof T>;\n\n  return keys.find(key => predicate(obj[key], key, obj));\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * @param {object} value - The value to check.\n * @returns {value is Record<PropertyKey, any>} - True if the value is a plain object, otherwise false.\n *\n * @example\n * ```typescript\n * //  True\n *\n * isPlainObject({ });                       // \n * isPlainObject({ key: 'value' });          // \n * isPlainObject({ key: new Date() });       // \n * isPlainObject(new Object());              // \n * isPlainObject(Object.create(null));       // \n * isPlainObject({ nested: { key: true} });  // \n * isPlainObject(new Proxy({}, {}));         // \n * isPlainObject({ [Symbol('tag')]: 'A' });  // \n *\n * //  (cross-realms, node context, workers, ...)\n * const runInNewContext = await import('node:vm').then(\n *     (mod) => mod.runInNewContext\n * );\n * isPlainObject(runInNewContext('({})'));   // \n *\n * //  False\n *\n * class Test { };\n * isPlainObject(new Test())           // \n * isPlainObject(10);                  // \n * isPlainObject(null);                // \n * isPlainObject('hello');             // \n * isPlainObject([]);                  // \n * isPlainObject(new Date());          // \n * isPlainObject(new Uint8Array([1])); // \n * isPlainObject(Buffer.from('ABC'));  // \n * isPlainObject(Promise.resolve({})); // \n * isPlainObject(Object.create({}));   // \n * isPlainObject(new (class Cls {}));  // \n * isPlainObject(globalThis);          // ,\n * ```\n */\nexport function isPlainObject(value: unknown): value is Record<PropertyKey, any> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value) as typeof Object.prototype | null;\n\n  const hasObjectPrototype =\n    proto === null ||\n    proto === Object.prototype ||\n    // Required to support node:vm.runInNewContext({})\n    Object.getPrototypeOf(proto) === null;\n\n  if (!hasObjectPrototype) {\n    return false;\n  }\n\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\ninterface FlattenObjectOptions {\n  /**\n   * The delimiter to use between nested keys.\n   * @default '.'\n   */\n  delimiter?: string;\n}\n\n/**\n * Flattens a nested object into a single level object with delimiter-separated keys.\n *\n * @param {object} object - The object to flatten.\n * @param {string} [options.delimiter='.'] - The delimiter to use between nested keys.\n * @returns {Record<string, any>} - The flattened object.\n *\n * @example\n * const nestedObject = {\n *   a: {\n *     b: {\n *       c: 1\n *     }\n *   },\n *   d: [2, 3]\n * };\n *\n * const flattened = flattenObject(nestedObject);\n * console.log(flattened);\n * // Output:\n * // {\n * //   'a.b.c': 1,\n * //   'd.0': 2,\n * //   'd.1': 3\n * // }\n */\nexport function flattenObject(object: object, { delimiter = '.' }: FlattenObjectOptions = {}): Record<string, any> {\n  return flattenObjectImpl(object, '', delimiter);\n}\n\nfunction flattenObjectImpl(object: object, prefix = '', delimiter = '.'): Record<string, any> {\n  const result: Record<string, any> = {};\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (object as any)[key];\n\n    const prefixedKey = prefix ? `${prefix}${delimiter}${key}` : key;\n\n    if (isPlainObject(value) && Object.keys(value).length > 0) {\n      Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));\n      continue;\n    }\n\n    result[prefixedKey] = value;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => K} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K, T[keyof T]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends Record<PropertyKey, any>, K extends PropertyKey>(\n  object: T,\n  getNewKey: (value: T[keyof T], key: keyof T, object: T) => K\n): Record<K, T[keyof T]> {\n  const result = {} as Record<K, T[keyof T]>;\n  const keys = Object.keys(object) as Array<keyof T>;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = object[key];\n\n    result[getNewKey(value, key, object)] = value as any;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K;\n    const value = object[key];\n\n    result[key] = getNewValue(value, key, object);\n  }\n\n  return result;\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function mutates the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The source object whose properties will be merged into the target object.\n * @returns {T & S} The updated target object with properties from the source object merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>>(\n  target: T,\n  source: S\n): T & S {\n  const sourceKeys = Object.keys(source) as Array<keyof S>;\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    const sourceValue = source[key];\n    const targetValue = target[key];\n\n    if (Array.isArray(sourceValue)) {\n      if (Array.isArray(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge([], sourceValue);\n      }\n    } else if (isPlainObject(sourceValue)) {\n      if (isPlainObject(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge({}, sourceValue);\n      }\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","/**\n * Checks if the given value is object-like.\n *\n * A value is object-like if its type is object and it is not null.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\n *\n * @template T - The type of value.\n * @param {T} value - The value to test if it is an object-like.\n * @returns {value is object} `true` if the value is an object-like, `false` otherwise.\n *\n * @example\n * const value1 = { a: 1 };\n * const value2 = [1, 2, 3];\n * const value3 = 'abc';\n * const value4 = () => {};\n * const value5 = null;\n *\n * console.log(isObjectLike(value1)); // true\n * console.log(isObjectLike(value2)); // true\n * console.log(isObjectLike(value3)); // false\n * console.log(isObjectLike(value4)); // false\n * console.log(isObjectLike(value5)); // false\n */\n\nexport function isObjectLike(value?: unknown): value is object {\n  return typeof value === 'object' && value !== null;\n}\n","/**\n * Checks if the given value is a Blob.\n *\n * This function tests whether the provided value is an instance of `Blob`.\n * It returns `true` if the value is an instance of `Blob`, and `false` otherwise.\n *\n * @param {unknown} x - The value to test if it is a Blob.\n * @returns {x is Blob} True if the value is a Blob, false otherwise.\n *\n * @example\n * const value1 = new Blob();\n * const value2 = {};\n *\n * console.log(isBlob(value1)); // true\n * console.log(isBlob(value2)); // false\n */\nexport function isBlob(x: unknown): x is Blob {\n  // Return false if Blob is not supported in the environment\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n\n  return x instanceof Blob;\n}\n","declare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Checks if the given value is a Buffer instance.\n *\n * This function tests whether the provided value is an instance of Buffer.\n * It returns `true` if the value is a Buffer, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Buffer`.\n *\n * @param {unknown} x - The value to check if it is a Buffer.\n * @returns {boolean} Returns `true` if `x` is a Buffer, else `false`.\n *\n * @example\n * const buffer = Buffer.from(\"test\");\n * console.log(isBuffer(buffer)); // true\n *\n * const notBuffer = \"not a buffer\";\n * console.log(isBuffer(notBuffer)); // false\n */\nexport function isBuffer(x: unknown): boolean {\n  // eslint-disable-next-line\n  // @ts-ignore\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(x);\n}\n","/**\n * Performs a `SameValueZero` comparison between two values to determine if they are equivalent.\n *\n * @param {unknown} value - The value to compare.\n * @param {unknown} other - The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n *\n * @example\n * eq(1, 1); // true\n * eq(0, -0); // true\n * eq(NaN, NaN); // true\n * eq('a', Object('a')); // false\n */\nexport function eq(value?: unknown, other?: unknown): boolean {\n  return value === other || (Number.isNaN(value) && Number.isNaN(other));\n}\n","import { isPlainObject } from './isPlainObject.ts';\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  bigInt64ArrayTag,\n  bigUint64ArrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  errorTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  functionTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { eq } from '../compat/util/eq.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Compares two values for equality using a custom comparison function.\n *\n * The custom function allows for fine-tuned control over the comparison process. If it returns a boolean, that result determines the equality. If it returns undefined, the function falls back to the default equality comparison.\n *\n * This function also uses the custom equality function to compare values inside objects,\n * arrays, maps, sets, and other complex structures, ensuring a deep comparison.\n *\n * This approach provides flexibility in handling complex comparisons while maintaining efficient default behavior for simpler cases.\n *\n * The custom comparison function can take up to six parameters:\n * - `x`: The value from the first object `a`.\n * - `y`: The value from the second object `b`.\n * - `property`: The property key used to get `x` and `y`.\n * - `xParent`: The parent of the first value `x`.\n * - `yParent`: The parent of the second value `y`.\n * - `stack`: An internal stack (Map) to handle circular references.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @param {(x: any, y: any, property?: PropertyKey, xParent?: any, yParent?: any, stack?: Map<any, any>) => boolean | void} areValuesEqual - A function to customize the comparison.\n *   If it returns a boolean, that result will be used. If it returns undefined,\n *   the default equality comparison will be used.\n * @returns {boolean} `true` if the values are equal according to the customizer, otherwise `false`.\n *\n * @example\n * const customizer = (a, b) => {\n *   if (typeof a === 'string' && typeof b === 'string') {\n *     return a.toLowerCase() === b.toLowerCase();\n *   }\n * };\n * isEqualWith('Hello', 'hello', customizer); // true\n * isEqualWith({ a: 'Hello' }, { a: 'hello' }, customizer); // true\n * isEqualWith([1, 2, 3], [1, 2, 3], customizer); // true\n */\nexport function isEqualWith(\n  a: any,\n  b: any,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);\n}\n\nfunction isEqualWithImpl(\n  a: any,\n  b: any,\n  property: PropertyKey | undefined,\n  aParent: any,\n  bParent: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  const result = areValuesEqual(a, b, property, aParent, bParent, stack);\n\n  if (result !== undefined) {\n    return result;\n  }\n\n  if (typeof a === typeof b) {\n    switch (typeof a) {\n      case 'bigint':\n      case 'string':\n      case 'boolean':\n      case 'symbol':\n      case 'undefined': {\n        return a === b;\n      }\n      case 'number': {\n        return a === b || Object.is(a, b);\n      }\n      case 'function': {\n        return a === b;\n      }\n      case 'object': {\n        return areObjectsEqual(a, b, stack, areValuesEqual);\n      }\n    }\n  }\n\n  return areObjectsEqual(a, b, stack, areValuesEqual);\n}\n\nfunction areObjectsEqual(\n  a: any,\n  b: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  let aTag = getTag(a);\n  let bTag = getTag(b);\n\n  if (aTag === argumentsTag) {\n    aTag = objectTag;\n  }\n\n  if (bTag === argumentsTag) {\n    bTag = objectTag;\n  }\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case stringTag:\n      return a.toString() === b.toString();\n\n    case numberTag: {\n      const x = a.valueOf();\n      const y = b.valueOf();\n\n      return eq(x, y);\n    }\n\n    case booleanTag:\n    case dateTag:\n    case symbolTag:\n      return Object.is(a.valueOf(), b.valueOf());\n\n    case regexpTag: {\n      return a.source === b.source && a.flags === b.flags;\n    }\n\n    case functionTag: {\n      return a === b;\n    }\n  }\n\n  stack = stack ?? new Map();\n\n  const aStack = stack.get(a);\n  const bStack = stack.get(b);\n\n  if (aStack != null && bStack != null) {\n    return aStack === b;\n  }\n\n  stack.set(a, b);\n  stack.set(b, a);\n\n  try {\n    switch (aTag) {\n      case mapTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        for (const [key, value] of a.entries()) {\n          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case setTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        const aValues = Array.from(a.values());\n        const bValues = Array.from(b.values());\n\n        for (let i = 0; i < aValues.length; i++) {\n          const aValue = aValues[i];\n          const index = bValues.findIndex(bValue => {\n            return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);\n          });\n\n          if (index === -1) {\n            return false;\n          }\n\n          bValues.splice(index, 1);\n        }\n\n        return true;\n      }\n\n      case arrayTag:\n      case uint8ArrayTag:\n      case uint8ClampedArrayTag:\n      case uint16ArrayTag:\n      case uint32ArrayTag:\n      case bigUint64ArrayTag:\n      case int8ArrayTag:\n      case int16ArrayTag:\n      case int32ArrayTag:\n      case bigInt64ArrayTag:\n      case float32ArrayTag:\n      case float64ArrayTag: {\n        // Buffers are also treated as [object Uint8Array]s.\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n          return false;\n        }\n\n        if (a.length !== b.length) {\n          return false;\n        }\n\n        for (let i = 0; i < a.length; i++) {\n          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case arrayBufferTag: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case dataViewTag: {\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case errorTag: {\n        return a.name === b.name && a.message === b.message;\n      }\n\n      case objectTag: {\n        const areEqualInstances =\n          areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) ||\n          (isPlainObject(a) && isPlainObject(b));\n\n        if (!areEqualInstances) {\n          return false;\n        }\n\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\n\n        if (aKeys.length !== bKeys.length) {\n          return false;\n        }\n\n        for (let i = 0; i < aKeys.length; i++) {\n          const propKey = aKeys[i];\n          const aProp = (a as any)[propKey];\n\n          if (!Object.hasOwn(b, propKey)) {\n            return false;\n          }\n\n          const bProp = (b as any)[propKey];\n\n          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      default: {\n        return false;\n      }\n    }\n  } finally {\n    stack.delete(a);\n    stack.delete(b);\n  }\n}\n","/**\n * The functions isJSONValue, isJSONArray, and isJSONObject are grouped in this file\n * to prevent any circular dependency issues.\n */\nimport { isPlainObject } from './isPlainObject.ts';\n\n/**\n * Checks if a given value is a valid JSON value.\n *\n * A valid JSON value can be:\n * - null\n * - a JSON object (an object with string keys and valid JSON values)\n * - a JSON array (an array of valid JSON values)\n * - a string\n * - a number\n * - a boolean\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} - True if the value is a valid JSON value, otherwise false.\n *\n * @example\n * console.log(isJSONValue(null)); // true\n * console.log(isJSONValue({ key: \"value\" })); // true\n * console.log(isJSONValue([1, 2, 3])); // true\n * console.log(isJSONValue(\"Hello\")); // true\n * console.log(isJSONValue(42)); // true\n * console.log(isJSONValue(true)); // true\n * console.log(isJSONValue(undefined)); // false\n * console.log(isJSONValue(() => {})); // false\n */\nexport function isJSONValue(value: unknown): value is Record<string, any> | any[] | string | number | boolean | null {\n  switch (typeof value) {\n    case 'object': {\n      return value === null || isJSONArray(value) || isJSONObject(value);\n    }\n    case 'string':\n    case 'number':\n    case 'boolean': {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/**\n * Checks if a given value is a valid JSON array.\n *\n * A valid JSON array is defined as an array where all items are valid JSON values.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is any[]} - True if the value is a valid JSON array, otherwise false.\n *\n * @example\n * console.log(isJSONArray([1, 2, 3])); // true\n * console.log(isJSONArray([\"string\", null, true])); // true\n * console.log(isJSONArray([1, 2, () => {}])); // false\n * console.log(isJSONArray(\"not an array\")); // false\n */\nexport function isJSONArray(value: unknown): value is any[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  return value.every(item => isJSONValue(item));\n}\n\n/**\n * Checks if a value is a JSON object.\n *\n * A valid JSON object is defined as an object with string keys and valid JSON values.\n *\n * @param {unknown} obj The value to check.\n * @returns {obj is Record<string, any>} True if `obj` is a JSON object, false otherwise.\n *\n * @example\n * isJSONObject({ nested: { boolean: true, array: [1, 2, 3], string: 'test', null: null } }); // true\n * isJSONObject({ regexp: /test/ }); // false\n * isJSONObject(123); // false\n */\nexport function isJSONObject(obj: unknown): obj is Record<string, any> {\n  if (!isPlainObject(obj)) {\n    return false;\n  }\n\n  const keys = Reflect.ownKeys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (!isJSONValue(value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Checks if a given value is a valid length.\n *\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\n * It returns `true` if the value is a valid length, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\n * argument to a valid length (`number`).\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n *\n * @example\n * isLength(0); // true\n * isLength(42); // true\n * isLength(-1); // false\n * isLength(1.5); // false\n * isLength(Number.MAX_SAFE_INTEGER); // true\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\n */\nexport function isLength(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: unknown): x is null | undefined {\n  return x == null;\n}\n","/**\n * Checks if the given value is null.\n *\n * This function tests whether the provided value is strictly equal to `null`.\n * It returns `true` if the value is `null`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\n *\n * @param {unknown} x - The value to test if it is null.\n * @returns {x is null} True if the value is null, false otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n *\n * console.log(isNull(value1)); // true\n * console.log(isNull(value2)); // false\n * console.log(isNull(value3)); // false\n */\nexport function isNull(x: unknown): x is null {\n  return x === null;\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n *\n * @example\n * import { isSymbol } from 'es-toolkit/predicate';\n *\n * isSymbol(Symbol('a')); // true\n * isSymbol(Symbol.for('a')); // true\n * isSymbol(Symbol.iterator); // true\n *\n * isSymbol(null); // false\n * isSymbol(undefined); // false\n * isSymbol('123'); // false\n * isSymbol(false); // false\n * isSymbol(123n); // false\n * isSymbol({}); // false\n * isSymbol([1, 2, 3]); // false\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === 'symbol';\n}\n","/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {unknown} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: unknown): x is undefined {\n  return x === undefined;\n}\n","/**\n * Converts the first character of string to upper case and the remaining to lower case.\n *\n * @template T - Literal type of the string.\n * @param {T} str - The string to be converted to uppercase.\n * @returns {Capitalize<T>} - The capitalized string.\n *\n * @example\n * const result = capitalize('fred') // returns 'Fred'\n * const result2 = capitalize('FRED') // returns 'Fred'\n */\n\nexport function capitalize<T extends string>(str: T): Capitalize<T> {\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\n}\n\ntype Capitalize<T extends string> = T extends `${infer F}${infer R}` ? `${Uppercase<F>}${Lowercase<R>}` : T;\n","/**\n * Regular expression pattern to split strings into words for various case conversions\n *\n * This pattern matches sequences of characters in a string, considering the following cases:\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\n * - Single uppercase letters\n * - Sequences of digits\n * - Emojis and other Unicode characters\n *\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\n * a consistent format like snake case. It also supports emojis and other Unicode characters.\n *\n * @example\n * const matches = 'camelCaseHTTPRequest'.match(CASE_SPLIT_PATTERN);\n * // matches: ['camel', 'Case', 'HTTP', 'Request', '']\n */\nexport const CASE_SPLIT_PATTERN =\n  /\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+/gu;\n\n/**\n * Splits `string` into an array of its words, treating spaces and punctuation marks as separators.\n *\n * @param {string} str The string to inspect.\n * @param {RegExp | string} [pattern] The pattern to match words.\n * @returns {string[]} Returns the words of `string`.\n *\n * @example\n * words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * words('camelCaseHTTPRequest');\n * // => ['camel', 'Case', 'HTTP', 'Request', '']\n *\n * words('Luned 18 Set')\n * // => ['Luned', '18', 'Set']\n */\nexport function words(str: string): string[] {\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\n}\n","const deburrMap = new Map<string, string>(\n  // eslint-disable-next-line no-restricted-syntax\n  Object.entries({\n    : 'Ae',\n    : 'D',\n    : 'O',\n    : 'Th',\n    : 'ss',\n    : 'ae',\n    : 'd',\n    : 'o',\n    : 'th',\n    : 'D',\n    : 'd',\n    : 'H',\n    : 'h',\n    : 'i',\n    : 'IJ',\n    : 'ij',\n    : 'k',\n    : 'L',\n    : 'l',\n    : 'L',\n    : 'l',\n    : \"'n\",\n    : 'N',\n    : 'n',\n    : 'Oe',\n    : 'oe',\n    : 'T',\n    : 't',\n    : 's',\n  })\n);\n\n/**\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\n * For example, \"Crme brle\" becomes \"Creme brulee\".\n *\n * @param {string} str - The input string to be deburred.\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\n *\n * @example\n * // Basic usage:\n * deburr('thelred') // returns 'Aethelred'\n *\n * @example\n * // Handling diacritical marks:\n * deburr('Mnchen') // returns 'Munchen'\n *\n * @example\n * // Special characters:\n * deburr('Crme brle') // returns 'Creme brulee'\n */\nexport function deburr(str: string): string {\n  str = str.normalize('NFD');\n\n  let result = '';\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n\n    if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\n      continue;\n    }\n\n    result += deburrMap.get(char) ?? char;\n  }\n\n  return result;\n}\n","const htmlEscapes: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\n */\nexport function escape(str: string): string {\n  return str.replace(/[&<>\"']/g, match => htmlEscapes[match]);\n}\n","/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\n * @returns {string} - The resulting string after the specified trailing character has been removed.\n *\n * @example\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\n */\nexport function trimEnd(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimEnd();\n  }\n\n  let endIndex = str.length;\n\n  switch (typeof chars) {\n    case 'string': {\n      while (endIndex > 0 && str[endIndex - 1] === chars) {\n        endIndex--;\n      }\n      break;\n    }\n    case 'object': {\n      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {\n        endIndex--;\n      }\n    }\n  }\n\n  return str.substring(0, endIndex);\n}\n","/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the start of the string.\n * @returns {string} - The resulting string after the specified leading character has been removed.\n *\n * @example\n * const trimmedStr1 = trimStart('---hello', '-') // returns 'hello'\n * const trimmedStr2 = trimStart('000123', '0') // returns '123'\n * const trimmedStr3 = trimStart('abcabcabc', 'a') // returns 'bcabcabc'\n * const trimmedStr4 = trimStart('xxxtrimmed', 'x') // returns 'trimmed'\n */\nexport function trimStart(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimStart();\n  }\n  let startIndex = 0;\n\n  switch (typeof chars) {\n    case 'string': {\n      while (startIndex < str.length && str[startIndex] === chars) {\n        startIndex++;\n      }\n      break;\n    }\n    case 'object': {\n      while (startIndex < str.length && chars.includes(str[startIndex])) {\n        startIndex++;\n      }\n    }\n  }\n\n  return str.substring(startIndex);\n}\n","import { trimEnd } from './trimEnd.ts';\nimport { trimStart } from './trimStart.ts';\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the string. Can be a single character or an array of characters.\n * @returns {string} - The resulting string after the specified characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trim();\n  }\n\n  return trimStart(trimEnd(str, chars), chars);\n}\n","const htmlUnescapes: Record<string, string> = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\",\n};\n\n/**\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\n * It is the inverse of `escape`.\n *\n * @param {string} str The string to unescape.\n * @returns {string} Returns the unescaped string.\n *\n * @example\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\n */\nexport function unescape(str: string): string {\n  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, match => htmlUnescapes[match] || \"'\");\n}\n","export function toArray<T>(value: ArrayLike<T>): T[] {\n  return Array.isArray(value) ? value : Array.from(value);\n}\n","import { isLength } from '../../predicate/isLength.ts';\n\n/**\n * Checks if `value` is array-like.\n *\n * @param {unknown} value The value to check.\n * @returns {value is ArrayLike<unknown>} Returns `true` if `value` is array-like, else `false`.\n *\n * @example\n * isArrayLike([1, 2, 3]); // true\n * isArrayLike('abc'); // true\n * isArrayLike({ 0: 'a', length: 1 }); // true\n * isArrayLike({}); // false\n * isArrayLike(null); // false\n * isArrayLike(undefined); // false\n */\nexport function isArrayLike(value?: unknown): value is ArrayLike<unknown> {\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\n}\n","import { isArrayLike } from './isArrayLike.ts';\nimport { isObjectLike } from './isObjectLike.ts';\n\n/**\n * Checks if the given value is a non-primitive, array-like object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is ArrayLike<unknown> & object} `true` if the value is a non-primitive, array-like object, `false` otherwise.\n *\n * @example\n * isArrayLikeObject([1, 2, 3]); // true\n * isArrayLikeObject({ 0: 'a', length: 1 }); // true\n * isArrayLikeObject('abc'); // false\n * isArrayLikeObject(()=>{}); // false\n */\nexport function isArrayLikeObject(value?: unknown): value is ArrayLike<unknown> & object {\n  return isObjectLike(value) && isArrayLike(value);\n}\n","import { last as lastToolkit } from '../../array/last.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(array: ArrayLike<T> | null | undefined): T | undefined {\n  if (!isArrayLike(array)) {\n    return undefined;\n  }\n  return lastToolkit(toArray(array));\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\nexport function flattenArrayLike<T>(values: Array<ArrayLike<T> | unknown>): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const arrayLike = values[i];\n\n    if (!isArrayLikeObject(arrayLike)) {\n      continue;\n    }\n\n    for (let j = 0; j < arrayLike.length; j++) {\n      result.push(arrayLike[j] as T);\n    }\n  }\n\n  return result;\n}\n","/**\n * Checks if a given key is a deep key.\n *\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\n *\n * @param {PropertyKey} key - The key to check.\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\n *\n * Examples:\n *\n * isDeepKey('a.b') // true\n * isDeepKey('a[b]') // true\n * isDeepKey('a') // false\n * isDeepKey(123) // false\n * isDeepKey('a.b.c') // true\n * isDeepKey('a[b][c]') // true\n */\nexport function isDeepKey(key: PropertyKey): boolean {\n  switch (typeof key) {\n    case 'number':\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return key.includes('.') || key.includes('[') || key.includes(']');\n    }\n  }\n}\n","/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nexport function toKey(value: number) {\n  if (Object.is(value, -0)) {\n    return '-0';\n  }\n  return value.toString();\n}\n","/**\n * Converts a deep key string into an array of path segments.\n *\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\n *\n * @param {string} deepKey - The deep key string to convert.\n * @returns {string[]} An array of strings, each representing a segment of the path.\n *\n * Examples:\n *\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\n * toPath('') // Returns []\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\n */\nexport function toPath(deepKey: string): string[] {\n  const result: string[] = [];\n  const length = deepKey.length;\n\n  if (length === 0) {\n    return result;\n  }\n\n  let index = 0;\n  let key = '';\n  let quoteChar = '';\n  let bracket = false;\n\n  // Leading dot\n  if (deepKey.charCodeAt(0) === 46) {\n    result.push('');\n    index++;\n  }\n\n  while (index < length) {\n    const char = deepKey[index];\n\n    if (quoteChar) {\n      if (char === '\\\\' && index + 1 < length) {\n        // Escape character\n        index++;\n        key += deepKey[index];\n      } else if (char === quoteChar) {\n        // End of quote\n        quoteChar = '';\n      } else {\n        key += char;\n      }\n    } else if (bracket) {\n      if (char === '\"' || char === \"'\") {\n        // Start of quoted string inside brackets\n        quoteChar = char;\n      } else if (char === ']') {\n        // End of bracketed segment\n        bracket = false;\n        result.push(key);\n        key = '';\n      } else {\n        key += char;\n      }\n    } else {\n      if (char === '[') {\n        // Start of bracketed segment\n        bracket = true;\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else if (char === '.') {\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else {\n        key += char;\n      }\n    }\n\n    index++;\n  }\n\n  if (key) {\n    result.push(key);\n  }\n\n  return result;\n}\n","import type { Get } from './get.types.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K]} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(object: T, path: K | readonly [K]): T[K];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(\n  object: T | null | undefined,\n  path: K | readonly [K]\n): T[K] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T, D>(\n  object: T | null | undefined,\n  path: K | readonly [K],\n  defaultValue: D\n): Exclude<T[K], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\n  object: T,\n  path: readonly [K1, K2]\n): T[K1][K2];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\n  object: T | null | undefined,\n  path: readonly [K1, K2]\n): T[K1][K2] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], D>(\n  object: T | null | undefined,\n  path: readonly [K1, K2],\n  defaultValue: D\n): Exclude<T[K1][K2], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T,\n  path: readonly [K1, K2, K3]\n): T[K1][K2][K3];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3]\n): T[K1][K2][K3] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], D>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3],\n  defaultValue: D\n): Exclude<T[K1][K2][K3], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4]} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4] | undefined} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T | null | undefined, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3][K4], undefined> | D} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  D,\n>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3, K4],\n  defaultValue: D\n): Exclude<T[K1][K2][K3][K4], undefined> | D;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T>} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T>, path: number): T;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T | undefined} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n * @template D - The type of the default value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {T | D} - Returns the resolved value.\n */\nexport function get<T, D>(object: Record<number, T> | null | undefined, path: number, defaultValue: D): T | D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning the default value.\n *\n * @template D - The type of the default value.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {D} - Returns the default value.\n */\nexport function get<D>(object: null | undefined, path: PropertyKey, defaultValue: D): D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning undefined.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @returns {undefined} - Returns undefined.\n */\nexport function get(object: null | undefined, path: PropertyKey): undefined;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @returns {string extends P ? any : Get<T, P>} - Returns the resolved value.\n */\nexport function get<T, P extends string>(data: T, path: P): string extends P ? any : Get<T, P>;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n * @template D - The type of the default value.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<Get<T, P>, null | undefined> | D} - Returns the resolved value.\n */\nexport function get<T, P extends string, D = Get<T, P>>(\n  data: T,\n  path: P,\n  defaultValue: D\n): Exclude<Get<T, P>, null | undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} - Returns the resolved value.\n */\nexport function get(object: unknown, path: PropertyKey | readonly PropertyKey[], defaultValue?: unknown): any;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} - Returns the resolved value.\n */\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\n  if (object == null) {\n    return defaultValue;\n  }\n\n  switch (typeof path) {\n    case 'string': {\n      const result = object[path];\n\n      if (result === undefined) {\n        if (isDeepKey(path)) {\n          return get(object, toPath(path), defaultValue);\n        } else {\n          return defaultValue;\n        }\n      }\n\n      return result;\n    }\n    case 'number':\n    case 'symbol': {\n      if (typeof path === 'number') {\n        path = toKey(path);\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n    default: {\n      if (Array.isArray(path)) {\n        return getWithPath(object, path, defaultValue);\n      }\n\n      if (Object.is(path?.valueOf(), -0)) {\n        path = '-0';\n      } else {\n        path = String(path);\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n  }\n}\n\nfunction getWithPath(object: any, path: readonly PropertyKey[], defaultValue?: any): any {\n  if (path.length === 0) {\n    return defaultValue;\n  }\n\n  let current = object;\n\n  for (let index = 0; index < path.length; index++) {\n    if (current == null) {\n      return defaultValue;\n    }\n\n    current = current[path[index]];\n  }\n\n  if (current === undefined) {\n    return defaultValue;\n  }\n\n  return current;\n}\n","import { get } from './get.ts';\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to get.\n * @returns {(object: unknown) => any} - Returns a new function that takes an object and returns the value at the specified path.\n *\n * @example\n * const getObjectValue = property('a.b.c');\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n *\n * @example\n * const getObjectValue = property(['a', 'b', 'c']);\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n */\nexport function property(path: PropertyKey | readonly PropertyKey[]): (object: unknown) => any {\n  return function (object: unknown) {\n    return get(object, path);\n  };\n}\n","/**\n * Checks if the given value is an object. An object is a value that is\n * not a primitive type (string, number, boolean, symbol, null, or undefined).\n *\n * This function tests whether the provided value is an object or not.\n * It returns `true` if the value is an object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object value.\n *\n * @param {unknown} value - The value to check if it is an object.\n * @returns {value is object} `true` if the value is an object, `false` otherwise.\n *\n * @example\n * const value1 = {};\n * const value2 = [1, 2, 3];\n * const value3 = () => {};\n * const value4 = null;\n *\n * console.log(isObject(value1)); // true\n * console.log(isObject(value2)); // true\n * console.log(isObject(value3)); // true\n * console.log(isObject(value4)); // false\n */\n\nexport function isObject(value?: unknown): value is object {\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n","import { isObject } from './isObject.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {unknown} target - The target value to match against.\n * @param {unknown} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: unknown, source: unknown): boolean;\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {unknown} target - The target value to match against.\n * @param {unknown} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: any, source: any): boolean {\n  if (source === target) {\n    return true;\n  }\n\n  switch (typeof source) {\n    case 'object': {\n      if (source == null) {\n        return true;\n      }\n\n      const keys = Object.keys(source as any);\n\n      if (target == null) {\n        return keys.length === 0;\n      }\n\n      if (Array.isArray(source)) {\n        return isArrayMatch(target, source);\n      }\n\n      if (source instanceof Map) {\n        return isMapMatch(target, source);\n      }\n\n      if (source instanceof Set) {\n        return isSetMatch(target, source);\n      }\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (!isPrimitive(target) && !(key in target)) {\n          return false;\n        }\n\n        if (source[key] === undefined && target[key] !== undefined) {\n          return false;\n        }\n\n        if (source[key] === null && target[key] !== null) {\n          return false;\n        }\n\n        if (!isMatch(target[key], source[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    case 'function': {\n      if (Object.keys(source).length > 0) {\n        return isMatch(target, { ...source });\n      }\n\n      return false;\n    }\n    default: {\n      if (!isObject(target)) {\n        return eq(target, source);\n      }\n\n      return !source;\n    }\n  }\n}\n\nexport function isMapMatch(target: unknown, source: Map<any, any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Map)) {\n    return false;\n  }\n\n  for (const [key, value] of source.entries()) {\n    if (!isMatch(target.get(key), value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isArrayMatch(target: unknown, source: readonly unknown[]) {\n  if (source.length === 0) {\n    return true;\n  }\n\n  if (!Array.isArray(target)) {\n    return false;\n  }\n\n  const countedIndex = new Set<number>();\n\n  for (let i = 0; i < source.length; i++) {\n    const sourceItem = source[i];\n    const index = target.findIndex((targetItem, index) => {\n      return isMatch(targetItem, sourceItem) && !countedIndex.has(index);\n    });\n\n    if (index === -1) {\n      return false;\n    }\n\n    countedIndex.add(index);\n  }\n\n  return true;\n}\n\nexport function isSetMatch(target: unknown, source: Set<any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Set)) {\n    return false;\n  }\n\n  return isArrayMatch([...target], [...source]);\n}\n","import { isMatch } from './isMatch.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @param {unknown} source - The source object to create the matcher from.\n * @returns {(target: unknown) => boolean} - Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * const matcher = matches({ a: 1, b: 2 });\n * matcher({ a: 1, b: 2, c: 3 }); // true\n * matcher({ a: 1, c: 3 }); // false\n *\n * @example\n * // Matching arrays\n * const arrayMatcher = matches([1, 2, 3]);\n * arrayMatcher([1, 2, 3, 4]); // true\n * arrayMatcher([4, 5, 6]); // false\n *\n * @example\n * // Matching objects with nested structures\n * const nestedMatcher = matches({ a: { b: 2 } });\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\n * nestedMatcher({ a: { c: 3 } }); // false\n */\nexport function matches(source: unknown): (target: unknown) => boolean {\n  source = cloneDeep(source);\n\n  return (target?: unknown): boolean => {\n    return isMatch(target, source);\n  };\n}\n","import { cloneDeepWith as cloneDeepWithToolkit } from '../../object/cloneDeepWith.ts';\nimport { copyProperties } from '../../object/cloneDeepWith.ts';\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\n\n/**\n * Creates a deep clone of the given object using a customizer function.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(\n  obj: T,\n  cloneValue?: (value: any, key: PropertyKey | undefined, object: T | undefined, stack: Map<any, any>) => any\n): T {\n  return cloneDeepWithToolkit(obj, (value, key, object, stack) => {\n    const cloned = cloneValue?.(value, key, object, stack);\n\n    if (cloned != null) {\n      return cloned;\n    }\n\n    if (typeof obj !== 'object') {\n      return undefined;\n    }\n\n    switch (Object.prototype.toString.call(obj)) {\n      case numberTag:\n      case stringTag:\n      case booleanTag: {\n        // eslint-disable-next-line\n        // @ts-ignore\n        const result = new obj.constructor(obj?.valueOf()) as T;\n        copyProperties(result, obj);\n        return result;\n      }\n\n      case argumentsTag: {\n        const result = {} as any;\n\n        copyProperties(result, obj);\n\n        // eslint-disable-next-line\n        // @ts-ignore\n        result.length = obj.length;\n        // eslint-disable-next-line\n        // @ts-ignore\n        result[Symbol.iterator] = obj[Symbol.iterator];\n\n        return result as T;\n      }\n\n      default: {\n        return undefined;\n      }\n    }\n  });\n}\n","import { cloneDeepWith } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWith(obj);\n}\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\n\nexport function isIndex(value: PropertyKey, length = Number.MAX_SAFE_INTEGER): boolean {\n  switch (typeof value) {\n    case 'number': {\n      return Number.isInteger(value) && value >= 0 && value < length;\n    }\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return IS_UNSIGNED_INTEGER.test(value);\n    }\n  }\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if the given value is an arguments object.\n *\n * This function tests whether the provided value is an arguments object or not.\n * It returns `true` if the value is an arguments object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\n *\n * @param {unknown} value - The value to test if it is an arguments object.\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\n *\n * @example\n * const args = (function() { return arguments; })();\n * const strictArgs = (function() { 'use strict'; return arguments; })();\n * const value = [1, 2, 3];\n *\n * console.log(isArguments(args)); // true\n * console.log(isArguments(strictArgs)); // true\n * console.log(isArguments(value)); // false\n */\nexport function isArguments(value?: unknown): value is IArguments {\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {object} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: unknown, path: PropertyKey | readonly PropertyKey[]): boolean;\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {object} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return false;\n  }\n\n  let current = object;\n\n  for (let i = 0; i < resolvedPath.length; i++) {\n    const key = resolvedPath[i];\n\n    // Check if the current key is a direct property of the current object\n    if (current == null || !Object.hasOwn(current, key)) {\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\n\n      if (!isSparseIndex) {\n        return false;\n      }\n    }\n\n    current = current[key];\n  }\n\n  return true;\n}\n","import { isMatch } from './isMatch.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { cloneDeep } from '../object/cloneDeep.ts';\nimport { get } from '../object/get.ts';\nimport { has } from '../object/has.ts';\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * The returned function takes a target object and determines if the property at the\n * specified path within the target object is equal to the given value.\n *\n * @param {PropertyKey | PropertyKey[]} property - The property path to check within the target object.\n *     This can be a single property key or an array of property keys.\n * @param {unknown} source - The value to compare against the property value in the target object.\n *\n * @returns {(target: unknown) => boolean} - A function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * // Using a single property key\n * const checkName = matchesProperty('name', 'Alice');\n * console.log(checkName({ name: 'Alice' })); // true\n * console.log(checkName({ name: 'Bob' })); // false\n *\n * // Using an array of property keys\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\n * console.log(checkNested({ address: { city: 'New York' } })); // true\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\n */\nexport function matchesProperty(\n  property: PropertyKey | readonly PropertyKey[],\n  source: unknown\n): (target?: unknown) => boolean {\n  switch (typeof property) {\n    case 'object': {\n      if (Object.is(property?.valueOf(), -0)) {\n        property = '-0';\n      }\n      break;\n    }\n    case 'number': {\n      property = toKey(property);\n      break;\n    }\n  }\n\n  source = cloneDeep(source);\n\n  return function (target?: unknown) {\n    const result = get(target, property as PropertyKey | PropertyKey[]);\n\n    if (result === undefined) {\n      return has(target, property as PropertyKey | PropertyKey[]);\n    }\n\n    if (source === undefined) {\n      return result === undefined;\n    }\n\n    return isMatch(result, source);\n  };\n}\n","import { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Returns a `identity` function when `value` is `null` or `undefined`.\n *\n * @param {null} [value] - The value to convert to an iteratee.\n * @returns {<T>(value: T) => T} - Returns a `identity` function.\n *\n * @example\n * const func = iteratee();\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [{ a: 1 }, { a: 2 }, { a: 3 }]\n */\nexport function iteratee(value?: null): <T>(value: T) => T;\n\n/**\n * Returns a given `func` function when `value` is a `function`.\n *\n * @template {(...args: any[]) => unknown} F - The function type.\n * @param {F} func - The function to return.\n * @returns {F} - Returns the given function.\n *\n * @example\n * const func = iteratee((object) => object.a);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n */\nexport function iteratee<F extends (...args: any[]) => unknown>(func: F): F;\n\n/**\n * Creates a function that invokes `value` with the arguments of the created function.\n *\n * The created function returns the property value for a given element.\n *\n * @param {symbol | number | string | object} value - The value to convert to an iteratee.\n * @returns {(...args: any[]) => any} - Returns the new iteratee function.\n *\n * @example\n * const func = iteratee('a');\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee({ a: 1 });\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n *\n * const func = iteratee(['a', 1]);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n */\nexport function iteratee(value?: symbol | number | string | object): (...args: any[]) => any;\n\n/**\n * Creates a function that returns a value from an element in a collection.\n *\n * You can call `iteratee` with the following types of arguments:\n *\n * - **Function**: Returns the function as-is, which will be called with the element from the collection.\n * - **Property name**: Returns the value of the specified property from the element.\n * - **Property-value pair**: Returns a boolean indicating whether the element's property matches the given value.\n * - **Partial object**: Returns a boolean indicating whether the element matches the properties of the partial object.\n *\n * If you don't provide any arguments or pass `null`, this function will return a function that simply returns its input unchanged.\n *\n * @param {symbol | number | string | object | null | ((...args: any[]) => any)} value - The value to convert to an iteratee.\n * @returns {(...args: any[]) => unknown} - Returns the new iteratee function.\n * @example\n * const func = iteratee();\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [{ a: 1 }, { a: 2 }, { a: 3 }]\n *\n * const func = iteratee((object) => object.a);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee('a');\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee({ a: 1 });\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n *\n * const func = iteratee(['a', 1]);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n */\nexport function iteratee(\n  value?: symbol | number | string | object | null | ((...args: any[]) => unknown)\n): (...args: any[]) => any {\n  if (value == null) {\n    return identity;\n  }\n\n  switch (typeof value) {\n    case 'function': {\n      return value as any;\n    }\n    case 'object': {\n      if (Array.isArray(value) && value.length === 2) {\n        return matchesProperty(value[0], value[1]);\n      }\n\n      return matches(value);\n    }\n    case 'string':\n    case 'symbol':\n    case 'number': {\n      return property(value);\n    }\n  }\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n * @example\n * isSymbol(Symbol.iterator);\n * // => true\n *\n * isSymbol('abc');\n * // => false\n */\nexport function isSymbol(value?: unknown): value is symbol {\n  return typeof value === 'symbol' || value instanceof Symbol;\n}\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**\n * Converts `value` to a number.\n *\n * Unlike `Number()`, this function returns `NaN` for symbols.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => Infinity\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => NaN\n * toNumber(NaN); // => NaN\n */\nexport function toNumber(value?: unknown): number {\n  if (isSymbol(value)) {\n    return NaN;\n  }\n\n  return Number(value);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Converts `value` to a finite number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => 1.7976931348623157e+308\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => 0\n * toNumber(NaN); // => 0\n */\nexport function toFinite(value?: unknown): number {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n\n  value = toNumber(value);\n\n  if (value === Infinity || value === -Infinity) {\n    const sign = value < 0 ? -1 : 1;\n    return sign * Number.MAX_VALUE;\n  }\n\n  return value === value ? (value as number) : 0;\n}\n","import { toFinite } from './toFinite.ts';\n\n/**\n * Converts `value` to an integer.\n *\n * This function first converts `value` to a finite number. If the result has any decimal places,\n * they are removed by rounding down to the nearest whole number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toInteger(3.2); // => 3\n * toInteger(Number.MIN_VALUE); // => 0\n * toInteger(Infinity); // => 1.7976931348623157e+308\n * toInteger('3.2'); // => 3\n * toInteger(Symbol.iterator); // => 0\n * toInteger(NaN); // => 0\n */\nexport function toInteger(value?: unknown): number {\n  const finite = toFinite(value);\n  const remainder = finite % 1;\n\n  return remainder ? finite - remainder : finite;\n}\n","import { isIndex } from './isIndex.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { eq } from '../util/eq.ts';\n\nexport function isIterateeCall(value: unknown, index: unknown, object: unknown): boolean {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  if (\n    (typeof index === 'number' && isArrayLike(object) && isIndex(index) && index < object.length) ||\n    (typeof index === 'string' && index in object)\n  ) {\n    return eq((object as any)[index], value);\n  }\n\n  return false;\n}\n","/**\n * Checks if a given value is string.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\n *\n * @param {unknown} value The value to check if it is string.\n * @returns {value is string} Returns `true` if `value` is a string, else `false`.\n *\n * @example\n * const value1 = 'abc';\n * const value2 = 123;\n * const value3 = true;\n *\n * console.log(isString(value1)); // true\n * console.log(isString(value2)); // false\n * console.log(isString(value3)); // false\n */\n\nexport function isString(value?: unknown): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n","/**\n * Checks if the given value is an array.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @param {unknown} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray(value1)); // true\n * console.log(isArray(value2)); // false\n * console.log(isArray(value3)); // false\n */\nexport function isArray(value?: unknown): value is any[] {\n  return Array.isArray(value);\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {ArrayLike<T> | null | undefined} value - The object to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(\n  value: ArrayLike<T> | null | undefined,\n  depth = 1 as D\n): Array<FlatArray<T[], D>> | [] {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  if (!isArrayLike(value)) {\n    return result;\n  }\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (\n        currentDepth < flooredDepth &&\n        (Array.isArray(item) ||\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\n      ) {\n        if (Array.isArray(item)) {\n          recursive(item, currentDepth + 1);\n        } else {\n          recursive(Array.from(item as T[]), currentDepth + 1);\n        }\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(Array.from(value), 0);\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template K - The type of elements in the array.\n * @template T - The type of the array.\n * @param {T | null | undefined} array - The array to iterate over.\n * @param {(value: K, index: number, array: T) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(array: T[], callback?: (value: T, index: number, array: T[]) => unknown): T[];\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template K - The type of elements in the array.\n * @template T - The type of the array.\n * @param {T | null | undefined} array - The array to iterate over.\n * @param {(value: K, index: number, array: T) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(\n  array: readonly T[],\n  callback?: (value: T, index: number, array: T[]) => unknown\n): readonly T[];\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template T - The type of string.\n * @param {T | null | undefined} string - The string to iterate over\n * @param {(value: T, index: number, string: T) => unknown} [callback] - The function invoked for each char.\n * The callback function receives three arguments:\n *  - 'char': The current char being processed in the string.\n *  - 'index': The index of the current char being processed in the string.\n *  - 'string': The string 'forEach' was called upon.\n * @returns {T} Returns the original string.\n *\n * @example\n * forEach('abc', (char, index, string) => console.log(char, index));\n * // Output:\n * // 'a' 0\n * // 'b' 1\n * // 'c' 2\n */\nexport function forEach<T extends string | null | undefined>(\n  string: T,\n  callback?: (char: string, index: number, string: string) => unknown\n): T;\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template T - The type of elements in the array.\n * @param { ArrayLike<T> } array - The array to iterate over.\n * @param {(value: T, index: number, array: ArrayLike<T>) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(\n  array: ArrayLike<T>,\n  callback?: (value: T, index: number, array: ArrayLike<T>) => unknown\n): ArrayLike<T>;\n\n/**\n * Iterates over each element of the object invoking the provided callback function for each property.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEach' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEach({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 1 'a'\n * // 2 'b'\n */\nexport function forEach<T extends object | null | undefined>(\n  object: T,\n  callback?: (value: T[keyof T], key: keyof T, object: T) => unknown\n): T;\n\n/**\n * Iterates over each element of the object invoking the provided callback function for each property.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEach' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEach({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 1 'a'\n * // 2 'b'\n */\nexport function forEach<T>(\n  collection: ArrayLike<T> | Record<any, any> | string | null | undefined,\n  callback: (item: any, index: any, arr: any) => unknown = identity\n): ArrayLike<T> | Record<any, any> | string | null | undefined {\n  if (!collection) {\n    return collection;\n  }\n\n  const keys: PropertyKey[] =\n    isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    const result = callback(value, key, collection);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return collection;\n}\n","import { head as headToolkit } from '../../array/head.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | undefined | null} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: ArrayLike<T> | undefined | null): T | undefined {\n  if (!isArrayLike(arr)) {\n    return undefined;\n  }\n  return headToolkit(toArray(arr));\n}\n","/**\n * Returns the first element of an array.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} arr - A non-empty array from which to get the first element.\n * @returns {T} The first element of the array.\n *\n * @example\n * const arr = [1, 2, 3];\n * const firstElement = head(arr);\n * // firstElement will be 1\n */\nexport function head<T>(arr: readonly [T, ...T[]]): T;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n","import { uniq as uniqToolkit } from '../../array/uniq.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return uniqToolkit(Array.from(arr));\n}\n","import { last } from './last.ts';\nimport { intersectionWith as intersectionWithToolkit } from '../../array/intersectionWith.ts';\nimport { uniq as uniqToolkit } from '../array/uniq.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2, name: 'amy' }] since this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionWith<T, U>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  areItemsEqual: (x: T, y: U) => boolean\n): T[];\n/**\n * Returns the intersection of three arrays based on a custom equality function.\n *\n * @template T - The type of elements in the first array\n * @template U - The type of elements in the second array\n * @template V - The type of elements in the third array\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {ArrayLike<U> | null | undefined} secondArr - The second array to compare\n * @param {ArrayLike<V> | null | undefined} thirdArr - The third array to compare\n * @param {(x: T, y: U | V) => boolean} areItemsEqual - Custom equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const result = intersectionWith(arr1, arr2, arr3, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T, U, V>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  thirdArr: ArrayLike<V> | null | undefined,\n  areItemsEqual: (x: T, y: U | V) => boolean\n): T[];\n\n/**\n * Returns the intersection of four arrays based on a custom equality function.\n *\n * @template T - The type of elements in the first array\n * @template U - The type of elements in the second array\n * @template V - The type of elements in the third array\n * @template W - The type of elements in the fourth array\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {ArrayLike<U> | null | undefined} secondArr - The second array to compare\n * @param {ArrayLike<V> | null | undefined} thirdArr - The third array to compare\n * @param {ArrayLike<V> | null | undefined} fourthArr - The fourth array to compare\n * @param {(x: T, y: U | V | W) => boolean} areItemsEqual - Custom equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const arr4 = [{id: 2}, {id: 5}];\n * const result = intersectionWith(arr1, arr2, arr3, arr4, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T, U, V, W>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  thirdArr: ArrayLike<V> | null | undefined,\n  fourthArr: ArrayLike<V> | null | undefined,\n  areItemsEqual: (x: T, y: U | V | W) => boolean\n): T[];\n\n/**\n * Returns the intersection of multiple arrays based on a custom equality function.\n *\n * @template T - The type of elements in the arrays\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {...(ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean))} otherArrs - Additional arrays and optional equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const result = intersectionWith(arr1, arr2, arr3, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T>(\n  firstArr: ArrayLike<T> | null | undefined,\n  ...otherArrs: Array<ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean)>\n): T[];\n\n/**\n * Returns the intersection of multiple arrays based on a custom equality function.\n *\n * @template T - The type of elements in the arrays\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {...(ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean))} otherArrs - Additional arrays and optional equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const result = intersectionWith(arr1, arr2, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T>(\n  firstArr: ArrayLike<T> | null | undefined,\n  ...otherArrs: Array<ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean)>\n): T[] {\n  console.log(firstArr);\n\n  if (firstArr == null) {\n    return [];\n  }\n\n  const _comparator = last(otherArrs);\n  let comparator = eq as (x: T, y: T) => boolean;\n  let uniq: (arr: T[]) => T[] = uniqToolkit;\n\n  if (typeof _comparator === 'function') {\n    comparator = _comparator;\n    uniq = uniqPreserve0;\n    otherArrs.pop();\n  }\n\n  let result = uniq(Array.from(firstArr));\n\n  for (let i = 0; i < otherArrs.length; ++i) {\n    const otherArr = otherArrs[i] as ArrayLike<T>;\n\n    if (otherArr == null) {\n      return [];\n    }\n\n    result = intersectionWithToolkit(result, Array.from(otherArr), comparator);\n  }\n\n  return result;\n}\n\n/**\n * This function is to preserve the sign of `-0`, which is a behavior in lodash.\n */\nfunction uniqPreserve0<T>(arr: T[]): T[] {\n  const result = [];\n  const added = new Set();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n\n    if (added.has(item)) {\n      continue;\n    }\n\n    result.push(item);\n    added.add(item);\n  }\n\n  return result;\n}\n","function getPriority(a: unknown): 0 | 1 | 2 | 3 | 4 {\n  if (typeof a === 'symbol') {\n    return 1;\n  }\n\n  if (a === null) {\n    return 2;\n  }\n\n  if (a === undefined) {\n    return 3;\n  }\n\n  if (a !== a) {\n    return 4;\n  }\n\n  return 0;\n}\n\nexport const compareValues = <V>(a: V, b: V, order: string) => {\n  if (a !== b) {\n    // If both values are strings, compare them using localeCompare.\n    if (typeof a === 'string' && typeof b === 'string') {\n      return order === 'desc' ? b.localeCompare(a) : a.localeCompare(b);\n    }\n\n    const aPriority = getPriority(a);\n    const bPriority = getPriority(b);\n\n    // If both values are of the same priority and are normal values, compare them.\n    if (aPriority === bPriority && aPriority === 0) {\n      if (a < b) {\n        return order === 'desc' ? 1 : -1;\n      }\n\n      if (a > b) {\n        return order === 'desc' ? -1 : 1;\n      }\n    }\n\n    return order === 'desc' ? bPriority - aPriority : aPriority - bPriority;\n  }\n\n  return 0;\n};\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n/**  Matches any word character (alphanumeric & underscore).*/\nconst regexIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\n * @param {unknown} value The value to check.\n * @param {unknown} object The object to query.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n *\n * @example\n * isKey('a', { a: 1 });\n * // => true\n *\n * isKey('a.b', { a: { b: 2 } });\n * // => false\n */\nexport function isKey(value?: unknown, object?: unknown): value is PropertyKey {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n\n  return (\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\n    (object != null && Object.hasOwn(object, value as PropertyKey))\n  );\n}\n","import { compareValues } from '../_internal/compareValues.ts';\nimport { isKey } from '../_internal/isKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\nexport type Criterion<T> = ((item: T) => unknown) | PropertyKey | PropertyKey[] | null | undefined;\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of criteria to sort by, and an array of order directions.\n * It returns the sorted array, ordering by each key according to its corresponding direction ('asc' for ascending or 'desc' for descending).\n * If values for a key are equal, it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | object | null | undefined} collection - The array of objects to be sorted.\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\n * @param {unknown} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {T[]} - The sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = orderBy(users, ['user', (item) => item.age], ['asc', 'desc']);\n * // result will be:\n * // [\n * //   { user: 'barney', age: 36 },\n * //   { user: 'barney', age: 34 },\n * //   { user: 'fred', age: 48 },\n * //   { user: 'fred', age: 40 },\n * // ]\n */\nexport function orderBy<T = any>(\n  collection: ArrayLike<T> | object | null | undefined,\n  criteria?: Criterion<T> | Array<Criterion<T>>,\n  orders?: unknown | unknown[],\n  guard?: unknown\n): T[] {\n  if (collection == null) {\n    return [];\n  }\n\n  orders = guard ? undefined : orders;\n\n  if (!Array.isArray(collection)) {\n    collection = Object.values(collection);\n  }\n\n  if (!Array.isArray(criteria)) {\n    criteria = criteria == null ? [null] : [criteria];\n  }\n  if (criteria.length === 0) {\n    criteria = [null];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n\n  // For Object('desc') case\n  orders = (orders as unknown[]).map(order => String(order));\n\n  const getValueByNestedPath = (object: object, path: PropertyKey[]) => {\n    let target: object = object;\n\n    for (let i = 0; i < path.length && target != null; ++i) {\n      target = target[path[i] as keyof typeof target];\n    }\n\n    return target;\n  };\n\n  const getValueByCriterion = (criterion: Criterion<T> | { key: PropertyKey; path: string[] }, object: T) => {\n    if (object == null || criterion == null) {\n      return object;\n    }\n\n    if (typeof criterion === 'object' && 'key' in criterion) {\n      if (Object.hasOwn(object, criterion.key)) {\n        return object[criterion.key as keyof typeof object];\n      }\n\n      return getValueByNestedPath(object, criterion.path);\n    }\n\n    if (typeof criterion === 'function') {\n      return criterion(object);\n    }\n\n    if (Array.isArray(criterion)) {\n      return getValueByNestedPath(object, criterion);\n    }\n\n    if (typeof object === 'object') {\n      return object[criterion as keyof typeof object];\n    }\n\n    return object;\n  };\n\n  // Prepare all cases for criteria\n  const preparedCriteria = criteria.map(criterion => {\n    // lodash handles a array with one element as a single criterion\n    if (Array.isArray(criterion) && criterion.length === 1) {\n      criterion = criterion[0];\n    }\n\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey(criterion)) {\n      return criterion;\n    }\n\n    // If criterion is not key, it has possibility to be a deep path. So we have to prepare both cases.\n    return { key: criterion, path: toPath(criterion) };\n  });\n\n  // Array.prototype.sort() always shifts the `undefined` values to the end of the array. So we have to prevent it by using a wrapper object.\n  const preparedCollection = (collection as T[]).map(item => ({\n    original: item,\n    criteria: preparedCriteria.map(criterion => getValueByCriterion(criterion, item)),\n  }));\n\n  return preparedCollection\n    .slice()\n    .sort((a, b) => {\n      for (let i = 0; i < preparedCriteria.length; i++) {\n        const comparedResult = compareValues(a.criteria[i], b.criteria[i], (orders as string[])[i]);\n\n        if (comparedResult !== 0) {\n          return comparedResult;\n        }\n      }\n\n      return 0;\n    })\n    .map(item => item.original);\n}\n","/**\n * Checks if the value is NaN.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is typeof NaN} `true` if the value is NaN, `false` otherwise.\n *\n * @example\n * isNaN(NaN); // true\n * isNaN(0); // false\n * isNaN('NaN'); // false\n * isNaN(undefined); // false\n */\nexport function isNaN(value?: unknown): value is typeof NaN {\n  return Number.isNaN(value);\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x?: unknown): x is null | undefined {\n  return x == null;\n}\n","import { isNull, isUndefined } from '../../predicate';\nimport { isNaN } from '../predicate/isNaN';\nimport { isNil } from '../predicate/isNil';\nimport { isSymbol } from '../predicate/isSymbol';\n\ntype Iteratee<T, R> = (value: T) => R;\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n/**\n * This method is like `sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @param {(value: T) => R} iteratee The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * const objects = [{ 'n': 4 }, { 'n': 5 }]\n * sortedIndexBy(objects, { 'n': 4 }, ({ n }) => n)\n * // => 0\n */\nexport function sortedIndexBy<T, R>(\n  array: ArrayLike<T> | null | undefined,\n  value: T,\n  iteratee?: Iteratee<T, R>,\n  retHighest?: boolean\n): number {\n  let low = 0;\n  let high = array == null ? 0 : array.length;\n  if (high === 0 || isNil(array)) {\n    return 0;\n  }\n\n  const transformedValue = iteratee?.(value);\n\n  const valIsNaN = isNaN(transformedValue);\n  const valIsNull = isNull(transformedValue);\n  const valIsSymbol = isSymbol(transformedValue);\n  const valIsUndefined = isUndefined(transformedValue);\n\n  while (low < high) {\n    let setLow: boolean;\n    const mid = Math.floor((low + high) / 2);\n    const computed = iteratee?.(array[mid]);\n\n    const othIsDefined = !isUndefined(computed);\n    const othIsNull = isNull(computed);\n    const othIsReflexive = !isNaN(computed);\n    const othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? computed! <= transformedValue : computed! < transformedValue;\n    }\n\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return Math.min(high, MAX_ARRAY_INDEX);\n}\n","/**\n * Checks if a given value is a number.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {unknown} value The value to check if it is a number.\n * @returns {value is number} Returns `true` if `value` is a number, else `false`.\n *\n * @example\n * const value1 = 123;\n * const value2 = 'abc';\n * const value3 = true;\n *\n * console.log(isNumber(value1)); // true\n * console.log(isNumber(value2)); // false\n * console.log(isNumber(value3)); // false\n */\nexport function isNumber(value?: unknown): value is number {\n  return typeof value === 'number' || value instanceof Number;\n}\n","import { isIndex } from '../_internal/isIndex.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to modify.\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T>(obj: object, path: PropertyKey | readonly PropertyKey[], value: unknown): T;\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to modify.\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T extends object>(obj: T, path: PropertyKey | readonly PropertyKey[], value: unknown): T {\n  const resolvedPath = Array.isArray(path) ? path : typeof path === 'string' ? toPath(path) : [path];\n\n  let current: any = obj;\n\n  for (let i = 0; i < resolvedPath.length - 1; i++) {\n    const key = resolvedPath[i];\n    const nextKey = resolvedPath[i + 1];\n\n    if (current[key] == null) {\n      current[key] = isIndex(nextKey) ? [] : {};\n    }\n\n    current = current[key];\n  }\n\n  const lastKey = resolvedPath[resolvedPath.length - 1];\n  current[lastKey] = value;\n\n  return obj;\n}\n","/**\n * Attempts to execute a function with the provided arguments.\n * If the function throws an error, it catches the error and returns it.\n * If the caught error is not an instance of Error, it wraps it in a new Error.\n *\n * @param {F} func - The function to be executed.\n * @param {...Parameters<F>} args - The arguments to pass to the function.\n * @returns {ReturnType<F> | Error} The return value of the function if successful, or an Error if an exception is thrown.\n *\n * @template F - The type of the function being attempted.\n *\n * @example\n * // Example 1: Successful execution\n * const result = attempt((x, y) => x + y, 2, 3);\n * console.log(result); // Output: 5\n *\n * @example\n * // Example 2: Function throws an error\n * const errorResult = attempt(() => {\n *   throw new Error(\"Something went wrong\");\n * });\n * console.log(errorResult); // Output: Error: Something went wrong\n *\n * @example\n * // Example 3: Non-Error thrown\n * const nonErrorResult = attempt(() => {\n *   throw \"This is a string error\";\n * });\n * console.log(nonErrorResult); // Output: Error: This is a string error\n */\nexport function attempt<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): ReturnType<F> | Error {\n  try {\n    return func(...args);\n  } catch (e: any) {\n    return e instanceof Error ? e : new Error(e);\n  }\n}\n","/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\n *\n * @template F - The type of the function to bind.\n * @param {F} func - The function to bind.\n * @param {unknown} thisObj - The `this` binding of `func`.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {F} - Returns the new bound function.\n *\n * @example\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n * const object = { user: 'fred' };\n * let bound = bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * bound = bind(greet, object, bind.placeholder, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nexport function bind<F extends (...args: any[]) => any>(func: F, thisObj?: unknown, ...partialArgs: any[]): F {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bind.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...args);\n    }\n\n    return func.apply(thisObj, args);\n  };\n\n  return bound as any as F;\n}\n\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\nbind.placeholder = bindPlaceholder;\n","/**\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\n *\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\n *\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * @template T - The type of the object to bind.\n * @template K - The type of the key to bind.\n * @param {T} object - The object to invoke the method on.\n * @param {K} key - The key of the method.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\n *\n * @example\n * const object = {\n *   user: 'fred',\n *   greet: function (greeting, punctuation) {\n *     return greeting + ' ' + this.user + punctuation;\n *   },\n * };\n *\n * let bound = bindKey(object, 'greet', 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * object.greet = function (greeting, punctuation) {\n *   return greeting + 'ya ' + this.user + punctuation;\n * };\n *\n * bound('!');\n * // => 'hiya fred!'\n *\n * // Bound with placeholders.\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\n * bound('hi');\n * // => 'hiya fred!'\n */\nexport function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(\n  object: T,\n  key: K,\n  ...partialArgs: any[]\n): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bindKey.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      return new object[key](...args);\n    }\n\n    // eslint-disable-next-line prefer-spread\n    return object[key].apply(object, args);\n  };\n\n  return bound as any;\n}\n\nconst bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');\nbindKey.placeholder = bindKeyPlaceholder;\n","/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * The `curry.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curry.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curry(abc);\n *\n * curried(1)(2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(1)(curry.placeholder, 3)(2);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curry(abc, 2);\n *\n * curried(1)(2);\n * // => [1, 2]\n */\nexport function curry(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curry.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurry(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurry(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curry.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurry(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const args = [];\n  let startIndex = 0;\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curry.placeholder && startIndex < providedArgs.length) {\n      args.push(providedArgs[startIndex++]);\n    } else {\n      args.push(arg);\n    }\n  }\n  for (let i = startIndex; i < providedArgs.length; i++) {\n    args.push(providedArgs[i]);\n  }\n  return args;\n}\n\nconst curryPlaceholder: unique symbol = Symbol('curry.placeholder');\ncurry.placeholder = curryPlaceholder;\n","/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * Unlike `curry`, this function curries the function from right to left.\n *\n * The `curryRight.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curryRight(abc);\n *\n * curried(3)(2)(1);\n * // => [1, 2, 3]\n *\n * curried(2, 3)(1);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(3)(curryRight.placeholder, 2)(1);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curryRight(abc, 2);\n *\n * curried(2)(1);\n * // => [1, 2]\n */\nexport function curryRight(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curryRight.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryRightPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurryRight(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curryRight.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryRightPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const placeholderLength = partialArgs.filter(arg => arg === curryRight.placeholder).length;\n  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n  const args: any[] = [];\n\n  let providedIndex = 0;\n  for (let i = 0; i < rangeLength; i++) {\n    args.push(providedArgs[providedIndex++]);\n  }\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curryRight.placeholder) {\n      if (providedIndex < providedArgs.length) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    } else {\n      args.push(arg);\n    }\n  }\n  return args;\n}\n\nconst curryRightPlaceholder: unique symbol = Symbol('curryRight.placeholder');\ncurryRight.placeholder = curryRightPlaceholder;\n","import { debounce as debounceToolkit } from '../../function/debounce.ts';\n\ninterface DebounceOptions {\n  /**\n   * An optional AbortSignal to cancel the debounced function.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * If `true`, the function will be invoked on the leading edge of the timeout.\n   * @default false\n   */\n  leading?: boolean;\n\n  /**\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\n   * @default true\n   */\n  trailing?: boolean;\n\n  /**\n   * The maximum time `func` is allowed to be delayed before it's invoked.\n   * @default Infinity\n   */\n  maxWait?: number;\n}\n\nexport interface DebouncedFunction<F extends (...args: any[]) => any> {\n  (...args: Parameters<F>): ReturnType<F> | undefined;\n  cancel(): void;\n  flush(): void;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\n * If `leading` is true, the function runs immediately on the first call.\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\n * (since one debounced function call cannot trigger the function twice).\n *\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => any>(\n  func: F,\n  debounceMs = 0,\n  options: DebounceOptions = {}\n): DebouncedFunction<F> {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  const { signal, leading = false, trailing = true, maxWait } = options;\n\n  const edges = Array(2);\n\n  if (leading) {\n    edges[0] = 'leading';\n  }\n\n  if (trailing) {\n    edges[1] = 'trailing';\n  }\n\n  let result: ReturnType<F> | undefined = undefined;\n  let pendingAt: number | null = null;\n\n  const _debounced = debounceToolkit(\n    function (this: any, ...args: Parameters<F>) {\n      result = func.apply(this, args);\n      pendingAt = null;\n    },\n    debounceMs,\n    { signal, edges }\n  );\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (maxWait != null) {\n      if (pendingAt === null) {\n        pendingAt = Date.now();\n      } else {\n        if (Date.now() - pendingAt >= maxWait) {\n          result = func.apply(this, args);\n          pendingAt = Date.now();\n\n          _debounced.cancel();\n          _debounced.schedule();\n\n          return result;\n        }\n      }\n    }\n\n    _debounced.apply(this, args);\n    return result;\n  };\n\n  const flush = () => {\n    _debounced.flush();\n    return result;\n  };\n\n  debounced.cancel = _debounced.cancel;\n  debounced.flush = flush;\n\n  return debounced;\n}\n","export function decimalAdjust(\n  type: 'round' | 'floor' | 'ceil',\n  number: number | string,\n  precision: number | string = 0\n): number {\n  number = Number(number);\n  if (Object.is(number, -0)) {\n    number = '-0';\n  }\n  precision = Math.min(Number.parseInt(precision as string, 10), 292);\n  if (precision) {\n    const [magnitude, exponent = 0] = number.toString().split('e');\n    let adjustedValue: string | number = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));\n    if (Object.is(adjustedValue, -0)) {\n      adjustedValue = '-0';\n    }\n    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split('e');\n    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);\n  }\n  return Math[type](Number(number));\n}\n","import { clamp as clampToolkit } from '../../math/clamp.ts';\n\n/**\n * Clamps a number within the inclusive upper bound.\n *\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified upper bound.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n */\nexport function clamp(value: number, maximum: number): number;\n\n/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, minimum: number, maximum: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (Number.isNaN(bound1)) {\n    bound1 = 0;\n  }\n\n  if (Number.isNaN(bound2)) {\n    bound2 = 0;\n  }\n\n  return clampToolkit(value, bound1, bound2!);\n}\n","/**\n * Clamps a number within the inclusive upper bound.\n *\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified upper bound.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n */\nexport function clamp(value: number, maximum: number): number;\n\n/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, minimum: number, maximum: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (bound2 == null) {\n    return Math.min(value, bound1);\n  }\n\n  return Math.min(Math.max(value, bound1), bound2);\n}\n","/**\n * Converts `value` to a string.\n *\n * An empty string is returned for `null` and `undefined` values.\n * The sign of `-0` is preserved.\n *\n * @param {unknown} value - The value to convert.\n * @returns {string} Returns the converted string.\n *\n * @example\n * toString(null) // returns ''\n * toString(undefined) // returns ''\n * toString(-0) // returns '-0'\n * toString([1, 2, -0]) // returns '1,2,-0'\n * toString([Symbol('a'), Symbol('b')]) // returns 'Symbol(a),Symbol(b)'\n */\nexport function toString(value?: unknown): string {\n  if (value == null) {\n    return '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(toString).join(',');\n  }\n\n  const result = String(value);\n\n  if (result === '0' && Object.is(Number(value), -0)) {\n    return '-0';\n  }\n\n  return result;\n}\n","import { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Computes the sum of the `number` values in `array`.\n *\n * @param {ArrayLike<number> | null | undefined} array - The array to iterate over.\n * @returns {number} Returns the sum.\n *\n * @example\n * sumBy([1, 2, 3]); // => 6\n * sumBy(null); // => 0\n * sumBy(undefined); // => 0\n */\nexport function sumBy(array: ArrayLike<number> | null | undefined): number;\n\n/**\n * Computes the sum of the `bigint` values in `array`.\n *\n * @param {ArrayLike<bigint>} array - The array to iterate over.\n * @returns {bigint} Returns the sum.\n *\n * @example\n * sumBy([1n, 2n, 3n]); // => 6n\n */\nexport function sumBy(array: ArrayLike<bigint>): bigint;\n/**\n * Computes the sum of the values in `array`.\n *\n * It does not coerce values to `number`.\n *\n * @param {ArrayLike<unknown> | null | undefined} array - The array to iterate over.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sumBy([\"1\", \"2\"]); // => \"12\"\n * sumBy([1, undefined, 2]); // => 3\n */\nexport function sumBy(array: ArrayLike<unknown> | null | undefined): unknown;\n\n/**\n * Computes the sum of the `number` values that are returned by the `iteratee` function.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T>} array - The array to iterate over.\n * @param {(value: T) => number} iteratee - The function invoked per iteration.\n * @returns {number} Returns the sum.\n *\n * @example\n * sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], object => object.a); // => 6\n */\nexport function sumBy<T>(array: ArrayLike<T>, iteratee: (value: T) => number): number;\n\n/**\n * Computes the sum of the `bigint` values that are returned by the `iteratee` function.\n *\n * NOTE: If the `array` is empty, the function returns `0`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T>} array - The array to iterate over.\n * @param {(value: T) => bigint} iteratee - The function invoked per iteration.\n * @returns {bigint | number} Returns the sum.\n *\n * @example\n * sumBy([{ a: 1n }, { a: 2n }, { a: 3n }], object => object.a); // => 6n\n * sumBy([], (item: { a: bigint }) => item.a); // => 0\n */\nexport function sumBy<T>(array: ArrayLike<T>, iteratee: (value: T) => bigint): bigint | number;\n\n/**\n * Computes the sum of the values that are returned by the `iteratee` function.\n *\n * It does not coerce values to `number`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T> | null | undefined} array - The array to iterate over.\n * @param {(value: T) => number | bigint} iteratee - The function invoked per iteration.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sumBy([1, undefined, 2], value => value); // => 3\n * sumBy(null); // => 0\n * sumBy(undefined); // => 0\n * sumBy([1, 2, 3]); // => 6\n * sumBy([1n, 2n, 3n]); // => 6n\n * sumBy([{ a: \"1\" }, { a: \"2\" }], object => object.a); // => \"12\"\n */\nexport function sumBy<T>(array: ArrayLike<T> | null | undefined, iteratee?: (value: T) => number | bigint): unknown {\n  if (!array || !array.length) {\n    return 0;\n  }\n\n  if (iteratee != null) {\n    iteratee = iterateeToolkit(iteratee);\n  }\n\n  let result: any = undefined;\n\n  for (let i = 0; i < array.length; i++) {\n    const current = iteratee ? iteratee(array[i]) : array[i];\n\n    if (current !== undefined) {\n      if (result === undefined) {\n        result = current;\n      } else {\n        result += current;\n      }\n    }\n  }\n\n  return result;\n}\n","export function isPrototype(value: {}) {\n  const constructor = value?.constructor;\n  const prototype = typeof constructor === 'function' ? constructor.prototype : Object.prototype;\n\n  return value === prototype;\n}\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\n\n/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *     Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(\n  x?: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return isTypedArrayToolkit(x);\n}\n","import { toInteger } from './toInteger.ts';\n\n/**\n * Invokes the getValue function n times, returning an array of the results.\n *\n * @template R The return type of the getValue function.\n * @param {number} n - The number of times to invoke getValue.\n * @param {(index: number) => R} getValue - The function to invoke for each index.\n * @returns {R[]} An array containing the results of invoking getValue n times.\n * @example\n * times(3, (i) => i * 2); // => [0, 2, 4]\n * times(2, () => 'es-toolkit'); // => ['es-toolkit', 'es-toolkit']\n */\nexport function times<R = number>(n?: number, getValue?: (index: number) => R): R[] {\n  n = toInteger(n);\n\n  if (n < 1 || !Number.isSafeInteger(n)) {\n    return [];\n  }\n\n  const result = new Array(n);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = typeof getValue === 'function' ? getValue(i) : i;\n  }\n\n  return result;\n}\n","import { isBuffer } from '../../predicate/isBuffer.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { times } from '../util/times.ts';\n\n/**\n * This function retrieves the names of string-keyed properties from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {unknown} [object] - The object to inspect for keys.\n * @returns {string[]} An array of string keys from the object.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * console.log(keysIn(obj)); // ['a', 'b']\n *\n * const arr = [1, 2, 3];\n * console.log(keysIn(arr)); // ['0', '1', '2']\n *\n * function Foo() {}\n * Foo.prototype.a = 1;\n * console.log(keysIn(new Foo())); // ['a']\n */\nexport function keysIn(object?: unknown): string[] {\n  if (object == null) {\n    return [];\n  }\n\n  switch (typeof object) {\n    case 'object':\n    case 'function': {\n      if (isArrayLike(object)) {\n        return arrayLikeKeysIn(object);\n      }\n\n      if (isPrototype(object)) {\n        return prototypeKeysIn(object);\n      }\n\n      return keysInImpl(object);\n    }\n\n    default: {\n      return keysInImpl(Object(object));\n    }\n  }\n}\n\nfunction keysInImpl(object: object): string[] {\n  const result: string[] = [];\n\n  for (const key in object) {\n    result.push(key);\n  }\n\n  return result;\n}\n\nfunction prototypeKeysIn(object: object): string[] {\n  const keys = keysInImpl(object);\n\n  return keys.filter(key => key !== 'constructor');\n}\n\nfunction arrayLikeKeysIn(object: ArrayLike<any>): string[] {\n  const indices = times(object.length, index => `${index}`);\n\n  const filteredKeys = new Set(indices);\n\n  if (isBuffer(object)) {\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    filteredKeys.add('offset');\n    filteredKeys.add('parent');\n  }\n\n  if (isTypedArray(object)) {\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    filteredKeys.add('buffer');\n    filteredKeys.add('byteLength');\n    filteredKeys.add('byteOffset');\n  }\n\n  return [...indices, ...keysInImpl(object).filter(key => !filteredKeys.has(key))];\n}\n","import { keysIn } from './keysIn.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Assigns the properties of a source object to a target object.\n *\n * This function merges the properties of the source object into the target object,\n * including properties from the prototype chain. If a property in the source object\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S} source - The source object whose properties will be assigned to the target object.\n * @returns {O & S} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assignIn(target, source);\n * console.log(result); // Output: { a: 1, b: 3, c: 4 }\n */\nexport function assignIn<O, S>(object: O, source: S): O & S;\n\n/**\n * Assigns the properties of two source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assignIn(target, source1, source2);\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\n\n/**\n * Assigns the properties of three source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @param {S3} source3 - The third source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assignIn(target, source1, source2, source3);\n * console.log(result); // Output: { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignIn<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\n\n/**\n * Assigns the properties of four source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @param {S3} source3 - The third source object whose properties will be assigned to the target object.\n * @param {S4} source4 - The fourth source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assignIn(target, source1, source2, source3, source4);\n * console.log(result); // Output: { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assignIn<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): O & S1 & S2 & S3;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 }, { a: 4 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn(object: any, ...sources: any[]): any;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn(object: any, ...sources: any[]): any {\n  for (let i = 0; i < sources.length; i++) {\n    assignInImpl(object, sources[i]);\n  }\n\n  return object;\n}\n\nfunction assignInImpl(object: any, source: any): any {\n  const keys = keysIn(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!(key in object) || !eq(object[key], source[key])) {\n      object[key] = source[key];\n    }\n  }\n}\n","import { eq } from '../util/eq.ts';\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @param {T} object - The target object.\n * @returns {T} The object itself.\n */\nexport function defaults<T extends object>(object: T): NonNullable<T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S} source - The object that specifies the default values to apply.\n * @returns {NonNullable<T & S>} The `object` that has been updated with default values from `source`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S extends object>(object: T, source: S): NonNullable<T & S>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2>} The `object` that has been updated with default values from `source1` and `source2`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2\n): NonNullable<T & S1 & S2>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3>} The `object` that has been updated with default values from `source1`, `source2`, and `source3`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object, S3 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3\n): NonNullable<T & S1 & S2 & S3>;\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @template S4 - The type of the fourth object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @param {S4} source4 - The fourth object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3 & S4>} The `object` that has been updated with default values from `source1`, `source2`, `source3`, and `source4`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object, S3 extends object, S4 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): NonNullable<T & S1 & S2 & S3 & S4>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} source - The objects that specifies the default values to apply.\n * @returns {object} The `object` that has been updated with default values from `sources`, ensuring that all properties are defined and none are left as `undefined`.\n *\n * @example\n * defaults({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: null }, { a: 1 }); // { a: null }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T extends object, S extends object>(object: T, ...sources: S[]): object;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} source - The objects that specifies the default values to apply.\n * @returns {object} The `object` that has been updated with default values from `sources`, ensuring that all properties are defined and none are left as `undefined`.\n *\n * @example\n * defaults({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: null }, { a: 1 }); // { a: null }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T extends object, S extends object>(object: T, ...sources: S[]): object {\n  object = Object(object);\n  const objectProto = Object.prototype;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    const keys = Object.keys(source) as Array<keyof S>;\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      const value = (object as any)[key];\n\n      if (\n        value === undefined ||\n        (!Object.hasOwn(object, key) && eq(value, objectProto[key as keyof typeof objectProto]))\n      ) {\n        (object as any)[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * A plain object is an object created by the `{}` literal, `new Object()`, or\n * `Object.create(null)`.\n *\n * This function also handles objects with custom\n * `Symbol.toStringTag` properties.\n *\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\n * default string description of objects.\n *\n * @param {unknown} [object] - The value to check.\n * @returns {boolean} - True if the value is a plain object, otherwise false.\n *\n * @example\n * console.log(isPlainObject({})); // true\n * console.log(isPlainObject([])); // false\n * console.log(isPlainObject(null)); // false\n * console.log(isPlainObject(Object.create(null))); // true\n * console.log(isPlainObject(new Map())); // false\n */\nexport function isPlainObject(object?: unknown): boolean {\n  if (typeof object !== 'object') {\n    return false;\n  }\n\n  if (object == null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(object) === null) {\n    return true;\n  }\n\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tag = object[Symbol.toStringTag];\n\n    if (tag == null) {\n      return false;\n    }\n\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n\n    if (isTagReadonly) {\n      return false;\n    }\n\n    return object.toString() === `[object ${tag}]`;\n  }\n\n  let proto = object;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(object) === proto;\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { clone } from '../../object/clone.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { getSymbols } from '../_internal/getSymbols.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The first source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {T & S} The updated target object with properties from the source object(s) merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the first source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<T, S>(\n  target: T,\n  source: S,\n  merge: (targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any\n): T & S;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object to be merged into the target object.\n * @param {S2} source2 - The second source object to be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n * @template S4 - Type of the fourth source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\n  const sources = otherArgs.slice(0, -1);\n  const merge = otherArgs[otherArgs.length - 1] as (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any;\n\n  let result = object;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n\n    result = mergeWithDeep(result, source, merge, new Map());\n  }\n\n  return result;\n}\n\nfunction mergeWithDeep(\n  target: any,\n  source: any,\n  merge: (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any,\n  stack: Map<any, any>\n) {\n  if (isPrimitive(target)) {\n    target = Object(target);\n  }\n\n  if (source == null || typeof source !== 'object') {\n    return target;\n  }\n\n  if (stack.has(source)) {\n    return clone(stack.get(source));\n  }\n\n  stack.set(source, target);\n\n  if (Array.isArray(source)) {\n    source = source.slice();\n    for (let i = 0; i < source.length; i++) {\n      source[i] = source[i] ?? undefined;\n    }\n  }\n\n  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    let sourceValue = source[key];\n    let targetValue = target[key];\n\n    if (isArguments(sourceValue)) {\n      sourceValue = { ...sourceValue };\n    }\n\n    if (isArguments(targetValue)) {\n      targetValue = { ...targetValue };\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n      sourceValue = cloneDeep(sourceValue);\n    }\n\n    if (Array.isArray(sourceValue)) {\n      if (typeof targetValue === 'object' && targetValue != null) {\n        const cloned: any = [];\n        const targetKeys = Reflect.ownKeys(targetValue);\n\n        for (let i = 0; i < targetKeys.length; i++) {\n          const targetKey = targetKeys[i];\n          cloned[targetKey] = targetValue[targetKey];\n        }\n\n        targetValue = cloned;\n      } else {\n        targetValue = [];\n      }\n    }\n\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\n\n    if (merged != null) {\n      target[key] = merged;\n    } else if (Array.isArray(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\n      target[key] = cloneDeep(sourceValue);\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","import { get } from './get.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Removes the property at the given path of the object.\n *\n * @param {unknown} obj - The object to modify.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to unset.\n * @returns {boolean} - Returns true if the property is deleted, else false.\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, 'a.b.c'); // true\n * console.log(obj); // { a: { b: {} } }\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, ['a', 'b', 'c']); // true\n * console.log(obj); // { a: { b: {} } }\n */\nexport function unset(obj: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  if (obj == null) {\n    return true;\n  }\n\n  switch (typeof path) {\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      if (Array.isArray(path)) {\n        return unsetWithPath(obj, path);\n      }\n\n      if (typeof path === 'number') {\n        path = toKey(path);\n      } else if (typeof path === 'object') {\n        if (Object.is(path?.valueOf(), -0)) {\n          path = '-0';\n        } else {\n          path = String(path);\n        }\n      }\n\n      if (obj?.[path] === undefined) {\n        return true;\n      }\n\n      try {\n        delete obj[path];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    case 'string': {\n      if (obj?.[path] === undefined && isDeepKey(path)) {\n        return unsetWithPath(obj, toPath(path));\n      }\n\n      try {\n        delete obj[path];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n  }\n}\n\nfunction unsetWithPath(obj: unknown, path: readonly PropertyKey[]): boolean {\n  const parent = get(obj, path.slice(0, -1), obj);\n  const lastKey = path[path.length - 1];\n\n  if (parent?.[lastKey] === undefined) {\n    return true;\n  }\n\n  try {\n    delete parent[lastKey];\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Checks if `object` conforms to `source` by invoking the predicate properties of `source` with the corresponding property values of `object`.\n *\n * Note: This method is equivalent to `conforms` when source is partially applied.\n *\n * @param {Record<PropertyKey, any>} target The object to inspect.\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\n * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n *\n * @example\n *\n * const object = { 'a': 1, 'b': 2 };\n * const source = {\n *   'a': (n) => n > 0,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source)); // => true\n *\n * const source2 = {\n *   'a': (n) => n > 1,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source2)); // => false\n */\nexport function conformsTo(\n  target: Record<PropertyKey, any>,\n  source: Record<PropertyKey, (value: any) => boolean>\n): boolean {\n  if (source == null) {\n    return true;\n  }\n\n  if (target == null) {\n    return Object.keys(source).length === 0;\n  }\n\n  const keys = Object.keys(source);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const predicate = source[key];\n    const value = target[key];\n    if ((value === undefined && !(key in target)) || !predicate(value)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { isMap as isMapToolKit } from '../../predicate/isMap.ts';\n\n/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value?: unknown): value is Map<any, any> {\n  return isMapToolKit(value);\n}\n","/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value: unknown): value is Map<any, any> {\n  return value instanceof Map;\n}\n","import { toString } from '../util/toString.ts';\n\nexport function normalizeForCase(str: unknown): string {\n  // Coerce to string\n  if (typeof str !== 'string') {\n    str = toString(str);\n  }\n\n  // Remove contraction apostrophes\n  return (str as string).replace(/['\\u2019]/g, '');\n}\n","import { escape as escapeToolkit } from '../../string/escape.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\n */\nexport function escape(string?: string): string {\n  return escapeToolkit(toString(string));\n}\n","import { escape } from './escape.ts';\nimport { attempt } from '../function/attempt.ts';\nimport { defaults } from '../object/defaults.ts';\nimport { toString } from '../util/toString.ts';\n\n// A regular expression for matching literal string in ES template string.\nconst esTemplateRegExp = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n// A regular expression for matching unescaped characters in string.\nconst unEscapedRegExp = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n// A regular expression for matching no match.\nconst noMatchExp = /($^)/;\n\nconst escapeMap = new Map([\n  ['\\\\', '\\\\'],\n  [\"'\", \"'\"],\n  ['\\n', 'n'],\n  ['\\r', 'r'],\n  ['\\u2028', 'u2028'],\n  ['\\u2029', 'u2029'],\n]);\n\nfunction escapeString(match: string): string {\n  return `\\\\${escapeMap.get(match)}`;\n}\n\n// Only import the necessary functions for preventing circular dependencies.(lodash-es also does this)\nexport const templateSettings = {\n  escape: /<%-([\\s\\S]+?)%>/g,\n  evaluate: /<%([\\s\\S]+?)%>/g,\n  interpolate: /<%=([\\s\\S]+?)%>/g,\n  variable: '',\n  imports: {\n    _: {\n      escape,\n      template,\n    },\n  },\n};\n\ninterface TemplateOptions {\n  escape?: RegExp;\n  evaluate?: RegExp;\n  interpolate?: RegExp;\n  variable?: string;\n  imports?: Record<string, unknown>;\n  sourceURL?: string;\n}\n\n/**\n * Compiles a template string into a function that can interpolate data properties.\n *\n * This function allows you to create a template with custom delimiters for escaping,\n * evaluating, and interpolating values. It can also handle custom variable names and\n * imported functions.\n *\n * @param {string} string - The template string.\n * @param {TemplateOptions} [options] - The options object.\n * @param {RegExp} [options.escape] - The regular expression for \"escape\" delimiter.\n * @param {RegExp} [options.evaluate] - The regular expression for \"evaluate\" delimiter.\n * @param {RegExp} [options.interpolate] - The regular expression for \"interpolate\" delimiter.\n * @param {string} [options.variable] - The data object variable name.\n * @param {Record<string, unknown>} [options.imports] - The object of imported functions.\n * @param {string} [options.sourceURL] - The source URL of the template.\n * @param {unknown} [guard] - The guard to detect if the function is called with `options`.\n * @returns {(data?: object) => string} Returns the compiled template function.\n *\n * @example\n * // Use the \"escape\" delimiter to escape data properties.\n * const compiled = template('<%- value %>');\n * compiled({ value: '<div>' }); // returns '&lt;div&gt;'\n *\n * @example\n * // Use the \"interpolate\" delimiter to interpolate data properties.\n * const compiled = template('<%= value %>');\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"evaluate\" delimiter to evaluate JavaScript code.\n * const compiled = template('<% if (value) { %>Yes<% } else { %>No<% } %>');\n * compiled({ value: true }); // returns 'Yes'\n *\n * @example\n * // Use the \"variable\" option to specify the data object variable name.\n * const compiled = template('<%= data.value %>', { variable: 'data' });\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"imports\" option to import functions.\n * const compiled = template('<%= _.toUpper(value) %>', { imports: { _: { toUpper } } });\n * compiled({ value: 'hello, world!' }); // returns 'HELLO, WORLD!'\n *\n * @example\n * // Use the custom \"escape\" delimiter.\n * const compiled = template('<@ value @>', { escape: /<@([\\s\\S]+?)@>/g });\n * compiled({ value: '<div>' }); // returns '&lt;div&gt;'\n *\n * @example\n * // Use the custom \"evaluate\" delimiter.\n * const compiled = template('<# if (value) { #>Yes<# } else { #>No<# } #>', { evaluate: /<#([\\s\\S]+?)#>/g });\n * compiled({ value: true }); // returns 'Yes'\n *\n * @example\n * // Use the custom \"interpolate\" delimiter.\n * const compiled = template('<$ value $>', { interpolate: /<\\$([\\s\\S]+?)\\$>/g });\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"sourceURL\" option to specify the source URL of the template.\n * const compiled = template('hello <%= user %>!', { sourceURL: 'template.js' });\n */\nexport function template(\n  string: string,\n  options?: TemplateOptions,\n  guard?: unknown\n): ((data?: object) => string) & { source: string } {\n  string = toString(string);\n\n  if (guard) {\n    options = templateSettings;\n  }\n\n  options = defaults({ ...options }, templateSettings);\n\n  const delimitersRegExp = new RegExp(\n    [\n      options.escape?.source ?? noMatchExp.source,\n      options.interpolate?.source ?? noMatchExp.source,\n      options.interpolate ? esTemplateRegExp.source : noMatchExp.source,\n      options.evaluate?.source ?? noMatchExp.source,\n      '$',\n    ].join('|'),\n    'g'\n  );\n\n  let lastIndex = 0;\n  let isEvaluated = false;\n  let source = `__p += ''`;\n\n  for (const match of string.matchAll(delimitersRegExp)) {\n    const [fullMatch, escapeValue, interpolateValue, esTemplateValue, evaluateValue] = match;\n    const { index } = match;\n\n    source += ` + '${string.slice(lastIndex, index).replace(unEscapedRegExp, escapeString)}'`;\n\n    if (escapeValue) {\n      source += ` + _.escape(${escapeValue})`;\n    }\n\n    if (interpolateValue) {\n      source += ` + ((${interpolateValue}) == null ? '' : ${interpolateValue})`;\n    } else if (esTemplateValue) {\n      source += ` + ((${esTemplateValue}) == null ? '' : ${esTemplateValue})`;\n    }\n\n    if (evaluateValue) {\n      source += `;\\n${evaluateValue};\\n __p += ''`;\n      isEvaluated = true;\n    }\n\n    lastIndex = index + fullMatch.length;\n  }\n\n  const imports = defaults({ ...options.imports }, templateSettings.imports);\n  const importsKeys = Object.keys(imports);\n  const importValues = Object.values(imports);\n\n  const sourceURL = `//# sourceURL=${\n    options.sourceURL ? String(options.sourceURL).replace(/[\\r\\n]/g, ' ') : `es-toolkit.templateSource[${Date.now()}]`\n  }\\n`;\n\n  const compiledFunction = `function(${options.variable || 'obj'}) {\n    let __p = '';\n    ${options.variable ? '' : 'if (obj == null) { obj = {}; }'}\n    ${isEvaluated ? `function print() { __p += Array.prototype.join.call(arguments, ''); }` : ''}\n    ${options.variable ? source : `with(obj) {\\n${source}\\n}`}\n    return __p;\n  }`;\n\n  const result = attempt(() => new Function(...importsKeys, `${sourceURL}return ${compiledFunction}`)(...importValues));\n\n  result.source = compiledFunction;\n\n  if (result instanceof Error) {\n    throw result;\n  }\n\n  return result;\n}\n","import { toPath } from './toPath';\nimport { toKey } from '../_internal/toKey.ts';\nimport { last } from '../array/last.ts';\nimport { get } from '../object/get.ts';\n\n/**\n * Invokes the method at `path` of `object` with the given arguments.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path of the method to invoke.\n * @param {any[]} args - The arguments to invoke the method with.\n * @returns {any} - Returns the result of the invoked method.\n *\n * @example\n * const object = {\n *   a: {\n *     b: function (x, y) {\n *       return x + y;\n *     }\n *   }\n * };\n *\n * invoke(object, 'a.b', [1, 2]); // => 3\n * invoke(object, ['a', 'b'], [1, 2]); // => 3\n */\nexport function invoke(object: unknown, path: PropertyKey | PropertyKey[], args: any[] = []): any {\n  if (object == null) {\n    return;\n  }\n\n  switch (typeof path) {\n    case 'string': {\n      if (typeof object === 'object' && Object.hasOwn(object, path)) {\n        return invokeImpl(object, [path], args);\n      }\n      return invokeImpl(object, toPath(path), args);\n    }\n    case 'number':\n    case 'symbol': {\n      return invokeImpl(object, [path], args);\n    }\n    default: {\n      if (Array.isArray(path)) {\n        return invokeImpl(object, path, args);\n      } else {\n        return invokeImpl(object, [path], args);\n      }\n    }\n  }\n}\n\nfunction invokeImpl(object: unknown, path: PropertyKey[], args: any[]) {\n  const parent = get(object, path.slice(0, -1), object);\n\n  if (parent == null) {\n    return undefined;\n  }\n\n  let lastKey = last(path);\n  let lastValue = lastKey?.valueOf();\n\n  if (typeof lastValue === 'number') {\n    lastKey = toKey(lastValue);\n  } else {\n    lastKey = String(lastKey);\n  }\n\n  const func = get(parent, lastKey);\n\n  return func?.apply(parent, args);\n}\n","export const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n","/** Counter used to generate unique numeric identifiers. */\nlet idCounter = 0;\n\n/**\n * Generates a unique identifier, optionally prefixed with a given string.\n *\n * @param {string} [prefix] - An optional string to prefix the unique identifier.\n *                            If not provided or not a string, only the unique\n *                            numeric identifier is returned.\n * @returns {string} A string containing the unique identifier, with the optional\n *                   prefix if provided.\n *\n * @example\n * // Generate a unique ID with a prefix\n * uniqueId('user_');  // => 'user_1'\n *\n * @example\n * // Generate a unique ID without a prefix\n * uniqueId();  // => '2'\n *\n * @example\n * // Subsequent calls increment the internal counter\n * uniqueId('item_');  // => 'item_3'\n * uniqueId();         // => '4'\n */\nexport function uniqueId(prefix = ''): string {\n  const id = ++idCounter;\n\n  return `${prefix}${id}`;\n}\n","import { Semaphore } from './semaphore.ts';\n\n/**\n * A Mutex (mutual exclusion lock) for async functions.\n * It allows only one async task to access a critical section at a time.\n *\n * @example\n * const mutex = new Mutex();\n *\n * async function criticalSection() {\n *   await mutex.acquire();\n *   try {\n *     // This code section cannot be executed simultaneously\n *   } finally {\n *     mutex.release();\n *   }\n * }\n *\n * criticalSection();\n * criticalSection(); // This call will wait until the first call releases the mutex.\n */\nexport class Mutex {\n  private semaphore = new Semaphore(1);\n\n  /**\n   * Checks if the mutex is currently locked.\n   * @returns {boolean} True if the mutex is locked, false otherwise.\n   *\n   * @example\n   * const mutex = new Mutex();\n   * console.log(mutex.isLocked); // false\n   * await mutex.acquire();\n   * console.log(mutex.isLocked); // true\n   * mutex.release();\n   * console.log(mutex.isLocked); // false\n   */\n  get isLocked(): boolean {\n    return this.semaphore.available === 0;\n  }\n\n  /**\n   * Acquires the mutex, blocking if necessary until it is available.\n   * @returns {Promise<void>} A promise that resolves when the mutex is acquired.\n   *\n   * @example\n   * const mutex = new Mutex();\n   * await mutex.acquire();\n   * try {\n   *   // This code section cannot be executed simultaneously\n   * } finally {\n   *   mutex.release();\n   * }\n   */\n  async acquire(): Promise<void> {\n    return this.semaphore.acquire();\n  }\n\n  /**\n   * Releases the mutex, allowing another waiting task to proceed.\n   *\n   * @example\n   * const mutex = new Mutex();\n   * await mutex.acquire();\n   * try {\n   *   // This code section cannot be executed simultaneously\n   * } finally {\n   *   mutex.release(); // Allows another waiting task to proceed.\n   * }\n   */\n  release(): void {\n    this.semaphore.release();\n  }\n}\n","/**\n * Adds two numbers while safely handling `NaN` values.\n *\n * This function takes two numbers and returns their sum. If either of the numbers is `NaN`,\n * the function returns `NaN`.\n *\n * @param {number} value - The first number to add.\n * @param {number} other - The second number to add.\n * @returns {number} The sum of the two numbers, or `NaN` if any input is `NaN`.\n *\n * @example\n * const result1 = add(2, 3);    // result1 will be 5\n * const result2 = add(5, NaN);  // result2 will be NaN\n * const result3 = add(NaN, 10); // result3 will be NaN\n */\n\nexport function add(value: number, other: number): number {\n  return value + other;\n}\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a function that only executes starting from the `n`-th call.\n * The provided function will be invoked starting from the `n`-th call.\n *\n * This is particularly useful for scenarios involving events or asynchronous operations\n * where an action should occur only after a certain number of invocations.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of calls required for `func` to execute.\n * @param {F} func - The function to be invoked.\n * @returns {(...args: Parameters<F>) => ReturnType<F> | undefined} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` starting from the `n`-th call.\n * - Returns `undefined` if fewer than `n` calls have been made.\n * @throws {TypeError} - If `func` is not a function.\n * @example\n *\n * const afterFn = after(3, () => {\n *  console.log(\"called\")\n * });\n *\n * // Will not log anything.\n * afterFn()\n * // Will not log anything.\n * afterFn()\n * // Will log 'called'.\n * afterFn()\n */\nexport function after<F extends (...args: any[]) => any>(\n  n: number,\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> | undefined {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  n = toInteger(n);\n  return function (this: any, ...args: Parameters<F>) {\n    if (--n < 1) {\n      return func.apply(this, args);\n    }\n  };\n}\n","import { ary as aryToolkit } from '../../function/ary.ts';\n\n/**\n * Creates a function that invokes func, with up to `n` arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @param {unknown} guard - The value to guard the arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * ary(fn, 0)(1, 2, 3); // []\n * ary(fn, 1)(1, 2, 3); // [1]\n * ary(fn, 2)(1, 2, 3); // [1, 2]\n * ary(fn, 3)(1, 2, 3); // [1, 2, 3]\n */\nexport function ary<F extends (...args: any[]) => any>(\n  func: F,\n  n: number = func.length,\n  guard?: unknown\n): (...args: any[]) => ReturnType<F> {\n  if (guard) {\n    n = func.length;\n  }\n\n  if (Number.isNaN(n) || n < 0) {\n    n = 0;\n  }\n\n  return aryToolkit(func, n);\n}\n","/**\n * An asynchronous no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * asyncNoop(); // Does nothing\n *\n * @returns {Promise<void>} This function returns a Promise that resolves to undefined.\n */\nexport async function asyncNoop(): Promise<void> {}\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a function that invokes `func`, with the `this` binding and arguments\n * of the created function, while it's called less than `n` times. Subsequent\n * calls to the created function return the result of the last `func` invocation.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of times the returned function is allowed to call `func` before stopping.\n * - If `n` is 0, `func` will never be called.\n * - If `n` is a positive integer, `func` will be called up to `n-1` times.\n * @param {F} func - The function to be called with the limit applied.\n * @returns {(...args: Parameters<F>) => ReturnType<F> } - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` until the `n-1`-th call.\n * - Returns last result of `func`, if `n` is reached.\n * @throws {TypeError} - If `func` is not a function.\n * @example\n * let count = 0;\n * const before3 = before(3, () => ++count);\n *\n * before3(); // => 1\n * before3(); // => 2\n * before3(); // => 2\n */\nexport function before<F extends (...args: any[]) => any>(\n  n: number,\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  let result: ReturnType<F>;\n  n = toInteger(n);\n\n  return function (this: unknown, ...args: Parameters<F>) {\n    if (--n > 0) {\n      result = func.apply(this, args);\n    }\n\n    if (n <= 1 && func) {\n      // for garbage collection\n      func = undefined as any;\n    }\n\n    return result;\n  };\n}\n","import { camelCase as camelCaseToolkit } from '../../string/camelCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to camel case.\n *\n * Camel case is the naming convention in which the first word is written in lowercase and\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\n *\n * @param {string | object} str - The string that is to be changed to camel case.\n * @returns {string} - The converted string to camel case.\n *\n * @example\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\n */\n\nexport function camelCase(str?: string | object): string {\n  return camelCaseToolkit(normalizeForCase(str));\n}\n","import { capitalize } from './capitalize.ts';\nimport { words as getWords } from './words.ts';\n\n/**\n * Converts a string to camel case.\n *\n * Camel case is the naming convention in which the first word is written in lowercase and\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\n *\n * @param {string} str - The string that is to be changed to camel case.\n * @returns {string} - The converted string to camel case.\n *\n * @example\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\n * const convertedStr5 = camelCase('Keep unicode ') // returns 'keepUnicode'\n */\nexport function camelCase(str: string): string {\n  const words = getWords(str);\n\n  if (words.length === 0) {\n    return '';\n  }\n\n  const [first, ...rest] = words;\n\n  return `${first.toLowerCase()}${rest.map(word => capitalize(word)).join('')}`;\n}\n","/**\n * Casts value as an array if it's not one.\n *\n * @template T The type of elements in the array.\n * @param {T | T[]} value The value to be cast to an array.\n * @returns {T[]} An array containing the input value if it wasn't an array, or the original array if it was.\n *\n * @example\n * const arr1 = castArray(1);\n * // Returns: [1]\n *\n * const arr2 = castArray([1]);\n * // Returns: [1]\n *\n * const arr3 = castArray({'a': 1});\n * // Returns: [{'a': 1}]\n *\n * const arr4 = castArray(null);\n * // Returns: [null]\n *\n * const arr5 = castArray(undefined);\n * // Returns: [undefined]\n *\n * const arr6 = castArray();\n * // Returns: []\n */\n\nexport function castArray<T>(value?: T | readonly T[]): T[] {\n  if (arguments.length === 0) {\n    return [];\n  }\n\n  return Array.isArray(value) ? value : ([value] as T[]);\n}\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded up to precision.\n *\n * @param {number | string} number The number to round up.\n * @param {number | string} precision The precision to round up to.\n * @returns {number} Returns the rounded up number.\n *\n * @example\n * ceil(4.006); // => 5\n * ceil(6.004, 2); // => 6.01\n * ceil(6040, -2); // => 6100\n */\nexport function ceil(number: number | string, precision: number | string = 0): number {\n  return decimalAdjust('ceil', number, precision);\n}\n","import { chunk as chunkToolkit } from '../../array/chunk.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: ArrayLike<T> | null | undefined, size = 1): T[][] {\n  size = Math.max(Math.floor(size), 0);\n\n  if (size === 0 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return chunkToolkit(toArray(arr), size);\n}\n","/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n * @throws {Error} Throws an error if `size` is not a positive integer.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\n  if (!Number.isInteger(size) || size <= 0) {\n    throw new Error('Size must be an integer greater than zero.');\n  }\n\n  const chunkLength = Math.ceil(arr.length / size);\n  const result: T[][] = Array(chunkLength);\n\n  for (let index = 0; index < chunkLength; index++) {\n    const start = index * size;\n    const end = start + size;\n\n    result[index] = arr.slice(start, end);\n  }\n\n  return result;\n}\n","import { compact as compactToolkit } from '../../array/compact.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\ntype Falsey = false | null | 0 | 0n | '' | undefined;\ntype NotFalsey<T> = Exclude<T, Falsey>;\n\n/**\n * Removes falsey values (false, null, 0, 0n, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T | Falsey> | null | undefined} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | 0n | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, 0n, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: ArrayLike<T | Falsey> | null | undefined): Array<NotFalsey<T>> {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return compactToolkit(Array.from(arr));\n}\n","type NotFalsey<T> = Exclude<T, false | null | 0 | 0n | '' | undefined>;\n\n/**\n * Removes falsey values (false, null, 0, 0n, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | 0n | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, 0n, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\n  const result: Array<NotFalsey<T>> = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (item) {\n      result.push(item as NotFalsey<T>);\n    }\n  }\n\n  return result;\n}\n","import { flatten } from '../../array/flatten.ts';\n\n/**\n * Concatenates multiple arrays and values into a single array.\n *\n * @template T The type of elements in the array.\n * @param {...(T | T[])} values - The values and/or arrays to concatenate.\n * @returns {T[]} A new array containing all the input values.\n *\n * @example\n * // Concatenate individual values\n * concat(1, 2, 3);\n * // returns [1, 2, 3]\n *\n * @example\n * // Concatenate arrays of values\n * concat([1, 2], [3, 4]);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate a mix of individual values and arrays\n * concat(1, [2, 3], 4);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate nested arrays\n * concat([1, [2, 3]], 4);\n * // returns [1, [2, 3], 4]\n */\nexport function concat<T>(...values: Array<T | readonly T[]>): T[] {\n  return flatten(values) as T[];\n}\n","import { conformsTo } from './conformsTo.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\n\n/**\n * Creates a function that invokes the predicate properties of `source` with the corresponding property values of a given object, returning `true` if all predicates return truthy, else `false`.\n *\n * Note: The created function is equivalent to `conformsTo` with source partially applied.\n *\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\n * @returns {(object: Record<PropertyKey, any>) => boolean} Returns the new spec function.\n *\n * @example\n * const isPositive = (n) => n > 0;\n * const isEven = (n) => n % 2 === 0;\n * const predicates = { a: isPositive, b: isEven };\n * const conform = conforms(predicates);\n *\n * console.log(conform({ a: 2, b: 4 })); // true\n * console.log(conform({ a: -1, b: 4 })); // false\n * console.log(conform({ a: 2, b: 3 })); // false\n * console.log(conform({ a: 0, b: 2 })); // false\n */\nexport function conforms(\n  source: Record<PropertyKey, (value: any) => boolean>\n): (object: Record<PropertyKey, any>) => boolean {\n  source = cloneDeep(source);\n\n  return function (object: Record<PropertyKey, any>) {\n    return conformsTo(object, source);\n  };\n}\n","/**\n * Creates a new function that always returns `undefined`.\n *\n * @returns {() => undefined} Returns the new constant function.\n */\nexport function constant(): () => undefined;\n\n/**\n * Creates a new function that always returns `value`.\n *\n * @template T - The type of the value to return.\n * @param {T} value - The value to return from the new function.\n * @returns {() => T} Returns the new constant function.\n */\nexport function constant<T>(value: T): () => T;\n\n/**\n * Creates a new function that always returns `value`.\n *\n * @template T - The type of the value to return.\n * @param {T} value - The value to return from the new function.\n * @returns {() => T | undefined} Returns the new constant function.\n *\n * @example\n * const object = { a: 1 };\n * const returnsObject = constant(object);\n *\n * returnsObject(); // => { a: 1 }\n * returnsObject() === object; // => true\n */\nexport function constant<T>(value?: T): () => T | undefined {\n  return () => value;\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to constant case.\n *\n * Constant case is a naming convention where each word is written in uppercase letters and separated by an underscore (`_`). For example, `CONSTANT_CASE`.\n *\n * @param {string} str - The string that is to be changed to constant case.\n * @returns {string} - The converted string to constant case.\n *\n * @example\n * const convertedStr1 = constantCase('camelCase') // returns 'CAMEL_CASE'\n * const convertedStr2 = constantCase('some whitespace') // returns 'SOME_WHITESPACE'\n * const convertedStr3 = constantCase('hyphen-text') // returns 'HYPHEN_TEXT'\n * const convertedStr4 = constantCase('HTTPRequest') // returns 'HTTP_REQUEST'\n */\n\nexport function constantCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toUpperCase()).join('_');\n}\n","/**\n * Count the occurrences of each item in an array\n * based on a transformation function.\n *\n * This function takes an array and a transformation function\n * that converts each item in the array to a key. It then\n * counts the occurrences of each transformed item and returns\n * an object with the transformed items as keys and the counts\n * as values.\n *\n * @template T - The type of the items in the input array.\n * @template K - The type of keys.\n * @param {T[]} arr - The input array to count occurrences.\n * @param {(item: T) => K} mapper - The transformation function that maps each item to a key.\n * @returns {Record<K, number>} An object containing the transformed items as keys and the\n * counts as values.\n *\n * @example\n * const array = ['a', 'b', 'c', 'a', 'b', 'a'];\n * const result = countBy(array, x => x);\n * // result will be { a: 3, b: 2, c: 1 }\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = countBy(array, item => item % 2 === 0 ? 'even' : 'odd');\n * // result will be { odd: 3, even: 2 }\n */\nexport function countBy<T, K extends PropertyKey>(arr: readonly T[], mapper: (item: T) => K): Record<K, number> {\n  const result = {} as Record<K, number>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = mapper(item);\n\n    result[key] = (result[key] ?? 0) + 1;\n  }\n\n  return result;\n}\n","import { deburr as deburrToolkit } from '../../string/deburr.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\n * For example, \"Crme brle\" becomes \"Creme brulee\".\n *\n * @param {string} str - The input string to be deburred.\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\n *\n * @example\n * // Basic usage:\n * deburr('thelred') // returns 'Aethelred'\n *\n * @example\n * // Handling diacritical marks:\n * deburr('Mnchen') // returns 'Munchen'\n *\n * @example\n * // Special characters:\n * deburr('Crme brle') // returns 'Creme brulee'\n */\nexport function deburr(str?: string): string {\n  return deburrToolkit(toString(str));\n}\n","/**\n * Returns the default value for `null`, `undefined`, and `NaN`.\n *\n * @param {T | null | undefined} value - The value to check.\n * @param {T} [defaultValue] - The default value to return if the first value is null, undefined, or NaN.\n * @returns {T} Returns either the first value or the default value.\n *\n * @example\n * defaultTo(null, 'default') // returns 'default'\n * defaultTo(undefined, 42) // returns 42\n * defaultTo(NaN, 0) // returns 0\n * defaultTo('actual', 'default') // returns 'actual'\n * defaultTo(123, 0) // returns 123\n */\nexport function defaultTo<T>(value: T | null | undefined, defaultValue?: T): T;\n\n/**\n * Returns the default value for `null`, `undefined`, and `NaN`.\n *\n * @param {unknown} value - The value to check.\n * @param {unknown} defaultValue - The default value to return if the first value is null, undefined, or NaN.\n * @returns {any} Returns either the first value or the default value.\n *\n * @example\n * defaultTo(null, 'default') // returns 'default'\n * defaultTo(undefined, 42) // returns 42\n * defaultTo(NaN, 0) // returns 0\n * defaultTo('actual', 'default') // returns 'actual'\n * defaultTo(123, 0) // returns 123\n */\nexport function defaultTo(value?: unknown, defaultValue?: unknown): any {\n  if (value == null || Number.isNaN(value)) {\n    return defaultValue;\n  }\n\n  return value;\n}\n","/**\n * Defers invoking the `func` until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.\n *\n * @param {F} func The function to defer.\n * @param {Parameters<F>} args The arguments to invoke `func` with.\n * @returns {number} Returns the timer id.\n *\n * @example\n * defer((text) => {\n *   console.log(text);\n * }, 'deferred');\n * // => Logs 'deferred' after the current call stack has cleared.\n */\nexport function defer<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): number {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  return setTimeout(func, 1, ...args);\n}\n","import { toNumber } from '../util/toNumber.ts';\n\n/**\n * Invokes the specified function after a delay of the given number of milliseconds.\n * Any additional arguments are passed to the function when it is invoked.\n *\n * @param {(...args: any[]) => any} func - The function to delay.\n * @param {number} wait - The number of milliseconds to delay the invocation.\n * @param {...any[]} args - The arguments to pass to the function when it is invoked.\n * @returns {number} Returns the timer id.\n * @throws {TypeError} If the first argument is not a function.\n *\n * @example\n * // Example 1: Delayed function execution\n * const timerId = delay(\n *   (greeting, recipient) => {\n *     console.log(`${greeting}, ${recipient}!`);\n *   },\n *   1000,\n *   'Hello',\n *   'Alice'\n * );\n * // => 'Hello, Alice!' will be logged after one second.\n *\n * // Example 2: Clearing the timeout before execution\n * clearTimeout(timerId);\n * // The function will not be executed because the timeout was cleared.\n */\nexport function delay(func: (...args: any[]) => any, wait: number, ...args: any[]): number {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  return setTimeout(func, toNumber(wait) || 0, ...args);\n}\n","import { difference as differenceToolkit } from '../../array/difference.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Computes the difference between an array and multiple arrays.\n *\n * @template T\n * @param {ArrayLike<T> | undefined | null} arr - The primary array from which to derive the difference. This is the main array\n * from which elements will be compared and filtered.\n * @param {Array<ArrayLike<T>>} values - Multiple arrays containing elements to be excluded from the primary array.\n * These arrays will be flattened into a single array, and each element in this array will be checked against the primary array.\n * If a match is found, that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the primary array but not\n * in the flattened array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const array3 = [5, 6];\n * const result = difference(array1, array2, array3);\n * // result will be [1, 3] since 2, 4, and 5 are in the other arrays and are excluded from the result.\n *\n * @example\n * const arrayLike1 = { 0: 1, 1: 2, 2: 3, length: 3 };\n * const arrayLike2 = { 0: 2, 1: 4, length: 2 };\n * const result = difference(arrayLike1, arrayLike2);\n * // result will be [1, 3] since 2 is in both array-like objects and is excluded from the result.\n */\nexport function difference<T>(arr: ArrayLike<T> | undefined | null, ...values: Array<ArrayLike<T>>): T[] {\n  if (!isArrayLikeObject(arr)) {\n    return [];\n  }\n\n  const arr1 = toArray(arr);\n  const arr2 = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (isArrayLikeObject(value)) {\n      arr2.push(...Array.from(value));\n    }\n  }\n\n  return differenceToolkit(arr1, arr2);\n}\n","import { last } from './last.ts';\nimport { difference as differenceToolkit } from '../../array/difference.ts';\nimport { differenceBy as differenceByToolkit } from '../../array/differenceBy.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\ntype Iteratee<T> = PropertyKey | Partial<T> | ((value: T) => unknown);\n\n/**\n * Computes the difference between an array and another array using an iteratee function.\n *\n * @template T1, T2\n * @param {ArrayLike<T1> | null | undefined} array - The primary array from which to derive the difference.\n * @param {ArrayLike<T2>} values - The array containing elements to be excluded from the primary array.\n * @param {Iteratee<T1 | T2>} iteratee - The iteratee invoked per element.\n * @returns {T1[]} A new array containing the elements that are present in the primary array but not in the values array.\n *\n * @example\n * const result = differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // result will be [1.2]\n *\n * @example\n * const result = differenceBy([{ x: 2 }, { x: 1 }], [{ x: 1 }], 'x');\n * // result will be [{ x: 2 }]\n */\nexport function differenceBy<T1, T2>(\n  array: ArrayLike<T1> | null | undefined,\n  values: ArrayLike<T2>,\n  iteratee: Iteratee<T1 | T2>\n): T1[];\n\n/**\n * Computes the difference between an array and two other arrays using an iteratee function.\n *\n * @template T1, T2, T3\n * @param {ArrayLike<T1> | null | undefined} array - The primary array from which to derive the difference.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to be excluded from the primary array.\n * @param {Iteratee<T1 | T2 | T3>} iteratee - The iteratee invoked per element.\n * @returns {T1[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n *\n * @example\n * const result = differenceBy([2.1, 1.2], [2.3, 3.4], [1.2], Math.floor);\n * // result will be []\n */\nexport function differenceBy<T1, T2, T3>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  iteratee: Iteratee<T1 | T2 | T3>\n): T1[];\n\n/**\n * Computes the difference between an array and three other arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4\n * @param {ArrayLike<T1> | null | undefined} array - The primary array from which to derive the difference.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T4>} values3 - The third array containing elements to be excluded from the primary array.\n * @param {Iteratee<T1 | T2 | T3 | T4>} iteratee - The iteratee invoked per element.\n * @returns {T1[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n *\n * @example\n * const result = differenceBy([2.1, 1.2], [2.3, 3.4], [1.2], [2.1], Math.floor);\n * // result will be []\n */\nexport function differenceBy<T1, T2, T3, T4>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  iteratee: Iteratee<T1 | T2 | T3 | T4>\n): T1[];\n\n/**\n * Computes the difference between an array and four other arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4, T5\n * @param {ArrayLike<T1> | null | undefined} array - The primary array from which to derive the difference.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T4>} values3 - The third array containing elements to be excluded from the primary array.\n * @param {ArrayLike<T5>} values4 - The fourth array containing elements to be excluded from the primary array.\n * @param {Iteratee<T1 | T2 | T3 | T4 | T5>} iteratee - The iteratee invoked per element.\n * @returns {T1[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n *\n * @example\n * const result = differenceBy([2.1, 1.2], [2.3, 3.4], [1.2], [2.1], [3.4], Math.floor);\n * // result will be []\n */\nexport function differenceBy<T1, T2, T3, T4, T5>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  values4: ArrayLike<T5>,\n  iteratee: Iteratee<T1 | T2 | T3 | T4 | T5>\n): T1[];\n\n/**\n * Computes the difference between an array and multiple arrays using an iteratee function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The primary array from which to derive the difference.\n * @param {...Array<ArrayLike<T>>} values - Multiple arrays containing elements to be excluded from the primary array.\n * @returns {T[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n *\n * @example\n * const result = differenceBy([2.1, 1.2], [2.3, 3.4], [1.2], [2.1], [3.4], Math.floor);\n * // result will be []\n */\nexport function differenceBy<T>(array: ArrayLike<T> | null | undefined, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Computes the difference between an array and multiple arrays using an iteratee function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The primary array from which to derive the difference.\n * @param {...any[]} values - Multiple arrays containing elements to be excluded from the primary array.\n * @returns {T[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n */\nexport function differenceBy<T>(arr: ArrayLike<T> | null | undefined, ..._values: any[]): T[] {\n  if (!isArrayLikeObject(arr)) {\n    return [];\n  }\n\n  const iteratee = last(_values);\n  const values = flattenArrayLike<T>(_values);\n\n  if (isArrayLikeObject(iteratee)) {\n    return differenceToolkit(Array.from(arr), values);\n  }\n\n  return differenceByToolkit(Array.from(arr), values, createIteratee(iteratee));\n}\n","import { last } from './last.ts';\nimport { difference as differenceToolkit } from '../../array/difference.ts';\nimport { differenceWith as differenceWithToolkit } from '../../array/differenceWith.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Computes the difference between the primary array and another array using a comparator function.\n *\n * @template T1, T2\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values - The array containing elements to compare with the primary array.\n * @param {(a: T1, b: T2) => boolean} comparator - A function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements in `values` based on the comparator.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values = [{ id: 2 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values, comparator);\n * // result will be [{ id: 1 }, { id: 3 }]\n */\nexport function differenceWith<T1, T2>(\n  array: ArrayLike<T1> | null | undefined,\n  values: ArrayLike<T2>,\n  comparator: (a: T1, b: T2) => boolean\n): T1[];\n\n/**\n * Computes the difference between the primary array and two arrays using a comparator function.\n *\n * @template T1, T2, T3\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to compare with the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to compare with the primary array.\n * @param {(a: T1, b: T2 | T3) => boolean} comparator - A function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements in `values1` or `values2` based on the comparator.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, comparator);\n * // result will be [{ id: 1 }]\n */\nexport function differenceWith<T1, T2, T3>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  comparator: (a: T1, b: T2 | T3) => boolean\n): T1[];\n\n/**\n * Computes the difference between the primary array and multiple arrays using a comparator function.\n *\n * @template T1, T2, T3, T4\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to compare with the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to compare with the primary array.\n * @param {...Array<ArrayLike<T4> | ((a: T1, b: T2 | T3 | T4) => boolean)>} values - Additional arrays and an optional comparator function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements\n * in `values1`, `values2`, or subsequent arrays. If a comparator function is provided, it will be used to compare elements;\n * otherwise, [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero) algorithm will be used.\n *\n * @example\n * // Example with comparator function\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const values3 = [{ id: 4 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, values3, comparator);\n * // result will be [{ id: 1 }]\n *\n * @example\n * // Example without comparator function (behaves like `difference`)\n * const array = [1, 2, 3, 4];\n * const values1 = [2];\n * const values2 = [3];\n * const values3 = [4];\n *\n * const result = differenceWith(array, values1, values2, values3);\n * // result will be [1]\n */\nexport function differenceWith<T1, T2, T3, T4>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  ...values: Array<ArrayLike<T4> | ((a: T1, b: T2 | T3 | T4) => boolean)>\n): T1[];\n\n/**\n * Computes the difference between the primary array and one or more arrays without using a comparator function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The primary array to compare elements against.\n * @param {...Array<ArrayLike<T>>} values - One or more arrays containing elements to compare with the primary array.\n * @returns {T[]} A new array containing the elements from the primary array that do not match any elements in the provided arrays.\n *\n * @example\n * const array = [1, 2, 3];\n * const values1 = [2];\n * const values2 = [3];\n *\n * const result = differenceWith(array, values1, values2);\n * // result will be [1]\n */\nexport function differenceWith<T>(array: ArrayLike<T> | null | undefined, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Computes the difference between the primary array and one or more arrays using an optional comparator function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The primary array to compare elements against.\n * @param {...Array<ArrayLike<unknown> | ((a: unknown, b: unknown) => boolean)>} values - One or more arrays to compare with the primary array, and an optional comparator function to determine if two elements are considered equal.\n * @returns {T[]} A new array containing the elements from the primary array that do not match any elements in the provided arrays or those compared using the comparator function.\n *\n * @example\n * // Example with a comparator function\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, comparator);\n * // result will be [{ id: 1 }]\n *\n * @example\n * // Example without a comparator function\n * const array = [1, 2, 3];\n * const values1 = [2];\n * const values2 = [3];\n *\n * const result = differenceWith(array, values1, values2);\n * // result will be [1]\n */\nexport function differenceWith<T>(\n  array: ArrayLike<T> | null | undefined,\n  ...values: Array<ArrayLike<unknown> | ((a: unknown, b: unknown) => boolean)>\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  const comparator = last(values);\n  const flattenedValues = flattenArrayLike<T>(values);\n\n  if (typeof comparator === 'function') {\n    return differenceWithToolkit(Array.from(array), flattenedValues, comparator);\n  }\n\n  return differenceToolkit(Array.from(array), flattenedValues);\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Divide two numbers.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number in a division.\n * @param {number} other The second number in a division.\n * @returns {number} The quotient of value and other.\n *\n * @example\n * divide(6, 3); // => 2\n * divide(2, NaN); // => NaN\n * divide(NaN, 3); // => NaN\n * divide(NaN, NaN); // => NaN\n */\nexport function divide(value: number, other: number): number {\n  console.log(value, other);\n\n  if (value === undefined && other === undefined) {\n    return 1;\n  }\n\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n\n  return value / other;\n}\n","import { drop as dropToolkit } from '../../array/drop.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} collection - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(collection: ArrayLike<T> | null | undefined, itemsCount = 1, guard?: unknown): T[] {\n  if (!isArrayLike(collection)) {\n    return [];\n  }\n  itemsCount = guard ? 1 : toInteger(itemsCount);\n\n  return dropToolkit(toArray(collection), itemsCount);\n}\n","/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * // result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.max(itemsCount, 0);\n\n  return arr.slice(itemsCount);\n}\n","import { dropRight as dropRightToolkit } from '../../array/dropRight.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} collection - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(collection: ArrayLike<T> | null | undefined, itemsCount = 1, guard?: unknown): T[] {\n  if (!isArrayLike(collection)) {\n    return [];\n  }\n  itemsCount = guard ? 1 : toInteger(itemsCount);\n\n  return dropRightToolkit(toArray(collection), itemsCount);\n}\n","/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.min(-itemsCount, 0);\n\n  if (itemsCount === 0) {\n    return arr.slice();\n  }\n\n  return arr.slice(0, itemsCount);\n}\n","import { dropRightWhile as dropRightWhileToolkit } from '../../array/dropRightWhile.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Drops elements from the end of an array while the predicate function returns truthy.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => unknown} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, index, and array, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [5, 4, 3, 2, 1];\n * const result = dropRightWhile(array, x => x < 3);\n * result will be [5, 4, 3] since elements less than 3 are dropped.\n */\nexport function dropRightWhile<T>(\n  arr: ArrayLike<T> | null | undefined,\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => unknown\n): T[];\n\n/**\n * Drops elements from the end of an array while the specified object properties match.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {Partial<T>} objectToDrop - An object specifying the properties to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * const result = dropRightWhile(array, { a: 3 });\n * result will be [{ a: 1 }, { a: 2 }] since the last object matches the properties of the provided object.\n */\nexport function dropRightWhile<T>(arr: ArrayLike<T> | null | undefined, objectToDrop: Partial<T>): T[];\n\n/**\n * Drops elements from the end of an array while the specified property matches a given value.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {[keyof T, unknown]} propertyToDrop - A tuple containing the property key and the value to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const result = dropRightWhile(array, ['id', 3]);\n * result will be [{ id: 1 }, { id: 2 }] since the last object has the id property matching the value 3.\n */\nexport function dropRightWhile<T>(arr: ArrayLike<T> | null | undefined, propertyToDrop: [keyof T, unknown]): T[];\n\n/**\n * Drops elements from the end of an array while the specified property name matches.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {PropertyKey} propertyToDrop - The name of the property to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ isActive: false }, { isActive: true }, { isActive: true }];\n * const result = dropRightWhile(array, 'isActive');\n * result will be [{ isActive: false }] since it drops elements until it finds one with a falsy isActive property.\n */\nexport function dropRightWhile<T>(arr: ArrayLike<T> | null | undefined, propertyToDrop: PropertyKey): T[];\n\n/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the end until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => unknown} predicate - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, index, and array, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [3, 2, 1];\n * const result = dropRightWhile(array, (item, index, arr) => index >= 1);\n * // Returns: [3]\n */\nexport function dropRightWhile<T>(\n  arr: ArrayLike<T> | null | undefined,\n  predicate: ((item: T, index: number, arr: readonly T[]) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return dropRightWhileImpl(Array.from(arr), predicate);\n}\n\nfunction dropRightWhileImpl<T>(\n  arr: readonly T[],\n  predicate: ((item: T, index: number, arr: readonly T[]) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  switch (typeof predicate) {\n    case 'function': {\n      return dropRightWhileToolkit(arr, (item, index, arr) => Boolean(predicate(item, index, arr)));\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        return dropRightWhileToolkit(arr, matchesProperty(key, value));\n      } else {\n        return dropRightWhileToolkit(arr, matches(predicate));\n      }\n    }\n    case 'symbol':\n    case 'number':\n    case 'string': {\n      return dropRightWhileToolkit(arr, property(predicate));\n    }\n  }\n}\n","import { dropWhile as dropWhileToolkit } from '../../array/dropWhile.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Drops elements from the beginning of an array while the predicate function returns truthy.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => unknown} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, index, and array, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(\n  arr: ArrayLike<T> | null | undefined,\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => unknown\n): T[];\n\n/**\n * Drops elements from the beginning of an array while the specified object properties match.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {Partial<T>} objectToDrop - An object specifying the properties to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * const result = dropWhile(array, { a: 1 });\n * result will be [{ a: 2 }, { a: 3 }] since the first object matches the properties of the provided object.\n */\nexport function dropWhile<T>(arr: ArrayLike<T> | null | undefined, objectToDrop: Partial<T>): T[];\n\n/**\n * Drops elements from the beginning of an array while the specified property matches a given value.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {[keyof T, unknown]} propertyToDrop - A tuple containing the property key and the value to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const result = dropWhile(array, ['id', 1]);\n * result will be [{ id: 2 }, { id: 3 }] since the first object has the id property matching the value 1.\n */\nexport function dropWhile<T>(arr: ArrayLike<T> | null | undefined, propertyToDrop: [keyof T, unknown]): T[];\n\n/**\n * Drops elements from the beginning of an array while the specified property name matches.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {PropertyKey} propertyToDrop - The name of the property to match for dropping elements.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [{ isActive: true }, { isActive: true }, { isActive: false }];\n * const result = dropWhile(array, 'isActive');\n * result will be [{ isActive: false }] since it drops elements until it finds one with a falsy isActive property.\n */\nexport function dropWhile<T>(arr: ArrayLike<T> | null | undefined, propertyToDrop: PropertyKey): T[];\n\n/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => unknown} predicate - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, index, and array, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = dropWhile(array, (item, index, arr) => index < 2);\n * // Returns: [3]\n */\nexport function dropWhile<T>(\n  arr: ArrayLike<T> | null | undefined,\n  predicate: ((item: T, index: number, arr: readonly T[]) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return dropWhileImpl(toArray(arr), predicate);\n}\n\nfunction dropWhileImpl<T>(\n  arr: readonly T[],\n  predicate: ((item: T, index: number, arr: readonly T[]) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  switch (typeof predicate) {\n    case 'function': {\n      return dropWhileToolkit(arr, (item, index, arr) => Boolean(predicate(item, index, arr)));\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        return dropWhileToolkit(arr, matchesProperty(key, value));\n      } else {\n        return dropWhileToolkit(arr, matches(predicate));\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      return dropWhileToolkit(arr, property(predicate));\n    }\n  }\n}\n","/**\n * Checks if a string contains another string at the end of the string.\n *\n * Checks if one string endsWith another string. Optional position parameter to offset searching before a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional position from the start to search up to this index\n * @returns {boolean} - True if the str string ends with the target string.\n *\n * @example\n * const isPrefix = endsWith('fooBar', 'foo') // returns true\n * const isPrefix = endsWith('fooBar', 'bar') // returns false\n * const isPrefix = endsWith('fooBar', 'abc') // returns false\n * const isPrefix = endsWith('fooBar', 'foo', 3) // returns true\n * const isPrefix = endsWith('fooBar', 'abc', 5) // returns false\n */\nexport function endsWith(str: string, target: string, position: number = str.length): boolean {\n  return str.endsWith(target, position);\n}\n","import { escapeRegExp as escapeRegExpToolkit } from '../../string/escapeRegExp.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\n *\n * @param {string} str The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * import { escapeRegExp } from 'es-toolkit/string';\n *\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\n */\nexport function escapeRegExp(str?: string): string {\n  return escapeRegExpToolkit(toString(str));\n}\n","/**\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\n *\n * @param {string} str The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * import { escapeRegExp } from 'es-toolkit/string';\n *\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\n */\nexport function escapeRegExp(str: string): string {\n  return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n","import { identity } from '../../function/identity.ts';\nimport { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Checks if all elements in an array are truthy.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to check through.\n * @returns {boolean} - `true` if all elements are truthy, or `false` if at least one element is falsy.\n *\n * @example\n * const items = [1, 2, 3, 4];\n * const result = every(items);\n * console.log(result); // true\n *\n * const itemsWithFalsy = [1, 0, 3, 4];\n * const resultWithFalsy = every(itemsWithFalsy);\n * console.log(resultWithFalsy); // false\n */\nexport function every<T>(arr: ArrayLike<T> | null | undefined): boolean;\n\n/**\n * Checks if every item in an array matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to check through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @returns {boolean} - `true` if every item matches the predicate, or `false` if at least one item does not match.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = every(items, (item) => item > 0);\n * console.log(result); // true\n */\nexport function every<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\n): boolean;\n\n/**\n * Checks if every item in an array matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to check through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @returns {boolean} - `true` if every item matches the partial object, or `false` if at least one item does not match.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = every(items, { name: 'Bob' });\n * console.log(result); // false\n */\nexport function every<T>(arr: ArrayLike<T> | null | undefined, doesMatch: Partial<T>): boolean;\n\n/**\n * Checks if every item in an array matches a property with a specific value.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to check through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {boolean} - `true` if every item has the specified property value, or `false` if at least one item does not match.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = every(items, ['name', 'Alice']);\n * console.log(result); // false\n */\nexport function every<T>(arr: ArrayLike<T> | null | undefined, doesMatchProperty: [keyof T, unknown]): boolean;\n\n/**\n * Checks if every item in an array has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to check through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @returns {boolean} - `true` if every item has the specified property, or `false` if at least one item does not match.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = every(items, 'name');\n * console.log(result); // true\n */\nexport function every<T>(arr: ArrayLike<T> | null | undefined, propertyToCheck: PropertyKey): boolean;\n\n/**\n * Checks if every item in an object matches the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object - The object to check through.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} doesMatch - A function that takes an value, its key, and the object, and returns a truthy value if the item matches the criteria.\n * @returns {boolean} - `true` if every property value matches the predicate, or `false` if at least one does not match.\n *\n * @example\n * // Using a predicate function\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = every(obj, (value) => value > 0);\n * console.log(result); // true\n */\nexport function every<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: (value: T[keyof T], key: keyof T, object: T) => unknown\n): boolean;\n\n/**\n * Checks if every item in an object matches the given partial value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to check through.\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\n * @returns {boolean} - `true` if every property value matches the partial value, or `false` if at least one does not match.\n *\n * @example\n * // Using a partial value\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = every(obj, { name: 'Bob' });\n * console.log(result); // false\n */\nexport function every<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: Partial<T[keyof T]>\n): boolean;\n\n/**\n * Checks if every item in an object matches a property with a specific value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to check through.\n * @param {[keyof T[keyof T], unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {boolean} - `true` if every item has the specified property value, or `false` if at least one item does not match.\n *\n * @example\n * // Using a property-value pair\n * const obj = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * const result = every(obj, ['name', 'Alice']);\n * console.log(result); // false\n */\nexport function every<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatchProperty: [keyof T[keyof T], unknown]\n): boolean;\n\n/**\n * Checks if every item in an object has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T | null | undefined} object - The object to check through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @returns {boolean} - `true` if every property value has the specified property, or `false` if at least one does not match.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = every(obj, 'name');\n * console.log(result); // true\n */\nexport function every<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  propertyToCheck: PropertyKey\n): boolean;\n\n/**\n * Checks if every item in an object has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T extends Record<string, unknown> ? T : never} object - The object to check through.\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to check through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {unknown} guard - Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} - `true` if every property value has the specified property, or `false` if at least one does not match.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = every(obj, 'name');\n * console.log(result); // true\n */\nexport function every<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  doesMatch?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  guard?: unknown\n): boolean {\n  if (!source) {\n    return true;\n  }\n  const values = Array.isArray(source) ? source : Object.values(source);\n  if (guard && isIterateeCall(source, doesMatch, guard)) {\n    doesMatch = undefined;\n  }\n\n  if (!doesMatch) {\n    doesMatch = identity;\n  }\n\n  switch (typeof doesMatch) {\n    case 'function': {\n      if (!Array.isArray(source)) {\n        const keys = Object.keys(source) as Array<keyof T>;\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const value = source[key];\n\n          if (!doesMatch(value as T, key as number, source)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return values.every(doesMatch);\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        return values.every(matchesProperty(key, value));\n      } else {\n        return values.every(matches(doesMatch));\n      }\n    }\n    case 'symbol':\n    case 'number':\n    case 'string': {\n      return values.every(property(doesMatch));\n    }\n  }\n}\n","import { fill as fillToolkit } from '../../array/fill.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isString } from '../predicate/isString.ts';\n\n/**\n * Fills the whole array with a specified value.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T\n * @param {unknown[] | null | undefined} array - The array to fill.\n * @param {T} value - The value to fill the array with.\n * @returns {T[]} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: unknown[] | null | undefined, value?: T): T[];\n/**\n * Fills the whole array with a specified value.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T\n * @param {ArrayLike<unknown> | null | undefined} array - The array to fill.\n * @param {T} value - The value to fill the array with.\n * @returns {ArrayLike<T>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: ArrayLike<unknown> | null | undefined, value?: T): ArrayLike<T>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U> | null | undefined} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(\n  array: Array<T | U> | null | undefined,\n  value: U,\n  start?: number,\n  end?: number\n): Array<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {ArrayLike<T | U> | null | undefined} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {ArrayLike<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(\n  array: ArrayLike<T | U> | null | undefined,\n  value: U,\n  start?: number,\n  end?: number\n): ArrayLike<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {ArrayLike<T | U> | null | undefined} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {ArrayLike<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(\n  array: ArrayLike<T | U> | null | undefined,\n  value: U,\n  start = 0,\n  end = array ? array.length : 0\n): ArrayLike<T | U> {\n  if (!isArrayLike(array)) {\n    return [];\n  }\n  if (isString(array)) {\n    // prevent TypeError: Cannot assign to read only property of string\n    return array;\n  }\n  start = Math.floor(start);\n  end = Math.floor(end);\n\n  if (!start) {\n    start = 0;\n  }\n  if (!end) {\n    end = 0;\n  }\n\n  return fillToolkit(array as any, value, start, end);\n}\n","/**\n * Fills the whole array with a specified value.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: unknown[], value: T): T[];\n/**\n * Fills elements of an array with a specified value from the start position up to the end of the array.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number): Array<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number, end: number): Array<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\n  const length = array.length;\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\n\n  for (let i = finalStart; i < finalEnd; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n","import { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Filters items from a array and returns an array of elements.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to iterate over.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - The function invoked per iteration.\n * @returns {T[]} - Returns a new array of elements that satisfy the given doesMatch function.\n *\n * @example\n * filter([1, 2, 3], n => n % 2 === 0)\n * // => [2]\n */\nexport function filter<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch?: (item: T, index: number, arr: readonly T[]) => unknown\n): T[];\n\n/**\n * Filters elements in a arr that match the properties of the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to iterate over.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @returns {T[]} - Returns a new array of elements that match the given properties.\n *\n * @example\n * const arr = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * filter(arr, { name: 'Bob' });\n * // => [{ id: 2, name: 'Bob' }]\n */\nexport function filter<T>(arr: ArrayLike<T> | null | undefined, doesMatch: Partial<T>): T[];\n\n/**\n * Filters elements in a arr that match the given key-value pair.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to iterate over.\n * @param {[keyof T, unknown]} doesMatchProperty - The key-value pair to match.\n * @returns {T[]} - Returns a new array of elements that match the given key-value pair.\n *\n * @example\n * const arr = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * filter(arr, ['name', 'Alice']);\n * // => [{ id: 1, name: 'Alice' }]\n */\nexport function filter<T>(arr: ArrayLike<T> | null | undefined, doesMatchProperty: [keyof T, unknown]): T[];\n\n/**\n * Filters the arr, returning elements that contain the given property name.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to iterate over.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @returns {T[]} - Returns a new array of elements that match the given property name.\n *\n * @example\n * const arr = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, age: 28 }];\n * filter(arr, 'name');\n * // => [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]\n */\nexport function filter<T>(arr: ArrayLike<T> | null | undefined, propertyToCheck: PropertyKey): T[];\n\n/**\n * Filters items from a object and returns an array of elements that match the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} doesMatch - The function invoked per iteration.\n * @returns {T[]} - Returns a new array of elements that satisfy the given predicate function.\n *\n * @example\n * const obj = { item1: { a: 0 }, item2: { a: 1 }, item3: { a: 0 } }\n * filter(obj, value => value.a)\n * // => [{ a: 1 }]\n *\n * const obj = { a: 1, b: 2, c: 3 };\n * filter(obj, value => value > 2)\n * // => [3]\n */\nexport function filter<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: (value: T[keyof T], key: keyof T, object: T) => unknown\n): T[];\n\n/**\n * Filters elements in a object that match the properties of the given partial object.\n *\n * @template T\n * @param {T | null | undefined} object - The object to iterate over.\n * @param {Partial<T[keyof T]>} doesMatch - The partial object to match\n * @returns {T[]} - Returns a new array of elements that match the given properties.pair.\n *\n * @example\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * filter(obj, { name: 'Bob' });\n * // => [{ id: 2, name: 'Bob' }]\n */\nexport function filter<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: Partial<T[keyof T]>\n): T[];\n\n/**\n * Filters elements in a arr that match the given key-value pair.\n *\n * @template T\n * @param {T | null | undefined} object - The object to iterate over.\n * @param {[keyof T[keyof T], unknown]} doesMatchProperty - The key-value pair to match.\n * @returns {T[]} - Returns a new array of elements that match the given key-value pair.\n *\n * @example\n * const obj = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * filter(obj, ['name', 'Alice']);\n * // => [{ id: 1, name: 'Alice' }]\n */\nexport function filter<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatchProperty: [keyof T[keyof T], unknown]\n): T[];\n\n/**\n * Filters the object, returning elements that contain the given property name.\n *\n * @template T\n * @param {T | null | undefined} object - The object to iterate over.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @returns {T[]} - Returns a new array of elements that match the given property name.\n *\n * @example\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' }, c: { id: 3, age: 28 } };\n * filter(obj, 'name');\n * // => [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]\n */\nexport function filter<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  propertyToCheck: PropertyKey\n): T[];\n\n/**\n * Iterates over the collection and filters elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The array or object to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] - The function invoked per iteration.\n * @returns {T[]} - Returns a new array of filtered elements that satisfy the predicate.\n *\n * @example\n * filter([{ a: 1 }, { a: 2 }, { b: 1 }], 'a');\n * // => [{ a: 1 }, { a: 2 }]\n *\n * filter([{ a: 1 }, { a: 2 }, { b: 1 }], { b: 1 });\n * // => [{ b: 1 }]\n *\n * filter({ item1: { a: 0, b: true }, item2: { a: 1, b: true }, item3: { a: 2, b: false }}, { b: false })\n * // => [{ a: 2, b: false }]\n *\n * filter([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => [{ a: 2 }]\n */\nexport function filter<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  if (!source) {\n    return [];\n  }\n  if (!predicate) {\n    predicate = identity;\n  }\n\n  const collection = isArray(source) ? source : Object.values(source);\n\n  switch (typeof predicate) {\n    case 'function': {\n      if (!Array.isArray(source)) {\n        const result: T[] = [];\n        const keys = Object.keys(source) as Array<keyof T>;\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const value = source[key] as T;\n\n          if (predicate(value, key as number, source)) {\n            result.push(value);\n          }\n        }\n\n        return result;\n      }\n\n      return collection.filter(predicate);\n    }\n    case 'object': {\n      return isArray(predicate)\n        ? collection.filter(matchesProperty(predicate[0], predicate[1]))\n        : collection.filter(matches(predicate));\n    }\n    case 'symbol':\n    case 'number':\n    case 'string': {\n      return collection.filter(property(predicate));\n    }\n  }\n}\n","import { iteratee } from '../util/iteratee.ts';\n\n/**\n * Finds the first item in an array that matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = find(items, (item) => item > 3);\n * console.log(result); // 4\n */\nexport function find<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an array that matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, { name: 'Bob' });\n * console.log(result); // { id: 2, name: 'Bob' }\n */\nexport function find<T>(arr: ArrayLike<T> | null | undefined, doesMatch: Partial<T>, fromIndex?: number): T | undefined;\n\n/**\n * Finds the first item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, ['name', 'Alice']);\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatchProperty: [keyof T, unknown],\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(\n  arr: ArrayLike<T> | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an object that matches the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {(item: T[keyof T], index: number, arr: T) => unknown} doesMatch - A function that takes an item, its key, and the object, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first property value that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = find(obj, (item) => item > 2);\n * console.log(result); // 3\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: (item: T[keyof T], index: keyof T, object: T) => unknown,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an object that matches the given partial value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first property value that matches the partial value, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial value\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, { name: 'Bob' });\n * console.log(result); // { id: 2, name: 'Bob' }\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: Partial<T[keyof T]>,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an object that matches a property with a specific value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {[keyof T[keyof T], unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * const result = find(items, ['name', 'Alice']);\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatchProperty: [keyof T[keyof T], unknown],\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  _doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  fromIndex = 0\n): T | undefined {\n  if (!source) {\n    return undefined;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(source.length + fromIndex, 0);\n  }\n\n  const doesMatch = iteratee(_doesMatch);\n  const values = Array.isArray(source) ? source.slice(fromIndex) : Object.values(source).slice(fromIndex);\n\n  if (typeof doesMatch === 'function' && !Array.isArray(source)) {\n    const keys = Object.keys(source).slice(fromIndex) as Array<keyof T>;\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = source[key] as T;\n\n      if (doesMatch(value, key as number, source)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  return values.find(doesMatch);\n}\n","import { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Finds the index of the first item in an array that matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = find(items, (item) => item > 3);\n * console.log(result); // 4\n */\nexport function findIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, { name: 'Bob' });\n * console.log(result); // 1\n */\nexport function findIndex<T>(arr: ArrayLike<T> | null | undefined, doesMatch: Partial<T>, fromIndex?: number): number;\n\n/**\n * Finds the index of the first item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, ['name', 'Alice']);\n * console.log(result); // 0\n */\nexport function findIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatchProperty: [keyof T, unknown],\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, 'name');\n * console.log(result); // 0\n */\nexport function findIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match against the items in the array. This can be a function, a partial object, a key-value pair, or a property name.\n * @param {PropertyKey} propertyToCheck - The property name to check for in the items of the array.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, 'name');\n * console.log(result); // 0\n */\nexport function findIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  fromIndex = 0\n): number {\n  if (!arr) {\n    return -1;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(arr.length + fromIndex, 0);\n  }\n  const subArray = Array.from(arr).slice(fromIndex);\n  let index = -1;\n  switch (typeof doesMatch) {\n    case 'function': {\n      index = subArray.findIndex(doesMatch);\n      break;\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        index = subArray.findIndex(matchesProperty(key, value));\n      } else {\n        index = subArray.findIndex(matches(doesMatch));\n      }\n      break;\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      index = subArray.findIndex(property(doesMatch));\n    }\n  }\n  return index === -1 ? -1 : index + fromIndex;\n}\n","import { property } from './property';\nimport { findKey as findKeyToolkit } from '../../object';\nimport { isObject } from '../predicate/isObject';\nimport { matches } from '../predicate/matches';\nimport { matchesProperty } from '../predicate/matchesProperty';\n\n/**\n * Finds the key of the first element predicate returns truthy for.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean} conditionToFind - The function invoked per iteration.\n * @returns {keyof T | undefined} Returns the key of the matched element, else `undefined`.\n *\n * @example\n * const users = { 'barney': { 'age': 36 }, 'fred': { 'age': 40 } };\n * const result = findKey(users, o => o.age < 40);\n * // => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T | null | undefined,\n  conditionToFind: (value: T[keyof T], key: keyof T, obj: T) => boolean\n): keyof T | undefined;\n\n/**\n * Finds the key of the first element that matches the given object.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {Partail<T[keyof T]>} objectToFind - The object to match.\n * @returns {keyof T | undefined} Returns the key of the matched element, else `undefined`.\n *\n * @example\n * const users = { 'barney': { 'age': 36 }, 'fred': { 'age': 40 } };\n * const result = findKey(users, { 'age': 36 });\n * // => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T | null | undefined,\n  objectToFind: Partial<T[keyof T]>\n): keyof T | undefined;\n\n/**\n * Finds the key of the first element that matches the given property and value.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {[keyof T[keyof T], any]} propertyToFind - The property and value to match.\n * @returns {keyof T | undefined} Returns the key of the matched element, else `undefined`.\n *\n * @example\n * const users = { 'barney': { 'age': 36 }, 'fred': { 'age': 40 } };\n * const result = findKey(users, ['age', 36]);\n * // => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T | null | undefined,\n  propertyToFind: [keyof T[keyof T], any]\n): keyof T | undefined;\n\n/**\n * Finds the key of the first element that has a truthy value for the given property.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {keyof T[keyof T]} propertyToFind - The property to check.\n * @returns {keyof T | undefined} Returns the key of the matched element, else `undefined`.\n *\n * @example\n * const users = { 'barney': { 'active': true }, 'fred': { 'active': false } };\n * const result = findKey(users, 'active');\n * // => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T | null | undefined,\n  propertyToFind: keyof T[keyof T]\n): keyof T | undefined;\n\n/**\n * Finds the key of the first element that matches the given predicate.\n *\n * This function determines the type of the predicate and delegates the search\n * to the appropriate helper function. It supports predicates as functions, objects,\n * arrays, or strings.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean | Partial<T[keyof T]> | [keyof T[keyof T], any] | keyof T[keyof T]} predicate - The predicate to match.\n * @returns {keyof T | undefined} Returns the key of the matched element, else `undefined`.\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T | null | undefined,\n  predicate:\n    | ((value: T[keyof T], key: keyof T, obj: T) => boolean)\n    | Partial<T[keyof T]>\n    | [keyof T[keyof T], any]\n    | keyof T[keyof T]\n): keyof T | undefined {\n  if (!isObject(obj)) {\n    return undefined;\n  }\n\n  return findKeyImpl(obj, predicate);\n}\n\nfunction findKeyImpl<T extends Record<any, any>>(\n  obj: T,\n  predicate:\n    | ((value: T[keyof T], key: keyof T, obj: T) => boolean)\n    | Partial<T[keyof T]>\n    | [keyof T[keyof T], any]\n    | keyof T[keyof T]\n) {\n  if (typeof predicate === 'function') {\n    return findKeyToolkit(obj, predicate);\n  }\n\n  if (typeof predicate === 'object') {\n    if (Array.isArray(predicate)) {\n      const key = predicate[0];\n      const value = predicate[1];\n\n      return findKeyToolkit(obj, matchesProperty(key, value));\n    }\n\n    return findKeyToolkit(obj, matches(predicate));\n  }\n\n  if (typeof predicate === 'string') {\n    return findKeyToolkit(obj, property(predicate));\n  }\n}\n","import { iteratee } from '../util/iteratee.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Finds the last item in an array that matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=arr.length-1] - The index to start the search from, defaults to arr.length-1.\n * @returns {T | undefined} - The last item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = findLast(items, (item) => item > 3);\n * console.log(result); // 5\n */\nexport function findLast<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an array that matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @param {number} [fromIndex=arr.length-1] - The index to start the search from, defaults to arr.length-1.\n * @returns {T | undefined} - The last item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Bob' }];\n * const result = findLast(items, { name: 'Bob' });\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: Partial<T>,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=arr.length-1] - The index to start the search from, defaults to arr.length-1.\n * @returns {T | undefined} - The last item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Alice' }];\n * const result = findLast(items, ['name', 'Alice']);\n * console.log(result); // { id: 3, name: 'Alice' }\n */\nexport function findLast<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatchProperty: [keyof T, unknown],\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=arr.length-1] - The index to start the search from, defaults to arr.length-1.\n * @returns {T | undefined} - The last item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2 }, { id: 3, name: 'Bob' }];\n * const result = findLast(items, 'name');\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T>(\n  arr: ArrayLike<T> | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an object that matches the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {(item: T[keyof T], index: number, arr: T) => unknown} doesMatch - A function that takes an item, its key, and the object, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=Object.keys(object).length-1] - The index to start the search from, defaults to Object.keys(object).length-1.\n * @returns {T | undefined} - The last property value that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = findLast(obj, (item) => item > 1);\n * console.log(result); // 3\n */\nexport function findLast<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: (item: T[keyof T], index: keyof T, object: T) => unknown,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an object that matches the given partial value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\n * @param {number} [fromIndex=Object.keys(object).length-1] - The index to start the search from, defaults to Object.keys(object).length-1.\n * @returns {T | undefined} - The last property value that matches the partial value, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial value\n * const obj = { a: { id: 1, name: 'Bob' }, b: { id: 2, name: 'Alice' }, c: { id: 3, name: 'Bob' } };\n * const result = findLast(obj, { name: 'Bob' });\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: Partial<T[keyof T]>,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an object that matches a property with a specific value.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {[keyof T[keyof T], unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=Object.keys(object).length-1] - The index to start the search from, defaults to Object.keys(object).length-1.\n * @returns {T | undefined} - The last item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' }, c: { id: 3, name: 'Alice' } };\n * const result = findLast(items, ['name', 'Alice']);\n * console.log(result); // { id: 3, name: 'Alice' }\n */\nexport function findLast<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatchProperty: [keyof T[keyof T], unknown],\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T | null | undefined} object - The object to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=Object.keys(object).length-1] - The index to start the search from, defaults to Object.keys(object).length-1.\n * @returns {T | undefined} - The last property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2 }, c: { id: 3, name: 'Bob' } };\n * const result = findLast(obj, 'name');\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {number} [fromIndex] - The index to start the search from, defaults to source.length-1 for arrays or Object.keys(source).length-1 for objects.\n * @returns {T | undefined} - The last property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2 }, c: { id: 3, name: 'Bob' } };\n * const result = findLast(obj, 'name');\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  _doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  fromIndex?: number\n): T | undefined {\n  if (!source) {\n    return undefined;\n  }\n\n  const length = Array.isArray(source) ? source.length : Object.keys(source).length;\n\n  fromIndex = toInteger(fromIndex ?? length - 1);\n\n  if (fromIndex < 0) {\n    fromIndex = Math.max(length + fromIndex, 0);\n  } else {\n    fromIndex = Math.min(fromIndex, length - 1);\n  }\n\n  const doesMatch = iteratee(_doesMatch);\n\n  const values = Array.isArray(source) ? source.slice(0, fromIndex + 1) : Object.values(source).slice(0, fromIndex + 1);\n\n  if (typeof doesMatch === 'function' && !Array.isArray(source)) {\n    const keys = Object.keys(source).slice(0, fromIndex + 1) as Array<keyof T>;\n\n    for (let i = fromIndex; i >= 0; i--) {\n      const key = keys[i];\n      const value = source[key] as T;\n\n      if (doesMatch(value, key as number, source)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  return values.findLast(doesMatch);\n}\n","import { toArray } from '../_internal/toArray.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Iterates through an array in reverse order and returns the index of the first item that matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = findLastIndex(items, (item) => item > 3)\n * console.log(result); // 4\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findLastIndex(items, { name: 'Bob' });\n * console.log(result); // 1\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: Partial<T>,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findLastIndex(items, ['name', 'Alice']);\n * console.log(result); // 0\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatchProperty: [keyof T, unknown],\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findLastIndex(items, 'name');\n * console.log(result); // 1\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  propertyToCheck: PropertyKey,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The property name to check.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findLastIndex(items, 'name');\n * console.log(result); // 1\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  fromIndex: number = arr ? arr.length - 1 : 0\n): number {\n  if (!arr) {\n    return -1;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(arr.length + fromIndex, 0);\n  } else {\n    fromIndex = Math.min(fromIndex, arr.length - 1);\n  }\n\n  const subArray = toArray(arr).slice(0, fromIndex + 1);\n\n  switch (typeof doesMatch) {\n    case 'function': {\n      return subArray.findLastIndex(doesMatch);\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        return subArray.findLastIndex(matchesProperty(key, value));\n      } else {\n        return subArray.findLastIndex(matches(doesMatch));\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      return subArray.findLastIndex(property(doesMatch));\n    }\n  }\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Maps each element in the array using the iteratee function and flattens the result up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template U - The type of elements within the returned array from the iteratee function.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<U[], D>>} The new array with the mapped and flattened elements.\n *\n * @example\n * const arr = [1, 2, 3];\n *\n * flatMap(arr, (item: number) => [item, item]);\n * // [1, 1, 2, 2, 3, 3]\n *\n * flatMap(arr, (item: number) => [[item, item]], 2);\n * // [1, 1, 2, 2, 3, 3]\n */\nexport function flatMap<T, U, D extends number = 1>(\n  arr: readonly T[],\n  iteratee: (item: T) => U,\n  depth: D = 1 as D\n): Array<FlatArray<U[], D>> {\n  return flatten(\n    arr.map(item => iteratee(item)),\n    depth\n  );\n}\n","import { ExtractNestedArrayType, flattenDeep } from './flattenDeep.ts';\n\n/**\n * Recursively maps each element in an array using a provided iteratee function and then deeply flattens the resulting array.\n *\n * @template T - The type of elements within the array.\n * @template U - The type of elements within the returned array from the iteratee function.\n * @param {T[]} arr - The array to flatten.\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\n * @returns {Array<ExtractNestedArrayType<U>>} A new array that has been flattened.\n *\n * @example\n * const result = flatMapDeep([1, 2, 3], n => [[n, n]]);\n * // [1, 1, 2, 2, 3, 3]\n */\nexport function flatMapDeep<T, U>(arr: readonly T[], iteratee: (item: T) => U): Array<ExtractNestedArrayType<U>> {\n  return flattenDeep(arr.map((item: T) => iteratee(item)));\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\n *\n * @example\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\n * // number\n *\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\n * // string | number | boolean\n */\nexport type ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\n\n/**\n * Flattens all depths of a nested array.\n *\n * @template T - The type of elements within the array.\n * @param {T[]} arr - The array to flatten.\n * @returns {Array<ExtractNestedArrayType<T>>} A new array that has been flattened.\n *\n * @example\n * const arr = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flattenDeep<T>(arr: readonly T[]): Array<ExtractNestedArrayType<T>> {\n  return flatten(arr, Infinity) as Array<ExtractNestedArrayType<T>>;\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\n *\n * @example\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\n * // number\n *\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\n * // string | number | boolean\n */\ntype ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\n\n/**\n * Flattens all depths of a nested array.\n *\n * @template T - The type of elements within the array.\n * @param {ArrayLike<T>} value - The value to flatten.\n * @returns {Array<ExtractNestedArrayType<T>> | []} A new array that has been flattened.\n *\n * @example\n * const value = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flattenDeep<T>(value: ArrayLike<T> | null | undefined): Array<ExtractNestedArrayType<T>> | [] {\n  return flatten(value, Infinity) as Array<ExtractNestedArrayType<T>>;\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {ArrayLike<T> | null | undefined} value - The value to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flattenDepth<T, D extends number = 1>(\n  value: ArrayLike<T> | null | undefined,\n  depth = 1 as D\n): Array<FlatArray<T[], D>> | [] {\n  return flatten(value, depth);\n}\n","/**\n * Reverses the order of arguments for a given function.\n *\n * @template F - The type of the function being flipped.\n * @param {F} func - The function whose arguments will be reversed.\n * @returns {(...args: Reversed<Parameters<F>>) => ReturnType<F>} A new function that takes the\n * reversed arguments and returns the result of calling `func`.\n *\n * @example\n * function fn(a: string, b: string, c: string, d: string) {\n *   return [a, b, c, d];\n * }\n *\n * const flipped = flip(fn);\n * flipped('a', 'b', 'c', 'd'); // => ['d', 'c', 'b', 'a']\n */\n\nexport function flip<F extends (...args: any[]) => any>(func: F): (...args: Reversed<Parameters<F>>) => ReturnType<F> {\n  return function (this: any, ...args: Reversed<Parameters<F>>) {\n    return func.apply(this, args.reverse());\n  };\n}\n\ntype Reversed<T extends any[]> = T extends [infer First, ...infer Rest] ? [...Reversed<Rest>, First] : [];\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded down to precision.\n *\n * @param {number | string} number The number to round down.\n * @param {number | string} precision The precision to round down to.\n * @returns {number} Returns the rounded down number.\n *\n * @example\n * floor(4.006); // => 4\n * floor(0.046, 2); // => 0.04\n * floor(4060, -2); // => 4000\n */\nexport function floor(number: number | string, precision: number | string = 0): number {\n  return decimalAdjust('floor', number, precision);\n}\n","import { flatten } from '../../array/flatten.ts';\nimport { flow as flowToolkit } from '../../function/flow.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *  return 42;\n * }\n *\n * const combined = flow(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flow<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *   return a * 2;\n * }\n *\n * const combined = flow(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flow<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flow(add, square, double, toStr);\n * console.log(combined(1, 2)); // '18'\n */\nexport function flow<A extends any[], R1, R2, R3, R4>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flow(add, square, double, toStr, split);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow([add, square], double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow(\n  ...funcs: Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>\n): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow([add, square], double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow(\n  ...funcs: Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>\n): (...args: any[]) => any {\n  const flattenFuncs = flatten(funcs, 1);\n  if (flattenFuncs.some(func => typeof func !== 'function')) {\n    throw new TypeError('Expected a function');\n  }\n  return flowToolkit(...flattenFuncs);\n}\n","import { flatten } from '../../array/flatten.ts';\nimport { flowRight as flowRightToolkit } from '../../function/flowRight.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *   return 42;\n * }\n * const combined = flowRight(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flowRight<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *  return a * 2;\n * }\n * const combined = flowRight(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flowRight<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight<A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, square, add);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight<A extends any[], R1, R2, R3>(\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flowRight(toStr, double, square, add);\n * console.log(combined(1, 2));  // '18'\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4>(\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flowRight(split, toStr, double, square, add);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5>(\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, [square, add]);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight(\n  ...funcs: Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>\n): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, [square, add]);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight(\n  ...funcs: Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>\n): (...args: any[]) => any {\n  const flattenFuncs = flatten(funcs, 1);\n  if (flattenFuncs.some(func => typeof func !== 'function')) {\n    throw new TypeError('Expected a function');\n  }\n  return flowRightToolkit(...flattenFuncs);\n}\n","import { flow } from './flow.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *   return 42;\n * }\n * const combined = flowRight(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flowRight<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *  return a * 2;\n * }\n * const combined = flowRight(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flowRight<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight<A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, square, add);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight<A extends any[], R1, R2, R3>(\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flowRight(toStr, double, square, add);\n * console.log(combined(1, 2));  // '18'\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4>(\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flowRight(split, toStr, double, square, add);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5>(\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: any[]) => any} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: any[]) => any} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\n  return flow(...funcs.reverse());\n}\n","/**\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'arr': The array 'forEachRight' was called upon.\n *\n * @example\n * const array = [1, 2, 3];\n * const result: number[] = [];\n *\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\n * forEachRight(array, (value) => {\n *  result.push(value);\n * })\n *\n * console.log(result) // Output: [3, 2, 1]\n */\nexport function forEachRight<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => void): void;\n/**\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'arr': The array 'forEachRight' was called upon.\n *\n * @example\n * const array = [1, 2, 3];\n * const result: number[] = [];\n *\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\n * forEachRight(array, (value) => {\n *  result.push(value);\n * })\n *\n * console.log(result) // Output: [3, 2, 1]\n */\nexport function forEachRight<T>(\n  arr: readonly T[],\n  callback: (value: T, index: number, arr: readonly T[]) => void\n): void;\n\n/**\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'arr': The array 'forEachRight' was called upon.\n *\n * @example\n * const array = [1, 2, 3];\n * const result: number[] = [];\n *\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\n * forEachRight(array, (value) => {\n *  result.push(value);\n * })\n *\n * console.log(result) // Output: [3, 2, 1]\n */\nexport function forEachRight<T>(arr: readonly T[], callback: (value: T, index: number, arr: T[]) => void): void {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const element = arr[i];\n    callback(element, i, arr as T[]);\n  }\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @param {any[]} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\n * @returns {Record<string, any>} - An object where the keys are from the first element and values are from the second element.\n *\n * @example\n * const pairs = [['a', 1], ['b', 2]];\n * const result = fromPairs(pairs);\n * // result will be: { a: 1, b: 2 }\n */\nexport function fromPairs(pairs: readonly any[]): Record<string, any>;\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\n * @template U - The type of the values in the resulting object.\n *\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\n *\n * @example\n * const pairs = [['a', 1], ['b', 2]];\n * const result = fromPairs(pairs);\n * // result will be: { a: 1, b: 2 }\n */\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U>;\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\n * @template U - The type of the values in the resulting object.\n *\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\n *\n * @example\n * const pairs = [['a', 1], ['b', 2]];\n * const result = fromPairs(pairs);\n * // result will be: { a: 1, b: 2 }\n */\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U> {\n  if (!isArrayLike(pairs) && !(pairs instanceof Map)) {\n    return {} as Record<T, U>;\n  }\n\n  const result = {} as Record<T, U>;\n\n  for (const [key, value] of pairs) {\n    result[key as T] = value;\n  }\n\n  return result;\n}\n","/**\n * Groups the elements of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are arrays of elements that share\n * the same key.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array to group.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\n * share that key.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = groupBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: [\n * //     { category: 'fruit', name: 'apple' },\n * //     { category: 'fruit', name: 'banana' }\n * //   ],\n * //   vegetable: [\n * //     { category: 'vegetable', name: 'carrot' }\n * //   ]\n * // }\n */\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = getKeyFromItem(item);\n\n    if (!Object.hasOwn(result, key)) {\n      result[key] = [];\n    }\n\n    result[key].push(item);\n  }\n\n  return result;\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is greater than other.\n *\n * @param {unknown} value The value to compare.\n * @param {unknown} other The other value to compare.\n * @returns {boolean} Returns `true` if value is greater than other, else `false`.\n *\n * @example\n * gt(3, 1); // true\n * gt(3, 3); // false\n * gt(1, 3); // false\n */\nexport function gt(value: unknown, other: unknown): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value > other;\n  }\n\n  return toNumber(value) > toNumber(other);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is greater than or equal to other.\n *\n * @param {unknown} value The value to compare.\n * @param {unknown} other The other value to compare.\n * @returns {boolean} Returns `true` if value is greater than or equal to other, else `false`.\n *\n * @example\n * gte(3, 1); // => true\n * gte(3, 3); // => true\n * gte(1, 3); // => false\n */\nexport function gte(value: unknown, other: unknown): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value >= other;\n  }\n\n  return toNumber(value) >= toNumber(other);\n}\n","import { inRange as inRangeToolkit } from '../../math/inRange.ts';\n\n/**\n * Checks if the value is less than the maximum.\n *\n * @param {number} value The value to check.\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 5); // result will be true.\n * const result2 = inRange(5, 5); // result2 will be false.\n */\nexport function inRange(value: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 2, 5); // result will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n */\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (!minimum) {\n    minimum = 0;\n  }\n\n  if (maximum != null && !maximum) {\n    maximum = 0;\n  }\n\n  if (minimum != null && typeof minimum !== 'number') {\n    minimum = Number(minimum);\n  }\n\n  if (maximum == null && minimum === 0) {\n    return false;\n  }\n\n  if (maximum != null && typeof maximum !== 'number') {\n    maximum = Number(maximum);\n  }\n\n  if (maximum != null && minimum > maximum) {\n    [minimum, maximum] = [maximum, minimum];\n  }\n\n  if (minimum === maximum) {\n    return false;\n  }\n\n  return inRangeToolkit(value, minimum, maximum!);\n}\n","/**\n * Checks if the value is less than the maximum.\n *\n * @param {number} value The value to check.\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 5); // result will be true.\n * const result2 = inRange(5, 5); // result2 will be false.\n */\nexport function inRange(value: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 2, 5); // result will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n */\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('The maximum value must be greater than the minimum value.');\n  }\n\n  return minimum <= value && value < maximum;\n}\n","import { isString } from '../predicate/isString.ts';\nimport { eq } from '../util/eq.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Checks if an item is included in an array.\n *\n * @param {T[]} arr - The array to search in.\n * @param {T} item - The item to search for.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the array.\n * @returns {boolean} `true` if the item is found in the array, `false` otherwise.\n *\n * @example\n * includes([1, 2, 3], 2); // true\n * includes([1, 2, 3], 4); // false\n * includes([1, 2, 3], 3, -1); // true\n */\nexport function includes<T>(arr: readonly T[], item: T, fromIndex?: number): boolean;\n\n/**\n * Checks if a value is included in an object.\n *\n * @param {T} obj - The object to search in.\n * @param {T[keyof T]} value - The value to search for.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the array.\n * @returns {boolean} `true` if the value is found in the object, `false` otherwise.\n *\n * @example\n * includes({ a: 1, b: 'a', c: NaN }, 1); // true\n * includes({ a: 1, b: 'a', c: NaN }, 'a'); // true\n * includes({ a: 1, b: 'a', c: NaN }, NaN); // true\n * includes({ [Symbol('sym1')]: 1 }, 1); // false\n */\nexport function includes<T extends Record<string, any>>(obj: T, value: T[keyof T], fromIndex?: number): boolean;\n\n/**\n * Checks if a substring is included in a string.\n *\n * @param {string} str - The string to search in.\n * @param {string} substr - The substring to search for.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the string.\n * @returns {boolean} `true` if the substring is found in the string, `false` otherwise.\n *\n * @example\n * includes('hello world', 'world'); // true\n * includes('hello world', 'test'); // false\n * includes('hello world', 'o', 5); // true\n */\nexport function includes(str: string, substr: string, fromIndex?: number): boolean;\n\n/**\n * Checks if a specified value exists within a given source, which can be an array, an object, or a string.\n *\n * The comparison uses SameValueZero to check for inclusion.\n *\n * @param {T[] | Record<string, any> | string} source - The source to search in. It can be an array, an object, or a string.\n * @param {T} [target] - The value to search for in the source.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the source.\n * @returns {boolean} `true` if the value is found in the source, `false` otherwise.\n *\n * @example\n * includes([1, 2, 3], 2); // true\n * includes({ a: 1, b: 'a', c: NaN }, 'a'); // true\n * includes('hello world', 'world'); // true\n * includes('hello world', 'test'); // false\n */\nexport function includes<T>(\n  source: readonly T[] | Record<string, any> | string,\n  target?: T,\n  fromIndex?: number\n): boolean;\n\n/**\n * Checks if a specified value exists within a given source, which can be an array, an object, or a string.\n *\n * The comparison uses SameValueZero to check for inclusion.\n *\n * @param {T[] | Record<string, any> | string} source - The source to search in. It can be an array, an object, or a string.\n * @param {T} [target] - The value to search for in the source.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the source.\n * @returns {boolean} `true` if the value is found in the source, `false` otherwise.\n *\n * @example\n * includes([1, 2, 3], 2); // true\n * includes({ a: 1, b: 'a', c: NaN }, 'a'); // true\n * includes('hello world', 'world'); // true\n * includes('hello world', 'test'); // false\n */\nexport function includes(\n  source: readonly unknown[] | Record<string, any> | string,\n  target?: unknown,\n  fromIndex?: number,\n  guard?: unknown\n): boolean {\n  if (source == null) {\n    return false;\n  }\n\n  if (guard || !fromIndex) {\n    fromIndex = 0;\n  } else {\n    fromIndex = toInteger(fromIndex);\n  }\n\n  if (isString(source)) {\n    if (fromIndex > source.length || target instanceof RegExp) {\n      return false;\n    }\n\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, source.length + fromIndex);\n    }\n\n    return source.includes(target as any, fromIndex);\n  }\n\n  if (Array.isArray(source)) {\n    return source.includes(target, fromIndex);\n  }\n\n  const keys = Object.keys(source);\n\n  if (fromIndex < 0) {\n    fromIndex = Math.max(0, keys.length + fromIndex);\n  }\n\n  for (let i = fromIndex; i < keys.length; i++) {\n    const value = Reflect.get(source, keys[i]);\n\n    if (eq(value, target)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Finds the index of the first occurrence of a value in an array.\n *\n * This method is similar to `Array.prototype.indexOf`, but it also finds `NaN` values.\n * It uses strict equality (`===`) to compare elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to search.\n * @param {T} searchElement - The value to search for.\n * @param {number} [fromIndex] - The index to start the search at.\n * @returns {number} The index (zero-based) of the first occurrence of the value in the array, or `-1` if the value is not found.\n *\n * @example\n * const array = [1, 2, 3, NaN];\n * indexOf(array, 3); // => 2\n * indexOf(array, NaN); // => 3\n */\nexport function indexOf<T>(array: ArrayLike<T> | null | undefined, searchElement: T, fromIndex?: number): number {\n  if (!isArrayLike(array)) {\n    return -1;\n  }\n\n  // `Array.prototype.indexOf` doesn't find `NaN` values, so we need to handle that case separately.\n  if (Number.isNaN(searchElement)) {\n    fromIndex = fromIndex ?? 0;\n\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, array.length + fromIndex);\n    }\n\n    for (let i = fromIndex; i < array.length; i++) {\n      if (Number.isNaN(array[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  // Array.prototype.indexOf already handles `fromIndex < -array.length`, `fromIndex >= array.length` and converts `fromIndex` to an integer, so we don't need to handle those cases here.\n  // And it uses strict equality (===) to compare elements like `lodash/indexOf` does.\n  return Array.from(array).indexOf(searchElement, fromIndex);\n}\n","/**\n * Returns an empty array when the input is a tuple containing exactly one element.\n *\n * @template T The type of the single element.\n * @param {[T]} arr - A tuple containing exactly one element.\n * @returns {[]} An empty array since there is only one element.\n *\n * @example\n * const array = [100] as const;\n * const result = initial(array);\n * // result will be []\n */\nexport function initial<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input array is empty.\n *\n * @returns {[]} Always returns an empty array for an empty input.\n *\n * @example\n * const array = [] as const;\n * const result = initial(array);\n * // result will be []\n */\nexport function initial(arr: readonly []): [];\n\n/**\n * Returns a new array containing all elements except the last one from a tuple with multiple elements.\n *\n * @template T The types of the initial elements.\n * @template U The type of the last element in the tuple.\n * @param {[...T[], U]} arr - A tuple with one or more elements.\n * @returns {T[]} A new array containing all but the last element of the tuple.\n *\n * @example\n * const array = ['apple', 'banana', 'cherry'] as const;\n * const result = initial(array);\n * // result will be ['apple', 'banana']\n */\nexport function initial<T, U>(arr: readonly [...T[], U]): T[];\n\n/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The input array.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const result = initial(arr);\n * // result will be [1, 2, 3]\n */\nexport function initial<T>(arr: readonly T[]): T[];\n\n/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The input array.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const result = initial(arr);\n * // result will be [1, 2, 3]\n */\nexport function initial<T>(arr: readonly T[]): T[] {\n  return arr.slice(0, -1);\n}\n","import { intersection as intersectionToolkit } from '../../array/intersection.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Returns the intersection of multiple arrays.\n *\n * This function takes multiple arrays and returns a new array containing the elements that are\n * present in all provided arrays. It effectively filters out any elements that are not found\n * in every array.\n *\n * @template T - The type of elements in the arrays.\n * @param {...(ArrayLike<T> | null | undefined)} arrays - The arrays to compare.\n * @returns {T[]} A new array containing the elements that are present in all arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[] {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  if (!isArrayLikeObject(arrays[0])) {\n    return [];\n  }\n\n  let result: T[] = uniq(Array.from(arrays[0]));\n\n  for (let i = 1; i < arrays.length; i++) {\n    const array = arrays[i];\n\n    if (!isArrayLikeObject(array)) {\n      return [];\n    }\n\n    result = intersectionToolkit(result, Array.from(array));\n  }\n\n  return result;\n}\n","import { intersectionBy as intersectionByToolkit } from '../../array/intersectionBy.ts';\nimport { last } from '../../array/last.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an iteratee function (or property key) to\n * compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n *\n * @template T1, T2\n * @param {ArrayLike<T1> | null | undefined} array - The first array to compare.\n * @param {ArrayLike<T2>} values - The second array to compare.\n * @param {(value: T1 | T2) => unknown | string} iteratee - The iteratee invoked on each element\n *  for comparison. It can also be a property key to compare based on that property.\n * @returns {T1[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }, { x: 4 }];\n * const result = intersectionBy(array1, array2, 'x');\n * // result will be [{ x: 2 }, { x: 3 }] since these elements have the same `x` property.\n *\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }, { x: 4 }];\n * const result = intersectionBy(array1, array2, value => value.x);\n * // result will be [{ x: 2 }, { x: 3 }] since these elements have the same `x` property.\n */\nexport function intersectionBy<T1, T2>(\n  array: ArrayLike<T1> | null | undefined,\n  values: ArrayLike<T2>,\n  iteratee: ((value: T1 | T2) => unknown) | string\n): T1[];\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an iteratee function (or property key) to\n * compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n *\n * @template T1, T2, T3\n * @param {ArrayLike<T1> | null | undefined} array - The first array to compare.\n * @param {ArrayLike<T2>} values1 - The second array to compare.\n * @param {ArrayLike<T3>} values2 - The third array to compare.\n * @param {(value: T1 | T2 | T3) => unknown | string} iteratee - The iteratee invoked on each element\n *  for comparison. It can also be a property key to compare based on that property.\n * @returns {T1[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const array3 = [{ x: 3 }];\n * const result = intersectionBy(array1, array2, array3, 'x');\n * // result will be [{ x: 3 }] since this element has the same `x` property in all arrays.\n *\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const array3 = [{ x: 3 }];\n * const result = intersectionBy(array1, array2, array3, value => value.x);\n * // result will be [{ x: 3 }] since this element has the same `x` property in all arrays.\n */\nexport function intersectionBy<T1, T2, T3>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  iteratee: ((value: T1 | T2 | T3) => unknown) | string\n): T1[];\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an iteratee function (or property key) to\n * compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n *\n * @template T1, T2, T3, T4\n * @param {ArrayLike<T1> | null | undefined} array - The first array to compare.\n * @param {ArrayLike<T2>} values1 - The second array to compare.\n * @param {ArrayLike<T3>} values2 - The third array to compare.\n * @param {...(ArrayLike<T4> | ((value: T1 | T2 | T3 | T4) => unknown) | string)} values - Additional arrays to compare, or the iteratee function.\n * @returns {T1[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const array3 = [{ x: 3 }];\n * const array4 = [{ x: 3 }, { x: 4 }];\n * const result = intersectionBy(array1, array2, array3, array4, 'x');\n * // result will be [{ x: 3 }] since this element has the same `x` property in all arrays.\n *\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const array3 = [{ x: 3 }];\n * const array4 = [{ x: 3 }, { x: 4 }];\n * const result = intersectionBy(array1, array2, array3, array4, value => value.x);\n * // result will be [{ x: 3 }] since this element has the same `x` property in all arrays.\n */\nexport function intersectionBy<T1, T2, T3, T4>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  ...values: Array<ArrayLike<T4> | ((value: T1 | T2 | T3 | T4) => unknown) | string>\n): T1[];\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an iteratee function (or property key) to\n * compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} [array] - The first array to compare.\n * @param {...ArrayLike<T>} values - Additional arrays to compare.\n * @returns {T[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3];\n * const array3 = [3];\n * const result = intersectionBy(array1, array2, array3);\n * // result will be [3] since these all elements have the same value 3.\n */\nexport function intersectionBy<T>(array?: ArrayLike<T> | null | undefined, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an optional iteratee function (or property key)\n * to compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n * If no iteratee is provided, the identity function is used.\n *\n * If the first array is `null` or `undefined`, an empty array is returned.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The first array to compare.\n * @param {...(ArrayLike<T> | ((value: T) => unknown) | string)} values - The arrays to compare, or the iteratee function.\n * @returns {T[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const result = intersectionBy(array1, array2, 'x');\n * // result will be [{ x: 2 }, { x: 3 }] since these elements have the same `x` property.\n *\n * @example\n * const array1 = [1.1, 2.2, 3.3];\n * const array2 = [2.3, 3.3];\n * const result = intersectionBy(array1, array2, Math.floor);\n * // result will be [2.3, 3.3] since it shares the same integer part when `Math.floor` is applied.\n */\nexport function intersectionBy<T>(\n  array: ArrayLike<T> | null | undefined,\n  ...values: Array<ArrayLike<T> | ((value: T) => unknown) | string>\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  const lastValue = last(values);\n  if (lastValue === undefined) {\n    return Array.from(array);\n  }\n\n  let result = uniq(Array.from(array));\n\n  const count = isArrayLikeObject(lastValue) ? values.length : values.length - 1;\n\n  for (let i = 0; i < count; ++i) {\n    const value = values[i];\n\n    if (!isArrayLikeObject(value)) {\n      return [];\n    }\n\n    if (isArrayLikeObject(lastValue)) {\n      result = intersectionByToolkit(result, Array.from(value), identity);\n    } else if (typeof lastValue === 'function') {\n      result = intersectionByToolkit(result, Array.from(value), value => lastValue(value));\n    } else if (typeof lastValue === 'string') {\n      result = intersectionByToolkit(result, Array.from(value), property(lastValue));\n    }\n  }\n\n  return result;\n}\n","/**\n * Asserts that a given condition is true. If the condition is false, an error is thrown with the provided message.\n *\n * @param {unknown} condition - The condition to evaluate.\n * @param {string} [message] - The error message to throw if the condition is false.\n * @returns {void} Returns void if the condition is true.\n * @throws {Error} Throws an error if the condition is false.\n *\n * @example\n * // This call will succeed without any errors\n * invariant(true, 'This should not throw');\n *\n * // This call will fail and throw an error with the message 'This should throw'\n * invariant(false, 'This should throw');\n *\n * // Example of using invariant with a condition\n * invariant(condition, 'Expected condition is false');\n *\n * // Ensure that the value is neither null nor undefined\n * invariant(value !== null && value !== undefined, 'Value should not be null or undefined');\n *\n * // Example of using invariant to check if a number is positive\n * invariant(number > 0, 'Number must be positive');\n */\nexport function invariant(condition: unknown, message: string): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  throw new Error(message);\n}\n","/**\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\n *\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\n * of the input object's key-value pairs.\n *\n * @template K - Type of the keys in the input object (string, number, symbol)\n * @template V - Type of the values in the input object (string, number, symbol)\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\n * @returns {Record<V, K>} - A new object with keys and values inverted\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\n */\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): Record<V, K> {\n  const result = {} as Record<V, K>;\n\n  const keys = Object.keys(obj) as K[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n    result[value] = key;\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { isNil } from '../../predicate/isNil.ts';\n\n/**\n * Creates a new object that reverses the keys and values of the given object, similar to the invert.\n *\n * The `iteratee` function specifies how the values are reversed into keys. If no `iteratee` function is provided, the values are used as keys as-is.\n *\n * The values of the new object are arrays of keys that correspond to the value returned by the `iteratee` function.\n *\n * @param {Record<K, V>} object - The object to iterate over.\n * @param {(value: V) => string} [iteratee] - Optional. A function that generates a key based on each value in the object.\n * If not provided, the function defaults to using the value as a string.\n *\n * @returns {Record<string, K[]>} An object where the keys are generated by the iteratee, and the values\n * are arrays of property names (keys) from the input object that correspond to those keys.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * const result = invertBy(obj);\n * // result => { '1': ['a', 'c'], '2': ['b'] }\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * const result = invertBy(obj, value => `group${value}`);\n * // result => { 'group1': ['a', 'c'], 'group2': ['b'] }\n */\nexport function invertBy<K extends PropertyKey, V>(\n  object: Record<K, V>,\n  iteratee?: (value: V) => string\n): Record<string, K[]> {\n  const result = {} as Record<string, K[]>;\n\n  if (isNil(object)) {\n    return result;\n  }\n\n  if (iteratee == null) {\n    iteratee = identity as (value: V) => string;\n  }\n\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K;\n\n    const value = object[key];\n    const valueStr = iteratee(value);\n\n    if (Array.isArray(result[valueStr])) {\n      result[valueStr].push(key);\n    } else {\n      result[valueStr] = [key];\n    }\n  }\n\n  return result;\n}\n","import { isArrayBuffer as isArrayBufferToolkit } from '../../predicate/isArrayBuffer.ts';\n\n/**\n * Checks if a given value is `ArrayBuffer`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `ArrayBuffer`.\n *\n * @param {unknown} value The value to check if it is a `ArrayBuffer`.\n * @returns {value is ArrayBuffer} Returns `true` if `value` is a `ArrayBuffer`, else `false`.\n *\n * @example\n * const value1 = new ArrayBuffer();\n * const value2 = new Array();\n * const value3 = new Map();\n *\n * console.log(isArrayBuffer(value1)); // true\n * console.log(isArrayBuffer(value2)); // false\n * console.log(isArrayBuffer(value3)); // false\n */\n\nexport function isArrayBuffer(value?: unknown): value is ArrayBuffer {\n  return isArrayBufferToolkit(value);\n}\n","/**\n * Checks if a given value is `ArrayBuffer`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `ArrayBuffer`.\n *\n * @param {unknown} value The value to check if it is a `ArrayBuffer`.\n * @returns {value is ArrayBuffer} Returns `true` if `value` is a `ArrayBuffer`, else `false`.\n *\n * @example\n * const value1 = new ArrayBuffer();\n * const value2 = new Array();\n * const value3 = new Map();\n *\n * console.log(isArrayBuffer(value1)); // true\n * console.log(isArrayBuffer(value2)); // false\n * console.log(isArrayBuffer(value3)); // false\n */\n\nexport function isArrayBuffer(value: unknown): value is ArrayBuffer {\n  return value instanceof ArrayBuffer;\n}\n","/**\n * Checks if the given value is boolean.\n *\n * This function tests whether the provided value is strictly `boolean`.\n * It returns `true` if the value is `boolean`, and `false` otherwise.\n *\n *  This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `boolean`.\n *\n * @param {unknown} value - The Value to test if it is boolean.\n * @returns {value is boolean} True if the value is boolean, false otherwise.\n *\n * @example\n *\n * const value1 = true;\n * const value2 = 0;\n * const value3 = 'abc';\n *\n * console.log(isBoolean(value1)); // true\n * console.log(isBoolean(value2)); // false\n * console.log(isBoolean(value3)); // false\n *\n */\nexport function isBoolean(value?: unknown): value is boolean {\n  return typeof value === 'boolean' || value instanceof Boolean;\n}\n","import { isBuffer as isBufferToolkit } from '../../predicate/isBuffer.ts';\n\n/**\n * Checks if the given value is a Buffer instance.\n *\n * This function tests whether the provided value is an instance of Buffer.\n * It returns `true` if the value is a Buffer, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Buffer`.\n *\n * @param {unknown} x - The value to check if it is a Buffer.\n * @returns {boolean} Returns `true` if `x` is a Buffer, else `false`.\n *\n * @example\n * const buffer = Buffer.from(\"test\");\n * console.log(isBuffer(buffer)); // true\n *\n * const notBuffer = \"not a buffer\";\n * console.log(isBuffer(notBuffer)); // false\n */\nexport function isBuffer(x?: unknown): boolean {\n  return isBufferToolkit(x);\n}\n","import { isDate as isDateToolkit } from '../../predicate/isDate.ts';\n\n/**\n * Checks if `value` is a Date object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\n *\n * @example\n * const value1 = new Date();\n * const value2 = '2024-01-01';\n *\n * console.log(isDate(value1)); // true\n * console.log(isDate(value2)); // false\n */\nexport function isDate(value?: unknown): value is Date {\n  return isDateToolkit(value);\n}\n","/**\n * Checks if `value` is a Date object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\n *\n * @example\n * const value1 = new Date();\n * const value2 = '2024-01-01';\n *\n * console.log(isDate(value1)); // true\n * console.log(isDate(value2)); // false\n */\nexport function isDate(value: unknown): value is Date {\n  return value instanceof Date;\n}\n","import { isObjectLike } from './isObjectLike';\nimport { isPlainObject } from './isPlainObject';\n\n/**\n * Checks if `value` is likely a DOM element.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n *\n * @example\n * console.log(isElement(document.body)); // true\n * console.log(isElement('<body>')); // false\n */\nexport function isElement(value?: any): boolean {\n  return isObjectLike(value) && (value as any).nodeType === 1 && !isPlainObject(value);\n}\n","import { isArguments } from './isArguments.ts';\nimport { isArrayLike } from './isArrayLike.ts';\nimport { isTypedArray } from './isTypedArray.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Checks if a given value is empty.\n *\n * @returns {true} Always returns true when no arguments are provided.\n *\n * @example\n * isEmpty(); // true\n */\nexport function isEmpty(): true;\n\n/**\n * Checks if a given string is empty.\n *\n * @param {string} value - The string to check.\n * @returns {boolean} `true` if the string is empty, `false` otherwise.\n *\n * @example\n * isEmpty(\"\"); // true\n * isEmpty(\"hello\"); // false\n */\nexport function isEmpty(value: string): value is '';\n\n/**\n * Checks if a given Map is empty.\n *\n * @param {Map<any, any>} value - The Map to check.\n * @returns {boolean} `true` if the Map is empty, `false` otherwise.\n *\n * @example\n * isEmpty(new Map()); // true\n * isEmpty(new Map([[\"key\", \"value\"]])); // false\n */\nexport function isEmpty(value: Map<any, any>): boolean;\n\n/**\n * Checks if a given Set is empty.\n *\n * @param {Set<any>} value - The Set to check.\n * @returns {boolean} `true` if the Set is empty, `false` otherwise.\n *\n * @example\n * isEmpty(new Set()); // true\n * isEmpty(new Set([1, 2, 3])); // false\n */\nexport function isEmpty(value: Set<any>): boolean;\n\n/**\n * Checks if a given array is empty.\n *\n * @param {any[]} value - The array to check.\n * @returns {boolean} `true` if the array is empty, `false` otherwise.\n *\n * @example\n * isEmpty([]); // true\n * isEmpty([1, 2, 3]); // false\n */\nexport function isEmpty(value: any[]): value is [];\n\n/**\n * Checks if a given object is empty.\n *\n * @param {T | null | undefined} value - The object to check.\n * @returns {boolean} `true` if the object is empty, `false` otherwise.\n *\n * @example\n * isEmpty({}); // true\n * isEmpty({ a: 1 }); // false\n */\nexport function isEmpty<T extends Record<any, any>>(\n  value: T | null | undefined\n): value is Record<keyof T, never> | null | undefined;\n\n/**\n * Checks if a given value is empty.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} `true` if the value is empty, `false` otherwise.\n *\n * @example\n * isEmpty(null); // true\n * isEmpty(undefined); // true\n * isEmpty(42); // true\n */\nexport function isEmpty(value: unknown): boolean;\n\n/**\n * Checks if a given value is empty.\n *\n * - If the given value is a string, checks if it is an empty string.\n * - If the given value is an array, `Map`, or `Set`, checks if its size is 0.\n * - If the given value is an [array-like object](../predicate/isArrayLike.md), checks if its length is 0.\n * - If the given value is an object, checks if it is an empty object with no properties.\n * - Primitive values (strings, booleans, numbers, or bigints) are considered empty.\n *\n * @param {unknown} [value] - The value to check.\n * @returns {boolean} `true` if the value is empty, `false` otherwise.\n *\n * @example\n * isEmpty(); // true\n * isEmpty(null); // true\n * isEmpty(\"\"); // true\n * isEmpty([]); // true\n * isEmpty({}); // true\n * isEmpty(new Map()); // true\n * isEmpty(new Set()); // true\n * isEmpty(\"hello\"); // false\n * isEmpty([1, 2, 3]); // false\n * isEmpty({ a: 1 }); // false\n * isEmpty(new Map([[\"key\", \"value\"]])); // false\n * isEmpty(new Set([1, 2, 3])); // false\n */\nexport function isEmpty(value?: unknown): boolean {\n  if (value == null) {\n    return true;\n  }\n\n  // Objects like { \"length\": 0 } are not empty in lodash\n  if (isArrayLike(value)) {\n    if (\n      typeof (value as any).splice !== 'function' &&\n      typeof value !== 'string' &&\n      (typeof Buffer === 'undefined' || !Buffer.isBuffer(value)) &&\n      !isTypedArray(value) &&\n      !isArguments(value)\n    ) {\n      return false;\n    }\n\n    return value.length === 0;\n  }\n\n  if (typeof value === 'object') {\n    if (value instanceof Map || value instanceof Set) {\n      return value.size === 0;\n    }\n\n    const keys = Object.keys(value);\n\n    if (isPrototype(value)) {\n      return keys.filter(x => x !== 'constructor').length === 0;\n    }\n\n    return keys.length === 0;\n  }\n\n  return true;\n}\n","import { isEqualWith } from './isEqualWith.ts';\nimport { noop } from '../function/noop.ts';\n\n/**\n * Checks if two values are equal, including support for `Date`, `RegExp`, and deep object comparison.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @returns {boolean} `true` if the values are equal, otherwise `false`.\n *\n * @example\n * isEqual(1, 1); // true\n * isEqual({ a: 1 }, { a: 1 }); // true\n * isEqual(/abc/g, /abc/g); // true\n * isEqual(new Date('2020-01-01'), new Date('2020-01-01')); // true\n * isEqual([1, 2, 3], [1, 2, 3]); // true\n */\nexport function isEqual(a: any, b: any): boolean {\n  return isEqualWith(a, b, noop);\n}\n","import { after } from '../../function/after.ts';\nimport { noop } from '../../function/noop.ts';\nimport { isEqualWith as isEqualWithToolkit } from '../../predicate/isEqualWith.ts';\n\n/**\n * Compares two values for equality using a custom comparison function.\n *\n * The custom function allows for fine-tuned control over the comparison process. If it returns a boolean, that result determines the equality. If it returns undefined, the function falls back to the default equality comparison.\n *\n * This function also uses the custom equality function to compare values inside objects,\n * arrays, maps, sets, and other complex structures, ensuring a deep comparison.\n *\n * This approach provides flexibility in handling complex comparisons while maintaining efficient default behavior for simpler cases.\n *\n * The custom comparison function can take up to six parameters:\n * - `x`: The value from the first object `a`.\n * - `y`: The value from the second object `b`.\n * - `property`: The property key used to get `x` and `y`.\n * - `xParent`: The parent of the first value `x`.\n * - `yParent`: The parent of the second value `y`.\n * - `stack`: An internal stack (Map) to handle circular references.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @param {(x: any, y: any, property?: PropertyKey, xParent?: any, yParent?: any, stack?: Map<any, any>) => boolean | void} [areValuesEqual=noop] - A function to customize the comparison.\n *   If it returns a boolean, that result will be used. If it returns undefined,\n *   the default equality comparison will be used.\n * @returns {boolean} `true` if the values are equal according to the customizer, otherwise `false`.\n *\n * @example\n * const customizer = (a, b) => {\n *   if (typeof a === 'string' && typeof b === 'string') {\n *     return a.toLowerCase() === b.toLowerCase();\n *   }\n * };\n * isEqualWith('Hello', 'hello', customizer); // true\n * isEqualWith({ a: 'Hello' }, { a: 'hello' }, customizer); // true\n * isEqualWith([1, 2, 3], [1, 2, 3], customizer); // true\n */\nexport function isEqualWith(\n  a: any,\n  b: any,\n  areValuesEqual: (\n    a: any,\n    b: any,\n    property?: PropertyKey,\n    aParent?: any,\n    bParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void = noop\n): boolean {\n  if (typeof areValuesEqual !== 'function') {\n    areValuesEqual = noop;\n  }\n\n  return isEqualWithToolkit(a, b, (...args): boolean | void => {\n    const result = areValuesEqual(...args);\n\n    if (result !== undefined) {\n      return Boolean(result);\n    }\n\n    if (a instanceof Map && b instanceof Map) {\n      return isEqualWith(\n        Array.from(a),\n        Array.from(b),\n        // areValuesEqual should not be called for converted values\n        after(2, areValuesEqual)\n      );\n    }\n\n    if (a instanceof Set && b instanceof Set) {\n      return isEqualWith(\n        Array.from(a),\n        Array.from(b),\n        // areValuesEqual should not be called for converted values\n        after(2, areValuesEqual)\n      );\n    }\n  });\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if `value` is an Error object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is Error} Returns `true` if `value` is an Error object, `false` otherwise.\n *\n * @example\n * ```typescript\n * console.log(isError(new Error())); // true\n * console.log(isError('Error')); // false\n * console.log(isError({ name: 'Error', message: '' })); // false\n * ```\n */\nexport function isError(value?: unknown): value is Error {\n  return getTag(value) === '[object Error]';\n}\n","import { isBlob } from './isBlob.ts';\n\n/**\n * Checks if the given value is a File.\n *\n * This function tests whether the provided value is an instance of `File`.\n * It returns `true` if the value is an instance of `File`, and `false` otherwise.\n *\n * @param {unknown} x - The value to test if it is a File.\n * @returns {x is File} True if the value is a File, false otherwise.\n *\n * @example\n * const value1 = new File([\"content\"], \"example.txt\");\n * const value2 = {};\n * const value3 = new Blob([\"content\"], { type: \"text/plain\" });\n *\n * console.log(isFile(value1)); // true\n * console.log(isFile(value2)); // false\n * console.log(isFile(value3)); // false\n */\nexport function isFile(x: unknown): x is File {\n  // Return false if File is not supported in the environment\n  if (typeof File === 'undefined') {\n    return false;\n  }\n\n  return isBlob(x) && x instanceof File;\n}\n","/**\n * Checks if `value` is a finite number.\n *\n * @param {unknown} value The value to check.\n * @returns {value is number} Returns `true` if `value` is a finite number, `false` otherwise.\n *\n * @example\n * ```typescript\n * const value1 = 100;\n * const value2 = Infinity;\n * const value3 = '100';\n *\n * console.log(isFinite(value1)); // true\n * console.log(isFinite(value2)); // false\n * console.log(isFinite(value3)); // false\n * ```\n */\nexport function isFinite(value?: unknown): value is number {\n  return Number.isFinite(value);\n}\n","/**\n * Checks if `value` is a function.\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n *\n * @example\n * isFunction(Array.prototype.slice); // true\n * isFunction(async function () {}); // true\n * isFunction(function* () {}); // true\n * isFunction(Proxy); // true\n * isFunction(Int8Array); // true\n */\nexport function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n  return typeof value === 'function';\n}\n","/**\n * Checks if `value` is an integer.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {unknown} value - The value to check\n * @returns {boolean} `true` if `value` is integer, otherwise `false`.\n *\n * @example\n * isInteger(3); // Returns: true\n * isInteger(Infinity); // Returns: false\n * isInteger('3'); // Returns: false\n * isInteger([]); // Returns: false\n */\nexport function isInteger(value?: unknown): value is number {\n  return Number.isInteger(value);\n}\n","/**\n * Checks if a given value is a valid JSON string.\n *\n * A valid JSON string is one that can be successfully parsed using `JSON.parse()`. According to JSON\n * specifications, valid JSON can represent:\n * - Objects (with string keys and valid JSON values)\n * - Arrays (containing valid JSON values)\n * - Strings\n * - Numbers\n * - Booleans\n * - null\n *\n * String values like `\"null\"`, `\"true\"`, `\"false\"`, and numeric strings (e.g., `\"42\"`) are considered\n * valid JSON and will return true.\n *\n * This function serves as a type guard in TypeScript, narrowing the type of the argument to `string`.\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid JSON string, else `false`.\n *\n * @example\n * isJSON('{\"name\":\"John\",\"age\":30}'); // true\n * isJSON('[1,2,3]'); // true\n * isJSON('true'); // true\n * isJSON('invalid json'); // false\n * isJSON({ name: 'John' }); // false (not a string)\n * isJSON(null); // false (not a string)\n */\nexport function isJSON(value: unknown): value is string {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  try {\n    JSON.parse(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Checks if the given value is not null nor undefined.\n *\n * The main use of this function is to be used with TypeScript as a type predicate.\n *\n * @template T - The type of value.\n * @param {T | null | undefined} x - The value to test if it is not null nor undefined.\n * @returns {x is T} True if the value is not null nor undefined, false otherwise.\n *\n * @example\n * // Here the type of `arr` is (number | undefined)[]\n * const arr = [1, undefined, 3];\n * // Here the type of `result` is number[]\n * const result = arr.filter(isNotNil);\n * // result will be [1, 3]\n */\nexport function isNotNil<T>(x: T | null | undefined): x is T {\n  return x != null;\n}\n","/**\n * Checks if a given value is `Promise`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Promise`.\n *\n * @param {unknown} value The value to check if it is a `Promise`.\n * @returns {value is Promise<any>} Returns `true` if `value` is a `Promise`, else `false`.\n *\n * @example\n * const value1 = new Promise((resolve) => resolve());\n * const value2 = {};\n * const value3 = 123;\n *\n * console.log(isPromise(value1)); // true\n * console.log(isPromise(value2)); // false\n * console.log(isPromise(value3)); // false\n */\nexport function isPromise(value: unknown): value is Promise<any> {\n  return value instanceof Promise;\n}\n","import { isRegExp as isRegExpToolkit } from '../../predicate/isRegExp.ts';\n\n/**\n * Checks if `value` is a RegExp.\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a RegExp, `false` otherwise.\n *\n * @example\n * const value1 = /abc/;\n * const value2 = '/abc/';\n *\n * console.log(isRegExp(value1)); // true\n * console.log(isRegExp(value2)); // false\n */\nexport function isRegExp(value?: unknown): value is RegExp {\n  return isRegExpToolkit(value);\n}\n","/**\n * Checks if `value` is a RegExp.\n *\n * @param {unknown} value The value to check.\n * @returns {value is RegExp} Returns `true` if `value` is a RegExp, `false` otherwise.\n *\n * @example\n * const value1 = /abc/;\n * const value2 = '/abc/';\n *\n * console.log(isRegExp(value1)); // true\n * console.log(isRegExp(value2)); // false\n */\nexport function isRegExp(value: unknown): value is RegExp {\n  return value instanceof RegExp;\n}\n","/**\n * Checks if `value` is a safe integer (between -(2^53  1) and (2^53  1), inclusive).\n *\n * A safe integer is an integer that can be precisely represented as a `number` in JavaScript,\n * without any other integer being rounded to it.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {unknown} value - The value to check\n * @returns {boolean} `true` if `value` is an integer and between the safe values, otherwise `false`\n *\n * @example\n * isSafeInteger(3); // Returns: true\n * isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // Returns: false\n * isSafeInteger(1n); // Returns: false\n * isSafeInteger('1'); // Returns: false\n */\nexport function isSafeInteger(value?: unknown): value is number {\n  return Number.isSafeInteger(value);\n}\n","import { isSet as isSetToolkit } from '../../predicate/isSet.ts';\n\n/**\n * Checks if a given value is `Set`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Set`.\n *\n * @param {unknown} value The value to check if it is a `Set`.\n * @returns {value is Set<any>} Returns `true` if `value` is a `Set`, else `false`.\n *\n * @example\n * const value1 = new Set();\n * const value2 = new Map();\n * const value3 = new WeakSet();\n *\n * console.log(isSet(value1)); // true\n * console.log(isSet(value2)); // false\n * console.log(isSet(value3)); // false\n */\n\nexport function isSet(value?: unknown): value is Set<any> {\n  return isSetToolkit(value);\n}\n","/**\n * Checks if a given value is `Set`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Set`.\n *\n * @param {unknown} value The value to check if it is a `Set`.\n * @returns {value is Set<any>} Returns `true` if `value` is a `Set`, else `false`.\n *\n * @example\n * const value1 = new Set();\n * const value2 = new Map();\n * const value3 = new WeakSet();\n *\n * console.log(isSet(value1)); // true\n * console.log(isSet(value2)); // false\n * console.log(isSet(value3)); // false\n */\n\nexport function isSet(value: unknown): value is Set<any> {\n  return value instanceof Set;\n}\n","import { difference } from '../array/difference.ts';\n\n/**\n * Checks if the `subset` array is entirely contained within the `superset` array.\n *\n *\n * @template T - The type of elements contained in the arrays.\n * @param {T[]} superset - The array that may contain all elements of the subset.\n * @param {T[]} subset - The array to check against the superset.\n * @returns {boolean} - Returns `true` if all elements of the `subset` are present in the `superset`, otherwise returns `false`.\n *\n * @example\n * ```typescript\n * const superset = [1, 2, 3, 4, 5];\n * const subset = [2, 3, 4];\n * isSubset(superset, subset); // true\n * ```\n *\n * @example\n * ```typescript\n * const superset = ['a', 'b', 'c'];\n * const subset = ['a', 'd'];\n * isSubset(superset, subset); // false\n * ```\n */\n\nexport function isSubset<T>(superset: readonly T[], subset: readonly T[]): boolean {\n  return difference(subset, superset).length === 0;\n}\n","import { differenceWith } from './differenceWith.ts';\n\n/**\n * Checks if the `subset` array is entirely contained within the `superset` array based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a boolean indicating\n * whether all elements in the subset array are present in the superset array, as determined by the provided\n * custom equality function.\n *\n * @template T - The type of elements contained in the arrays.\n * @param {T[]} superset - The array that may contain all elements of the subset.\n * @param {T[]} subset - The array to check against the superset.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {boolean} - Returns `true` if all elements of the subset are present in the superset\n * according to the custom equality function, otherwise returns `false`.\n *\n * @example\n * ```typescript\n * const superset = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const subset = [{ id: 2 }, { id: 1 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * isSubsetWith(superset, subset, areItemsEqual); // true\n * ```\n *\n * @example\n * ```typescript\n * const superset = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const subset = [{ id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * isSubsetWith(superset, subset, areItemsEqual); // false\n * ```\n */\nexport function isSubsetWith<T>(\n  superset: readonly T[],\n  subset: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): boolean {\n  return differenceWith(subset, superset, areItemsEqual).length === 0;\n}\n","import { isWeakMap as isWeakMapToolkit } from '../../predicate/isWeakMap.ts';\n\n/**\n * Checks if the given value is a `WeakMap`.\n *\n * This function tests whether the provided value is an instance of `WeakMap`.\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\n *\n * @param {unknown} value - The value to test if it is a `WeakMap`.\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\n *\n * @example\n * const value1 = new WeakMap();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakMap(value1)); // true\n * console.log(isWeakMap(value2)); // false\n * console.log(isWeakMap(value3)); // false\n */\nexport function isWeakMap(value?: unknown): value is WeakMap<WeakKey, any> {\n  return isWeakMapToolkit(value);\n}\n","/**\n * Checks if the given value is a `WeakMap`.\n *\n * This function tests whether the provided value is an instance of `WeakMap`.\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\n *\n * @param {unknown} value - The value to test if it is a `WeakMap`.\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\n *\n * @example\n * const value1 = new WeakMap();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakMap(value1)); // true\n * console.log(isWeakMap(value2)); // false\n * console.log(isWeakMap(value3)); // false\n */\nexport function isWeakMap(value: unknown): value is WeakMap<WeakKey, any> {\n  return value instanceof WeakMap;\n}\n","import { isWeakSet as isWeakSetToolkit } from '../../predicate/isWeakSet.ts';\n\n/**\n * Checks if the given value is a `WeakSet`.\n *\n * This function tests whether the provided value is an instance of `WeakSet`.\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\n *\n * @param {unknown} value - The value to test if it is a `WeakSet`.\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\n *\n * @example\n * const value1 = new WeakSet();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakSet(value1)); // true\n * console.log(isWeakSet(value2)); // false\n * console.log(isWeakSet(value3)); // false\n */\nexport function isWeakSet(value?: unknown): value is WeakSet<WeakKey> {\n  return isWeakSetToolkit(value);\n}\n","/**\n * Checks if the given value is a `WeakSet`.\n *\n * This function tests whether the provided value is an instance of `WeakSet`.\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\n *\n * @param {unknown} value - The value to test if it is a `WeakSet`.\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\n *\n * @example\n * const value1 = new WeakSet();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakSet(value1)); // true\n * console.log(isWeakSet(value2)); // false\n * console.log(isWeakSet(value3)); // false\n */\nexport function isWeakSet(value: unknown): value is WeakSet<WeakKey> {\n  return value instanceof WeakSet;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Joins elements of an array into a string.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to join.\n * @param {string} separator - The separator used to join the elements, default is common separator `,`.\n * @returns {string} - Returns a string containing all elements of the array joined by the specified separator.\n *\n * @example\n * const arr = [\"a\", \"b\", \"c\"];\n * const result = join(arr, \"~\");\n * console.log(result); // Output: \"a~b~c\"\n */\nexport function join<T>(array: ArrayLike<T> | null | undefined, separator = ','): string {\n  if (!isArrayLike(array)) {\n    return '';\n  }\n  return Array.from(array).join(separator);\n}\n","import { kebabCase as kebabCaseToolkit } from '../../string/kebabCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to kebab case.\n *\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\n *\n * @param {string | object} str - The string that is to be changed to kebab case.\n * @returns {string} - The converted string to kebab case.\n *\n * @example\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\n */\nexport function kebabCase(str?: string | object): string {\n  return kebabCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to kebab case.\n *\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\n *\n * @param {string} str - The string that is to be changed to kebab case.\n * @returns {string} - The converted string to kebab case.\n *\n * @example\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\n */\n\nexport function kebabCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('-');\n}\n","/**\n * Maps each element of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are the corresponding elements.\n * If there are multiple elements generating the same key, the last element among them is used\n * as the value.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array of elements to be mapped.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T>} An object where keys are mapped to each element of an array.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = keyBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: { category: 'fruit', name: 'banana' },\n * //   vegetable: { category: 'vegetable', name: 'carrot' }\n * // }\n */\nexport function keyBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T> {\n  const result = {} as Record<K, T>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = getKeyFromItem(item);\n    result[key] = item;\n  }\n\n  return result;\n}\n","import { isBuffer } from '../../predicate/isBuffer.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { times } from '../util/times.ts';\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * Non-object values are coerced to objects.\n *\n * @param {object} object The object to query.\n * @returns {string[]} Returns the array of property names.\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n * Foo.prototype.c = 3;\n * keys(new Foo); // ['a', 'b'] (iteration order is not guaranteed)\n *\n * keys('hi'); // ['0', '1']\n * keys([1, 2, 3]); // ['0', '1', '2']\n * keys({ a: 1, b: 2 }); // ['a', 'b']\n */\nexport function keys(object?: any): string[] {\n  if (isArrayLike(object)) {\n    return arrayLikeKeys(object);\n  }\n\n  const result = Object.keys(Object(object));\n\n  if (!isPrototype(object)) {\n    return result;\n  }\n\n  return result.filter(key => key !== 'constructor');\n}\n\nfunction arrayLikeKeys(object: ArrayLike<any>): string[] {\n  const indices = times(object.length, index => `${index}`);\n\n  const filteredKeys = new Set(indices);\n\n  if (isBuffer(object)) {\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    filteredKeys.add('offset');\n    filteredKeys.add('parent');\n  }\n\n  if (isTypedArray(object)) {\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    filteredKeys.add('buffer');\n    filteredKeys.add('byteLength');\n    filteredKeys.add('byteOffset');\n  }\n\n  return [...indices, ...Object.keys(object).filter(key => !filteredKeys.has(key))];\n}\n","import { isArrayLike } from '../predicate/isArrayLike';\n\n/**\n * Finds the index of the last occurrence of a value in an array.\n *\n * This method is similar to `Array.prototype.lastIndexOf`, but it also finds `NaN` values.\n * It uses strict equality (`===`) to compare elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to search.\n * @param {T} searchElement - The value to search for.\n * @param {number} [fromIndex] - The index to start the search at.\n * @returns {number} The index (zero-based) of the last occurrence of the value in the array, or `-1` if the value is not found.\n *\n * @example\n * const array = [1, 2, 3, NaN, 1];\n * lastIndexOf(array, 3); // => 4\n * lastIndexOf(array, NaN); // => 3\n */\nexport function lastIndexOf<T>(array: ArrayLike<T> | null | undefined, searchElement: T, fromIndex?: number): number {\n  if (!isArrayLike(array) || array.length === 0) {\n    return -1;\n  }\n\n  const length = array.length;\n\n  let index = fromIndex ?? length - 1;\n  if (fromIndex != null) {\n    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n\n  // `Array.prototype.lastIndexOf` doesn't find `NaN` values, so we need to handle that case separately.\n  if (Number.isNaN(searchElement)) {\n    for (let i = index; i >= 0; i--) {\n      if (Number.isNaN(array[i])) {\n        return i;\n      }\n    }\n  }\n\n  return Array.from(array).lastIndexOf(searchElement, index);\n}\n","import { lowerCase as lowerCaseToolkit } from '../../string/lowerCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to lower case.\n *\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\n *\n * @param {string | object} str - The string that is to be changed to lower case.\n * @returns {string} - The converted string to lower case.\n *\n * @example\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\n */\nexport function lowerCase(str?: string | object): string {\n  return lowerCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to lower case.\n *\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\n *\n * @param {string} str - The string that is to be changed to lower case.\n * @returns {string} - The converted string to lower case.\n *\n * @example\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\n */\nexport function lowerCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join(' ');\n}\n","import { lowerFirst as lowerFirstToolkit } from '../../string/lowerFirst.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the first character of string to lower case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\n */\nexport function lowerFirst(str?: string): string {\n  return lowerFirstToolkit(toString(str));\n}\n","/**\n * Converts the first character of string to lower case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\n */\nexport function lowerFirst(str: string): string {\n  return str.substring(0, 1).toLowerCase() + str.substring(1);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is less than other.\n *\n * @param {unknown} value The value to compare.\n * @param {unknown} other The other value to compare.\n * @returns {boolean} Returns `true` if value is less than other, else `false`.\n *\n * @example\n * lt(1, 3); // true\n * lt(3, 3); // false\n * lt(3, 1); // false\n */\nexport function lt(value: unknown, other: unknown): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value < other;\n  }\n\n  return toNumber(value) < toNumber(other);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is less than or equal to other.\n *\n * @param {unknown} value The value to compare.\n * @param {unknown} other The other value to compare.\n * @returns {boolean} Returns `true` if value is less than or equal to other, else `false`.\n *\n * @example\n * lte(1, 3); // => true\n * lte(3, 3); // => true\n * lte(3, 1); // => false\n */\nexport function lte(value: unknown, other: unknown): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value <= other;\n  }\n\n  return toNumber(value) <= toNumber(other);\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Maps each element in a readonly array to a new array of values using an iteratee function.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {(value: T, index: number, collection: readonly T[]) => U} iteratee - The function invoked per iteration.\n * @returns {U[]} - Returns the new mapped array.\n *\n * @example\n * const array = [1, 2, 3];\n * map(array, value => value * 2); // => [2, 4, 6]\n */\nexport function map<T, U>(\n  collection: readonly T[],\n  iteratee: (value: T, index: number, collection: readonly T[]) => U\n): U[];\n\n/**\n * Maps each element in a readonly array to a boolean array based on a partial object match.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {Partial<T>} iteratee - The partial object to match against each element.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(objects, { a: 1 }); // => [true, false, false]\n */\nexport function map<T>(collection: readonly T[], iteratee: Partial<T>): boolean[];\n\n/**\n * Maps each element in a readonly array to a boolean array based on a property-value pair match.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {[keyof T, unknown]} iteratee - The property-value pair to match against each element.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(objects, ['a', 1]); // => [true, false, false]\n */\nexport function map<T>(collection: readonly T[], iteratee: [keyof T, unknown]): boolean[];\n\n/**\n * Maps each element in a readonly array to an array of property values.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {K} iteratee - The key of the property to extract from each element.\n * @returns {Array<T[K]>} - Returns an array of property values.\n *\n * @example\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(objects, 'a'); // => [1, 2, 3]\n */\nexport function map<T, K extends keyof T>(collection: readonly T[], iteratee: K): Array<T[K]>;\n\n/**\n * Maps each element in a readonly array to itself if no iteratee is provided.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {null | undefined} [iteratee] - Optional iteratee.\n * @returns {T[]} - Returns the original array.\n *\n * @example\n * const numbers = [1, 2, 3];\n * map(numbers); // => [1, 2, 3]\n */\nexport function map<T>(collection: readonly T[], iteratee?: null | undefined): T[];\n\n/**\n * Maps each element in an ArrayLike object to a new array of values using an iteratee function.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {(value: T, index: number, collection: ArrayLike<T>) => U} iteratee - The function invoked per iteration.\n * @returns {U[]} - Returns the new mapped array.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * map(arrayLike, value => value * 2); // => [2, 4, 6]\n */\nexport function map<T, U>(\n  collection: ArrayLike<T>,\n  iteratee: (value: T, index: number, collection: ArrayLike<T>) => U\n): U[];\n\n/**\n * Maps each element in an ArrayLike object to a boolean array based on a partial object match.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {Partial<T>} iteratee - The partial object to match against each element.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const arrayLike = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(arrayLike, { a: 1 }); // => [true, false, false]\n */\nexport function map<T>(collection: ArrayLike<T>, iteratee: Partial<T>): boolean[];\n\n/**\n * Maps each element in an ArrayLike object to a boolean array based on a property-value pair match.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {[keyof T, unknown]} iteratee - The property-value pair to match against each element.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const arrayLike = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(arrayLike, ['a', 1]); // => [true, false, false]\n */\nexport function map<T>(collection: ArrayLike<T>, iteratee: [keyof T, unknown]): boolean[];\n\n/**\n * Maps each element in an ArrayLike object to an array of property values.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {K} iteratee - The key of the property to extract from each element.\n * @returns {Array<T[K]>} - Returns an array of property values.\n *\n * @example\n * const arrayLike = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(arrayLike, 'a'); // => [1, 2, 3]\n */\nexport function map<T, K extends keyof T>(collection: ArrayLike<T>, iteratee: K): Array<T[K]>;\n\n/**\n * Maps each element in an ArrayLike object to itself if no iteratee is provided.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {null | undefined} [iteratee] - Optional iteratee.\n * @returns {ArrayLike<T>} - Returns the original ArrayLike object.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * map(arrayLike); // => {0: 1, 1: 2, 2: 3, length: 3}\n */\nexport function map<T, U>(collection: ArrayLike<T>, iteratee?: null | undefined): ArrayLike<T>;\n\n/**\n * Maps each value in an object to a new array of values using an iteratee function.\n *\n * @param {T} collection - The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => U} iteratee - The function invoked per iteration.\n * @returns {U[]} - Returns the new mapped array.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * map(obj, (value, key) => `${key}: ${value}`); // => ['a: 1', 'b: 2', 'c: 3']\n */\nexport function map<T extends object, U>(\n  collection: T,\n  iteratee: (value: T[keyof T], key: string, collection: T) => U\n): U[];\n\n/**\n * Maps each value in an object to a boolean array based on a partial object match.\n *\n * @param {T} object - The object to iterate over.\n * @param {Partial<T[keyof T]>} iteratee - The partial object to match against each value.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const obj = { a: { x: 1 }, b: { x: 2 }, c: { x: 3 } };\n * map(obj, { x: 1 }); // => [true, false, false]\n */\nexport function map<T>(object: T, iteratee: Partial<T[keyof T]>): boolean[];\n\n/**\n * Maps each value in an object to a boolean array based on a property-value pair match.\n *\n * @param {T} object - The object to iterate over.\n * @param {[keyof T[keyof T], unknown]} iteratee - The property-value pair to match against each value.\n * @returns {boolean[]} - Returns an array of booleans indicating matches.\n *\n * @example\n * const obj = { a: { x: 1 }, b: { x: 2 }, c: { x: 3 } };\n * map(obj, ['x', 1]); // => [true, false, false]\n */\nexport function map<T>(object: T, iteratee: [keyof T[keyof T], unknown]): boolean[];\n\n/**\n * Maps each value in an object to an array of property values.\n *\n * @param {T} object - The object to iterate over.\n * @param {K} iteratee - The key of the property to extract from each value.\n * @returns {Array<T[keyof T][K]>} - Returns an array of property values.\n *\n * @example\n * const obj = { a: { x: 1 }, b: { x: 2 }, c: { x: 3 } };\n * map(obj, 'x'); // => [1, 2, 3]\n */\nexport function map<T, K extends keyof T[keyof T]>(object: T, iteratee: K): Array<T[keyof T][K]>;\n\n/**\n * Maps each value in an object to itself if no iteratee is provided.\n *\n * @param {T} object - The object to iterate over.\n * @param {null | undefined} [iteratee] - Optional iteratee.\n * @returns {U[]} - Returns the original object values as an array.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * map(obj); // => [1, 2, 3]\n */\nexport function map<T extends object, U>(object: T, iteratee?: null | undefined): U[];\n\n/**\n * Maps each element in a collection to a new array of values using an iteratee.\n *\n * @param {T[] | ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {((value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object} iteratee - The function invoked per iteration or the key to map over.\n * @returns {any[]} - Returns the new mapped array.\n *\n * @example\n * // Using a transformation function\n * const array = [1, 2, 3];\n * map(array, value => value * 2); // => [2, 4, 6]\n *\n * @example\n * // Using a property key as the iteratee\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(objects, 'a'); // => [1, 2, 3]\n *\n * @example\n * // Using an object as the iteratee\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * map(objects, { a: 1 }); // => [true, false, false]\n *\n * @example\n * // No iteratee\n * const numbers = [1, 2, 3];\n * map(numbers); // => [1, 2, 3]\n *\n * @example\n * // Using an object as the collection\n * const obj = { a: 1, b: 2, c: 3 };\n * map(obj, (value, key) => `${key}: ${value}`); // => ['a: 1', 'b: 2', 'c: 3']\n */\nexport function map(\n  collection: any[] | ArrayLike<any> | Record<any, any> | null | undefined,\n  _iteratee?: ((value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object | null\n): any[] {\n  if (!collection) {\n    return [];\n  }\n\n  const keys: PropertyKey[] =\n    isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  const iteratee = iterateeToolkit(_iteratee ?? identity);\n\n  const result: any[] = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    result[i] = iteratee(value, key, collection);\n  }\n\n  return result;\n}\n","import { property } from './property.ts';\nimport { identity } from '../../function/identity.ts';\nimport { mapKeys as mapKeysToolkit } from '../../object/mapKeys.ts';\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n *\n * @param {T} object - The object to iterate over.\n * @param {PropertyKey | PropertyKey[]} getNewKey - The path of the property to get to generate the new keys.\n * @returns {Record<PropertyKey, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object>(\n  object: T,\n  getNewKey?: PropertyKey | readonly PropertyKey[]\n): Record<PropertyKey, T[keyof T]>;\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n * @template K2 - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\n  object: T,\n  getNewKey?: (value: T[K1], key: K1, object: T) => K2\n): Record<K2, T[K1]>;\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n * @template K2 - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K1], key: K1, object: T) => K2} [getNewKey] - The function invoked per own enumerable property, or a path to generate new keys.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object, K extends PropertyKey>(\n  object: T,\n  getNewKey?: PropertyKey | readonly PropertyKey[] | ((value: T[keyof T], key: keyof T, object: T) => K)\n): Record<K, T[keyof T]> {\n  getNewKey = getNewKey ?? (identity as (value: T[keyof T], key: keyof T, object: T) => K);\n\n  switch (typeof getNewKey) {\n    case 'string':\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      return mapKeysToolkit(object, property(getNewKey));\n    }\n    case 'function': {\n      return mapKeysToolkit(object, getNewKey);\n    }\n  }\n}\n","import { property } from './property.ts';\nimport { identity } from '../../function/identity.ts';\nimport { mapValues as mapValuesToolkit } from '../../object/mapValues.ts';\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined\n): Record<K, V>;\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V>;\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V | PropertyKey | readonly PropertyKey[] | null | undefined} [getNewValue] -\n *        The function invoked per own enumerable property, or a path to generate new values.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined | ((value: T[K], key: K, object: T) => V)\n): Record<K, V> {\n  getNewValue = getNewValue ?? (identity as (value: T[K], key: K, object: T) => V);\n\n  switch (typeof getNewValue) {\n    case 'string':\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      return mapValuesToolkit(object, property(getNewValue));\n    }\n    case 'function': {\n      return mapValuesToolkit(object, getNewValue);\n    }\n  }\n}\n","/**\n * Finds the element in an array that has the maximum value.\n *\n * @param {[T, ...T[]]} items - The array of elements to search.\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\n * @example\n * // Returns 9\n * max([3, 1, 4, 1, 5, 9]);\n *\n * @example\n * // Returns 8\n * max([0, -3, 2, 8, 7]);\n */\nexport function max<T>(items: readonly [T, ...T[]]): T;\n/**\n * Finds the element in an array that has the maximum value.\n * Returns undefined when no arguments are provided.\n * @returns {undefined}\n */\nexport function max(): undefined;\n/**\n * Finds the element in an array that has the maximum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\n */\nexport function max<T>(items?: readonly T[]): T | undefined;\n/**\n * Finds the element in an array that has the maximum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\n */\nexport function max<T>(items: readonly T[] = []): T | undefined {\n  let maxElement = items[0];\n  let max: any = undefined;\n\n  for (let i = 0; i < items.length; i++) {\n    const element = items[i];\n    if (max == null || element > max) {\n      max = element;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","import { maxBy as maxByToolkit } from '../../array/maxBy.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `iteratee` to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {((element: T) => number) | keyof T | [keyof T, unknown] | Partial<T>} iteratee\n * The criteria used to determine the maximum value.\n *  - If a **function** is provided, it extracts a numeric value from each element.\n *  - If a **string** is provided, it is treated as a key to extract values from the objects.\n *  - If a **[key, value]** pair is provided, it matches elements with the specified key-value pair.\n *  - If an **object** is provided, it matches elements that contain the specified properties.\n * @returns {T | undefined} The element with the maximum value as determined by the `iteratee`.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n * maxBy([{ a: 1 }, { a: 2 }], 'a'); // Returns: { a: 2 }\n * maxBy([{ a: 1 }, { a: 2 }], ['a', 1]); // Returns: { a: 1 }\n * maxBy([{ a: 1 }, { a: 2 }], { a: 1 }); // Returns: { a: 1 }\n */\nexport function maxBy<T>(\n  items: ArrayLike<T> | null | undefined,\n  iteratee: ((element: T) => number) | keyof T | [keyof T, unknown] | Partial<T>\n): T | undefined {\n  if (items == null) {\n    return undefined;\n  }\n\n  return maxByToolkit(Array.from(items), iterateeToolkit(iteratee));\n}\n","/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T {\n  let maxElement = items[0];\n  let max = -Infinity;\n\n  for (let i = 0; i < items.length; i++) {\n    const element = items[i];\n    const value = getValue(element);\n    if (value > max) {\n      max = value;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","import { mean } from './mean.ts';\n\n/**\n * Calculates the average of an array of numbers when applying\n * the `getValue` function to each element.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\n *\n * @example\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\n * meanBy([], x => x.a); // Returns: NaN\n */\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return mean(nums);\n}\n","import { median } from './median.ts';\n\n/**\n * Calculates the median of an array of elements when applying\n * the `getValue` function to each element.\n *\n * The median is the middle value of a sorted array.\n * If the array has an odd number of elements, the median is the middle value.\n * If the array has an even number of elements, it returns the average of the two middle values.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the median.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The median of all the numbers as determined by the `getValue` function.\n *\n * @example\n * medianBy([{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }], x => x.a); // Returns: 3\n * medianBy([{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }], x => x.a); // Returns: 2.5\n * medianBy([], x => x.a); // Returns: NaN\n */\nexport function medianBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return median(nums);\n}\n","/**\n * Creates a memoized version of the provided function. The memoized function caches\n * results based on the argument it receives, so if the same argument is passed again,\n * it returns the cached result instead of recomputing it.\n *\n * This function works with functions that take zero or just one argument. If your function\n * originally takes multiple arguments, you should refactor it to take a single object or array\n * that combines those arguments.\n *\n * If the argument is not primitive (e.g., arrays or objects), provide a\n * `getCacheKey` function to generate a unique cache key for proper caching.\n *\n * @template F - The type of the function to be memoized.\n * @param {F} fn - The function to be memoized. It should accept a single argument and return a value.\n * @param {MemoizeOptions<Parameters<F>[0], ReturnType<F>>} [options={}] - Optional configuration for the memoization.\n * @param {MemoizeCache<any, V>} [options.cache] - The cache object used to store results. Defaults to a new `Map`.\n * @param {(args: A) => unknown} [options.getCacheKey] - An optional function to generate a unique cache key for each argument.\n *\n * @returns The memoized function with an additional `cache` property that exposes the internal cache.\n *\n * @example\n * // Example using the default cache\n * const add = (x: number) => x + 10;\n * const memoizedAdd = memoize(add);\n *\n * console.log(memoizedAdd(5)); // 15\n * console.log(memoizedAdd(5)); // 15 (cached result)\n * console.log(memoizedAdd.cache.size); // 1\n *\n * @example\n * // Example using a custom resolver\n * const sum = (arr: number[]) => arr.reduce((x, y) => x + y, 0);\n * const memoizedSum = memoize(sum, { getCacheKey: (arr: number[]) => arr.join(',') });\n * console.log(memoizedSum([1, 2])); // 3\n * console.log(memoizedSum([1, 2])); // 3 (cached result)\n * console.log(memoizedSum.cache.size); // 1\n *\n * @example\n * // Example using a custom cache implementation\n * class CustomCache<K, T> implements MemoizeCache<K, T> {\n *   private cache = new Map<K, T>();\n *\n *   set(key: K, value: T): void {\n *     this.cache.set(key, value);\n *   }\n *\n *   get(key: K): T | undefined {\n *     return this.cache.get(key);\n *   }\n *\n *   has(key: K): boolean {\n *     return this.cache.has(key);\n *   }\n *\n *   delete(key: K): boolean {\n *     return this.cache.delete(key);\n *   }\n *\n *   clear(): void {\n *     this.cache.clear();\n *   }\n *\n *   get size(): number {\n *     return this.cache.size;\n *   }\n * }\n * const customCache = new CustomCache<string, number>();\n * const memoizedSumWithCustomCache = memoize(sum, { cache: customCache });\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3 (cached result)\n * console.log(memoizedAddWithCustomCache.cache.size); // 1\n */\nexport function memoize<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    cache?: MemoizeCache<any, ReturnType<F>>;\n    getCacheKey?: (args: Parameters<F>[0]) => unknown;\n  } = {}\n): F & { cache: MemoizeCache<any, ReturnType<F>> } {\n  const { cache = new Map<unknown, ReturnType<F>>(), getCacheKey } = options;\n\n  const memoizedFn = function (this: unknown, arg: Parameters<F>[0]): ReturnType<F> {\n    const key = getCacheKey ? getCacheKey(arg) : arg;\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = fn.call(this, arg);\n\n    cache.set(key, result);\n\n    return result;\n  };\n\n  memoizedFn.cache = cache;\n\n  return memoizedFn as F & { cache: MemoizeCache<any, ReturnType<F>> };\n}\n\n/**\n * Represents a cache for memoization, allowing storage and retrieval of computed values.\n *\n * @template K - The type of keys used to store values in the cache.\n * @template V - The type of values stored in the cache.\n */\nexport interface MemoizeCache<K, V> {\n  /**\n   * Stores a value in the cache with the specified key.\n   *\n   * @param key - The key to associate with the value.\n   * @param value - The value to store in the cache.\n   */\n  set(key: K, value: V): void;\n\n  /**\n   * Retrieves a value from the cache by its key.\n   *\n   * @param key - The key of the value to retrieve.\n   * @returns The value associated with the key, or undefined if the key does not exist.\n   */\n  get(key: K): V | undefined;\n\n  /**\n   * Checks if a value exists in the cache for the specified key.\n   *\n   * @param key - The key to check for existence in the cache.\n   * @returns True if the cache contains the key, false otherwise.\n   */\n  has(key: K): boolean;\n\n  /**\n   * Deletes a value from the cache by its key.\n   *\n   * @param key - The key of the value to delete.\n   * @returns True if the value was successfully deleted, false otherwise.\n   */\n  delete(key: K): boolean | void;\n\n  /**\n   * Clears all values from the cache.\n   */\n  clear(): void;\n\n  /**\n   * The number of entries in the cache.\n   */\n  size: number;\n}\n","import { mergeWith } from './mergeWith.ts';\nimport { noop } from '../../function/noop.ts';\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The first source object whose properties will be merged into the target object.\n * @returns {O & S} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S - Type of the first source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S>(object: O, source: S): O & S;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object to be merged into the target object.\n * @param {S2} source2 - The second source object to be merged into the target object.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n * @template S4 - Type of the fourth source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge(object: any, ...sources: any[]): any;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge(object: any, ...sources: any[]): any {\n  return mergeWith(object, ...sources, noop);\n}\n","import { invoke } from './invoke.ts';\n\n/**\n * Creates a function that invokes the method at `path` of a given object with the provided arguments.\n *\n * @param {PropertyKey | PropertyKey[]} path - The path of the method to invoke.\n * @param {...any} args - The arguments to invoke the method with.\n * @returns {(object?: unknown) => any} - Returns a new function that takes an object and invokes the method at `path` with `args`.\n *\n * @example\n * const object = {\n *   a: {\n *     b: function (x, y) {\n *       return x + y;\n *     }\n *   }\n * };\n *\n * const add = method('a.b', 1, 2);\n * console.log(add(object)); // => 3\n */\nexport function method(path: PropertyKey | PropertyKey[], ...args: any[]): (object?: unknown) => any {\n  return function (object?: unknown) {\n    return invoke(object, path, args);\n  };\n}\n","import { invoke } from './invoke.ts';\n\n/**\n * Creates a function that invokes the method at a given path of `object` with the provided arguments.\n *\n * @param {object} object - The object to query.\n * @param {...any} args - The arguments to invoke the method with.\n * @returns {(path: PropertyKey | PropertyKey[]) => any} - Returns a new function that takes a path and invokes the method at `path` with `args`.\n *\n * @example\n * const object = {\n *  a: {\n *   b: function (x, y) {\n *    return x + y;\n *    }\n *   }\n * };\n *\n * const add = methodOf(object, 1, 2);\n * console.log(add('a.b')); // => 3\n */\nexport function methodOf(object: object, ...args: any[]): (path: PropertyKey | PropertyKey[]) => any {\n  return function (path: PropertyKey | PropertyKey[]) {\n    return invoke(object, path, args);\n  };\n}\n","/**\n * Finds the element in an array that has the minimum value.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} items - The array of elements to search.\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\n * @example\n * // Returns 1\n * min([3, 1, 4, 1, 5, 9]);\n *\n * @example\n * // Returns -3\n * min([0, -3, 2, 8, 7]);\n */\nexport function min<T>(items: readonly [T, ...T[]]): T;\n\n/**\n * Finds the element in an array that has the minimum value.\n * Returns undefined when no arguments are provided.\n * @returns {undefined}\n */\nexport function min(): undefined;\n\n/**\n * Finds the element in an array that has the minimum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\n */\nexport function min<T>(items?: readonly T[]): T | undefined;\n\n/**\n * Finds the element in an array that has the minimum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T} - The element with the minimum value.\n */\nexport function min<T>(items: readonly T[] = []): T {\n  let minElement = items[0];\n  let min: any = undefined;\n\n  for (let i = 0; i < items.length; i++) {\n    const element = items[i];\n    if (min == null || element < min) {\n      min = element;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\n/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\n/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined {\n  let minElement = items[0];\n  let min = Infinity;\n\n  for (let i = 0; i < items.length; i++) {\n    const element = items[i];\n    const value = getValue(element);\n    if (value < min) {\n      min = value;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Multiply two numbers.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number in a multiplication\n * @param {number} other The second number in a multiplication\n * @returns {number} The product of value and other\n *\n * @example\n * multiply(2, 3); // => 6\n * multiply(2, NaN); // => NaN\n * multiply(NaN, 3); // => NaN\n * multiply(NaN, NaN); // => NaN\n */\n\nexport function multiply(value: number, other: number): number {\n  if (value === undefined && other === undefined) {\n    return 1;\n  }\n\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n\n  return value * other;\n}\n","/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template F - The type of the function to negate.\n * @param {F} func - The function to negate.\n * @returns {F} The new negated function, which negates the boolean result of `func`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5, 6];\n * const isEven = (n: number) => n % 2 === 0;\n * const result = array.filter(negate(isEven));\n * // result will be [1, 3, 5]\n */\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  return function (this: any, ...args: any[]) {\n    return !func.apply(this, args);\n  } as F;\n}\n","/**\n * Returns the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.\n *\n * @returns {number} The current time in milliseconds.\n *\n * @example\n * const currentTime = now();\n * console.log(currentTime); // Outputs the current time in milliseconds\n *\n * @example\n * const startTime = now();\n * // Some time-consuming operation\n * const endTime = now();\n * console.log(`Operation took ${endTime - startTime} milliseconds`);\n */\nexport function now(): number {\n  return Date.now();\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.\n *\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {number} [n=0] - The index of the element to return.\n * @return {T | undefined} Returns the nth element of `array`.\n *\n * @example\n * nth([1, 2, 3], 1); // => 2\n * nth([1, 2, 3], -1); // => 3\n */\nexport function nth<T>(array: ArrayLike<T> | null | undefined, n: number = 0): T | undefined {\n  if (!isArrayLikeObject(array) || array.length === 0) {\n    return undefined;\n  }\n\n  n = toInteger(n);\n\n  if (n < 0) {\n    n += array.length;\n  }\n\n  return array[n];\n}\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a function that retrieves the argument at the specified index `n`.\n *\n * If `n` is negative, the nth argument from the end is returned.\n *\n * @param {number} [n=0] - The index of the argument to retrieve.\n *   If negative, counts from the end of the arguments list.\n * @returns {(args: any[]) => unknown} A new function that returns the argument at the specified index.\n *\n * @example\n * const getSecondArg = nthArg(1);\n * const result = getSecondArg('a', 'b', 'c');\n * console.log(result); // => 'b'\n *\n * @example\n * const getLastArg = nthArg(-1);\n * const result = getLastArg('a', 'b', 'c');\n * console.log(result); // => 'c'\n */\nexport function nthArg(n = 0): (...args: any[]) => unknown {\n  return function (...args: any[]) {\n    return args.at(toInteger(n));\n  };\n}\n","import { unset } from './unset.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to omit keys from.\n * @param {K[]} keys - An array of keys to be omitted from the object.\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = omit(obj, ['b', 'c']);\n * // result will be { a: 1 }\n */\nexport function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Omit<T, K>;\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and a variable number of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys.\n *\n * Deep keys can be specified for keys.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit keys from.\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][])} keys - A variable number of keys to be omitted from the object.\n * @returns {Partial<T>} A new object with the specified keys omitted.\n */\nexport function omit<\n  // eslint-disable-next-line\n  T extends {},\n>(\n  obj: T | null | undefined,\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\n): Partial<T>;\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and a variable number of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys. Note that keys can be deep.\n *\n * Deep keys can be specified for keys.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit keys from.\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][])} keysArr - A variable number of keys to be omitted from the object.\n * @returns {Partial<T>} A new object with the specified keys omitted.\n */\nexport function omit<\n  // eslint-disable-next-line\n  T extends {},\n>(\n  obj: T | null | undefined,\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\n): Partial<T> {\n  if (obj == null) {\n    return {};\n  }\n\n  const result = cloneDeep(obj);\n\n  for (let i = 0; i < keysArr.length; i++) {\n    let keys = keysArr[i];\n\n    switch (typeof keys) {\n      case 'object': {\n        if (!Array.isArray(keys)) {\n          // eslint-disable-next-line\n          // @ts-ignore\n          keys = Array.from(keys) as PropertyKey[];\n        }\n\n        for (let j = 0; j < keys.length; j++) {\n          const key = keys[j];\n\n          unset(result, key);\n        }\n\n        break;\n      }\n      case 'string':\n      case 'symbol':\n      case 'number': {\n        unset(result, keys);\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n","/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns false.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit properties from.\n * @param {(value: T[string], key: keyof T) => boolean} shouldOmit - A predicate function that determines\n * whether a property should be omitted. It takes the property's key and value as arguments and returns `true`\n * if the property should be omitted, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that do not satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'omit', c: 3 };\n * const shouldOmit = (value) => typeof value === 'string';\n * const result = omitBy(obj, shouldOmit);\n * // result will be { a: 1, c: 3 }\n */\nexport function omitBy<T extends Record<string, any>>(\n  obj: T,\n  shouldOmit: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n\n  const keys = Object.keys(obj) as Array<keyof T>;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n\n    if (!shouldOmit(value, key)) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n","/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F extends () => any} func - The function to restrict.\n * @returns {F} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends () => any>(func: F): F;\n/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F extends (...args: any[]) => void} func - The function to restrict with arguments.\n * @returns {F} A new function that invokes `func` once.\n *\n * @example\n * const log = once(console.log);\n *\n * log('Hello, world!'); // prints 'Hello, world!' and doesn't return anything\n * log('Hello, world!'); // doesn't print anything and doesn't return anything\n */\nexport function once<F extends (...args: any[]) => void>(func: F): F;\n/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F} func - The function to restrict.\n * @returns {(...args: Parameters<F>) => ReturnType<F>} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends (() => any) | ((...args: any[]) => void)>(func: F): F {\n  let called = false;\n  let cache: ReturnType<F>;\n\n  return function (...args: Parameters<F>): ReturnType<F> {\n    if (!called) {\n      called = true;\n      cache = func(...args);\n    }\n\n    return cache;\n  } as F;\n}\n","import { pad as padToolkit } from '../../string/pad.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = pad('abc', 8);         // result will be '  abc   '\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\n * const result3 = pad('abc', 3);         // result will be 'abc'\n * const result4 = pad('abc', 2);         // result will be 'abc'\n *\n */\nexport function pad(str: string, length: number, chars = ' '): string {\n  return padToolkit(toString(str), length, chars);\n}\n","/**\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = pad('abc', 8);         // result will be '  abc   '\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\n * const result3 = pad('abc', 3);         // result will be 'abc'\n * const result4 = pad('abc', 2);         // result will be 'abc'\n *\n */\nexport function pad(str: string, length: number, chars = ' '): string {\n  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Pads the end of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padEnd('abc', 6);          // result will be 'abc   '\n * const result2 = padEnd('abc', 6, '_-');    // result will be 'abc_-_'\n * const result3 = padEnd('abc', 3);          // result will be 'abc'\n * const result4 = padEnd('abc', 2);          // result will be 'abc'\n */\n\nexport function padEnd(str: string, length = 0, chars = ' '): string {\n  return toString(str).padEnd(length, chars);\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Pads the start of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padStart('abc', 6);          // result will be '   abc'\n * const result2 = padStart('abc', 6, '_-');    // result will be '_-_abc'\n * const result3 = padStart('abc', 3);          // result will be 'abc'\n * const result4 = padStart('abc', 2);          // result will be 'abc'\n */\nexport function padStart(str: string, length = 0, chars = ' '): string {\n  return toString(str).padStart(length, chars);\n}\n","/**\n * Converts `string` to an integer of the specified radix. If `radix` is undefined or 0, a `radix` of 10 is used unless `string` is a hexadecimal, in which case a `radix` of 16 is used.\n *\n * @param {string} string The string to convert to an integer.\n * @param {number} radix The radix to use when converting the string to an integer. Defaults to `0`.\n * @param {unknown} guard Enables use as an iteratee for methods like `Array#map`.\n * @returns {number} Returns the converted integer.\n *\n * @example\n * parseInt('08'); // => 8\n * parseInt('0x20'); // => 32\n *\n * parseInt('08', 10); // => 8\n * parseInt('0x20', 16); // => 32\n *\n * ['6', '08', '10'].map(parseInt); // => [6, 8, 10]\n */\nexport function parseInt(string: string, radix = 0, guard?: unknown): number {\n  if (guard) {\n    radix = 0;\n  }\n  return Number.parseInt(string, radix);\n}\n","/**\n * Splits an array into two groups based on a predicate function.\n *\n * This function takes an array and a predicate function. It returns a tuple of two arrays:\n * the first array contains elements for which the predicate function returns true, and\n * the second array contains elements for which the predicate function returns false.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to partition.\n * @param {(value: T) => boolean} isInTruthy - A predicate function that determines\n * whether an element should be placed in the truthy array. The function is called with each\n * element of the array.\n * @returns {[T[], T[]]} A tuple containing two arrays: the first array contains elements for\n * which the predicate returned true, and the second array contains elements for which the\n * predicate returned false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const isEven = x => x % 2 === 0;\n * const [even, odd] = partition(array, isEven);\n * // even will be [2, 4], and odd will be [1, 3, 5]\n */\nexport function partition<T>(arr: readonly T[], isInTruthy: (value: T) => boolean): [truthy: T[], falsy: T[]] {\n  const truthy: T[] = [];\n  const falsy: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (isInTruthy(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item);\n    }\n  }\n\n  return [truthy, falsy];\n}\n","import { capitalize } from './capitalize.ts';\nimport { words as getWords } from './words.ts';\n\n/**\n * Converts a string to Pascal case.\n *\n * Pascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.\n *\n * @param {string} str - The string that is to be changed to pascal case.\n * @returns {string} - The converted string to Pascal case.\n *\n * @example\n * const convertedStr1 = pascalCase('pascalCase') // returns 'PascalCase'\n * const convertedStr2 = pascalCase('some whitespace') // returns 'SomeWhitespace'\n * const convertedStr3 = pascalCase('hyphen-text') // returns 'HyphenText'\n * const convertedStr4 = pascalCase('HTTPRequest') // returns 'HttpRequest'\n */\nexport function pascalCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => capitalize(word)).join('');\n}\n","import { get } from './get.ts';\nimport { has } from './has.ts';\nimport { set } from './set.ts';\nimport { isNil } from '../predicate/isNil.ts';\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to pick keys from.\n * @param {K[]} keys - An array of keys to be picked from the object.\n * @returns {Pick<T, K>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n */\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Pick<T, K>;\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} obj - The object to pick keys from.\n * @param {...any} keys\n * @param {PropertyKey | PropertyKey[] | PropertyKey[][]}} keys - An array of keys to be picked from the object. received keys goes through a flattening process before being used.\n * @returns {Partial<T, K>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n *\n * // each path can be passed individually as an argument\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, 'a', 'c');\n *\n * // pick a key over a path\n * const obj = { 'a.b': 1, a: { b: 2 } };\n * const result = pick(obj, 'a.b');\n * // result will be { 'a.b': 1 }\n */\nexport function pick<\n  // eslint-disable-next-line\n  T extends {},\n>(\n  obj: T | null | undefined,\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\n): Partial<T>;\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} obj - The object to pick keys from.\n * @param {...any} keysArr - An array of keys to be picked from the object. received keys goes through a flattening process before being used.\n * @param {PropertyKey | PropertyKey[] | PropertyKey[][]}} keys - An array of keys to be picked from the object. received keys goes through a flattening process before being used.\n * @returns {Partial<T, K>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n *\n * // each path can be passed individually as an argument\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, 'a', 'c');\n *\n * // pick a key over a path\n * const obj = { 'a.b': 1, a: { b: 2 } };\n * const result = pick(obj, 'a.b');\n * // result will be { 'a.b': 1 }\n */\nexport function pick<\n  // eslint-disable-next-line\n  T extends {},\n>(\n  obj: T | null | undefined,\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\n): Partial<T> {\n  if (isNil(obj)) {\n    return {};\n  }\n\n  const result: any = {};\n\n  for (let i = 0; i < keysArr.length; i++) {\n    let keys = keysArr[i];\n    switch (typeof keys) {\n      case 'object': {\n        if (!Array.isArray(keys)) {\n          // eslint-disable-next-line\n          // @ts-ignore\n          keys = Array.from(keys) as PropertyKey[];\n        }\n        break;\n      }\n      case 'string':\n      case 'symbol':\n      case 'number': {\n        keys = [keys];\n        break;\n      }\n    }\n\n    for (const key of keys) {\n      const value = get(obj, key);\n\n      if (value === undefined && !has(obj, key)) {\n        continue;\n      }\n\n      if (typeof key === 'string' && Object.hasOwn(obj, key)) {\n        result[key] = value;\n      } else {\n        set(result, key, value);\n      }\n    }\n  }\n\n  return result;\n}\n","import { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns true.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to pick properties from.\n * @param {(value: T[keyof T], key: keyof T) => boolean} shouldPick - A predicate function that determines\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\n * if the property should be picked, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'pick', c: 3 };\n * const shouldPick = (value) => typeof value === 'string';\n * const result = pickBy(obj, shouldPick);\n * // result will be { b: 'pick' }\n */\nexport function pickBy<T extends Record<string, any>>(\n  obj: T,\n  shouldPick?: (value: T[keyof T], key: keyof T, obj: T) => boolean\n): Partial<T> {\n  if (obj == null) {\n    return {};\n  }\n\n  const result: Partial<T> = {};\n\n  if (shouldPick == null) {\n    return obj;\n  }\n\n  const keys = isArrayLike(obj) ? range(0, obj.length) : (Object.keys(obj) as Array<keyof T>);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i].toString() as keyof T;\n    const value = obj[key];\n\n    if (shouldPick(value, key, obj)) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n","import { get } from './get.ts';\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * Unlike `property`, which creates a function bound to a specific path and allows you to query different objects,\n * `propertyOf` creates a function bound to a specific object and allows you to query different paths within that object.\n *\n * @param {unknown} object - The object to query.\n * @returns {(path: PropertyKey | PropertyKey[]) => unknown} - Returns a new function that takes a path and retrieves the value from the object at the specified path.\n *\n * @example\n * const getValue = propertyOf({ a: { b: { c: 3 } } });\n * const result = getValue('a.b.c');\n * console.log(result); // => 3\n *\n * @example\n * const getValue = propertyOf({ a: { b: { c: 3 } } });\n * const result = getValue(['a', 'b', 'c']);\n * console.log(result); // => 3\n */\nexport function propertyOf(object: unknown): (path: PropertyKey | readonly PropertyKey[]) => unknown {\n  return function (path: PropertyKey | readonly PropertyKey[]) {\n    return get(object, path);\n  };\n}\n","import { flatten } from './flatten.ts';\nimport { pull as pullToolkit } from '../../array/pull.ts';\n\n/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T, U\n * @param {T[]} arr - The array to modify.\n * @param {...unknown[]} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pull(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pull<T>(arr: T[], ...valuesToRemove: readonly unknown[]): T[] {\n  return pullToolkit(arr, valuesToRemove);\n}\n","import { pull as pullToolkit } from '../../array/pull.ts';\n\n/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pullAll(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pullAll<T>(arr: T[], valuesToRemove: ArrayLike<T> = []): T[] {\n  return pullToolkit(arr, Array.from(valuesToRemove));\n}\n","import { iteratee } from '../util/iteratee';\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {(value: T) => unknown} getValue - The iteratee invoked per element.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], obj => obj.value);\n * console.log(result); // [{ value: 2 }]\n */\nexport function pullAllBy<T>(arr: T[], valuesToRemove: ArrayLike<T>, getValue: (value: T) => unknown): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {Partial<T>} getValue - The partial object to match against each element.\n * @returns {T[]} The modified array with the specified values removed.\n */\nexport function pullAllBy<T>(arr: T[], valuesToRemove: ArrayLike<T>, getValue: Partial<T>): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {[keyof T, unknown]} getValue - The property-value pair to match against each element.\n * @returns {T[]} The modified array with the specified values removed.\n */\nexport function pullAllBy<T>(arr: T[], valuesToRemove: ArrayLike<T>, getValue: [keyof T, unknown]): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {keyof T} getValue - The key of the property to match against each element.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], 'value');\n * console.log(result); // [{ value: 2 }]\n */\nexport function pullAllBy<T>(arr: T[], valuesToRemove: ArrayLike<T>, getValue: keyof T): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {keyof T} getValue - The key of the property to match against each element.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * // Using a iteratee function\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], obj => obj.value);\n * console.log(result); // [{ value: 2 }]\n *\n * // Using a property name\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], 'value');\n * console.log(result); // [{ value: 2 }]\n */\nexport function pullAllBy<T>(\n  arr: T[],\n  valuesToRemove: ArrayLike<T>,\n  _getValue: ((value: T, index: number, arr: ArrayLike<T>) => boolean) | Partial<T> | [keyof T, unknown] | keyof T\n): T[] {\n  const getValue = iteratee(_getValue);\n  const valuesSet = new Set(Array.from(valuesToRemove).map(x => getValue(x)));\n\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    const value = getValue(arr[i]);\n\n    if (valuesSet.has(value)) {\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return arr;\n}\n","import { at } from './at.ts';\n\n/**\n * Removes elements from an array at specified indices and returns the removed elements.\n *\n * This function supports negative indices, which count from the end of the array.\n *\n * @template T\n * @param {T[]} arr - The array from which elements will be removed.\n * @param {number[]} indicesToRemove - An array of indices specifying the positions of elements to remove.\n * @returns {Array<T | undefined>} An array containing the elements that were removed from the original array.\n *\n * @example\n * import { pullAt } from './pullAt';\n *\n * const numbers = [10, 20, 30, 40, 50];\n * const removed = pullAt(numbers, [1, 3, 4]);\n * console.log(removed); // [20, 40, 50]\n * console.log(numbers); // [10, 30]\n */\nexport function pullAt<T>(arr: T[], indicesToRemove: number[]): T[] {\n  const removed = at(arr, indicesToRemove);\n  const indices = new Set(indicesToRemove.slice().sort((x, y) => y - x));\n\n  for (const index of indices) {\n    arr.splice(index, 1);\n  }\n\n  return removed;\n}\n","import { clamp } from './clamp.ts';\nimport { random as randomToolkit } from '../../math/random.ts';\nimport { randomInt as randomIntToolkit } from '../../math/randomInt.ts';\n\n/**\n * Generate a random number within 0 and 1.\n *\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result = random(); // Returns a random number between 0 and 1.\n */\nexport function random(floating?: boolean): number;\n\n/**\n * Generate a random number within 0 and 1.\n *\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result = random(); // Returns a random number between 0 and 1.\n */\nexport function random(min: number, index: string | number, guard: object): number;\n\n/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result1 = random(5); // Returns a random number between 0 and 5.\n * const result2 = random(0); // Returns a random number between 0 and 0 (which is 0).\n */\nexport function random(maximum: number, floating?: boolean): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum: number, floating?: boolean): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(...args: any[]): number {\n  let minimum = 0;\n  let maximum = 1;\n  let floating = false;\n\n  switch (args.length) {\n    case 1: {\n      if (typeof args[0] === 'boolean') {\n        floating = args[0];\n      } else {\n        maximum = args[0];\n      }\n\n      break;\n    }\n    case 2: {\n      if (typeof args[1] === 'boolean') {\n        maximum = args[0];\n        floating = args[1];\n      } else {\n        minimum = args[0];\n        maximum = args[1];\n      }\n    }\n    // eslint-disable-next-line no-fallthrough\n    case 3: {\n      if (typeof args[2] === 'object' && args[2] != null && args[2][args[1]] === args[0]) {\n        minimum = 0;\n        maximum = args[0];\n        floating = false;\n      } else {\n        minimum = args[0];\n        maximum = args[1];\n        floating = args[2];\n      }\n    }\n  }\n\n  if (typeof minimum !== 'number') {\n    minimum = Number(minimum);\n  }\n\n  if (typeof maximum !== 'number') {\n    minimum = Number(maximum);\n  }\n\n  if (!minimum) {\n    minimum = 0;\n  }\n\n  if (!maximum) {\n    maximum = 0;\n  }\n\n  if (minimum > maximum) {\n    [minimum, maximum] = [maximum, minimum];\n  }\n\n  minimum = clamp(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n  maximum = clamp(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n  if (minimum === maximum) {\n    return minimum;\n  }\n\n  if (floating) {\n    return randomToolkit(minimum, maximum + 1);\n  } else {\n    return randomIntToolkit(minimum, maximum + 1);\n  }\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { toFinite } from '../util/toFinite.ts';\n\n/**\n * Returns an array of numbers from `0` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `0` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n */\nexport function range(end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [1, 2, 3]\n * range(1, 4);\n */\nexport function range(start: number, end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n */\nexport function range(start: number, end: number, step: number): number[];\n\n/**\n * Enables use as an iteratee for methods like `_.map`.\n *\n * @param {number} end - The current iteratee value.\n * @param {PropertyKey} index - The iteration index.\n * @param {object} guard - The iteratee object.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n */\nexport function range(end: number, index: PropertyKey, guard: object): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n */\nexport function range(start: number, end?: PropertyKey, step?: any): number[] {\n  // Enables use as an iteratee for methods like `_.map`.\n  if (step && typeof step !== 'number' && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = toFinite(start);\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = toFinite(end);\n  }\n  step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n\n  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);\n  const result = new Array(length);\n  for (let index = 0; index < length; index++) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { toFinite } from '../util/toFinite.ts';\n\n/**\n * Returns an array of numbers from `end` (exclusive) to `0` (inclusive), decrementing by `1`.\n *\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `end` (exclusive) to `0` (inclusive) with a step of `1`.\n *\n * @example\n * // Returns [3, 2, 1, 0]\n * rangeRight(4);\n */\nexport function rangeRight(end: number): number[];\n\n/**\n * Returns an array of numbers from `end` (exclusive) to `start` (inclusive), decrementing by `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `end` (exclusive) to `start` (inclusive) with a step of `1`.\n *\n * @example\n * // Returns [3, 2, 1]\n * rangeRight(1, 4);\n */\nexport function rangeRight(start: number, end: number): number[];\n\n/**\n * Returns an array of numbers from `end` (exclusive) to `start` (inclusive), decrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `end` (exclusive) to `start` (inclusive) with the specified `step`.\n *\n * @example\n * // Returns [15, 10, 5, 0]\n * rangeRight(0, 20, 5);\n */\nexport function rangeRight(start: number, end: number, step: number): number[];\n\n/**\n * Enables use as an iteratee for methods like `_.map`.\n *\n * @param {number} end - The current iteratee value.\n * @param {PropertyKey} index - The iteration index.\n * @param {object} guard - The iteratee object.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n */\nexport function rangeRight(end: number, index: PropertyKey, guard: object): number[];\n\n/**\n * Returns an array of numbers from `end` (exclusive) to `start` (inclusive), decrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `end` (exclusive) to `start` (inclusive) with the specified `step`.\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\n *\n * @example\n * // Returns [3, 2, 1, 0]\n * rangeRight(4);\n *\n * @example\n * // Returns [-3, -2, -1, 0]\n * rangeRight(0, -4, -1);\n */\nexport function rangeRight(start: number, end?: PropertyKey, step?: any): number[] {\n  // Enables use as an iteratee for methods like `_.map`.\n  if (step && typeof step !== 'number' && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = toFinite(start);\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = toFinite(end);\n  }\n  step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n\n  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);\n  const result = new Array(length);\n  for (let index = length - 1; index >= 0; index--) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n","import { flatten } from '../array/flatten.ts';\n\n/**\n * Creates a function that invokes `func` with arguments arranged according to the specified `indices`\n * where the argument value at the first index is provided as the first argument,\n * the argument value at the second index is provided as the second argument, and so on.\n *\n * @template F The type of the function to re-arrange.\n * @param {F} func The function to rearrange arguments for.\n * @param {Array<number | number[]>} indices The arranged argument indices.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const rearrangedGreet = rearg(greet, 1, 0);\n * console.log(rearrangedGreet('World', 'Hello')); // Output: \"Hello, World!\"\n */\nexport function rearg<F extends (...args: any[]) => any>(\n  func: F,\n  ...indices: Array<number | number[]>\n): (...args: any[]) => ReturnType<F> {\n  const flattenIndices = flatten(indices);\n\n  return function (this: any, ...args: any[]) {\n    const reorderedArgs: any[] = flattenIndices.map(i => args[i]).slice(0, args.length);\n\n    for (let i = reorderedArgs.length; i < args.length; i++) {\n      reorderedArgs.push(args[i]);\n    }\n\n    return func.apply(this, reorderedArgs);\n  };\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * The `reduce()` function goes through each element in an array and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduce()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the first element of the array and begins with the second element for the calculation.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: readonly T[]) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = [1, 2, 3];\n * reduce(arrayLike, (acc, value) => acc && value % 2 === 0, true); // => false\n */\nexport function reduce<T, U>(\n  collection: readonly T[],\n  iteratee: (accumulator: U, value: T, index: number, collection: readonly T[]) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * The `reduce()` function goes through each element in an array and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduce()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the first element of the array and begins with the second element for the calculation.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {(accumulator: T, value: T, index: number, collection: readonly T[]) => T} iteratee - The function invoked per iteration.\n * @returns {T} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = [1, 2, 3];\n * reduce(arrayLike, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T>(\n  collection: readonly T[],\n  iteratee: (accumulator: T, value: T, index: number, collection: readonly T[]) => T\n): T;\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * The `reduce()` function goes through each element in an array and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduce()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the first element of the array and begins with the second element for the calculation.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduce(arrayLike, (acc, value) => acc + value % 2 === 0, true); // => false\n */\nexport function reduce<T, U>(\n  collection: ArrayLike<T>,\n  iteratee: (accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * The `reduce()` function goes through each element in an array and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduce()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the first element of the array and begins with the second element for the calculation.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U} iteratee - The function invoked per iteration.\n * @returns {T} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduce(arrayLike, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T>(\n  collection: ArrayLike<T>,\n  iteratee: (accumulator: T, value: T, index: number, collection: ArrayLike<T>) => T\n): T;\n\n/**\n * Reduces an object to a single value using an iteratee function.\n *\n * @param {T} collection - The object to iterate over.\n * @param {(accumulator: U, value: T[keyof T], key: string, collection: T) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value % 2 === 0, true); // => false\n */\nexport function reduce<T extends object, U>(\n  collection: T,\n  iteratee: (accumulator: U, value: T[keyof T], key: keyof T, collection: T) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an object to a single value using an iteratee function.\n *\n * @param {T} collection - The object to iterate over.\n * @param {(accumulator: T[keyof T], value: T[keyof T], key: keyof T, collection: T) => U} iteratee - The function invoked per iteration.\n * @returns {T[keyof T]} - Returns the accumulated value.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T extends object>(\n  collection: T,\n  iteratee: (accumulator: T[keyof T], value: T[keyof T], key: keyof T, collection: T) => T[keyof T]\n): T[keyof T];\n\n/**\n * Reduces a collection to a single value using an iteratee function.\n *\n * @param {T[] | ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {((accumulator: any, value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object} iteratee - The function invoked per iteration or the key to reduce over.\n * @param {any} initialValue - The initial value.\n * @returns {any} - Returns the accumulated value.\n *\n * @example\n * // Using a reducer function\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value, 0); // => 6\n *\n * @example\n * // Using a reducer function with initialValue\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value % 2 === 0, true); // => false\n *\n * @example\n * // Using an object as the collection\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduce(\n  collection: ArrayLike<any> | Record<any, any> | null | undefined,\n  iteratee: (accumulator: any, value: any, index: any, collection: any) => any = identity,\n  accumulator?: any\n): any {\n  if (!collection) {\n    return accumulator;\n  }\n\n  let keys: any[];\n  let startIndex = 0;\n\n  if (isArrayLike(collection)) {\n    keys = range(0, collection.length);\n\n    if (accumulator == null && collection.length > 0) {\n      accumulator = collection[0];\n      startIndex += 1;\n    }\n  } else {\n    keys = Object.keys(collection);\n\n    if (accumulator == null) {\n      accumulator = (collection as any)[keys[0]];\n      startIndex += 1;\n    }\n  }\n\n  for (let i = startIndex; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    accumulator = iteratee(accumulator, value, key, collection);\n  }\n\n  return accumulator;\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: readonly T[]) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = [1, 2, 3];\n * reduceRight(arrayLike, (acc, value) => acc && value % 2 === 0, true); // => false\n */\nexport function reduceRight<T, U>(\n  collection: readonly T[],\n  iteratee: (accumulator: U, value: T, index: number, collection: readonly T[]) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @param {readonly T[]} collection - The collection to iterate over.\n * @param {(accumulator: T, value: T, index: number, collection: readonly T[]) => T} iteratee - The function invoked per iteration.\n * @returns {T} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = [1, 2, 3];\n * reduceRight(arrayLike, (acc, value) => acc + value); // => 6\n */\nexport function reduceRight<T>(\n  collection: readonly T[],\n  iteratee: (accumulator: T, value: T, index: number, collection: readonly T[]) => T\n): T;\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduceRight(arrayLike, (acc, value) => acc + value % 2 === 0, true); // => false\n */\nexport function reduceRight<T, U>(\n  collection: ArrayLike<T>,\n  iteratee: (accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {(accumulator: U, value: T, index: number, collection: ArrayLike<T>) => U} iteratee - The function invoked per iteration.\n * @returns {T} - Returns the accumulated value.\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduceRight(arrayLike, (acc, value) => acc + value); // => 6\n */\nexport function reduceRight<T>(\n  collection: ArrayLike<T>,\n  iteratee: (accumulator: T, value: T, index: number, collection: ArrayLike<T>) => T\n): T;\n\n/**\n * Reduces an object to a single value using an iteratee function, starting from the right.\n *\n * @param {T} collection - The object to iterate over.\n * @param {(accumulator: U, value: T[keyof T], key: string, collection: T) => U} iteratee - The function invoked per iteration.\n * @param {U} initialValue - The initial value.\n * @returns {U} - Returns the accumulated value.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduceRight(obj, (acc, value) => acc + value % 2 === 0, true); // => false\n */\nexport function reduceRight<T extends object, U>(\n  collection: T,\n  iteratee: (accumulator: U, value: T[keyof T], key: keyof T, collection: T) => U,\n  initialValue: U\n): U;\n\n/**\n * Reduces an object to a single value using an iteratee function, starting from the right.\n *\n * @param {T} collection - The object to iterate over.\n * @param {(accumulator: T[keyof T], value: T[keyof T], key: keyof T, collection: T) => U} iteratee - The function invoked per iteration.\n * @returns {T[keyof T]} - Returns the accumulated value.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduceRight(obj, (acc, value) => acc + value); // => 6\n */\nexport function reduceRight<T extends object>(\n  collection: T,\n  iteratee: (accumulator: T[keyof T], value: T[keyof T], key: keyof T, collection: T) => T[keyof T]\n): T[keyof T];\n\n/**\n * Reduces a collection to a single value using an iteratee function, starting from the right.\n *\n * @param {T[] | ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {((accumulator: any, value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object} iteratee - The function invoked per iteration or the key to reduce over.\n * @param {any} initialValue - The initial value.\n * @returns {any} - Returns the accumulated value.\n *\n * @example\n * // Using a reducer function\n * const array = [1, 2, 3];\n * reduceRight(array, (acc, value) => acc + value, 0); // => 6\n *\n * @example\n * // Using a reducer function with initialValue\n * const array = [1, 2, 3];\n * reduceRight(array, (acc, value) => acc + value % 2 === 0, true); // => false\n *\n * @example\n * // Using an object as the collection\n * const obj = { a: 1, b: 2, c: 3 };\n * reduceRight(obj, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduceRight(\n  collection: ArrayLike<any> | Record<any, any> | null | undefined,\n  iteratee: (accumulator: any, value: any, index: any, collection: any) => any = identity,\n  accumulator?: any\n): any {\n  if (!collection) {\n    return accumulator;\n  }\n\n  let keys: any[];\n  let startIndex: number;\n\n  if (isArrayLike(collection)) {\n    keys = range(0, collection.length).reverse();\n\n    if (accumulator == null && collection.length > 0) {\n      accumulator = collection[collection.length - 1];\n      startIndex = 1;\n    } else {\n      startIndex = 0;\n    }\n  } else {\n    keys = Object.keys(collection).reverse();\n\n    if (accumulator == null) {\n      accumulator = (collection as any)[keys[0]];\n      startIndex = 1;\n    } else {\n      startIndex = 0;\n    }\n  }\n\n  for (let i = startIndex; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    accumulator = iteratee(accumulator, value, key, collection);\n  }\n\n  return accumulator;\n}\n","import { remove as removeToolkit } from '../../array/remove.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Removes elements from an array based on a predicate function.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: ArrayLike<T>) => boolean} shouldRemoveElement - The function invoked per iteration.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * const array = [1, 2, 3];\n * remove(array, value => value % 2 === 0); // => [1, 3]\n */\nexport function remove<T>(\n  arr: ArrayLike<T>,\n  shouldRemoveElement: (value: T, index: number, arr: ArrayLike<T>) => boolean\n): T[];\n\n/**\n * Removes elements from an array based on a partial object match.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {Partial<T>} shouldRemoveElement - The partial object to match against each element.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, { a: 1 }); // => [{ a: 2 }, { a: 3 }]\n */\nexport function remove<T>(arr: ArrayLike<T>, shouldRemoveElement: Partial<T>): T[];\n\n/**\n * Removes elements from an array based on a property-value pair match.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {[keyof T, unknown]} shouldRemoveElement - The property-value pair to match against each element.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, ['a', 1]); // => [{ a: 2 }, { a: 3 }]\n */\nexport function remove<T>(arr: ArrayLike<T>, shouldRemoveElement: [keyof T, unknown]): T[];\n\n/**\n * Removes elements from an array based on a property key.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {keyof T} shouldRemoveElement - The key of the property to match against each element.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * const objects = [{ a: 0 }, { a: 1 }];\n * remove(objects, 'a'); // => [{ a: 0 }]\n */\nexport function remove<T, K extends keyof T>(arr: ArrayLike<T>, shouldRemoveElement: K): T[];\n\n/**\n * Removes elements from an array based on various criteria.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: ArrayLike<T>) => boolean | Partial<T> | [keyof T, unknown] | keyof T} shouldRemoveElement - The function invoked per iteration, a partial object, a property-value pair, or a key to match against each element.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * // Using a predicate function\n * const numbers = [1, 2, 3, 4, 5];\n * remove(numbers, value => value % 2 === 0); // => [1, 3, 5]\n *\n * @example\n * // Using a partial object\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, { a: 1 }); // => [{ a: 2 }, { a: 3 }]\n *\n * @example\n * // Using a property-value pair\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, ['a', 1]); // => [{ a: 2 }, { a: 3 }]\n *\n * @example\n * // Using a property key\n * const objects = [{ a: 0 }, { a: 1 }];\n * remove(objects, 'a'); // => [{ a: 0 }]\n */\nexport function remove<T>(\n  arr: ArrayLike<T>,\n  shouldRemoveElement:\n    | ((value: T, index: number, arr: ArrayLike<T>) => boolean)\n    | Partial<T>\n    | [keyof T, unknown]\n    | keyof T\n): T[] {\n  return removeToolkit(arr as T[], iteratee(shouldRemoveElement));\n}\n","/**\n * Removes elements from an array based on a predicate function.\n *\n * This function changes `arr` in place.\n * If you want to remove elements without modifying the original array, use `filter`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {(value: T, index: number, array: T[]) => boolean} shouldRemoveElement - The function invoked per iteration to determine if an element should be removed.\n * @returns {T[]} The modified array with the specified elements removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * remove(numbers, (value) => value % 2 === 0);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function remove<T>(arr: T[], shouldRemoveElement: (value: T, index: number, array: T[]) => boolean): T[] {\n  const originalArr = arr.slice();\n  const removed = [];\n\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (shouldRemoveElement(arr[i], i, originalArr)) {\n      removed.push(arr[i]);\n\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return removed;\n}\n","/**\n * Repeats the given string n times.\n *\n * If n is less than 1, an empty string is returned, or if the string is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to repeat.\n * @param {number} n - The number of times to repeat the string.\n * @returns {string} - The repeated string, or an empty string if n is less than 1.\n *\n * @example\n * repeat('abc', 0); // ''\n * repeat('abc', 2); // 'abcabc'\n */\nexport function repeat(str: string, n: number): string {\n  return str.repeat(n);\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Replaces the matched pattern with the replacement string.\n *\n * @param {string} target - The target string.\n * @param {string | RegExp} pattern - The pattern to match.\n * @param {string | ((substring: string, ...args: any[]) => string)} replacement - The replacement string or a function that returns the replacement string.\n * @returns {string} The new string with the matched pattern replaced.\n *\n * @example\n * replace('abcde', 'de', '123'); // 'abc123'\n * replace('abcde', /[bd]/g, '-'); // 'a-c-e'\n * replace('abcde', 'de', substring => substring.toUpperCase()); // 'abcDE'\n * replace('abcde', /[bd]/g, substring => substring.toUpperCase()); // 'aBcDe'\n */\nexport function replace(\n  target = '',\n  pattern: string | RegExp,\n  replacement: string | ((substring: string, ...args: any[]) => string)\n): string {\n  if (arguments.length < 3) {\n    return toString(target);\n  }\n\n  return toString(target).replace(pattern, replacement as any);\n}\n","import { rest as restToolkit } from '../../function/rest.ts';\n\n/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [start=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest<F extends (...args: any[]) => any>(\n  func: F,\n  start = func.length - 1\n): (...args: any[]) => ReturnType<F> {\n  start = Number.parseInt(start as any, 10);\n\n  if (Number.isNaN(start) || start < 0) {\n    start = func.length - 1;\n  }\n\n  return restToolkit(func, start);\n}\n","/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest<F extends (...args: any[]) => any>(\n  func: F,\n  startIndex = func.length - 1\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: any[]) {\n    const rest = args.slice(startIndex);\n    const params = args.slice(0, startIndex);\n    while (params.length < startIndex) {\n      params.push(undefined);\n    }\n    return func.apply(this, [...params, rest]);\n  };\n}\n","/**\n * Reverses the elements of an array in place.\n *\n * This function takes an array and reverses its elements in place, modifying the original array.\n * If the input is `null` or `undefined`, it returns the input as is.\n *\n * @template T - The type of elements in the array.\n * @param {T[] | null | undefined} array - The array to reverse. If `null` or `undefined`, the input is returned as is.\n * @returns {T[] | null | undefined} The reversed array, or `null`/`undefined` if the input was `null`/`undefined`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const reversedArray = reverse(array);\n * // reversedArray is [5, 4, 3, 2, 1], and array is also modified to [5, 4, 3, 2, 1].\n *\n * const emptyArray = reverse([]);\n * // emptyArray is [].\n *\n * const nullArray = reverse(null);\n * // nullArray is null.\n */\nexport function reverse<T>(array: T[] | null | undefined): T[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.reverse();\n}\n","/**\n * Reverses a given string.\n *\n * This function takes a string as input and returns a new string that is the reverse of the input.\n *\n * @param {string} value - The string that is to be reversed.\n * @returns {string} - The reversed string.\n *\n * @example\n * const reversedStr1 = reverseString('hello') // returns 'olleh'\n * const reversedStr2 = reverseString('PascalCase') // returns 'esaClacsaP'\n * const reversedStr3 = reverseString('foo  bar') // returns 'rab  oof'\n */\nexport function reverseString(value: string): string {\n  return [...value].reverse().join('');\n}\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded to precision.\n *\n * @param {number | string} number  The number to round.\n * @param {number | string} precision The precision to round to.\n * @returns {number} Returns the rounded number.\n *\n * @example\n * round(4.006); // => 4\n * round(4.006, 2); // => 4.01\n * round(4060, -2); // => 4100\n */\nexport function round(number: number | string, precision: number | string = 0): number {\n  return decimalAdjust('round', number, precision);\n}\n","import { sample as sampleToolkit } from '../../array/sample.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns a random element from an array.\n *\n * @template T\n * @param {T[]} array - The array to sample from.\n * @returns {T | undefined} A random element from the array, or `undefined` if the array is empty.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = sample(array);\n * console.log(result); // Output: 1, 2, or 3 (randomly selected)\n */\nexport function sample<T>(array: readonly T[]): T | undefined;\n\n/**\n * Returns a random character from a string.\n *\n * @param {string} str - The string to sample from.\n * @returns {string | undefined} A random character from the string, or `undefined` if the string is empty.\n *\n * @example\n * const str = \"hello\";\n * const result = sample(str);\n * console.log(result); // Output: 'h', 'e', 'l', 'l', or 'o' (randomly selected)\n */\nexport function sample(str: string): string | undefined;\n\n/**\n * Returns a random element from an array.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array-like object to sample from.\n * @returns {T | undefined} A random element from the array, or `undefined` if the array is empty.\n *\n * @example\n * const arrayLike: ArrayLike<string> = { 0: 'a', 1: 'b', 2: 'c', length: 3 };\n * const result = sample(arrayLike);\n * console.log(result); // Output: 'a', 'b', or 'c' (randomly selected)\n */\nexport function sample<T>(array: ArrayLike<T>): T | undefined;\n\n/**\n * Returns a random value from an object.\n *\n * @template T - The type of values in the object.\n * @param {Record<string, T>} obj - The object to sample from.\n * @returns {T | undefined} A random value from the object, or `undefined` if the object is empty.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = sample(obj);\n * console.log(result); // Output: 1, 2, or 3 (randomly selected)\n */\nexport function sample<T>(obj: Record<string, T>): T | undefined;\n\n/**\n * Returns a random element from an array-like object or a regular object.\n *\n * This function takes an array-like object (such as an array or string) or a regular object,\n * and returns a randomly selected element or value. If the collection is empty or invalid, it returns `undefined`.\n *\n * @template T - The type of elements in the collection.\n * @param {ArrayLike<T> | Record<string, T>} collection - The collection to sample from.\n * @returns {T | string | undefined} A random element from the collection, or `undefined` if the collection is empty or invalid.\n *\n * @example\n * // Array example\n * const array = [1, 2, 3];\n * const result = sample(array);\n * console.log(result); // Output: 1, 2, or 3 (randomly selected)\n *\n * // String example\n * const str = 'abc';\n * const result2 = sample(str);\n * console.log(result2); // Output: 'a', 'b', or 'c' (randomly selected)\n *\n * // Object example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result3 = sample(obj);\n * console.log(result3); // Output: 1, 2, or 3 (randomly selected)\n */\nexport function sample<T>(collection: ArrayLike<T> | Record<string, T>): T | string | undefined;\n\n/**\n * The implementation for the overloaded sample function.\n *\n * This function takes an array, string, or object and returns a single element selected randomly.\n * If the input is empty, or if it's null or undefined, the function returns `undefined`.\n *\n * @template T - The type of elements in the collection.\n * @param {ArrayLike<T> | Record<string, T>} collection - The collection to sample from.\n * @returns {T | string | undefined} A random element from the collection, or `undefined` if the collection is empty or invalid.\n */\nexport function sample<T>(collection: ArrayLike<T> | Record<string, T>): T | string | undefined {\n  if (collection == null) {\n    return undefined;\n  }\n\n  if (isArrayLike(collection)) {\n    return sampleToolkit(toArray(collection));\n  }\n\n  return sampleToolkit(Object.values(collection));\n}\n","import { randomInt } from '../math/randomInt.ts';\n\n/**\n * Returns a sample element array of a specified `size`.\n *\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\n *\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algorithm}\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to sample from.\n * @param {number} size - The size of sample.\n * @returns {T[]} A new array with sample size applied.\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\n *\n * @example\n * const result = sampleSize([1, 2, 3], 2)\n * // result will be an array containing two of the elements from the array.\n * // [1, 2] or [1, 3] or [2, 3]\n */\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\n  if (size > array.length) {\n    throw new Error('Size must be less than or equal to the length of array.');\n  }\n\n  const result = new Array(size);\n  const selected = new Set();\n\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\n    let index = randomInt(0, step + 1);\n\n    if (selected.has(index)) {\n      index = step;\n    }\n\n    selected.add(index);\n\n    result[resultIndex] = array[index];\n  }\n\n  return result;\n}\n","/**\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\n *\n * This function takes an array and returns a new array with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to shuffle.\n * @returns {T[]} A new array with its elements shuffled in random order.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const shuffledArray = shuffle(array);\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\n */\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = arr.slice();\n\n  /**\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n   */\n  for (let i = result.length - 1; i >= 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n\n  return result;\n}\n","import { isNil } from '../../predicate/isNil.ts';\n\n/**\n * Returns the length of an array, string, or object.\n *\n * This function takes an array, string, or object and returns its length.\n * For arrays and strings, it returns the number of elements or characters, respectively.\n * For objects, it returns the number of enumerable properties.\n *\n * @template T - The type of the input value.\n * @param {T[] | object | string | Map<unknown, T> | Set<T> | null | undefined } target - The value whose size is to be determined. It can be an array, string, or object.\n * @returns {number} The size of the input value.\n *\n * @example\n * const arr = [1, 2, 3];\n * const arrSize = size(arr);\n * // arrSize will be 3\n *\n * const str = 'hello';\n * const strSize = size(str);\n * // strSize will be 5\n *\n * const obj = { a: 1, b: 2, c: 3 };\n * const objSize = size(obj);\n * // objSize will be 3\n *\n * const emptyArr = [];\n * const emptyArrSize = size(emptyArr);\n * // emptyArrSize will be 0\n *\n * const emptyStr = '';\n * const emptyStrSize = size(emptyStr);\n * // emptyStrSize will be 0\n *\n * const emptyObj = {};\n * const emptyObjSize = size(emptyObj);\n * // emptyObjSize will be 0\n */\nexport function size<T>(target: readonly T[] | object | string | Map<unknown, T> | Set<T> | null | undefined): number {\n  if (isNil(target)) {\n    return 0;\n  }\n\n  if (target instanceof Map || target instanceof Set) {\n    return target.size;\n  }\n\n  return Object.keys(target).length;\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Create a slice of `array` from `start` up to, but not including, `end`.\n *\n * It does not return a dense array for sparse arrays unlike the native `Array.prototype.slice`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T> | null | undefined} array - The array to slice.\n * @param {number} [start=0] - The start position.\n * @param {number} [end=array.length] - The end position.\n * @returns {T[]} - Returns the slice of `array`.\n *\n * @example\n * slice([1, 2, 3], 1, 2); // => [2]\n * slice(new Array(3)); // => [undefined, undefined, undefined]\n */\nexport function slice<T>(array: ArrayLike<T> | null | undefined, start?: number, end?: number): T[] {\n  if (!isArrayLike(array)) {\n    return [];\n  }\n\n  const length = array.length;\n\n  if (end === undefined) {\n    end = length;\n  } else if (typeof end !== 'number' && isIterateeCall(array, start, end)) {\n    // support for expression like `_.map(slice)`\n    start = 0;\n    end = length;\n  }\n\n  start = toInteger(start);\n  end = toInteger(end);\n\n  if (start < 0) {\n    start = Math.max(length + start, 0);\n  } else {\n    start = Math.min(start, length);\n  }\n\n  if (end < 0) {\n    end = Math.max(length + end, 0);\n  } else {\n    end = Math.min(end, length);\n  }\n\n  const resultLength = Math.max(end - start, 0);\n  const result = new Array(resultLength);\n\n  for (let i = 0; i < resultLength; ++i) {\n    result[i] = array[start + i];\n  }\n\n  return result;\n}\n","import { snakeCase as snakeCaseToolkit } from '../../string/snakeCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to snake case.\n *\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string | object} str - The string that is to be changed to snake case.\n * @returns {string} - The converted string to snake case.\n *\n * @example\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\n */\nexport function snakeCase(str?: string | object): string {\n  return snakeCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to snake case.\n *\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string} str - The string that is to be changed to snake case.\n * @returns {string} - The converted string to snake case.\n *\n * @example\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\n */\n\nexport function snakeCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('_');\n}\n","import { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Checks if there is an element in an array that is truthy.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr The array to iterate over.\n * @returns {boolean} Returns `true` if any element is truthy, else `false`.\n *\n * @example\n * some([1, 2, 3, 4]);\n * // => true\n */\nexport function some<T>(arr: ArrayLike<T> | null | undefined): boolean;\n\n/**\n * Checks if there is an element in an array that matches the given predicate function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr The array to iterate over.\n * @param {(item: T, index: number, arr: readonly T[]) => unknown} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some([1, 2, 3, 4], n => n % 2 === 0);\n * // => true\n */\nexport function some<T>(\n  arr: ArrayLike<T> | null | undefined,\n  predicate: (item: T, index: number, arr: readonly T[]) => unknown\n): boolean;\n\n/**\n * Checks if there is an element in an array that matches the given key-value pair.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr The array to iterate over.\n * @param {[keyof T, unknown]} predicate The key-value pair to match.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => true\n */\nexport function some<T>(arr: ArrayLike<T> | null | undefined, predicate: [keyof T, unknown]): boolean;\n\n/**\n * Checks if there is an element in an array that has a truthy value for the given property name.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr The array to iterate over.\n * @param {PropertyKey} propertyToCheck The property name to check.\n * @returns {boolean} Returns `true` if any element has a truthy value for the property, else `false`.\n *\n * @example\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\n * // => true\n */\nexport function some<T>(arr: ArrayLike<T> | null | undefined, propertyToCheck: PropertyKey): boolean;\n\n/**\n * Checks if there is an element in an array that matches the given partial object.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr The array to iterate over.\n * @param {Partial<T>} doesMatch The partial object to match.\n * @returns {boolean} Returns `true` if any element matches the partial object, else `false`.\n *\n * @example\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\n * // => true\n */\nexport function some<T>(arr: ArrayLike<T> | null | undefined, doesMatch: Partial<T>): boolean;\n\n/**\n * Checks if there is an element in an object that matches the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object The object to iterate over.\n * @returns {boolean} Returns `true` if any element is truthy, else `false`.\n *\n * @example\n * some({ a: 1, b: 2, c: 3 });\n * // => true\n */\nexport function some<T extends Record<string, unknown>>(object: T | null | undefined): boolean;\n\n/**\n * Checks if there is an element in an object that matches the given predicate function.\n *\n * @template T\n * @param {T | null | undefined} object The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} doesMatch A function that takes an value, its key, and the object, and returns a truthy value if the item matches the criteria.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some({ a: 1, b: 2, c: 3 }, n => n % 2 === 0);\n * // => true\n */\nexport function some<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: (value: T[keyof T], key: keyof T, object: T) => unknown\n): boolean;\n\n/**\n * Checks if there is an element in an object that matches the given partial value.\n *\n * @template T\n * @param {T | null | undefined} object The object to iterate over.\n * @param {Partial<T[keyof T]>} doesMatch A partial value to match against the values of the object.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, { name: 'Bob' });\n * // => true\n */\nexport function some<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatch: Partial<T[keyof T]>\n): boolean;\n\n/**\n * Checks if there is an element in an object that matches a property with a specific value.\n *\n * @template T\n * @param {T | null | undefined} object The object to iterate over.\n * @param {[keyof T, unknown]} doesMatchProperty An array where the first element is the property key and the second element is the value to match.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * const obj = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * const result = some(obj, ['name', 'Alice']);\n * // => true\n */\nexport function some<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  doesMatchProperty: [keyof T[keyof T], unknown]\n): boolean;\n\n/**\n * Checks if there is an element in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T | null | undefined} object The object to iterate over.\n * @param {PropertyKey} propertyToCheck The property name to check.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * const obj = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * const result = some(obj, 'name');\n * // => true\n */\nexport function some<T extends Record<string, unknown>>(\n  object: T | null | undefined,\n  propertyToCheck: PropertyKey\n): boolean;\n/**\n * Checks if there is an element in an array that matches the given predicate.\n *\n * Iteration is stopped once there is an element that matches `predicate`.\n *\n * @template T\n * @param {ArrayLike<T> | Record<string, any> | null | undefined} source The source to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] The function invoked per iteration.\n * If a property name or an object is provided it will be used to create a predicate function.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some([1, 2, 3, 4], n => n % 2 === 0);\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\n * // => true\n *\n * some({ a: 1, b: 2, c: 3 }, n => n % 2 === 0);\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, { name: 'Bob' });\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, ['name', 'Alice']);\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, 'name');\n * // => true\n */\nexport function some<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  guard?: unknown\n): boolean {\n  if (!source) {\n    return false;\n  }\n  if (guard != null) {\n    predicate = undefined;\n  }\n\n  if (!predicate) {\n    predicate = identity;\n  }\n\n  const values = Array.isArray(source) ? source : Object.values(source);\n\n  switch (typeof predicate) {\n    case 'function': {\n      if (!Array.isArray(source)) {\n        const keys = Object.keys(source) as Array<keyof T>;\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const value = source[key];\n\n          if (predicate(value as T, key as number, source)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      return values.some(predicate);\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        return values.some(matchesProperty(key, value));\n      } else {\n        return values.some(matches(predicate));\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      return values.some(property(predicate));\n    }\n  }\n}\n","import { Criterion, orderBy } from './orderBy.ts';\nimport { flatten } from '../../array/flatten.ts';\nimport { isIterateeCall } from '../_internal/isIterateeCall.ts';\n\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of criteria to sort by.\n * It returns the ascending sorted array, ordering by each key.\n * If values for a key are equal, it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | object | null | undefined} collection - The array of objects to be sorted.\n * @param {Array<Array<Criterion<T> | Criterion<T>>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\n * @returns {T[]} - The ascending sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = sortBy(users, ['user', (item) => item.age])\n * // result will be:\n * // [\n * //   { user: 'barney', age: 34 },\n * //   { user: 'barney', age: 36 },\n * //   { user: 'fred', age: 40 },\n * //   { user: 'fred', age: 48 },\n * // ]\n */\nexport function sortBy<T = any>(\n  collection: ArrayLike<T> | object | null | undefined,\n  ...criteria: Array<Criterion<T> | Array<Criterion<T>>>\n): T[] {\n  const length = criteria.length;\n  // Enables use as an iteratee for methods like `_.reduce` and `_.map`.\n  if (length > 1 && isIterateeCall(collection, criteria[0], criteria[1])) {\n    criteria = [];\n  } else if (length > 2 && isIterateeCall(criteria[0], criteria[1], criteria[2])) {\n    criteria = [criteria[0]];\n  }\n  return orderBy(collection, flatten(criteria), ['asc']);\n}\n","import { sortedIndexBy } from './sortedIndexBy';\nimport { isNil, isNull, isSymbol } from '../../predicate';\nimport { isNumber } from '../predicate/isNumber';\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @category Array\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * sortedIndex([30, 50], 40)\n * // => 1\n */\nexport function sortedIndex<T>(array: ArrayLike<T> | null | undefined, value: T): number {\n  if (isNil(array)) {\n    return 0;\n  }\n  let low = 0,\n    high = isNil(array) ? low : array.length;\n\n  if (isNumber(value) && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n    while (low < high) {\n      const mid = (low + high) >>> 1;\n      const compute = array[mid];\n      if (!isNull(compute) && !isSymbol(compute) && (compute as any) < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n  return sortedIndexBy(array, value, value => value);\n}\n","/**\n * Creates a new function that spreads elements of an array argument into individual arguments\n * for the original function. The array argument is positioned based on the `argsIndex` parameter.\n *\n * @template F - A function type with any number of parameters and any return type.\n * @param {F} func - The function to be transformed. It can be any function with any number of arguments.\n * @param {number} [argsIndex=0] - The index where the array argument is positioned among the other arguments.\n *   If `argsIndex` is negative or `NaN`, it defaults to `0`. If it's a fractional number, it is rounded to the nearest integer.\n * @returns {(...args: any[]) => ReturnType<F>} - A new function that takes multiple arguments, including an array of arguments at the specified `argsIndex`,\n *   and returns the result of calling the original function with those arguments.\n *\n * @example\n * function add(a, b) {\n *   return a + b;\n * }\n *\n * const spreadAdd = spread(add);\n * console.log(spreadAdd([1, 2])); // Output: 3\n *\n * @example\n * // Example function to spread arguments over\n * function add(a, b) {\n *   return a + b;\n * }\n *\n * // Create a new function that uses `spread` to combine arguments\n * const spreadAdd = spread(add, 1);\n *\n * // Calling `spreadAdd` with an array as the second argument\n * console.log(spreadAdd(1, [2])); // Output: 3\n *\n * @example\n * // Function with default arguments\n * function greet(name, greeting = 'Hello') {\n *   return `${greeting}, ${name}!`;\n * }\n *\n * // Create a new function that uses `spread` to position the argument array at index 0\n * const spreadGreet = spread(greet, 0);\n *\n * // Calling `spreadGreet` with an array of arguments\n * console.log(spreadGreet(['Alice'])); // Output: Hello, Alice!\n * console.log(spreadGreet(['Bob', 'Hi'])); // Output: Hi, Bob!\n */\nexport function spread<F extends (...args: any[]) => any>(func: F, argsIndex = 0): (...args: any[]) => ReturnType<F> {\n  argsIndex = Number.parseInt(argsIndex as any, 10);\n\n  if (Number.isNaN(argsIndex) || argsIndex < 0) {\n    argsIndex = 0;\n  }\n\n  return function (this: any, ...args: any[]) {\n    const array = args[argsIndex];\n    const params = args.slice(0, argsIndex);\n\n    if (array) {\n      params.push(...array);\n    }\n\n    return func.apply(this, params);\n  };\n}\n","import { words as getWords } from '../../string/words.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\n *\n * Start case is the naming convention in which each word is written with an initial capital letter.\n * @param {string | object} str - The string to convert.\n * @returns {string} The converted string.\n *\n * @example\n * const result1 = startCase('hello world');  // result will be 'Hello World'\n * const result2 = startCase('HELLO WORLD');  // result will be 'HELLO WORLD'\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\n */\nexport function startCase(str?: string | object): string {\n  const words = getWords(normalizeForCase(str).trim());\n\n  let result = '';\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n\n    if (result) {\n      result += ' ';\n    }\n\n    if (word === word.toUpperCase()) {\n      result += word;\n    } else {\n      result += word[0].toUpperCase() + word.slice(1).toLowerCase();\n    }\n  }\n\n  return result;\n}\n","/**\n * Checks if a string contains another string at the beginning of the string.\n *\n * Checks if one string startsWith another string. Optional position parameter to start searching from a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional offset to start searching in the str string\n * @returns {boolean} - True if the str string starts with the target string.\n *\n * @example\n * const isPrefix = startsWith('fooBar', 'foo') // returns true\n * const isPrefix = startsWith('fooBar', 'bar') // returns false\n * const isPrefix = startsWith('fooBar', 'abc') // returns false\n * const isPrefix = startsWith('fooBar', 'Bar', 2) // returns true\n * const isPrefix = startsWith('fooBar', 'Bar', 5) // returns false\n */\nexport function startsWith(str: string, target: string, position = 0): boolean {\n  return str.startsWith(target, position);\n}\n","/**\n * Returns a new empty array.\n *\n * @returns {Array} A new empty array.\n * @example\n * stubArray() // Returns []\n */\nexport function stubArray(): [] {\n  return [];\n}\n","/**\n * Returns false.\n *\n * @returns {boolean} false.\n * @example\n * stubFalse() // Returns false\n */\nexport function stubFalse(): boolean {\n  return false;\n}\n","/**\n * Returns an empty object.\n *\n * @returns {Object} An empty object.\n * @example\n * stubObject() // Returns {}\n */\nexport function stubObject(): {} {\n  return {};\n}\n","/**\n * Returns an empty string.\n *\n * @returns {string} An empty string.\n * @example\n * stubString() // Returns ''\n */\nexport function stubString(): '' {\n  return '';\n}\n","/**\n * Returns true.\n *\n * @returns {boolean} true.\n * @example\n * stubTrue() // Returns true\n */\nexport function stubTrue(): boolean {\n  return true;\n}\n","/**\n * Subtracts one number from another.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number. (minuend)\n * @param {number} other The second number.(subtrahend)\n * @returns {number} The difference of the two numbers, or `NaN` if any input is `NaN`.\n *\n * @example\n * subtract(6, 3); // => 3\n * subtract(6, NaN); // => NaN\n * subtract(NaN, 3); // => NaN\n */\nexport function subtract(value: number, other: number): number {\n  return value - other;\n}\n","import { sumBy } from './sumBy.ts';\n\n/**\n * Computes the sum of the `number` values in `array`.\n *\n * @param {ArrayLike<number> | null | undefined} array - The array to iterate over.\n * @returns {number} Returns the sum.\n *\n * @example\n * sum([1, 2, 3]); // => 6\n * sum(null); // => 0\n * sum(undefined); // => 0\n */\nexport function sum(array: ArrayLike<number> | null | undefined): number;\n\n/**\n * Computes the sum of the `bigint` values in `array`.\n *\n * @param {ArrayLike<bigint>} array - The array to iterate over.\n * @returns {bigint} Returns the sum.\n *\n * @example\n * sum([1n, 2n, 3n]); // => 6n\n */\nexport function sum(array: ArrayLike<bigint>): bigint;\n\n/**\n * Computes the sum of the values in `array`.\n *\n * It does not coerce values to `number`.\n *\n * @param {ArrayLike<unknown> | null | undefined} array - The array to iterate over.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sum([\"1\", \"2\"]); // => \"12\"\n * sum([1, undefined, 2]); // => 3\n */\nexport function sum(array: ArrayLike<unknown> | null | undefined): unknown;\n\n/**\n * Computes the sum of the values that are returned by the `iteratee` function.\n *\n * It does not coerce values to `number`.\n *\n * @param {ArrayLike<unknown> | null | undefined} array - The array to iterate over.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sum([1, 2, 3]); // => 6\n * sum([1n, 2n, 3n]); // => 6n\n * sum([\"1\", \"2\"]); // => \"12\"\n * sum([1, undefined, 2]); // => 3\n * sum(null); // => 0\n * sum(undefined); // => 0\n */\nexport function sum(array: ArrayLike<unknown> | null | undefined): unknown {\n  return sumBy(array);\n}\n","import { tail as tailToolkit } from '../../array/tail.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return tailToolkit(toArray(arr));\n}\n","/**\n * Returns an empty array when the input is a single-element array.\n *\n * @template T - The type of the single element in the array.\n * @param {[T]} arr - The single-element array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [1];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input is an empty array.\n *\n * @template T - The type of elements in the array.\n * @param {[]} arr - The empty array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail(arr: readonly []): [];\n\n/**\n * Returns a new array with all elements except for the first when the input is a tuple array.\n *\n * @template T - The type of the first element in the tuple array.\n * @template U - The type of the remaining elements in the tuple array.\n * @param {[T, ...U[]]} arr - The tuple array to process.\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr = [1, 2, 3];\n * const result = tail(arr);\n * // result will be [2, 3]\n */\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[] {\n  return arr.slice(1);\n}\n","import { take as takeToolkit } from '../../array/take.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {ArrayLike<T> | null | undefined} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: ArrayLike<T> | null | undefined, count = 1, guard?: unknown): T[] {\n  count = guard ? 1 : toInteger(count);\n  if (count < 1 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return takeToolkit(toArray(arr), count);\n}\n","/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {number} count - The number of elements to take.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: readonly T[], count: number): T[] {\n  return arr.slice(0, count);\n}\n","import { takeRight as takeRightToolkit } from '../../array/takeRight.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: ArrayLike<T> | null | undefined, count = 1, guard?: unknown): T[] {\n  count = guard ? 1 : toInteger(count);\n  if (count <= 0 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return takeRightToolkit(toArray(arr), count);\n}\n","/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: readonly T[], count = 1): T[] {\n  if (count <= 0) {\n    return [];\n  }\n\n  return arr.slice(-count);\n}\n","import { negate } from '../../function/negate.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a slice of array.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @returns {T[]} - A slice of the array or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * const items = [1, 2, 3];\n * const result = takeRightWhile(items);\n * console.log(result); // [1, 2, 3]\n *\n * const result2 = takeRightWhile(null);\n * console.log(result2); // []\n */\nexport function takeRightWhile<T>(array: ArrayLike<T> | null | undefined): T[];\n\n/**\n * Creates a slice of array with elements taken from the end until the predicate function returns falsey.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {(item: T, index: number, array: T[]) => unknown} predicate - A function invoked per iteration. Returns a truthy value to continue taking elements.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * const items = [1, 2, 3, 4, 5];\n * const result = takeRightWhile(items, (item) => item > 3);\n * console.log(result); // [4, 5]\n */\nexport function takeRightWhile<T>(\n  array: ArrayLike<T> | null | undefined,\n  predicate: (item: T, index: number, array: T[]) => unknown\n): T[];\n\n/**\n * Creates a slice of array with elements taken from the end until the element does not match the given object.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {Partial<T>} matches - A partial object that specifies the properties to match.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * const items = [{ id: 10 }, { id: 20 }, { id: 30 }];\n * const result = takeRightWhile(items, { id: 30 });\n * console.log(result); // [{ id: 30 }]\n */\nexport function takeRightWhile<T>(array: ArrayLike<T> | null | undefined, matches: Partial<T>): T[];\n\n/**\n * Creates a slice of array with elements taken from the end until the element does not match the given property key and value.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {[keyof T, unknown]} matchesProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * const items = [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Alice' }];\n * const result = takeRightWhile(items, ['name', 'Alice']);\n * console.log(result); // [{ name: 'Alice' }]\n */\nexport function takeRightWhile<T>(array: ArrayLike<T> | null | undefined, matchesProperty: [keyof T, unknown]): T[];\n\n/**\n * Creates a slice of array with elements taken from the end until the element does not have a truthy value for the given property key.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {PropertyKey} property - A property key. Elements are included if they have a truthy value for this key.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * const items = [{ valid: false }, { valid: true }, { valid: true }];\n * const result = takeRightWhile(items, 'valid');\n * console.log(result); // [{ valid: true }, { valid: true }]\n */\nexport function takeRightWhile<T>(array: ArrayLike<T> | null | undefined, property: PropertyKey): T[];\n\n/**\n * Creates a slice of the array with elements taken from the end while the specified predicate is satisfied.\n * If no predicate is provided, the identity function is used by default.\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {(item: T, index: number, array: T[]) => unknown | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate] - The condition used to determine elements to include. Can be:\n * - A function invoked per iteration.\n * - A partial object to match properties.\n * - A key-value pair as a tuple.\n * - A property key to check for truthy values.\n * Defaults to the identity function if not provided.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = takeRightWhile(items, (item) => item > 3);\n * console.log(result); // [4, 5]\n *\n * // Using a partial object\n * const items2 = [{ id: 10 }, { id: 20 }, { id: 30 }];\n * const result2 = takeRightWhile(items2, { id: 30 });\n * console.log(result2); // [{ id: 30 }]\n *\n * // Using a key-value pair\n * const items3 = [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Alice' }];\n * const result3 = takeRightWhile(items3, ['name', 'Alice']);\n * console.log(result3); // [{ name: 'Alice' }]\n *\n * // Using a property key\n * const items4 = [{ active: false }, { active: true }, { active: true }];\n * const result4 = takeRightWhile(items4, 'active');\n * console.log(result4); // [{ active: true }, { active: true }]\n *\n * // No predicate provided\n * const items5 = [false, true];\n * const result5 = takeRightWhile(items5);\n * console.log(result5); // [true]\n *\n * // null or undefined array\n * const result6 = takeRightWhile(null);\n * console.log(result6); // []\n */\nexport function takeRightWhile<T>(\n  _array: ArrayLike<T> | null | undefined,\n  predicate?:\n    | ((value: T, index: number, array: ArrayLike<T>) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey\n): T[] {\n  if (!isArrayLikeObject(_array)) {\n    return [];\n  }\n\n  const array = toArray(_array);\n  const index = array.findLastIndex(negate(createIteratee(predicate)));\n\n  return array.slice(index + 1);\n}\n","/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template F - The type of the function to negate.\n * @param {F} func - The function to negate.\n * @returns {F} The new negated function, which negates the boolean result of `func`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5, 6];\n * const isEven = (n: number) => n % 2 === 0;\n * const result = array.filter(negate(isEven));\n * // result will be [1, 3, 5]\n */\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\n  return ((...args: any[]) => !func(...args)) as F;\n}\n","/**\n * Returns a new array containing the leading elements of the provided array\n * that satisfy the provided predicate function. It stops taking elements as soon\n * as an element does not satisfy the predicate.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(element: T) => boolean} shouldContinueTaking - The predicate function that is called with each element. Elements are included in the result as long as this function returns true.\n * @returns {T[]} A new array containing the leading elements that satisfy the predicate.\n *\n * @example\n * // Returns [1, 2]\n * takeWhile([1, 2, 3, 4], x => x < 3);\n *\n * @example\n * // Returns []\n * takeWhile([1, 2, 3, 4], x => x > 3);\n */\nexport function takeWhile<T>(arr: readonly T[], shouldContinueTaking: (element: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (!shouldContinueTaking(item)) {\n      break;\n    }\n\n    result.push(item);\n  }\n\n  return result;\n}\n","import { debounce, type DebouncedFunction } from './debounce.ts';\n\ninterface ThrottleOptions {\n  /**\n   * An optional AbortSignal to cancel the function invocation on the trailing edge.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * If `true`, the function will be invoked on the leading edge of the timeout.\n   * @default true\n   */\n  leading?: boolean;\n\n  /**\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\n   * @default true\n   */\n  trailing?: boolean;\n}\n\n/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @param {ThrottleOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<F extends (...args: any[]) => any>(\n  func: F,\n  throttleMs = 0,\n  options: ThrottleOptions = {}\n): DebouncedFunction<F> {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  const { leading = true, trailing = true, signal } = options;\n\n  return debounce(func, throttleMs, {\n    leading,\n    trailing,\n    signal,\n    maxWait: throttleMs,\n  });\n}\n","import { isArrayLike } from '../predicate/isArrayLike';\nimport { isMap } from '../predicate/isMap';\n\n/**\n * Converts a value to an array.\n *\n * @param {unknown} value - The value to convert.\n * @returns {any[]} Returns the converted array.\n *\n * @example\n * toArray({ 'a': 1, 'b': 2 }) // => returns [1,2]\n * toArray('abc') // => returns ['a', 'b', 'c']\n * toArray(1) // => returns []\n * toArray(null) // => returns []\n */\n\nexport function toArray(value?: unknown): any[] {\n  if (value == null) {\n    return [];\n  }\n\n  if (isArrayLike(value) || isMap(value)) {\n    return Array.from(value);\n  }\n\n  if (typeof value === 'object') {\n    return Object.values(value);\n  }\n\n  return [];\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { defaults } from './defaults.ts';\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @param {T} object - The target object.\n * @returns {T} The cloned object.\n */\nexport function toDefaulted<T extends object>(object: T): T;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S} source - The object that specifies the default values to apply.\n * @returns {NonNullable<T & S>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, source: S): NonNullable<T & S>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S1 extends object, S2 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2\n): NonNullable<T & S1 & S2>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S1 extends object, S2 extends object, S3 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3\n): NonNullable<T & S1 & S2 & S3>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @template S4 - The type of the fourth object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @param {S4} source4 - The fourth object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3 & S4>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<\n  T extends object,\n  S1 extends object,\n  S2 extends object,\n  S3 extends object,\n  S4 extends object,\n>(object: T, source1: S1, source2: S2, source3: S3, source4: S4): NonNullable<T & S1 & S2 & S3 & S4>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} sources - The objects that specifies the default values to apply.\n * @returns {object} A new object that combines the target and default values, ensuring no properties are left undefined.\n *\n * @example\n * toDefaulted({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: null }, { a: 1 }); // { a: null }\n * toDefaulted({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, ...sources: S[]): object;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} sources - The objects that specifies the default values to apply.\n * @returns {object} A new object that combines the target and default values, ensuring no properties are left undefined.\n *\n * @example\n * toDefaulted({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: null }, { a: 1 }); // { a: null }\n * toDefaulted({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, ...sources: S[]): object {\n  const cloned = cloneDeep(object);\n\n  return defaults(cloned, ...sources);\n}\n","/**\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\n * This function does not mutate the original array.\n *\n * @template T - The type of elements in the original array.\n * @template U - The type of the value to fill the new array with.\n * @param {Array<T>} arr - The array to base the new array on.\n * @param {U} value - The value to fill the new array with.\n * @returns {Array<T | U>} The new array with the filled values.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * let result = toFilled(array, '*', 2);\n * console.log(result); // [1, 2, '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', 1, 4);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*');\n * console.log(result); // ['*', '*', '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', -4, -1);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n */\nexport function toFilled<T, U>(arr: readonly T[], value: U): Array<T | U>;\n\n/**\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\n * This function does not mutate the original array.\n *\n * @template T - The type of elements in the original array.\n * @template U - The type of the value to fill the new array with.\n * @param {Array<T>} arr - The array to base the new array on.\n * @param {U} value - The value to fill the new array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @returns {Array<T | U>} The new array with the filled values.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * let result = toFilled(array, '*', 2);\n * console.log(result); // [1, 2, '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', 1, 4);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*');\n * console.log(result); // ['*', '*', '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', -4, -1);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n */\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number): Array<T | U>;\n\n/**\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\n * This function does not mutate the original array.\n *\n * @template T - The type of elements in the original array.\n * @template U - The type of the value to fill the new array with.\n * @param {Array<T>} arr - The array to base the new array on.\n * @param {U} value - The value to fill the new array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The new array with the filled values.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * let result = toFilled(array, '*', 2);\n * console.log(result); // [1, 2, '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', 1, 4);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*');\n * console.log(result); // ['*', '*', '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', -4, -1);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n */\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number, end: number): Array<T | U>;\n\n/**\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\n * This function does not mutate the original array.\n *\n * @template T - The type of elements in the original array.\n * @template U - The type of the value to fill the new array with.\n * @param {Array<T>} arr - The array to base the new array on.\n * @param {U} value - The value to fill the new array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The new array with the filled values.\n */\nexport function toFilled<T, U>(arr: readonly T[], value: U, start = 0, end = arr.length): Array<T | U> {\n  const length = arr.length;\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\n\n  const newArr: Array<T | U> = arr.slice();\n\n  for (let i = finalStart; i < finalEnd; i++) {\n    newArr[i] = value;\n  }\n\n  return newArr;\n}\n","import { MAX_ARRAY_LENGTH } from '../_internal/MAX_ARRAY_LENGTH.ts';\nimport { clamp } from '../math/clamp.ts';\n\n/**\n * Converts the value to a valid index. A valid index is an integer that is greater than or equal to `0` and less than or equal to `2^32 - 1`.\n *\n * It converts the given value to a number and floors it to an integer. If the value is less than `0`, it returns `0`. If the value exceeds `2^32 - 1`, it returns `2^32 - 1`.\n *\n * @param {unknown} value - The value to convert to a valid index.\n * @returns {number} The converted value.\n *\n * @example\n * toLength(3.2)  // => 3\n * toLength(-1)   // => 0\n * toLength(1.9)  // => 1\n * toLength('42') // => 42\n * toLength(null) // => 0\n */\nexport function toLength(value?: unknown): number {\n  if (value == null) {\n    return 0;\n  }\n\n  const length = Math.floor(Number(value));\n\n  return clamp(length, 0, MAX_ARRAY_LENGTH);\n}\n","export const MAX_ARRAY_LENGTH = 4_294_967_295;\n","import { toString } from '../util/toString.ts';\n\n/**\n * Converts the given value to a string and transforms it to lower case.\n * The function can handle various input types by first converting them to strings.\n *\n * @param {unknown} [value=''] The value to convert.\n * @returns {string} Returns the lower cased string.\n * @example\n *\n * toLower('--FOO-BAR--');\n * // => '--foo-bar--'\n *\n * toLower(null);\n * // => ''\n *\n * toLower([1, 2, 3]);\n * // => '1,2,3'\n */\nexport function toLower(value?: unknown): string {\n  return toString(value).toLowerCase();\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { merge } from './merge.ts';\n\n/**\n * Merges the properties of the source object into a deep clone of the target object.\n * Unlike `merge`, This function does not modify the original target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n *\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function does not mutate the target object.\n *\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function toMerged<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>>(\n  target: T,\n  source: S\n): T & S {\n  return merge(cloneDeep(target), source);\n}\n","import { keysIn } from '../object/keysIn.ts';\n\n/**\n * Converts value to a plain object flattening inherited enumerable string keyed properties of value to own properties of the plain object.\n *\n * @param {any} value The value to convert.\n * @returns {Record<string, any>} Returns the converted plain object.\n *\n * @example\n * function Foo() {\n *   this.b = 2;\n * }\n * Foo.prototype.c = 3;\n * toPlainObject(new Foo()); // { b: 2, c: 3 }\n */\nexport function toPlainObject(value: any): Record<string, any> {\n  const plainObject: Record<string, any> = {};\n  const valueKeys = keysIn(value);\n\n  for (let i = 0; i < valueKeys.length; i++) {\n    const key = valueKeys[i];\n    const objValue = (value as any)[key];\n    if (key === '__proto__') {\n      Object.defineProperty(plainObject, key, {\n        configurable: true,\n        enumerable: true,\n        value: objValue,\n        writable: true,\n      });\n    } else {\n      plainObject[key] = objValue;\n    }\n  }\n  return plainObject;\n}\n","import { toInteger } from './toInteger.ts';\nimport { MAX_SAFE_INTEGER } from '../_internal/MAX_SAFE_INTEGER.ts';\nimport { clamp } from '../math/clamp.ts';\n\n/**\n * Converts `value` to a safe integer.\n *\n * A safe integer can be compared and represented correctly.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the value converted to a safe integer.\n *\n * @example\n * toSafeInteger(3.2); // => 3\n * toSafeInteger(Number.MAX_VALUE); // => 9007199254740991\n * toSafeInteger(Infinity); // => 9007199254740991\n * toSafeInteger('3.2'); // => 3\n * toSafeInteger(NaN); // => 0\n * toSafeInteger(null); // => 0\n * toSafeInteger(-Infinity); // => -9007199254740991\n */\nexport function toSafeInteger(value?: unknown): number {\n  if (value == null) {\n    return 0;\n  }\n\n  return clamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n}\n","import { toString } from '../util/toString';\n\n/**\n * Converts `string`, as a whole, to upper case just like\n * [String#toUpperCase](https://mdn.io/toUpperCase).\n *\n * @param {unknown} [value=''] The value to convert.\n * @returns {string} Returns the upper cased string.\n * @example\n *\n * toUpper('--foo-bar--');\n * // => '--FOO-BAR--'\n *\n * toUpper(null);\n * // => ''\n *\n * toUpper([1, 2, 3]);\n * // => '1,2,3'\n */\nexport function toUpper(value?: unknown): string {\n  return toString(value).toUpperCase();\n}\n","import { trim as trimToolkit } from '../../string/trim.ts';\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading and trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\n * @returns {string} - The resulting string after the specified leading and trailing characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(str: string, chars?: string | string[], guard?: unknown): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trim();\n  }\n\n  switch (typeof chars) {\n    case 'string': {\n      return trimToolkit(str, chars.toString().split(''));\n    }\n    case 'object': {\n      if (Array.isArray(chars)) {\n        return trimToolkit(\n          str,\n          chars.flatMap(x => x.toString().split(''))\n        );\n      } else {\n        return trimToolkit(str, (chars as any).toString().split(''));\n      }\n    }\n  }\n}\n","import { trimEnd as trimEndToolkit } from '../../string/trimEnd.ts';\n\n/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\n * @returns {string} - The resulting string after the specified trailing character has been removed.\n *\n * @example\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\n */\nexport function trimEnd(str: string, chars?: string | string[], guard?: unknown): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trimEnd();\n  }\n\n  switch (typeof chars) {\n    case 'string': {\n      return trimEndToolkit(str, chars.toString().split(''));\n    }\n    case 'object': {\n      if (Array.isArray(chars)) {\n        return trimEndToolkit(\n          str,\n          chars.flatMap(x => x.toString().split(''))\n        );\n      } else {\n        return trimEndToolkit(str, (chars as any).toString().split(''));\n      }\n    }\n  }\n}\n","import { trimStart as trimStartToolkit } from '../../string/trimStart.ts';\n\n/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\n * @returns {string} - The resulting string after the specified leading character has been removed.\n *\n * @example\n * const trimmedStr1 = ltrim('---hello', '-') // returns 'hello'\n * const trimmedStr2 = ltrim('000123', '0') // returns '123'\n * const trimmedStr3 = ltrim('abcabcabc', 'a') // returns 'bcabcabc'\n * const trimmedStr4 = ltrim('xxxtrimmed', 'x') // returns 'trimmed'\n */\nexport function trimStart(str: string, chars?: string | string[], guard?: unknown): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trimStart();\n  }\n\n  switch (typeof chars) {\n    case 'string': {\n      return trimStartToolkit(str, chars.toString().split(''));\n    }\n    case 'object': {\n      if (Array.isArray(chars)) {\n        return trimStartToolkit(\n          str,\n          chars.flatMap(x => x.toString().split(''))\n        );\n      } else {\n        return trimStartToolkit(str, (chars as any).toString().split(''));\n      }\n    }\n  }\n}\n","import { ary } from './ary.ts';\n\n/**\n * Creates a function that accepts up to one argument, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a, b, c) {\n *   console.log(arguments);\n * }\n *\n * unary(fn)(1, 2, 3); // [Arguments] { '0': 1 }\n */\nexport function unary<F extends (...args: any[]) => any>(func: F): (...args: any[]) => ReturnType<F> {\n  return ary(func, 1);\n}\n","import { unescape as unescapeToolkit } from '../../string/unescape.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\n * It is the inverse of `escape`.\n *\n * @param {string} str The string to unescape.\n * @returns {string} Returns the unescaped string.\n *\n * @example\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\n */\nexport function unescape(str?: string): string {\n  return unescapeToolkit(toString(str));\n}\n","import { flatten } from './flatten.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * This function takes multiple arrays and returns a new array containing only the unique values\n * from all input arrays, preserving the order of their first occurrence.\n *\n * @template T - The type of elements in the arrays.\n * @param {Array<ArrayLike<T> | null | undefined>} arrays - The arrays to inspect.\n * @returns {T[]} Returns the new array of combined unique values.\n *\n * @example\n * // Returns [2, 1]\n * union([2], [1, 2]);\n *\n * @example\n * // Returns [2, 1, 3]\n * union([2], [1, 2], [2, 3]);\n *\n * @example\n * // Returns [1, 3, 2, [5], [4]] (does not deeply flatten nested arrays)\n * union([1, 3, 2], [1, [5]], [2, [4]]);\n *\n * @example\n * // Returns [0, 2, 1] (ignores non-array values like 3 and { '0': 1 })\n * union([0], 3, { '0': 1 }, null, [2, 1]);\n * @example\n * // Returns [0, 'a', 2, 1] (treats array-like object { 0: 'a', length: 1 } as a valid array)\n * union([0], { 0: 'a', length: 1 }, [2, 1]);\n */\nexport function union<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[] {\n  const validArrays = arrays.filter(isArrayLikeObject);\n\n  const flattened = flatten(validArrays, 1);\n\n  return uniq(flattened) as T[];\n}\n","import { uniqBy as uniqByToolkit } from '../../array/uniqBy.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a duplicate-free version of an array using a transform function for comparison.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * uniqBy([1, 2, 3, 1]);\n * // => [1, 2, 3]\n */\nexport function uniqBy<T>(array: ArrayLike<T>): T[];\n/**\n * Creates a duplicate-free version of an array using a transform function for comparison.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @param {(value: T) => unknown} iteratee - The transform function.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n */\nexport function uniqBy<T>(array: ArrayLike<T>, iteratee: (value: T) => unknown): T[];\n\n/**\n * Creates a duplicate-free version of an array using a property name for comparison.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @param {PropertyKey} iteratee - The property path to get values from.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * const users = [\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 37 }\n * ];\n * uniqBy(users, 'user');\n * // => [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }]\n */\nexport function uniqBy<T>(array: ArrayLike<T>, iteratee: PropertyKey): T[];\n/**\n * Creates a duplicate-free version of an array using a property name for comparison.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @param {Partial<T>} iteratee - The partial object to get values from.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * const users = [\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 37 }\n * ];\n * uniqBy(users, { 'user': 'barney'});\n * // => [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }]\n */\nexport function uniqBy<T>(array: ArrayLike<T>, iteratee: Partial<T>): T[];\n/**\n * Creates a duplicate-free version of an array using a property name for comparison.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @param {[keyof T, unknown]} iteratee - The property-value pair to get values from.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * const users = [\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 37 }\n * ];\n * uniqBy(users, ['user', 'barney']);\n * // => [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }]\n */\nexport function uniqBy<T>(array: ArrayLike<T>, iteratee: [keyof T, unknown]): T[];\n/**\n * Creates a duplicate-free version of an array, combining multiple arrays and using an optional transform function.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array to inspect.\n * @param {((value: T) => unknown) | PropertyKey | [keyof T, unknown] | Partial<T>} iteratee - The transform function or property name to get values from.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * uniqBy([1, 2], [2, 3], [3, 4], Math.floor);\n * // => [1, 2, 3, 4]\n */\nexport function uniqBy<T>(\n  array: ArrayLike<T> | null | undefined,\n  iteratee?: ((value: T) => unknown) | PropertyKey | [keyof T, unknown] | Partial<T>\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  return uniqByToolkit(Array.from(array), createIteratee(iteratee));\n}\n","import { unzip as unzipToolkit } from '../../array/unzip.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {T[][] | ArrayLike<ArrayLike<T>> | null | undefined} array - The nested array to unzip.\n * @returns {T[][]} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T>(array: T[][] | ArrayLike<ArrayLike<T>> | null | undefined): T[][] {\n  if (!isArrayLikeObject(array) || !array.length) {\n    return [];\n  }\n  if (Array.isArray(array)) {\n    return unzipToolkit(array);\n  }\n  return unzipToolkit(Array.from(array, value => Array.from(value)));\n}\n","/**\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\n *\n * @template T, R\n * @param {T[][]} target - The nested array to unzip. This is an array of arrays,\n * where each inner array contains elements to be unzipped.\n * @param {(...args: T[]) => R} iteratee - A function to transform the unzipped elements.\n * @returns {R[]} A new array of unzipped and transformed elements.\n *\n * @example\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\n * const result = unzipWith(nestedArray, (item, item2, item3) => item + item2 + item3);\n * // result will be [9, 12]\n */\nexport function unzipWith<T, R>(target: readonly T[][], iteratee: (...args: T[]) => R): R[] {\n  const maxLength = Math.max(...target.map(innerArray => innerArray.length));\n  const result: R[] = new Array(maxLength);\n\n  for (let i = 0; i < maxLength; i++) {\n    const group = new Array(target.length);\n\n    for (let j = 0; j < target.length; j++) {\n      group[j] = target[j][i];\n    }\n\n    result[i] = iteratee(...group);\n  }\n\n  return result;\n}\n","import { upperCase as upperCaseToolkit } from '../../string/upperCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to upper case.\n *\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\n *\n * @param {string | object} str - The string that is to be changed to upper case.\n * @returns {string} - The converted string to upper case.\n *\n * @example\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\n */\nexport function upperCase(str?: string | object): string {\n  return upperCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to upper case.\n *\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\n *\n * @param {string} str - The string that is to be changed to upper case.\n * @returns {string} - The converted string to upper case.\n *\n * @example\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\n */\nexport function upperCase(str: string): string {\n  const words = getWords(str);\n\n  let result = '';\n\n  for (let i = 0; i < words.length; i++) {\n    result += words[i].toUpperCase();\n    if (i < words.length - 1) {\n      result += ' ';\n    }\n  }\n\n  return result;\n}\n","import { upperFirst as upperFirstToolkit } from '../../string/upperFirst.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the first character of string to upper case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = upperFirst('fred') // returns 'Fred'\n * const convertedStr2 = upperFirst('Fred') // returns 'Fred'\n * const convertedStr3 = upperFirst('FRED') // returns 'FRED'\n */\nexport function upperFirst(str?: string): string {\n  return upperFirstToolkit(toString(str));\n}\n","/**\n * Converts the first character of string to upper case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = upperFirst('fred') // returns 'Fred'\n * const convertedStr2 = upperFirst('Fred') // returns 'Fred'\n * const convertedStr3 = upperFirst('FRED') // returns 'FRED'\n */\nexport function upperFirst(str: string): string {\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\n}\n","/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @param {Record<PropertyKey, T> | null | undefined} object The object to query.\n * @returns {T[]} Returns an array of property values.\n * @example\n * const object = { a: 1, b: 2 };\n * values(object); // => [1, 2]\n */\nexport function values<T>(object: Record<PropertyKey, T> | null | undefined): T[];\n\n/**\n * Creates an array of the values of an array or array-like object.\n *\n * @param {ArrayLike<T>} arr The array or array-like object to query.\n * @returns {T[]} Returns an array of values.\n * @example\n * const array = ['a', 'b'];\n * values(arrayLike); // => ['a', 'b']\n */\nexport function values<T>(arr: ArrayLike<T>): T[];\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @param {T | null | undefined} object The object to query.\n * @returns {Array<T[keyof T]>} Returns an array of property values.\n * @example\n * const obj = { x: 1, y: 2, z: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @param {any} object The object to query.\n * @returns {any[]} Returns an array of property values.\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values(object: any): any[] {\n  return Object.values(object);\n}\n","import { keysIn } from './keysIn';\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {Record<PropertyKey, T> | null | undefined} object The object to query.\n * @returns {T[]} Returns an array of property values.\n * @example\n * const object = { a: 1, b: 2 };\n * valuesIn(object); // => [1, 2]\n *\n * const arr = [1, 2, 3];\n * valuesIn(arr); // => [1, 2, 3]\n *\n * function Foo() {\n *   this.a = 1;\n * }\n * Foo.prototype.b = 2;\n * const foo = new Foo();\n * valuesIn(foo); // => [1] (includes inherited properties)\n *\n * const objWithLength = { 0: 'a', 1: 'b', length: 2 };\n * valuesIn(objWithLength); // => ['a', 'b', 2]\n */\nexport function valuesIn<T>(object: Record<PropertyKey, T> | null | undefined): T[];\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {ArrayLike<T>} arr The array or array-like object to query.\n * @returns {T[]} Returns an array of values.\n * @example\n * const arrayLike = { 0: 'a', 1: 'b', length: 2 };\n * valuesIn(arrayLike); // => ['a', 'b']\n */\nexport function valuesIn<T>(arr: ArrayLike<T>): T[];\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {T | null | undefined} object The object to query.\n * @returns {Array<T[keyof T]>} Returns an array of property values.\n * @example\n * const obj = { x: 1, y: 2, z: 3 };\n * valuesIn(obj); // => [1, 2, 3]\n */\nexport function valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {any} object The object to query.\n * @returns {any[]} Returns an array of property values.\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * valuesIn(obj); // => [1, 2, 3]\n */\nexport function valuesIn(object: any): any[] {\n  const keys = keysIn(object);\n  const result: any[] = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    result[i] = object[key];\n  }\n\n  return result;\n}\n","/**\n * Options for the windowed function.\n *\n * @interface WindowedOptions\n * @property {boolean} [partialWindows=false] - Whether to include partial windows at the end of the array.\n */\nexport interface WindowedOptions {\n  /**\n   * Whether to include partial windows at the end of the array.\n   *\n   * By default, `windowed` only includes full windows in the result,\n   * ignoring any leftover elements that can't form a full window.\n   *\n   * If `partialWindows` is true, the function will also include these smaller, partial windows at the end of the result.\n   */\n  partialWindows?: boolean;\n}\n\n/**\n * Creates an array of sub-arrays (windows) from the input array, each of the specified size.\n * The windows can overlap depending on the step size provided.\n *\n * By default, only full windows are included in the result, and any leftover elements that can't form a full window are ignored.\n *\n * If the `partialWindows` option is set to true in the options object, the function will also include partial windows at the end of the result.\n * Partial windows are smaller sub-arrays created when there aren't enough elements left in the input array to form a full window.\n *\n * @template T\n * @param {readonly T[]} arr - The input array to create windows from.\n * @param {number} size - The size of each window. Must be a positive integer.\n * @param {number} [step=1] - The step size between the start of each window. Must be a positive integer.\n * @param {WindowedOptions} [options={}] - Options object to configure the behavior of the function.\n * @param {boolean} [options.partialWindows=false] - Whether to include partial windows at the end of the array.\n * @returns {T[][]} An array of windows (sub-arrays) created from the input array.\n * @throws {Error} If the size or step is not a positive integer.\n *\n * @example\n * windowed([1, 2, 3, 4], 2);\n * // => [[1, 2], [2, 3], [3, 4]]\n *\n * @example\n * windowed([1, 2, 3, 4, 5, 6], 3, 2);\n * // => [[1, 2, 3], [3, 4, 5]]\n *\n * @example\n * windowed([1, 2, 3, 4, 5, 6], 3, 2, { partialWindows: true });\n * // => [[1, 2, 3], [3, 4, 5], [5, 6]]\n */\nexport function windowed<T>(\n  arr: readonly T[],\n  size: number,\n  step: number = 1,\n  { partialWindows = false }: WindowedOptions = {}\n): T[][] {\n  if (size <= 0 || !Number.isInteger(size)) {\n    throw new Error('Size must be a positive integer.');\n  }\n\n  if (step <= 0 || !Number.isInteger(step)) {\n    throw new Error('Step must be a positive integer.');\n  }\n\n  const result: T[][] = [];\n  const end = partialWindows ? arr.length : arr.length - size + 1;\n\n  for (let i = 0; i < end; i += step) {\n    result.push(arr.slice(i, i + size));\n  }\n\n  return result;\n}\n","import { timeout } from './timeout.ts';\n\n/**\n * Executes an async function and enforces a timeout.\n *\n * If the promise does not resolve within the specified time,\n * the timeout will trigger and the returned promise will be rejected.\n *\n *\n * @template T\n * @param {() => Promise<T>} run - A function that returns a promise to be executed.\n * @param {number} ms - The timeout duration in milliseconds.\n * @returns {Promise<T>} A promise that resolves with the result of the `run` function or rejects if the timeout is reached.\n *\n * @example\n * async function fetchData() {\n *   const response = await fetch('https://example.com/data');\n *   return response.json();\n * }\n *\n * try {\n *   const data = await withTimeout(fetchData, 1000);\n *   console.log(data); // Logs the fetched data if `fetchData` is resolved within 1 second.\n * } catch (error) {\n *   console.error(error); // Will log 'TimeoutError' if `fetchData` is not resolved within 1 second.\n * }\n */\nexport async function withTimeout<T>(run: () => Promise<T>, ms: number): Promise<T> {\n  return Promise.race([run(), timeout(ms)]);\n}\n","import { without as withoutToolkit } from '../../array/without.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: ArrayLike<T> | null | undefined, ...values: T[]): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n  return withoutToolkit(Array.from(array), ...values);\n}\n","import { difference } from './difference.ts';\n\n/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {T[]} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\n  return difference(array, values);\n}\n","import { CASE_SPLIT_PATTERN } from '../../string/words.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Splits `string` into an array of its words.\n *\n * @param {string | object} str - The string or object that is to be split into words.\n * @param {RegExp | string} [pattern] - The pattern to match words.\n * @returns {string[]} - Returns the words of `string`.\n *\n * @example\n * const wordsArray1 = words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n */\nexport function words(str?: string | object, pattern: RegExp | string = CASE_SPLIT_PATTERN): string[] {\n  const input = toString(str);\n\n  const words = Array.from(input.match(pattern) ?? []);\n\n  return words.filter(x => x !== '');\n}\n","import { difference } from './difference.ts';\nimport { intersection } from './intersection.ts';\nimport { union } from './union.ts';\n\n/**\n * Computes the symmetric difference between two arrays. The symmetric difference is the set of elements\n * which are in either of the arrays, but not in their intersection.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both.\n *\n * @example\n * // Returns [1, 2, 5, 6]\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\n *\n * @example\n * // Returns ['a', 'c']\n * xor(['a', 'b'], ['b', 'c']);\n */\nexport function xor<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return difference(union(arr1, arr2), intersection(arr1, arr2));\n}\n","import { uniq } from './uniq.ts';\n\n/**\n * Creates an array of unique values from all given arrays.\n *\n * This function takes two arrays, merges them into a single array, and returns a new array\n * containing only the unique values from the merged array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @returns {T[]} A new array of unique values.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [3, 4, 5];\n * const result = union(array1, array2);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function union<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return uniq(arr1.concat(arr2));\n}\n","import { differenceBy } from './differenceBy.ts';\nimport { intersectionBy } from './intersectionBy.ts';\nimport { unionBy } from './unionBy.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom mapping function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection, determined by the result of the mapping function.\n *\n * @template T - Type of elements in the input arrays.\n * @template U - Type of the values returned by the mapping function.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = obj => obj.id;\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  const union = unionBy(arr1, arr2, mapper);\n  const intersection = intersectionBy(arr1, arr2, mapper);\n\n  return differenceBy(union, intersection, mapper);\n}\n","import { differenceWith } from './differenceWith.ts';\nimport { intersectionWith } from './intersectionWith.ts';\nimport { unionWith } from './unionWith.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom equality function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection.\n *\n * @template T - Type of elements in the input arrays.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\n *\n * @example\n * // Custom equality function for objects with an 'id' property\n * const areObjectsEqual = (a, b) => a.id === b.id;\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areElementsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  const union = unionWith(arr1, arr2, areElementsEqual);\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\n\n  return differenceWith(union, intersection, areElementsEqual);\n}\n","import { zip as zipToolkit } from '../../array/zip.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @returns {Array<[T | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = zip(arr1);\n * // result will be [[1], [2], [3]]\n */\nexport function zip<T>(arr1: ArrayLike<T>): Array<[T | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @returns {Array<[T | undefined, U | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function zip<T, U>(arr1: ArrayLike<T>, arr2: ArrayLike<U>): Array<[T | undefined, U | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T, U, V>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>\n): Array<[T | undefined, U | undefined, V | undefined]>;\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const result = zip(arr1, arr2, arr3, arr4);\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\n */\nexport function zip<T, U, V, W>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>\n): Array<[T | undefined, U | undefined, V | undefined, W | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @param {ArrayLike<X>} arr5 - The fifth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined, X | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\nexport function zip<T, U, V, W, X>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>,\n  arr5: ArrayLike<X>\n): Array<[T | undefined, U | undefined, V | undefined, W | undefined, X | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {Array<ArrayLike<any> | null | undefined>} arrays - The arrays to zip.\n * @returns {Array<Array<T | undefined>>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\nexport function zip<T>(...arrays: Array<ArrayLike<any> | null | undefined>): Array<Array<T | undefined>>;\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {Array<ArrayLike<any> | null | undefined>} arrays - The arrays to zip.\n * @returns {Array<Array<T | undefined>>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\nexport function zip<T>(...arrays: Array<ArrayLike<any> | null | undefined>): Array<Array<T | undefined>> {\n  if (!arrays.length) {\n    return [];\n  }\n  // @ts-expect-error - TS doesn't support array types with a spread operator\n  return zipToolkit(...arrays.filter(group => isArrayLikeObject(group)));\n}\n","/**\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\n *\n * This function takes two arrays: one containing property names and another containing corresponding values.\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\n * have `undefined` as their values.\n *\n * @template P - The type of elements in the array.\n * @template V - The type of elements in the array.\n * @param {P[]} keys - An array of property names.\n * @param {V[]} values - An array of values corresponding to the property names.\n * @returns {Record<P, V>} - A new object composed of the given property names and values.\n *\n * @example\n * const keys = ['a', 'b', 'c'];\n * const values = [1, 2, 3];\n * const result = zipObject(keys, values);\n * // result will be { a: 1, b: 2, c: 3 }\n *\n * const keys2 = ['a', 'b', 'c'];\n * const values2 = [1, 2];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2, c: undefined }\n *\n * const keys2 = ['a', 'b'];\n * const values2 = [1, 2, 3];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2 }\n */\nexport function zipObject<P extends PropertyKey, V>(keys: readonly P[], values: readonly V[]): Record<P, V> {\n  const result = {} as Record<P, V>;\n\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i];\n  }\n\n  return result;\n}\n","import { zip } from '../../array/zip.ts';\nimport { set } from '../object/set.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a deeply nested object given arrays of paths and values.\n *\n * This function takes two arrays: one containing arrays of property paths, and the other containing corresponding values.\n * It returns a new object where paths from the first array are used as key paths to set values, with corresponding elements from the second array as values.\n * Paths can be dot-separated strings or arrays of property names.\n *\n * If the `keys` array is longer than the `values` array, the remaining keys will have `undefined` as their values.\n *\n * @template P - The type of property paths.\n * @template V - The type of values corresponding to the property paths.\n * @param {ArrayLike<P | P[]>} keys - An array of property paths, each path can be a dot-separated string or an array of property names.\n * @param {ArrayLike<V>} values - An array of values corresponding to the property paths.\n * @returns {Record<P, V>} A new object composed of the given property paths and values.\n *\n * @example\n * const paths = ['a.b.c', 'd.e.f'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = [['a', 'b', 'c'], ['d', 'e', 'f']];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = ['a.b[0].c', 'a.b[1].d'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n */\nexport function zipObjectDeep<P extends PropertyKey, V>(keys: ArrayLike<P | P[]>, values: ArrayLike<V>): Record<P, V> {\n  const result = {} as { [K in P]: V };\n  if (!isArrayLike(keys)) {\n    return result;\n  }\n  if (!isArrayLike(values)) {\n    values = [];\n  }\n  const zipped = zip<P | P[], V>(Array.from(keys), Array.from(values));\n\n  for (let i = 0; i < zipped.length; i++) {\n    const [key, value] = zipped[i];\n\n    if (key != null) {\n      set(result, key, value);\n    }\n  }\n\n  return result;\n}\n","/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes multiple arrays and a combiner function, and returns a new array where each element\n * is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @template T - The type of elements in the first array.\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * // Example usage with two arrays:\n * const arr1 = [1, 2, 3];\n * const arr2 = [4, 5, 6];\n * const result = zipWith(arr1, arr2, (a, b) => a + b);\n * // result will be [5, 7, 9]\n *\n * @example\n * // Example usage with three arrays:\n * const arr1 = [1, 2];\n * const arr2 = [3, 4];\n * const arr3 = [5, 6];\n * const result = zipWith(arr1, arr2, arr3, (a, b, c) => `${a}${b}${c}`);\n * // result will be [`135`, `246`]\n */\nexport function zipWith<T, R>(arr1: readonly T[], combine: (item: T) => R): R[];\n/**\n * Combines two arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {(item1: T, item2: U) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, R>(arr1: readonly T[], arr2: readonly U[], combine: (item1: T, item2: U) => R): R[];\n/**\n * Combines three arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template V - The type of elements in the third array.\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @param {(item1: T, item2: U, item3: V) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, V, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  combine: (item1: T, item2: U, item3: V) => R\n): R[];\n/**\n * Combines four arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template V - The type of elements in the third array.\n * @template W - The type of elements in the fourth array.\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @param {W[]} arr4 - The fourth array to zip.\n * @param {(item1: T, item2: U, item3: V, item4: W) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, V, W, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[],\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\n): R[];\n\n/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes one array and a variable number of additional arrays,\n * applying the provided combiner function to the corresponding elements of each array.\n * If the input arrays are of different lengths, the resulting array will have the length\n * of the longest input array, with undefined values for missing elements.\n *\n * @template T - The type of elements in the input arrays.\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {...Array<T[]>} rest - The additional arrays to zip together, followed by the combiner function.\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zipWith(arr1, arr2, (num, char) => `${num}${char}`);\n * // result will be ['1a', '2b', '3c']\n */\nexport function zipWith<T, R>(arr1: readonly T[], ...rest: any[]): R[] {\n  const arrs = [arr1, ...rest.slice(0, -1)];\n  const combine = rest[rest.length - 1] as (...items: T[]) => R;\n\n  const maxIndex = Math.max(...arrs.map(arr => arr.length));\n  const result: R[] = Array(maxIndex);\n\n  for (let i = 0; i < maxIndex; i++) {\n    const elements: T[] = arrs.map(arr => arr[i]);\n    result[i] = combine(...elements);\n  }\n\n  return result;\n}\n"],"names":["at","arr","indices","result","Array","length","i","index","Number","isInteger","Math","trunc","difference","firstArr","secondArr","secondSet","Set","filter","item","has","differenceBy","mapper","mappedSecondSet","map","differenceWith","areItemsEqual","firstItem","every","secondItem","dropRightWhile","canContinueDropping","slice","dropWhile","dropEndIndex","findIndex","flatten","depth","flooredDepth","floor","recursive","currentDepth","isArray","push","intersection","intersectionBy","intersectionWith","some","last","pull","valuesToRemove","valuesSet","resultIndex","Object","hasOwn","sample","random","minimum","maximum","Error","randomInt","uniq","from","uniqBy","Map","key","set","values","unionBy","arr1","arr2","concat","uniqWith","v","unionWith","unzip","zipped","maxLen","j","zip","arrs","rowCount","columnCount","row","AbortError","constructor","message","super","this","name","TimeoutError","after","n","func","counter","args","ary","apply","debounce","debounceMs","signal","edges","pendingThis","pendingArgs","leading","includes","trailing","invoke","undefined","timeoutId","schedule","clearTimeout","setTimeout","cancel","onTimerEnd","cancelTimer","debounced","aborted","isFirstCall","flush","addEventListener","once","flow","funcs","call","identity","x","noop","partial","partialArgs","providedArgs","startIndex","arg","placeholder","partialPlaceholder","Symbol","partialRight","placeholderLength","partialRightPlaceholder","rangeLength","max","providedIndex","delay","ms","Promise","resolve","reject","abortError","abortHandler","removeEventListener","Semaphore","capacity","available","deferredTasks","acquire","release","deferredTask","shift","async","timeout","DEFAULT_RETRIES","POSITIVE_INFINITY","mean","nums","sum","median","NaN","sorted","sort","a","b","middleIndex","range","start","end","step","ceil","isPrimitive","value","isTypedArray","ArrayBuffer","isView","DataView","clone","obj","SharedArrayBuffer","prototype","getPrototypeOf","Constructor","Date","RegExp","newRegExp","lastIndex","buffer","newError","stack","cause","File","type","lastModified","newObject","create","assign","getSymbols","object","getOwnPropertySymbols","symbol","propertyIsEnumerable","getTag","toString","regexpTag","stringTag","numberTag","booleanTag","argumentsTag","symbolTag","dateTag","mapTag","setTag","arrayTag","functionTag","arrayBufferTag","objectTag","errorTag","dataViewTag","uint8ArrayTag","uint8ClampedArrayTag","uint16ArrayTag","uint32ArrayTag","bigUint64ArrayTag","int8ArrayTag","int16ArrayTag","int32ArrayTag","bigInt64ArrayTag","float32ArrayTag","float64ArrayTag","cloneDeepWithImpl","valueToClone","keyToClone","objectToClone","cloneValue","cloned","get","input","getTime","source","flags","add","Buffer","isBuffer","subarray","byteOffset","byteLength","copyProperties","Blob","isCloneableObject","target","keys","descriptor","getOwnPropertyDescriptor","writable","cloneDeep","findKey","predicate","find","isPlainObject","proto","flattenObjectImpl","prefix","delimiter","prefixedKey","mapKeys","getNewKey","mapValues","getNewValue","merge","sourceKeys","sourceValue","targetValue","isObjectLike","isBlob","eq","other","isNaN","isEqualWith","areValuesEqual","isEqualWithImpl","property","aParent","bParent","is","areObjectsEqual","aTag","bTag","valueOf","aStack","bStack","size","entries","aValues","bValues","aValue","bValue","splice","Uint8Array","aKeys","bKeys","propKey","aProp","delete","isJSONValue","isJSONArray","isJSONObject","Reflect","ownKeys","isLength","isSafeInteger","isNil","isNull","isSymbol","isUndefined","capitalize","str","charAt","toUpperCase","toLowerCase","CASE_SPLIT_PATTERN","words","match","deburrMap","htmlEscapes","trimEnd","chars","endIndex","substring","trimStart","trim","htmlUnescapes","toArray","isArrayLike","isArrayLikeObject","array","lastToolkit","flattenArrayLike","arrayLike","isDeepKey","toKey","toPath","deepKey","quoteChar","bracket","charCodeAt","char","path","defaultValue","getWithPath","current","String","isObject","isMatch","isArrayMatch","isMapMatch","isSetMatch","countedIndex","sourceItem","targetItem","matches","cloneDeepWith","cloneDeepWithToolkit","iterator","IS_UNSIGNED_INTEGER","isIndex","MAX_SAFE_INTEGER","test","isArguments","resolvedPath","matchesProperty","iteratee","toNumber","toFinite","Infinity","MAX_VALUE","toInteger","finite","remainder","isIterateeCall","isString","Boolean","isConcatSpreadable","forEach","collection","callback","head","headToolkit","uniqToolkit","uniqPreserve0","added","getPriority","compareValues","order","localeCompare","aPriority","bPriority","regexIsDeepProp","regexIsPlainProp","orderBy","criteria","orders","guard","getValueByNestedPath","preparedCriteria","criterion","isKey","original","getValueByCriterion","comparedResult","MAX_ARRAY_INDEX","MAX_ARRAY_LENGTH","sortedIndexBy","retHighest","low","high","transformedValue","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","setLow","mid","computed","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","min","isNumber","nextKey","attempt","e","bind","thisObj","bound","bindPlaceholder","bindKey","bindKeyPlaceholder","curry","arity","parseInt","wrapper","holders","makeCurry","curryPlaceholder","composeArgs","curryRight","makeCurryRight","curryRightPlaceholder","options","maxWait","pendingAt","_debounced","debounceToolkit","now","decimalAdjust","number","precision","magnitude","exponent","split","adjustedValue","newMagnitude","newExponent","clamp","bound1","bound2","clampToolkit","join","sumBy","iterateeToolkit","isPrototype","isTypedArrayToolkit","times","getValue","keysIn","arrayLikeKeysIn","filteredKeys","keysInImpl","prototypeKeysIn","assignIn","sources","assignInImpl","defaults","objectProto","tag","toStringTag","mergeWith","otherArgs","mergeWithDeep","targetKeys","targetKey","merged","unset","unsetWithPath","parent","lastKey","conformsTo","isMap","isMapToolKit","normalizeForCase","replace","escape","string","escapeToolkit","esTemplateRegExp","unEscapedRegExp","noMatchExp","escapeMap","escapeString","templateSettings","evaluate","interpolate","variable","imports","_","template","delimitersRegExp","isEvaluated","matchAll","fullMatch","escapeValue","interpolateValue","esTemplateValue","evaluateValue","importsKeys","importValues","sourceURL","compiledFunction","Function","invokeImpl","lastValue","idCounter","Mutex","semaphore","isLocked","TypeError","aryToolkit","asyncNoop","before","camelCase","getWords","first","rest","word","camelCaseToolkit","castArray","arguments","chunk","chunkLength","chunkToolkit","compact","compactToolkit","conforms","constant","constantCase","countBy","deburr","normalize","deburrToolkit","defaultTo","defer","wait","differenceToolkit","_values","differenceByToolkit","createIteratee","comparator","flattenedValues","differenceWithToolkit","divide","console","log","drop","itemsCount","dropToolkit","dropRight","dropRightToolkit","dropRightWhileImpl","dropRightWhileToolkit","dropWhileImpl","dropWhileToolkit","endsWith","position","escapeRegExp","escapeRegExpToolkit","doesMatch","fill","finalStart","finalEnd","fillToolkit","_doesMatch","fromIndex","subArray","findKeyImpl","findKeyToolkit","findLast","findLastIndex","flatMap","flatMapDeep","flattenDeep","flattenDepth","flattenObject","flip","reverse","flattenFuncs","flowToolkit","flowRight","flowRightToolkit","forEachRight","fromPairs","pairs","groupBy","getKeyFromItem","gt","gte","inRange","inRangeToolkit","indexOf","searchElement","initial","arrays","intersectionToolkit","count","intersectionByToolkit","otherArrs","_comparator","pop","otherArr","intersectionWithToolkit","invariant","condition","invert","invertBy","valueStr","isArrayBuffer","isArrayBufferToolkit","isBoolean","isBufferToolkit","isDate","isDateToolkit","isElement","nodeType","isEmpty","isEqual","isEqualWithToolkit","isError","isFile","isFinite","isFunction","isJSON","JSON","parse","isNotNil","isPromise","isRegExp","isRegExpToolkit","isSet","isSetToolkit","isSubset","superset","subset","isSubsetWith","isWeakMap","WeakMap","isWeakMapToolkit","isWeakSet","WeakSet","isWeakSetToolkit","separator","kebabCase","kebabCaseToolkit","keyBy","arrayLikeKeys","lastIndexOf","lowerCase","lowerCaseToolkit","lowerFirst","lowerFirstToolkit","lt","lte","_iteratee","mapKeysToolkit","mapValuesToolkit","items","maxElement","element","maxBy","maxByToolkit","meanBy","medianBy","memoize","fn","cache","getCacheKey","memoizedFn","method","methodOf","minElement","minBy","multiply","negate","nth","nthArg","omit","keysArr","omitBy","shouldOmit","called","pad","padStart","padEnd","padToolkit","radix","partition","isInTruthy","truthy","falsy","pascalCase","pick","pickBy","shouldPick","propertyOf","pullToolkit","pullAll","pullAllBy","_getValue","pullAt","indicesToRemove","removed","y","floating","randomToolkit","randomIntToolkit","rangeRight","rearg","flattenIndices","reorderedArgs","reduce","accumulator","reduceRight","remove","shouldRemoveElement","originalArr","removeToolkit","repeat","pattern","replacement","params","restToolkit","retry","_options","retries","error","err","delayToolkit","reverseString","round","sampleToolkit","sampleSize","selected","shuffle","resultLength","snakeCase","snakeCaseToolkit","sortBy","sortedIndex","compute","spread","argsIndex","startCase","startsWith","stubArray","stubFalse","stubObject","stubString","stubTrue","subtract","tail","tailToolkit","take","takeToolkit","takeRight","takeRightToolkit","takeRightWhile","_array","takeWhile","shouldContinueTaking","throttle","throttleMs","toDefaulted","toFilled","newArr","toLength","toLower","toMerged","toPlainObject","plainObject","valueKeys","objValue","defineProperty","configurable","enumerable","toSafeInteger","toUpper","trimToolkit","trimEndToolkit","trimStartToolkit","unary","unescape","unescapeToolkit","union","uniqByToolkit","uniqueId","unzipToolkit","unzipWith","maxLength","innerArray","group","upperCase","upperCaseToolkit","upperFirst","upperFirstToolkit","valuesIn","windowed","partialWindows","withTimeout","run","race","without","withoutToolkit","xor","xorBy","xorWith","areElementsEqual","zipToolkit","zipObject","zipObjectDeep","zipWith","combine","maxIndex","elements"],"mappings":"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"}