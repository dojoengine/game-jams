import {
  CallData,
  WalletAccount,
  addAddressPadding,
  constants_exports,
  export_TypedDataRevision,
  getChecksumAddress,
  hash_exports,
  num_exports,
  shortString_exports,
  typedData_exports
} from "./chunk-NGYOB2GY.js";
import "./chunk-PZ5AY32C.js";

// node_modules/.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/dist/provider-CznCrt4b.js
var T = "0.10.5";
var d = {
  version: T
};
var w = ((e) => (e.SUCCESS = "SUCCESS", e.NOT_CONNECTED = "NOT_CONNECTED", e.ERROR = "ERROR", e.CANCELED = "CANCELED", e.USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED", e))(w || {});
var l = ((e) => (e.PAYMASTER = "PAYMASTER", e.CREDITS = "CREDITS", e))(l || {});
var C = ((e) => (e.NONFUNGIBLE = "NONFUNGIBLE", e.FUNGIBLE = "FUNGIBLE", e))(C || {});
var m = /* @__PURE__ */ new Set([
  "contracts",
  "messages",
  "target",
  "method",
  "name",
  "description",
  "types",
  "domain",
  "primaryType"
]);
function L(e) {
  if (!m.has(e))
    throw new Error(`Invalid property name: ${e}`);
}
function s(e, t) {
  return L(t), e[t];
}
function x(e) {
  return i(e).map((t) => ({
    entrypoint: t.entrypoint,
    contractAddress: addAddressPadding(t.contractAddress),
    calldata: CallData.toHex(t.calldata)
  }));
}
function U(e) {
  return Array.isArray(e) ? e.reduce(
    (t, N2) => {
      if (s(N2, "target")) {
        const M2 = getChecksumAddress(
          s(N2, "target")
        ), a = s(N2, "method"), r = s(
          t,
          "contracts"
        ), c = {
          name: O(a),
          entrypoint: a,
          description: s(N2, "description")
        };
        if (M2 in r) {
          const g2 = i(r[M2].methods);
          r[M2] = {
            methods: [...g2, c]
          };
        } else
          r[M2] = {
            methods: [c]
          };
      } else
        s(t, "messages").push(N2);
      return t;
    },
    { contracts: {}, messages: [] }
  ) : e;
}
function k(e) {
  return [
    ...Object.entries(e.contracts ?? {}).flatMap(
      ([t, { methods: N2 }]) => i(N2).map((M2) => ({
        target: t,
        method: hash_exports.getSelectorFromName(M2.entrypoint),
        authorized: M2.authorized
      }))
    ),
    ...(e.messages ?? []).map((t) => {
      const N2 = typedData_exports.getStructHash(
        t.types,
        "StarknetDomain",
        t.domain,
        export_TypedDataRevision.ACTIVE
      ), M2 = typedData_exports.getTypeHash(
        t.types,
        t.primaryType,
        export_TypedDataRevision.ACTIVE
      );
      return {
        scope_hash: hash_exports.computePoseidonHash(N2, M2),
        authorized: t.authorized
      };
    })
  ];
}
function i(e) {
  return Array.isArray(e) ? e : [e];
}
function O(e) {
  return e.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").toLowerCase().replace(/^\w/, (t) => t.toUpperCase());
}
function f(e) {
  const t = e.pathname.split("/");
  if (e.hostname === "localhost" || e.hostname === "127.0.0.1" || e.hostname === "0.0.0.0") {
    if (typeof XMLHttpRequest > "u")
      return console.warn(
        `Cannot make synchronous HTTP call in Node.js environment for ${e.toString()}`
      ), shortString_exports.encodeShortString("LOCALHOST");
    const N2 = new XMLHttpRequest();
    N2.open("POST", e.toString(), false), N2.setRequestHeader("Content-Type", "application/json");
    const M2 = JSON.stringify({
      jsonrpc: "2.0",
      method: "starknet_chainId",
      params: [],
      id: 1
    });
    try {
      if (N2.send(M2), N2.status === 200) {
        const a = JSON.parse(N2.responseText);
        if (a.result)
          return a.result;
      }
      throw new Error(
        `Failed to get chain ID from ${e.toString()}: ${N2.status} ${N2.statusText}`
      );
    } catch (a) {
      throw new Error(`Failed to connect to ${e.toString()}: ${a}`);
    }
  }
  if (t.includes("starknet")) {
    if (t.includes("mainnet"))
      return constants_exports.StarknetChainId.SN_MAIN;
    if (t.includes("sepolia"))
      return constants_exports.StarknetChainId.SN_SEPOLIA;
  } else if (t.length >= 3) {
    const N2 = t[2];
    if (t.includes("katana"))
      return shortString_exports.encodeShortString(
        `WP_${N2.toUpperCase().replace(/-/g, "_")}`
      );
    if (t.includes("mainnet"))
      return shortString_exports.encodeShortString(
        `GG_${N2.toUpperCase().replace(/-/g, "_")}`
      );
  }
  throw new Error(`Chain ${e.toString()} not supported`);
}
var u = class _u extends Error {
  constructor() {
    super("Not ready to connect"), Object.setPrototypeOf(this, _u.prototype);
  }
};
var P = "https://x.cartridge.gg";
var b = "https://api.cartridge.gg";
var h = {
  ACCOUNTS: "accounts"
};
var E = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K";
function S() {
}
var Y = class {
  m_lastPromise = Promise.resolve();
  /**
   * Acquire lock
   * @param [bypass=false] option to skip lock acquisition
   */
  async obtain(t = false) {
    let N2 = S;
    if (t) return N2;
    const M2 = this.m_lastPromise;
    return this.m_lastPromise = new Promise((a) => N2 = a), await M2, N2;
  }
};
var p = new Y();
var Z = class {
  id = "controller";
  name = "Controller";
  version = d.version;
  icon = E;
  account;
  subscriptions = [];
  _probePromise = null;
  async safeProbe() {
    if (this.account)
      return this.account;
    if (this._probePromise)
      return this._probePromise;
    const t = await p.obtain();
    return await new Promise(async (N2) => {
      try {
        this._probePromise = this.probe();
        const M2 = await this._probePromise;
        N2(M2);
      } finally {
        this._probePromise = null;
      }
    }).finally(() => {
      t();
    });
  }
  request = async (t) => {
    switch (t.type) {
      case "wallet_getPermissions":
        return await this.safeProbe(), this.account ? [h.ACCOUNTS] : [];
      case "wallet_requestAccounts": {
        if (this.account)
          return [this.account.address];
        const M2 = t.params && t.params.silent_mode;
        return this.account = await this.safeProbe(), !this.account && !M2 && (this.account = await this.connect()), this.account ? [this.account.address] : [];
      }
      case "wallet_watchAsset":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_watchAsset not implemented"
        };
      case "wallet_addStarknetChain": {
        let M2 = t.params;
        return this.addStarknetChain(M2);
      }
      case "wallet_switchStarknetChain": {
        let M2 = t.params;
        return this.switchStarknetChain(M2.chainId);
      }
      case "wallet_requestChainId":
        if (!this.account)
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        return await this.account.getChainId();
      case "wallet_deploymentData":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_deploymentData not implemented"
        };
      case "wallet_addInvokeTransaction":
        if (!this.account)
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        let N2 = t.params;
        return await this.account.execute(
          N2.calls.map((M2) => ({
            contractAddress: M2.contract_address,
            entrypoint: M2.entry_point,
            calldata: M2.calldata
          }))
        );
      case "wallet_addDeclareTransaction":
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: "wallet_addDeclareTransaction not implemented"
        };
      case "wallet_signTypedData": {
        if (!this.account)
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "Account not initialized"
          };
        return await this.account.signMessage(t.params);
      }
      case "wallet_supportedSpecs":
        return [];
      case "wallet_supportedWalletApi":
        return [];
      default:
        throw {
          code: 63,
          message: "An unexpected error occurred",
          data: `Unknown RPC call type: ${t.type}`
        };
    }
  };
  on = (t, N2) => {
    if (t !== "accountsChanged" && t !== "networkChanged")
      throw new Error(`Unknown event: ${t}`);
    this.subscriptions.push({ type: t, handler: N2 });
  };
  off = (t, N2) => {
    if (t !== "accountsChanged" && t !== "networkChanged")
      throw new Error(`Unknown event: ${t}`);
    const M2 = this.subscriptions.findIndex(
      (a) => a.type === t && a.handler === N2
    );
    M2 >= 0 && this.subscriptions.splice(M2, 1);
  };
  emitNetworkChanged(t) {
    this.subscriptions.filter((N2) => N2.type === "networkChanged").forEach((N2) => {
      N2.handler(t);
    });
  }
  emitAccountsChanged(t) {
    this.subscriptions.filter((N2) => N2.type === "accountsChanged").forEach((N2) => {
      N2.handler(t);
    });
  }
};

// node_modules/.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/dist/index.js
var Le = class extends WalletAccount {
  keychain;
  modal;
  options;
  constructor(e, r, n, s2, o, a) {
    super({
      provider: { nodeUrl: r },
      walletProvider: e,
      address: n
    }), this.keychain = s2, this.options = o, this.modal = a;
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(e) {
    return e = i(e), new Promise(async (r, n) => {
      const s2 = await this.keychain.execute(
        e,
        void 0,
        void 0,
        false,
        this.options?.feeSource
      );
      if (s2.code === w.SUCCESS) {
        r(s2);
        return;
      }
      if (this.options?.propagateSessionErrors && s2.code !== w.USER_INTERACTION_REQUIRED) {
        n(s2.error);
        return;
      }
      this.modal.open();
      const o = await this.keychain.execute(
        e,
        void 0,
        void 0,
        true,
        s2.error
      );
      if (o.code === w.SUCCESS) {
        r(o), this.modal.close();
        return;
      }
      n(o.error);
    });
  }
  /**
   * Sign an JSON object for off-chain usage with the starknet private key and return the signature
   * This adds a message prefix so it cant be interchanged with transactions
   *
   * @param json - JSON object to be signed
   * @returns the signature of the JSON object
   * @throws {Error} if the JSON object is not a valid JSON
   */
  async signMessage(e) {
    return new Promise(async (r, n) => {
      const s2 = await this.keychain.signMessage(e, "", true);
      if (!("code" in s2)) {
        r(s2);
        return;
      }
      this.modal.open();
      const o = await this.keychain.signMessage(e, "", false);
      "code" in o ? n(o.error) : r(o), this.modal.close();
    });
  }
};
var P2;
(function(t) {
  t.Call = "call", t.Reply = "reply", t.Syn = "syn", t.SynAck = "synAck", t.Ack = "ack";
})(P2 || (P2 = {}));
var z;
(function(t) {
  t.Fulfilled = "fulfilled", t.Rejected = "rejected";
})(z || (z = {}));
var G;
(function(t) {
  t.ConnectionDestroyed = "ConnectionDestroyed", t.ConnectionTimeout = "ConnectionTimeout", t.NoIframeSrc = "NoIframeSrc";
})(G || (G = {}));
var be;
(function(t) {
  t.DataCloneError = "DataCloneError";
})(be || (be = {}));
var T2;
(function(t) {
  t.Message = "message";
})(T2 || (T2 = {}));
var Lt = (t, e) => {
  const r = [];
  let n = false;
  return {
    destroy(s2) {
      n || (n = true, e(`${t}: Destroying connection`), r.forEach((o) => {
        o(s2);
      }));
    },
    onDestroy(s2) {
      n ? s2() : r.push(s2);
    }
  };
};
var Mt = (t) => (...e) => {
  t && console.log("[Penpal]", ...e);
};
var Qt = {
  "http:": "80",
  "https:": "443"
};
var Ft = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/;
var jt = ["file:", "data:"];
var Wt = (t) => {
  if (t && jt.find((i2) => t.startsWith(i2)))
    return "null";
  const e = document.location, r = Ft.exec(t);
  let n, s2, o;
  r ? (n = r[1] ? r[1] : e.protocol, s2 = r[2], o = r[4]) : (n = e.protocol, s2 = e.hostname, o = e.port);
  const a = o && o !== Qt[n] ? `:${o}` : "";
  return `${n}//${s2}${a}`;
};
var Me = ({ name: t, message: e, stack: r }) => ({
  name: t,
  message: e,
  stack: r
});
var Yt = (t) => {
  const e = new Error();
  return Object.keys(t).forEach((r) => e[r] = t[r]), e;
};
var Ht = (t, e, r) => {
  const { localName: n, local: s2, remote: o, originForSending: a, originForReceiving: i2 } = t;
  let l2 = false;
  const c = (d2) => {
    if (d2.source !== o || d2.data.penpal !== P2.Call)
      return;
    if (i2 !== "*" && d2.origin !== i2) {
      r(`${n} received message from origin ${d2.origin} which did not match expected origin ${i2}`);
      return;
    }
    const h2 = d2.data, { methodName: f2, args: u2, id: w2 } = h2;
    r(`${n}: Received ${f2}() call`);
    const k2 = (m2) => (S2) => {
      if (r(`${n}: Sending ${f2}() reply`), l2) {
        r(`${n}: Unable to send ${f2}() reply due to destroyed connection`);
        return;
      }
      const _ = {
        penpal: P2.Reply,
        id: w2,
        resolution: m2,
        returnValue: S2
      };
      m2 === z.Rejected && S2 instanceof Error && (_.returnValue = Me(S2), _.returnValueIsError = true);
      try {
        o.postMessage(_, a);
      } catch (p2) {
        if (p2.name === be.DataCloneError) {
          const E2 = {
            penpal: P2.Reply,
            id: w2,
            resolution: z.Rejected,
            returnValue: Me(p2),
            returnValueIsError: true
          };
          o.postMessage(E2, a);
        }
        throw p2;
      }
    };
    new Promise((m2) => m2(e[f2].call(e, d2.origin).apply(e, u2))).then(k2(z.Fulfilled), k2(z.Rejected));
  };
  return s2.addEventListener(T2.Message, c), () => {
    l2 = true, s2.removeEventListener(T2.Message, c);
  };
};
var Kt = 0;
var Vt = () => ++Kt;
var nt = ".";
var st = (t) => t ? t.split(nt) : [];
var qt = (t) => t.join(nt);
var Gt = (t, e) => {
  const r = st(e || "");
  return r.push(t), qt(r);
};
var Xt = (t, e, r) => {
  const n = st(e);
  return n.reduce((s2, o, a) => (typeof s2[o] > "u" && (s2[o] = {}), a === n.length - 1 && (s2[o] = r), s2[o]), t), t;
};
var ot = (t, e) => {
  const r = {};
  return Object.keys(t).forEach((n) => {
    const s2 = t[n], o = Gt(n, e);
    typeof s2 == "object" && Object.assign(r, ot(s2, o)), typeof s2 == "function" && (r[o] = s2);
  }), r;
};
var Jt = (t) => {
  const e = {};
  for (const r in t)
    Xt(e, r, t[r]);
  return e;
};
var Zt = (t, e, r, n, s2) => {
  const { localName: o, local: a, remote: i2, originForSending: l2, originForReceiving: c } = e;
  let d2 = false;
  s2(`${o}: Connecting call sender`);
  const h2 = (u2) => (...w2) => {
    s2(`${o}: Sending ${u2}() call`);
    let k2;
    try {
      i2.closed && (k2 = true);
    } catch {
      k2 = true;
    }
    if (k2 && n(), d2) {
      const m2 = new Error(`Unable to send ${u2}() call due to destroyed connection`);
      throw m2.code = G.ConnectionDestroyed, m2;
    }
    return new Promise((m2, S2) => {
      const _ = Vt(), p2 = (C2) => {
        if (C2.source !== i2 || C2.data.penpal !== P2.Reply || C2.data.id !== _)
          return;
        if (c !== "*" && C2.origin !== c) {
          s2(`${o} received message from origin ${C2.origin} which did not match expected origin ${c}`);
          return;
        }
        const de = C2.data;
        s2(`${o}: Received ${u2}() reply`), a.removeEventListener(T2.Message, p2);
        let he = de.returnValue;
        de.returnValueIsError && (he = Yt(he)), (de.resolution === z.Fulfilled ? m2 : S2)(he);
      };
      a.addEventListener(T2.Message, p2);
      const E2 = {
        penpal: P2.Call,
        id: _,
        methodName: u2,
        args: w2
      };
      i2.postMessage(E2, l2);
    });
  }, f2 = r.reduce((u2, w2) => (u2[w2] = h2(w2), u2), {});
  return Object.assign(t, Jt(f2)), () => {
    d2 = true;
  };
};
var er = (t, e, r, n, s2) => {
  const { destroy: o, onDestroy: a } = n;
  let i2, l2;
  const c = {};
  return (d2) => {
    if (e !== "*" && d2.origin !== e) {
      s2(`Parent: Handshake - Received ACK message from origin ${d2.origin} which did not match expected origin ${e}`);
      return;
    }
    s2("Parent: Handshake - Received ACK");
    const h2 = {
      localName: "Parent",
      local: window,
      remote: d2.source,
      originForSending: r,
      originForReceiving: e
    };
    i2 && i2(), i2 = Ht(h2, t, s2), a(i2), l2 && l2.forEach((u2) => {
      delete c[u2];
    }), l2 = d2.data.methodNames;
    const f2 = Zt(c, h2, l2, o, s2);
    return a(f2), c;
  };
};
var tr = (t, e, r, n) => (s2) => {
  if (!s2.source)
    return;
  if (r !== "*" && s2.origin !== r) {
    t(`Parent: Handshake - Received SYN message from origin ${s2.origin} which did not match expected origin ${r}`);
    return;
  }
  t("Parent: Handshake - Received SYN, responding with SYN-ACK");
  const o = {
    penpal: P2.SynAck,
    methodNames: Object.keys(e)
  };
  s2.source.postMessage(o, n);
};
var rr = 6e4;
var nr = (t, e) => {
  const { destroy: r, onDestroy: n } = e, s2 = setInterval(() => {
    t.isConnected || (clearInterval(s2), r());
  }, rr);
  n(() => {
    clearInterval(s2);
  });
};
var sr = (t, e) => {
  let r;
  return t !== void 0 && (r = window.setTimeout(() => {
    const n = new Error(`Connection timed out after ${t}ms`);
    n.code = G.ConnectionTimeout, e(n);
  }, t)), () => {
    clearTimeout(r);
  };
};
var or = (t) => {
  if (!t.src && !t.srcdoc) {
    const e = new Error("Iframe must have src or srcdoc property defined.");
    throw e.code = G.NoIframeSrc, e;
  }
};
var ir = (t) => {
  let { iframe: e, methods: r = {}, childOrigin: n, timeout: s2, debug: o = false } = t;
  const a = Mt(o), i2 = Lt("Parent", a), { onDestroy: l2, destroy: c } = i2;
  n || (or(e), n = Wt(e.src));
  const d2 = n === "null" ? "*" : n, h2 = ot(r), f2 = tr(a, h2, n, d2), u2 = er(h2, n, d2, i2, a);
  return {
    promise: new Promise((k2, m2) => {
      const S2 = sr(s2, c), _ = (p2) => {
        if (!(p2.source !== e.contentWindow || !p2.data)) {
          if (p2.data.penpal === P2.Syn) {
            f2(p2);
            return;
          }
          if (p2.data.penpal === P2.Ack) {
            const E2 = u2(p2);
            E2 && (S2(), k2(E2));
            return;
          }
        }
      };
      window.addEventListener(T2.Message, _), a("Parent: Awaiting handshake"), nr(e, i2), l2((p2) => {
        window.removeEventListener(T2.Message, _), p2 && m2(p2);
      });
    }),
    destroy() {
      c();
    }
  };
};
var ar = class {
  url;
  iframe;
  container;
  onClose;
  child;
  closeTimeout;
  constructor({
    id: e,
    url: r,
    preset: n,
    onClose: s2,
    onConnect: o,
    methods: a = {}
  }) {
    if (typeof document > "u" || typeof window > "u")
      return;
    n && r.searchParams.set("preset", n), this.url = r;
    const i2 = document.createElement("iframe");
    i2.src = r.toString(), i2.id = e, i2.style.border = "none", i2.sandbox.add("allow-forms"), i2.sandbox.add("allow-popups"), i2.sandbox.add("allow-popups-to-escape-sandbox"), i2.sandbox.add("allow-scripts"), i2.sandbox.add("allow-same-origin"), i2.allow = "publickey-credentials-create *; publickey-credentials-get *; clipboard-write", document.hasStorageAccess && i2.sandbox.add("allow-storage-access-by-user-activation");
    const l2 = document.createElement("div");
    l2.id = "controller", l2.style.position = "fixed", l2.style.height = "100%", l2.style.width = "100%", l2.style.top = "0", l2.style.left = "0", l2.style.zIndex = "10000", l2.style.backgroundColor = "rgba(0,0,0,0.6)", l2.style.display = "none", l2.style.alignItems = "center", l2.style.justifyContent = "center", l2.style.transition = "opacity 0.2s ease", l2.style.opacity = "0", l2.style.pointerEvents = "auto", l2.appendChild(i2), l2.addEventListener("click", (h2) => {
      h2.target === l2 && (e === "controller-keychain" && this.child && this.child.reset?.().catch((f2) => console.error("Error resetting context:", f2)), this.close());
    }), this.iframe = i2, this.container = l2, ir({
      iframe: this.iframe,
      methods: {
        close: (h2) => () => this.close(),
        reload: (h2) => () => window.location.reload(),
        ...a
      }
    }).promise.then((h2) => {
      this.child = h2, o(h2);
    }), this.resize(), window.addEventListener("resize", () => this.resize());
    const c = new MutationObserver(() => {
      if (typeof document > "u") return;
      const h2 = document.getElementById("controller");
      document.body && e === "controller-keychain" && !h2 && (document.body.appendChild(l2), c.disconnect());
    });
    c.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    const d2 = document.getElementById("controller");
    document.body && e === "controller-keychain" && !d2 && document.body.appendChild(l2), this.onClose = s2;
  }
  open() {
    !this.container || typeof document > "u" || !document.body || (this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = void 0), document.body.style.overflow = "hidden", this.container.style.display = "flex", requestAnimationFrame(() => {
      this.container && (this.container.style.opacity = "1");
    }));
  }
  close() {
    !this.container || typeof document > "u" || !document.body || (this.onClose?.(), document.body.style.overflow = "auto", this.container.style.opacity = "0", this.closeTimeout = setTimeout(() => {
      this.container && (this.container.style.display = "none"), this.closeTimeout = void 0;
    }, 200));
  }
  sendBackward() {
    this.container && (this.container.style.zIndex = "9999");
  }
  sendForward() {
    this.container && (this.container.style.zIndex = "10000");
  }
  resize() {
    if (!(!this.iframe || typeof window > "u")) {
      if (this.iframe.style.userSelect = "none", window.innerWidth < 768) {
        this.iframe.style.height = "100%", this.iframe.style.width = "100%", this.iframe.style.borderRadius = "0";
        return;
      }
      this.iframe.style.height = "600px", this.iframe.style.width = "432px", this.iframe.style.borderRadius = "8px";
    }
  }
  isOpen() {
    return this.container?.style.display !== "none";
  }
};
var cr = "6.13.7";
function Qe(t, e, r) {
  for (let n in e) {
    let s2 = e[n];
    Object.defineProperty(t, n, { enumerable: true, value: s2, writable: false });
  }
}
function M(t) {
  if (t == null)
    return "null";
  if (Array.isArray(t))
    return "[ " + t.map(M).join(", ") + " ]";
  if (t instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let r = "0x";
    for (let n = 0; n < t.length; n++)
      r += e[t[n] >> 4], r += e[t[n] & 15];
    return r;
  }
  if (typeof t == "object" && typeof t.toJSON == "function")
    return M(t.toJSON());
  switch (typeof t) {
    case "boolean":
    case "symbol":
      return t.toString();
    case "bigint":
      return BigInt(t).toString();
    case "number":
      return t.toString();
    case "string":
      return JSON.stringify(t);
    case "object": {
      const e = Object.keys(t);
      return e.sort(), "{ " + e.map((r) => `${M(r)}: ${M(t[r])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function lr(t, e, r) {
  let n = t;
  {
    const o = [];
    if (r) {
      if ("message" in r || "code" in r || "name" in r)
        throw new Error(`value will overwrite populated values: ${M(r)}`);
      for (const a in r) {
        if (a === "shortMessage")
          continue;
        const i2 = r[a];
        o.push(a + "=" + M(i2));
      }
    }
    o.push(`code=${e}`), o.push(`version=${cr}`), o.length && (t += " (" + o.join(", ") + ")");
  }
  let s2;
  switch (e) {
    case "INVALID_ARGUMENT":
      s2 = new TypeError(t);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s2 = new RangeError(t);
      break;
    default:
      s2 = new Error(t);
  }
  return Qe(s2, { code: e }), r && Object.assign(s2, r), s2.shortMessage == null && Qe(s2, { shortMessage: n }), s2;
}
function dr(t, e, r, n) {
  if (!t)
    throw lr(e, r, n);
}
function Y2(t, e, r, n) {
  dr(t, e, "INVALID_ARGUMENT", { argument: r, value: n });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    t.push(e);
  } catch {
  }
  return t;
}, []);
function hr(t, e, r) {
  if (t instanceof Uint8Array)
    return t;
  if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((t.length - 2) / 2);
    let s2 = 2;
    for (let o = 0; o < n.length; o++)
      n[o] = parseInt(t.substring(s2, s2 + 2), 16), s2 += 2;
    return n;
  }
  Y2(false, "invalid BytesLike value", e || "value", t);
}
function xe(t, e) {
  return hr(t, e);
}
var Fe = "0123456789abcdef";
function fr(t) {
  const e = xe(t);
  let r = "0x";
  for (let n = 0; n < e.length; n++) {
    const s2 = e[n];
    r += Fe[(s2 & 240) >> 4] + Fe[s2 & 15];
  }
  return r;
}
function ur(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function je(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function re(t, ...e) {
  if (!ur(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function We(t, e = true) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function gr(t, e) {
  re(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error("digestInto() expects output buffer of length at least " + r);
}
function wr(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function it(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
var pr = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function yr(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function mr(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = yr(t[e]);
  return t;
}
var Ye = pr ? (t) => t : mr;
function br(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function at(t) {
  return typeof t == "string" && (t = br(t)), re(t), t;
}
var kr = class {
};
function _r(t) {
  const e = (n) => t().update(at(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
var Z2 = BigInt(2 ** 32 - 1);
var He = BigInt(32);
function Ar(t, e = false) {
  return e ? { h: Number(t & Z2), l: Number(t >> He & Z2) } : { h: Number(t >> He & Z2) | 0, l: Number(t & Z2) | 0 };
}
function Er(t, e = false) {
  const r = t.length;
  let n = new Uint32Array(r), s2 = new Uint32Array(r);
  for (let o = 0; o < r; o++) {
    const { h: a, l: i2 } = Ar(t[o], e);
    [n[o], s2[o]] = [a, i2];
  }
  return [n, s2];
}
var vr = (t, e, r) => t << r | e >>> 32 - r;
var xr = (t, e, r) => e << r | t >>> 32 - r;
var $r = (t, e, r) => e << r - 32 | t >>> 64 - r;
var Ir = (t, e, r) => t << r - 32 | e >>> 64 - r;
var Sr = BigInt(0);
var W = BigInt(1);
var Cr = BigInt(2);
var Br = BigInt(7);
var Pr = BigInt(256);
var Nr = BigInt(113);
var ct = [];
var lt = [];
var dt = [];
for (let t = 0, e = W, r = 1, n = 0; t < 24; t++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], ct.push(2 * (5 * n + r)), lt.push((t + 1) * (t + 2) / 2 % 64);
  let s2 = Sr;
  for (let o = 0; o < 7; o++)
    e = (e << W ^ (e >> Br) * Nr) % Pr, e & Cr && (s2 ^= W << (W << BigInt(o)) - W);
  dt.push(s2);
}
var ht = Er(dt, true);
var Rr = ht[0];
var Tr = ht[1];
var Ke = (t, e, r) => r > 32 ? $r(t, e, r) : vr(t, e, r);
var Ve = (t, e, r) => r > 32 ? Ir(t, e, r) : xr(t, e, r);
function Ur(t, e = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let a = 0; a < 10; a++)
      r[a] = t[a] ^ t[a + 10] ^ t[a + 20] ^ t[a + 30] ^ t[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const i2 = (a + 8) % 10, l2 = (a + 2) % 10, c = r[l2], d2 = r[l2 + 1], h2 = Ke(c, d2, 1) ^ r[i2], f2 = Ve(c, d2, 1) ^ r[i2 + 1];
      for (let u2 = 0; u2 < 50; u2 += 10)
        t[a + u2] ^= h2, t[a + u2 + 1] ^= f2;
    }
    let s2 = t[2], o = t[3];
    for (let a = 0; a < 24; a++) {
      const i2 = lt[a], l2 = Ke(s2, o, i2), c = Ve(s2, o, i2), d2 = ct[a];
      s2 = t[d2], o = t[d2 + 1], t[d2] = l2, t[d2 + 1] = c;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let i2 = 0; i2 < 10; i2++)
        r[i2] = t[a + i2];
      for (let i2 = 0; i2 < 10; i2++)
        t[a + i2] ^= ~r[(i2 + 2) % 10] & r[(i2 + 4) % 10];
    }
    t[0] ^= Rr[n], t[1] ^= Tr[n];
  }
  it(r);
}
var $e = class _$e extends kr {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, n, s2 = false, o = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = s2, this.rounds = o, je(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = wr(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ye(this.state32), Ur(this.state32, this.rounds), Ye(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    We(this), e = at(e), re(e);
    const { blockLen: r, state: n } = this, s2 = e.length;
    for (let o = 0; o < s2; ) {
      const a = Math.min(r - this.pos, s2 - o);
      for (let i2 = 0; i2 < a; i2++)
        n[this.pos++] ^= e[o++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: e, suffix: r, pos: n, blockLen: s2 } = this;
    e[n] ^= r, (r & 128) !== 0 && n === s2 - 1 && this.keccak(), e[s2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    We(this, false), re(e), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let s2 = 0, o = e.length; s2 < o; ) {
      this.posOut >= n && this.keccak();
      const a = Math.min(n - this.posOut, o - s2);
      e.set(r.subarray(this.posOut, this.posOut + a), s2), this.posOut += a, s2 += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return je(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (gr(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, it(this.state);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: n, outputLen: s2, rounds: o, enableXOF: a } = this;
    return e || (e = new _$e(r, n, s2, a, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = n, e.outputLen = s2, e.enableXOF = a, e.destroyed = this.destroyed, e;
  }
};
var zr = (t, e, r) => _r(() => new $e(e, t, r));
var Dr = zr(1, 136, 256 / 8);
var ft = false;
var ut = function(t) {
  return Dr(t);
};
var gt = ut;
function X(t) {
  const e = xe(t, "data");
  return fr(gt(e));
}
X._ = ut;
X.lock = function() {
  ft = true;
};
X.register = function(t) {
  if (ft)
    throw new TypeError("keccak256 is locked");
  gt = t;
};
Object.freeze(X);
var Or = BigInt(0);
var Lr = BigInt(36);
function qe(t) {
  t = t.toLowerCase();
  const e = t.substring(2).split(""), r = new Uint8Array(40);
  for (let s2 = 0; s2 < 40; s2++)
    r[s2] = e[s2].charCodeAt(0);
  const n = xe(X(r));
  for (let s2 = 0; s2 < 40; s2 += 2)
    n[s2 >> 1] >> 4 >= 8 && (e[s2] = e[s2].toUpperCase()), (n[s2 >> 1] & 15) >= 8 && (e[s2 + 1] = e[s2 + 1].toUpperCase());
  return "0x" + e.join("");
}
var Ie = {};
for (let t = 0; t < 10; t++)
  Ie[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  Ie[String.fromCharCode(65 + t)] = String(10 + t);
var Ge = 15;
function Mr(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((n) => Ie[n]).join("");
  for (; e.length >= Ge; ) {
    let n = e.substring(0, Ge);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
var Qr = function() {
  const t = {};
  for (let e = 0; e < 36; e++) {
    const r = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    t[r] = BigInt(e);
  }
  return t;
}();
function Fr(t) {
  t = t.toLowerCase();
  let e = Or;
  for (let r = 0; r < t.length; r++)
    e = e * Lr + Qr[t[r]];
  return e;
}
function N(t) {
  if (Y2(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    t.startsWith("0x") || (t = "0x" + t);
    const e = qe(t);
    return Y2(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e;
  }
  if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    Y2(t.substring(2, 4) === Mr(t), "bad icap checksum", "address", t);
    let e = Fr(t.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return qe("0x" + e);
  }
  Y2(false, "invalid address", "address", t);
}
var jr = class {
  type = "argent";
  platform = "starknet";
  wallet = void 0;
  account = void 0;
  connectedAccounts = [];
  accountChangeListener = void 0;
  isAvailable() {
    return typeof window < "u" && !!window.starknet_argentX;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.starknet_argentX?.version || "Unknown" : void 0,
      chainId: e ? window.starknet_argentX?.chainId : void 0,
      name: "Argent",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Argent is not available");
      const e = window.starknet_argentX;
      if (!e)
        throw new Error("No wallet found");
      const r = await e.request({
        type: "wallet_requestAccounts",
        params: { silent_mode: false }
      });
      if (!r || r.length === 0)
        throw new Error("No accounts found");
      return this.removeAccountChangeListener(), this.wallet = e, this.account = r[0], this.connectedAccounts = r, this.setupAccountChangeListener(), { success: true, wallet: this.type, account: this.account };
    } catch (e) {
      return console.error("Error connecting to Argent:", e), {
        success: false,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      const r = await this.wallet.request({
        type: "wallet_signTypedData",
        params: e
      });
      return { success: true, wallet: this.type, result: r };
    } catch (r) {
      return console.error("Error signing typed data with Argent:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    if (!this.wallet)
      throw new Error("No wallet found");
    try {
      const r = await this.wallet.request({
        type: "wallet_addInvokeTransaction",
        params: {
          calls: e
        }
      });
      return {
        success: true,
        wallet: this.type,
        result: r
      };
    } catch (r) {
      return console.error("Error sending transaction with Argent:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async switchChain(e) {
    if (!this.wallet)
      throw new Error("No wallet found");
    return await this.wallet.request({
      type: "wallet_switchStarknetChain",
      params: {
        chainId: e
      }
    });
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      return {
        success: true,
        wallet: this.type,
        result: "Implement based on Argent API"
      };
    } catch (r) {
      return console.error("Error getting balance from Argent:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async waitForTransaction(e, r) {
    return {
      success: false,
      wallet: this.type,
      error: "waitForTransaction not supported for Argent wallet"
    };
  }
  setupAccountChangeListener() {
    this.wallet && (this.accountChangeListener = (e) => {
      e && e.length > 0 ? (this.account = e[0], this.connectedAccounts = e) : (this.account = void 0, this.connectedAccounts = []);
    }, this.wallet.on("accountsChanged", this.accountChangeListener));
  }
  removeAccountChangeListener() {
    this.wallet && this.accountChangeListener && (this.wallet.off("accountsChanged", this.accountChangeListener), this.accountChangeListener = void 0);
  }
  disconnect() {
    this.removeAccountChangeListener(), this.wallet = void 0, this.account = void 0, this.connectedAccounts = [];
  }
};
function Wr(t) {
  if (typeof window > "u")
    return;
  const e = (r) => t(r.detail);
  return window.addEventListener("eip6963:announceProvider", e), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", e);
}
function Yr() {
  const t = /* @__PURE__ */ new Set();
  let e = [];
  const r = () => Wr((s2) => {
    e.some(({ info: o }) => o.uuid === s2.info.uuid) || (e = [...e, s2], t.forEach((o) => o(e, { added: [s2] })));
  });
  let n = r();
  return {
    _listeners() {
      return t;
    },
    clear() {
      t.forEach((s2) => s2([], { removed: [...e] })), e = [];
    },
    destroy() {
      this.clear(), t.clear(), n?.();
    },
    findProvider({ rdns: s2 }) {
      return e.find((o) => o.info.rdns === s2);
    },
    getProviders() {
      return e;
    },
    reset() {
      this.clear(), n?.(), n = r();
    },
    subscribe(s2, { emitImmediately: o } = {}) {
      return t.add(s2), o && s2(e, { added: e }), () => t.delete(s2);
    }
  };
}
var Hr = {
  "0x1": "ethereum",
  // ethereum mainnet
  "0xaa36a7": "ethereum",
  // ethereum sepolia
  "0x14a34": "base",
  // base mainnet
  "0x2105": "base",
  // base sepolia
  "0x66eee": "arbitrum",
  // arbitrum mainnet
  "0xa4b1": "arbitrum",
  // arbitrum sepolia
  "0xa": "optimism",
  // op mainnet
  "0xaa37dc": "optimism",
  // op sepolia
  [constants_exports.StarknetChainId.SN_MAIN]: "starknet",
  [constants_exports.StarknetChainId.SN_SEPOLIA]: "starknet"
};
var fe = (t) => {
  const e = num_exports.toHex(t), r = Hr[e];
  return r || console.warn(`Unknown chain ID: ${e}`), r;
};
var Se = class {
  platform;
  account = void 0;
  store = Yr();
  provider;
  connectedAccounts = [];
  constructor() {
    this.initializeIfAvailable();
  }
  getProvider() {
    return this.provider || (this.provider = this.store.getProviders().find((e) => e.info.rdns === this.rdns)), this.provider;
  }
  getEthereumProvider() {
    const e = this.getProvider();
    return e ? e.provider : this.rdns === "io.metamask" && typeof window < "u" && window.ethereum?.isMetaMask ? window.ethereum : null;
  }
  initializeIfAvailable() {
    this.getProvider() && !this.initialized && (this.initialized = true, this.initializeProvider());
  }
  initialized = false;
  initializeProvider() {
    const e = this.getProvider();
    e && (e.provider.request({
      method: "eth_accounts"
    }).then((r) => {
      this.connectedAccounts = r.map(N), r.length > 0 && (this.account = N(r[0]));
    }).catch(console.error), e.provider.request({
      method: "eth_chainId"
    }).then((r) => {
      this.platform = fe(r);
    }).catch(console.error), e.provider?.on("chainChanged", (r) => {
      this.platform = fe(r);
    }), e.provider?.on("accountsChanged", (r) => {
      r && (this.connectedAccounts = r.map((n) => N(n)), this.account = r.length > 0 ? N(r[0]) : void 0);
    }));
  }
  isAvailable() {
    const e = this.getProvider();
    return !e && this.rdns === "io.metamask" && typeof window < "u" ? !!window.ethereum?.isMetaMask : (e && !this.initialized && this.initializeIfAvailable(), typeof window < "u" && !!e);
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.ethereum?.version || "Unknown" : void 0,
      chainId: e ? window.ethereum?.chainId : void 0,
      name: this.displayName,
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async connect(e) {
    if (e && this.connectedAccounts.includes(N(e)) && (this.account = N(e)), this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error(`${this.displayName} is not available`);
      let r;
      const n = this.getProvider();
      if (n ? r = n.provider : this.rdns === "io.metamask" && window.ethereum?.isMetaMask && (r = window.ethereum), !r)
        throw new Error(`${this.displayName} provider not found`);
      const s2 = await r.request({
        method: "eth_requestAccounts"
      });
      if (s2 && s2.length > 0)
        return this.account = N(s2[0]), this.connectedAccounts = s2.map(N), !n && this.rdns === "io.metamask" && (this.provider = {
          info: {
            uuid: "metamask-fallback",
            name: "MetaMask",
            icon: "data:image/svg+xml;base64,",
            rdns: "io.metamask"
          },
          provider: r
        }, this.initializeIfAvailable()), { success: true, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (r) {
      return console.error(`Error connecting to ${this.displayName}:`, r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async signTransaction(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error(`${this.displayName} is not connected`);
      const r = this.getEthereumProvider();
      if (!r)
        throw new Error(`${this.displayName} is not connected`);
      const n = await r.request({
        method: "eth_sendTransaction",
        params: [e]
      });
      return { success: true, wallet: this.type, result: n };
    } catch (r) {
      return console.error(
        `Error signing transaction with ${this.displayName}:`,
        r
      ), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async signMessage(e, r) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error(`${this.displayName} is not connected`);
      const n = this.getEthereumProvider();
      if (!n)
        throw new Error(`${this.displayName} provider not found`);
      const s2 = await n.request({
        method: "personal_sign",
        params: [e, r || this.account]
      });
      return { success: true, wallet: this.type, result: s2 };
    } catch (n) {
      return console.error(`Error signing message with ${this.displayName}:`, n), {
        success: false,
        wallet: this.type,
        error: n.message || "Unknown error"
      };
    }
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error(`${this.displayName} is not connected`);
      const r = this.getEthereumProvider();
      if (!r)
        throw new Error(`${this.displayName} is not connected`);
      const n = await r.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e)]
      });
      return { success: true, wallet: this.type, result: n };
    } catch (r) {
      return console.error(
        `Error signing typed data with ${this.displayName}:`,
        r
      ), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error(`${this.displayName} is not connected`);
      const r = this.getEthereumProvider();
      if (!r)
        throw new Error(`${this.displayName} is not connected`);
      const n = await r.request({
        method: "eth_sendTransaction",
        params: [e]
      });
      return { success: true, wallet: this.type, result: n };
    } catch (r) {
      return console.error(
        `Error sending transaction with ${this.displayName}:`,
        r
      ), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async switchChain(e) {
    try {
      if (!this.isAvailable())
        throw new Error(`${this.displayName} is not available`);
      const r = this.getEthereumProvider();
      if (!r)
        throw new Error(`${this.displayName} is not connected`);
      try {
        return await r.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e }]
        }), this.platform = fe(e), true;
      } catch (n) {
        throw n.code === 4902 && console.warn(`Chain not added to ${this.displayName}`), n;
      }
    } catch (r) {
      return console.error(`Error switching chain for ${this.displayName}:`, r), false;
    }
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error(`${this.displayName} is not connected`);
      if (e)
        return {
          success: false,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const r = this.getEthereumProvider();
        if (!r)
          throw new Error(`${this.displayName} is not connected`);
        const n = await r.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: true, wallet: this.type, result: n };
      }
    } catch (r) {
      return console.error(`Error getting balance from ${this.displayName}:`, r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async waitForTransaction(e, r = 6e4) {
    try {
      if (!this.isAvailable())
        throw new Error(`${this.displayName} is not connected`);
      const n = this.getEthereumProvider();
      if (!n)
        throw new Error(`${this.displayName} is not connected`);
      const s2 = Date.now(), o = 1e3;
      for (; Date.now() - s2 < r; ) {
        const a = await n.request({
          method: "eth_getTransactionReceipt",
          params: [e]
        });
        if (a)
          return {
            success: true,
            wallet: this.type,
            result: a
          };
        await new Promise((i2) => setTimeout(i2, o));
      }
      throw new Error("Transaction confirmation timed out");
    } catch (n) {
      return console.error(
        `Error waiting for transaction with ${this.displayName}:`,
        n
      ), {
        success: false,
        wallet: this.type,
        error: n.message || "Unknown error"
      };
    }
  }
};
var Kr = class extends Se {
  type = "base";
  rdns = "com.coinbase.wallet";
  displayName = "Base Wallet";
};
var Vr = class extends Se {
  type = "metamask";
  rdns = "io.metamask";
  displayName = "MetaMask";
};
function Ce(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function wt(t, ...e) {
  if (!Ce(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function pt(t, e) {
  return Array.isArray(e) ? e.length === 0 ? true : t ? e.every((r) => typeof r == "string") : e.every((r) => Number.isSafeInteger(r)) : false;
}
function qr(t) {
  if (typeof t != "function")
    throw new Error("function expected");
  return true;
}
function j(t, e) {
  if (typeof e != "string")
    throw new Error(`${t}: string expected`);
  return true;
}
function J(t) {
  if (!Number.isSafeInteger(t))
    throw new Error(`invalid integer: ${t}`);
}
function ne(t) {
  if (!Array.isArray(t))
    throw new Error("array expected");
}
function se(t, e) {
  if (!pt(true, e))
    throw new Error(`${t}: array of strings expected`);
}
function yt(t, e) {
  if (!pt(false, e))
    throw new Error(`${t}: array of numbers expected`);
}
function Be(...t) {
  const e = (o) => o, r = (o, a) => (i2) => o(a(i2)), n = t.map((o) => o.encode).reduceRight(r, e), s2 = t.map((o) => o.decode).reduce(r, e);
  return { encode: n, decode: s2 };
}
function Pe(t) {
  const e = typeof t == "string" ? t.split("") : t, r = e.length;
  se("alphabet", e);
  const n = new Map(e.map((s2, o) => [s2, o]));
  return {
    encode: (s2) => (ne(s2), s2.map((o) => {
      if (!Number.isSafeInteger(o) || o < 0 || o >= r)
        throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);
      return e[o];
    })),
    decode: (s2) => (ne(s2), s2.map((o) => {
      j("alphabet.decode", o);
      const a = n.get(o);
      if (a === void 0)
        throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);
      return a;
    }))
  };
}
function Ne(t = "") {
  return j("join", t), {
    encode: (e) => (se("join.decode", e), e.join(t)),
    decode: (e) => (j("join.decode", e), e.split(t))
  };
}
function Gr(t, e = "=") {
  return J(t), j("padding", e), {
    encode(r) {
      for (se("padding.encode", r); r.length * t % 8; )
        r.push(e);
      return r;
    },
    decode(r) {
      se("padding.decode", r);
      let n = r.length;
      if (n * t % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === e; n--)
        if ((n - 1) * t % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return r.slice(0, n);
    }
  };
}
function Xr(t) {
  return qr(t), { encode: (e) => e, decode: (e) => t(e) };
}
function Xe(t, e, r) {
  if (e < 2)
    throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
  if (ne(t), !t.length)
    return [];
  let n = 0;
  const s2 = [], o = Array.from(t, (i2) => {
    if (J(i2), i2 < 0 || i2 >= e)
      throw new Error(`invalid integer: ${i2}`);
    return i2;
  }), a = o.length;
  for (; ; ) {
    let i2 = 0, l2 = true;
    for (let c = n; c < a; c++) {
      const d2 = o[c], h2 = e * i2, f2 = h2 + d2;
      if (!Number.isSafeInteger(f2) || h2 / e !== i2 || f2 - d2 !== h2)
        throw new Error("convertRadix: carry overflow");
      const u2 = f2 / r;
      i2 = f2 % r;
      const w2 = Math.floor(u2);
      if (o[c] = w2, !Number.isSafeInteger(w2) || w2 * r + i2 !== f2)
        throw new Error("convertRadix: carry overflow");
      if (l2)
        w2 ? l2 = false : n = c;
      else continue;
    }
    if (s2.push(i2), l2)
      break;
  }
  for (let i2 = 0; i2 < t.length - 1 && t[i2] === 0; i2++)
    s2.push(0);
  return s2.reverse();
}
var mt = (t, e) => e === 0 ? t : mt(e, t % e);
var oe = (t, e) => t + (e - mt(t, e));
var ue = (() => {
  let t = [];
  for (let e = 0; e < 40; e++)
    t.push(2 ** e);
  return t;
})();
function Je(t, e, r, n) {
  if (ne(t), e <= 0 || e > 32)
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (oe(e, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${oe(e, r)}`);
  let s2 = 0, o = 0;
  const a = ue[e], i2 = ue[r] - 1, l2 = [];
  for (const c of t) {
    if (J(c), c >= a)
      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);
    if (s2 = s2 << e | c, o + e > 32)
      throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);
    for (o += e; o >= r; o -= r)
      l2.push((s2 >> o - r & i2) >>> 0);
    const d2 = ue[o];
    if (d2 === void 0)
      throw new Error("invalid carry");
    s2 &= d2 - 1;
  }
  if (s2 = s2 << r - o & i2, !n && o >= e)
    throw new Error("Excess padding");
  if (!n && s2 > 0)
    throw new Error(`Non-zero padding: ${s2}`);
  return n && o > 0 && l2.push(s2 >>> 0), l2;
}
function Jr(t) {
  J(t);
  const e = 2 ** 8;
  return {
    encode: (r) => {
      if (!Ce(r))
        throw new Error("radix.encode input should be Uint8Array");
      return Xe(Array.from(r), e, t);
    },
    decode: (r) => (yt("radix.decode", r), Uint8Array.from(Xe(r, t, e)))
  };
}
function bt(t, e = false) {
  if (J(t), t <= 0 || t > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (oe(8, t) > 32 || oe(t, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!Ce(r))
        throw new Error("radix2.encode input should be Uint8Array");
      return Je(Array.from(r), 8, t, !e);
    },
    decode: (r) => (yt("radix2.decode", r), Uint8Array.from(Je(r, t, 8, e)))
  };
}
var Zr = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function";
var en = Zr ? {
  encode(t) {
    return wt(t), t.toBase64();
  },
  decode(t) {
    return j("base64", t), Uint8Array.fromBase64(t, { lastChunkHandling: "strict" });
  }
} : Be(bt(6), Pe("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), Gr(6), Ne(""));
var tn = (t) => Be(Jr(58), Pe(t), Ne(""));
var ke = tn("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var rn = {
  encode: (t) => new TextDecoder().decode(t),
  decode: (t) => new TextEncoder().encode(t)
};
var nn = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var sn = {
  encode(t) {
    return wt(t), t.toHex();
  },
  decode(t) {
    return j("hex", t), Uint8Array.fromHex(t);
  }
};
var ge = nn ? sn : Be(bt(4), Pe("0123456789abcdef"), Ne(""), Xr((t) => {
  if (typeof t != "string" || t.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);
  return t.toLowerCase();
}));
function _e(t, e) {
  if (t.length !== e.length)
    return false;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return false;
  return true;
}
function R(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
var kt = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function L2(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function B(t) {
  return Number.isSafeInteger(t);
}
var _t = (t) => {
  if (t !== null && typeof t != "string" && !I(t) && !R(t) && !B(t))
    throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${t} (${typeof t})`);
  return {
    encodeStream(e, r) {
      if (t === null)
        return;
      if (I(t))
        return t.encodeStream(e, r);
      let n;
      if (typeof t == "number" ? n = t : typeof t == "string" && (n = O2.resolve(e.stack, t)), typeof n == "bigint" && (n = Number(n)), n === void 0 || n !== r)
        throw e.err(`Wrong length: ${n} len=${t} exp=${r} (${typeof r})`);
    },
    decodeStream(e) {
      let r;
      if (I(t) ? r = Number(t.decodeStream(e)) : typeof t == "number" ? r = t : typeof t == "string" && (r = O2.resolve(e.stack, t)), typeof r == "bigint" && (r = Number(r)), typeof r != "number")
        throw e.err(`Wrong length: ${r}`);
      return r;
    }
  };
};
var A = {
  BITS: 32,
  FULL_MASK: -1 >>> 0,
  // 1<<32 will overflow
  len: (t) => Math.ceil(t / 32),
  create: (t) => new Uint32Array(A.len(t)),
  clean: (t) => t.fill(0),
  debug: (t) => Array.from(t).map((e) => (e >>> 0).toString(2).padStart(32, "0")),
  checkLen: (t, e) => {
    if (A.len(e) !== t.length)
      throw new Error(`wrong length=${t.length}. Expected: ${A.len(e)}`);
  },
  chunkLen: (t, e, r) => {
    if (e < 0)
      throw new Error(`wrong pos=${e}`);
    if (e + r > t)
      throw new Error(`wrong range=${e}/${r} of ${t}`);
  },
  set: (t, e, r, n = true) => !n && (t[e] & r) !== 0 ? false : (t[e] |= r, true),
  pos: (t, e) => ({
    chunk: Math.floor((t + e) / 32),
    mask: 1 << 32 - (t + e) % 32 - 1
  }),
  indices: (t, e, r = false) => {
    A.checkLen(t, e);
    const { FULL_MASK: n, BITS: s2 } = A, o = s2 - e % s2, a = o ? n >>> o << o : n, i2 = [];
    for (let l2 = 0; l2 < t.length; l2++) {
      let c = t[l2];
      if (r && (c = ~c), l2 === t.length - 1 && (c &= a), c !== 0)
        for (let d2 = 0; d2 < s2; d2++) {
          const h2 = 1 << s2 - d2 - 1;
          c & h2 && i2.push(l2 * s2 + d2);
        }
    }
    return i2;
  },
  range: (t) => {
    const e = [];
    let r;
    for (const n of t)
      r === void 0 || n !== r.pos + r.length ? e.push(r = { pos: n, length: 1 }) : r.length += 1;
    return e;
  },
  rangeDebug: (t, e, r = false) => `[${A.range(A.indices(t, e, r)).map((n) => `(${n.pos}/${n.length})`).join(", ")}]`,
  setRange: (t, e, r, n, s2 = true) => {
    A.chunkLen(e, r, n);
    const { FULL_MASK: o, BITS: a } = A, i2 = r % a ? Math.floor(r / a) : void 0, l2 = r + n, c = l2 % a ? Math.floor(l2 / a) : void 0;
    if (i2 !== void 0 && i2 === c)
      return A.set(t, i2, o >>> a - n << a - n - r, s2);
    if (i2 !== void 0 && !A.set(t, i2, o >>> r % a, s2))
      return false;
    const d2 = i2 !== void 0 ? i2 + 1 : r / a, h2 = c !== void 0 ? c : l2 / a;
    for (let f2 = d2; f2 < h2; f2++)
      if (!A.set(t, f2, o, s2))
        return false;
    return !(c !== void 0 && i2 !== c && !A.set(t, c, o << a - l2 % a, s2));
  }
};
var O2 = {
  /**
   * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
   * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
   * Also, this makes impossible:
   * - pushing field when stack is empty
   * - pushing field inside of field (real bug)
   * NOTE: we don't want to do '.pop' on error!
   */
  pushObj: (t, e, r) => {
    const n = { obj: e };
    t.push(n), r((s2, o) => {
      n.field = s2, o(), n.field = void 0;
    }), t.pop();
  },
  path: (t) => {
    const e = [];
    for (const r of t)
      r.field !== void 0 && e.push(r.field);
    return e.join("/");
  },
  err: (t, e, r) => {
    const n = new Error(`${t}(${O2.path(e)}): ${typeof r == "string" ? r : r.message}`);
    return r instanceof Error && r.stack && (n.stack = r.stack), n;
  },
  resolve: (t, e) => {
    const r = e.split("/"), n = t.map((a) => a.obj);
    let s2 = 0;
    for (; s2 < r.length && r[s2] === ".."; s2++)
      n.pop();
    let o = n.pop();
    for (; s2 < r.length; s2++) {
      if (!o || o[r[s2]] === void 0)
        return;
      o = o[r[s2]];
    }
    return o;
  }
};
var Re = class _Re {
  constructor(e, r = {}, n = [], s2 = void 0, o = 0) {
    this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.data = e, this.opts = r, this.stack = n, this.parent = s2, this.parentOffset = o, this.view = kt(e);
  }
  /** Internal method for pointers. */
  _enablePointers() {
    if (this.parent)
      return this.parent._enablePointers();
    this.bs || (this.bs = A.create(this.data.length), A.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
  }
  markBytesBS(e, r) {
    return this.parent ? this.parent.markBytesBS(this.parentOffset + e, r) : !r || !this.bs ? true : A.setRange(this.bs, this.data.length, e, r, false);
  }
  markBytes(e) {
    const r = this.pos;
    this.pos += e;
    const n = this.markBytesBS(r, e);
    if (!this.opts.allowMultipleReads && !n)
      throw this.err(`multiple read pos=${this.pos} len=${e}`);
    return n;
  }
  pushObj(e, r) {
    return O2.pushObj(this.stack, e, r);
  }
  readView(e, r) {
    if (!Number.isFinite(e))
      throw this.err(`readView: wrong length=${e}`);
    if (this.pos + e > this.data.length)
      throw this.err("readView: Unexpected end of buffer");
    const n = r(this.view, this.pos);
    return this.markBytes(e), n;
  }
  // read bytes by absolute offset
  absBytes(e) {
    if (e > this.data.length)
      throw new Error("Unexpected end of buffer");
    return this.data.subarray(e);
  }
  finish() {
    if (!this.opts.allowUnreadBytes) {
      if (this.bitPos)
        throw this.err(`${this.bitPos} bits left after unpack: ${ge.encode(this.data.slice(this.pos))}`);
      if (this.bs && !this.parent) {
        const e = A.indices(this.bs, this.data.length, true);
        if (e.length) {
          const r = A.range(e).map(({ pos: n, length: s2 }) => `(${n}/${s2})[${ge.encode(this.data.subarray(n, n + s2))}]`).join(", ");
          throw this.err(`unread byte ranges: ${r} (total=${this.data.length})`);
        } else
          return;
      }
      if (!this.isEnd())
        throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${ge.encode(this.data.slice(this.pos))}`);
    }
  }
  // User methods
  err(e) {
    return O2.err("Reader", this.stack, e);
  }
  offsetReader(e) {
    if (e > this.data.length)
      throw this.err("offsetReader: Unexpected end of buffer");
    return new _Re(this.absBytes(e), this.opts, this.stack, this, e);
  }
  bytes(e, r = false) {
    if (this.bitPos)
      throw this.err("readBytes: bitPos not empty");
    if (!Number.isFinite(e))
      throw this.err(`readBytes: wrong length=${e}`);
    if (this.pos + e > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const n = this.data.subarray(this.pos, this.pos + e);
    return r || this.markBytes(e), n;
  }
  byte(e = false) {
    if (this.bitPos)
      throw this.err("readByte: bitPos not empty");
    if (this.pos + 1 > this.data.length)
      throw this.err("readBytes: Unexpected end of buffer");
    const r = this.data[this.pos];
    return e || this.markBytes(1), r;
  }
  get leftBytes() {
    return this.data.length - this.pos;
  }
  get totalBytes() {
    return this.data.length;
  }
  isEnd() {
    return this.pos >= this.data.length && !this.bitPos;
  }
  // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
  bits(e) {
    if (e > 32)
      throw this.err("BitReader: cannot read more than 32 bits in single call");
    let r = 0;
    for (; e; ) {
      this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
      const n = Math.min(e, this.bitPos);
      this.bitPos -= n, r = r << n | this.bitBuf >> this.bitPos & 2 ** n - 1, this.bitBuf &= 2 ** this.bitPos - 1, e -= n;
    }
    return r >>> 0;
  }
  find(e, r = this.pos) {
    if (!R(e))
      throw this.err(`find: needle is not bytes! ${e}`);
    if (this.bitPos)
      throw this.err("findByte: bitPos not empty");
    if (!e.length)
      throw this.err("find: needle is empty");
    for (let n = r; (n = this.data.indexOf(e[0], n)) !== -1; n++) {
      if (n === -1 || this.data.length - n < e.length)
        return;
      if (_e(e, this.data.subarray(n, n + e.length)))
        return n;
    }
  }
};
var on = class {
  constructor(e = []) {
    this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = false, this.stack = e, this.view = kt(this.viewBuf);
  }
  pushObj(e, r) {
    return O2.pushObj(this.stack, e, r);
  }
  writeView(e, r) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (!B(e) || e > 8)
      throw new Error(`wrong writeView length=${e}`);
    r(this.view), this.bytes(this.viewBuf.slice(0, e)), this.viewBuf.fill(0);
  }
  // User methods
  err(e) {
    if (this.finished)
      throw this.err("buffer: finished");
    return O2.err("Reader", this.stack, e);
  }
  bytes(e) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeBytes: ends with non-empty bit buffer");
    this.buffers.push(e), this.pos += e.length;
  }
  byte(e) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("writeByte: ends with non-empty bit buffer");
    this.buffers.push(new Uint8Array([e])), this.pos++;
  }
  finish(e = true) {
    if (this.finished)
      throw this.err("buffer: finished");
    if (this.bitPos)
      throw this.err("buffer: ends with non-empty bit buffer");
    const r = this.buffers.concat(this.ptrs.map((o) => o.buffer)), n = r.map((o) => o.length).reduce((o, a) => o + a, 0), s2 = new Uint8Array(n);
    for (let o = 0, a = 0; o < r.length; o++) {
      const i2 = r[o];
      s2.set(i2, a), a += i2.length;
    }
    for (let o = this.pos, a = 0; a < this.ptrs.length; a++) {
      const i2 = this.ptrs[a];
      s2.set(i2.ptr.encode(o), i2.pos), o += i2.buffer.length;
    }
    if (e) {
      this.buffers = [];
      for (const o of this.ptrs)
        o.buffer.fill(0);
      this.ptrs = [], this.finished = true, this.bitBuf = 0;
    }
    return s2;
  }
  bits(e, r) {
    if (r > 32)
      throw this.err("writeBits: cannot write more than 32 bits in single call");
    if (e >= 2 ** r)
      throw this.err(`writeBits: value (${e}) >= 2**bits (${r})`);
    for (; r; ) {
      const n = Math.min(r, 8 - this.bitPos);
      this.bitBuf = this.bitBuf << n | e >> r - n, this.bitPos += n, r -= n, e &= 2 ** r - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([this.bitBuf])), this.pos++);
    }
  }
};
var Ae = (t) => Uint8Array.from(t).reverse();
function an(t, e, r) {
  if (r) {
    const n = 2n ** (e - 1n);
    if (t < -n || t >= n)
      throw new Error(`value out of signed bounds. Expected ${-n} <= ${t} < ${n}`);
  } else if (0n > t || t >= 2n ** e)
    throw new Error(`value out of unsigned bounds. Expected 0 <= ${t} < ${2n ** e}`);
}
function At(t) {
  return {
    // NOTE: we cannot export validate here, since it is likely mistake.
    encodeStream: t.encodeStream,
    decodeStream: t.decodeStream,
    size: t.size,
    encode: (e) => {
      const r = new on();
      return t.encodeStream(r, e), r.finish();
    },
    decode: (e, r = {}) => {
      const n = new Re(e, r), s2 = t.decodeStream(n);
      return n.finish(), s2;
    }
  };
}
function Et(t, e) {
  if (!I(t))
    throw new Error(`validate: invalid inner value ${t}`);
  if (typeof e != "function")
    throw new Error("validate: fn should be function");
  return At({
    size: t.size,
    encodeStream: (r, n) => {
      let s2;
      try {
        s2 = e(n);
      } catch (o) {
        throw r.err(o);
      }
      t.encodeStream(r, s2);
    },
    decodeStream: (r) => {
      const n = t.decodeStream(r);
      try {
        return e(n);
      } catch (s2) {
        throw r.err(s2);
      }
    }
  });
}
var x2 = (t) => {
  const e = At(t);
  return t.validate ? Et(e, t.validate) : e;
};
var ce = (t) => L2(t) && typeof t.decode == "function" && typeof t.encode == "function";
function I(t) {
  return L2(t) && ce(t) && typeof t.encodeStream == "function" && typeof t.decodeStream == "function" && (t.size === void 0 || B(t.size));
}
function cn() {
  return {
    encode: (t) => {
      if (!Array.isArray(t))
        throw new Error("array expected");
      const e = {};
      for (const r of t) {
        if (!Array.isArray(r) || r.length !== 2)
          throw new Error("array of two elements expected");
        const n = r[0], s2 = r[1];
        if (e[n] !== void 0)
          throw new Error(`key(${n}) appears twice in struct`);
        e[n] = s2;
      }
      return e;
    },
    decode: (t) => {
      if (!L2(t))
        throw new Error(`expected plain object, got ${t}`);
      return Object.entries(t);
    }
  };
}
var ln = {
  encode: (t) => {
    if (typeof t != "bigint")
      throw new Error(`expected bigint, got ${typeof t}`);
    if (t > BigInt(Number.MAX_SAFE_INTEGER))
      throw new Error(`element bigger than MAX_SAFE_INTEGER=${t}`);
    return Number(t);
  },
  decode: (t) => {
    if (!B(t))
      throw new Error("element is not a safe integer");
    return BigInt(t);
  }
};
function dn(t) {
  if (!L2(t))
    throw new Error("plain object expected");
  return {
    encode: (e) => {
      if (!B(e) || !(e in t))
        throw new Error(`wrong value ${e}`);
      return t[e];
    },
    decode: (e) => {
      if (typeof e != "string")
        throw new Error(`wrong value ${typeof e}`);
      return t[e];
    }
  };
}
function hn(t, e = false) {
  if (!B(t))
    throw new Error(`decimal/precision: wrong value ${t}`);
  if (typeof e != "boolean")
    throw new Error(`decimal/round: expected boolean, got ${typeof e}`);
  const r = 10n ** BigInt(t);
  return {
    encode: (n) => {
      if (typeof n != "bigint")
        throw new Error(`expected bigint, got ${typeof n}`);
      let s2 = (n < 0n ? -n : n).toString(10), o = s2.length - t;
      o < 0 && (s2 = s2.padStart(s2.length - o, "0"), o = 0);
      let a = s2.length - 1;
      for (; a >= o && s2[a] === "0"; a--)
        ;
      let i2 = s2.slice(0, o), l2 = s2.slice(o, a + 1);
      return i2 || (i2 = "0"), n < 0n && (i2 = "-" + i2), l2 ? `${i2}.${l2}` : i2;
    },
    decode: (n) => {
      if (typeof n != "string")
        throw new Error(`expected string, got ${typeof n}`);
      if (n === "-0")
        throw new Error("negative zero is not allowed");
      let s2 = false;
      if (n.startsWith("-") && (s2 = true, n = n.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(n))
        throw new Error(`wrong string value=${n}`);
      let o = n.indexOf(".");
      o = o === -1 ? n.length : o;
      const a = n.slice(0, o), i2 = n.slice(o + 1).replace(/0+$/, ""), l2 = BigInt(a) * r;
      if (!e && i2.length > t)
        throw new Error(`fractional part cannot be represented with this precision (num=${n}, prec=${t})`);
      const c = Math.min(i2.length, t), d2 = BigInt(i2.slice(0, c)) * 10n ** BigInt(t - c), h2 = l2 + d2;
      return s2 ? -h2 : h2;
    }
  };
}
function fn(t) {
  if (!Array.isArray(t))
    throw new Error(`expected array, got ${typeof t}`);
  for (const e of t)
    if (!ce(e))
      throw new Error(`wrong base coder ${e}`);
  return {
    encode: (e) => {
      for (const r of t) {
        const n = r.encode(e);
        if (n !== void 0)
          return n;
      }
      throw new Error(`match/encode: cannot find match in ${e}`);
    },
    decode: (e) => {
      for (const r of t) {
        const n = r.decode(e);
        if (n !== void 0)
          return n;
      }
      throw new Error(`match/decode: cannot find match in ${e}`);
    }
  };
}
var un = (t) => {
  if (!ce(t))
    throw new Error("BaseCoder expected");
  return { encode: t.decode, decode: t.encode };
};
var H = { dict: cn, numberBigint: ln, tsEnum: dn, decimal: hn, match: fn, reverse: un };
var gn = (t, e = false, r = false, n = true) => {
  if (!B(t))
    throw new Error(`bigint/size: wrong value ${t}`);
  if (typeof e != "boolean")
    throw new Error(`bigint/le: expected boolean, got ${typeof e}`);
  if (typeof r != "boolean")
    throw new Error(`bigint/signed: expected boolean, got ${typeof r}`);
  if (typeof n != "boolean")
    throw new Error(`bigint/sized: expected boolean, got ${typeof n}`);
  const s2 = BigInt(t), o = 2n ** (8n * s2 - 1n);
  return x2({
    size: n ? t : void 0,
    encodeStream: (a, i2) => {
      r && i2 < 0 && (i2 = i2 | o);
      const l2 = [];
      for (let d2 = 0; d2 < t; d2++)
        l2.push(Number(i2 & 255n)), i2 >>= 8n;
      let c = new Uint8Array(l2).reverse();
      if (!n) {
        let d2 = 0;
        for (d2 = 0; d2 < c.length && c[d2] === 0; d2++)
          ;
        c = c.subarray(d2);
      }
      a.bytes(e ? c.reverse() : c);
    },
    decodeStream: (a) => {
      const i2 = a.bytes(n ? t : Math.min(t, a.leftBytes)), l2 = e ? i2 : Ae(i2);
      let c = 0n;
      for (let d2 = 0; d2 < l2.length; d2++)
        c |= BigInt(l2[d2]) << 8n * BigInt(d2);
      return r && c & o && (c = (c ^ o) - o), c;
    },
    validate: (a) => {
      if (typeof a != "bigint")
        throw new Error(`bigint: invalid value: ${a}`);
      return an(a, 8n * s2, !!r), a;
    }
  });
};
var b2 = gn(8, true);
var wn = (t, e) => x2({
  size: t,
  encodeStream: (r, n) => r.writeView(t, (s2) => e.write(s2, n)),
  decodeStream: (r) => r.readView(t, e.read),
  validate: (r) => {
    if (typeof r != "number")
      throw new Error(`viewCoder: expected number, got ${typeof r}`);
    return e.validate && e.validate(r), r;
  }
});
var vt = (t, e, r) => {
  const n = t * 8, s2 = 2 ** (n - 1), o = (l2) => {
    if (!B(l2))
      throw new Error(`sintView: value is not safe integer: ${l2}`);
    if (l2 < -s2 || l2 >= s2)
      throw new Error(`sintView: value out of bounds. Expected ${-s2} <= ${l2} < ${s2}`);
  }, a = 2 ** n, i2 = (l2) => {
    if (!B(l2))
      throw new Error(`uintView: value is not safe integer: ${l2}`);
    if (0 > l2 || l2 >= a)
      throw new Error(`uintView: value out of bounds. Expected 0 <= ${l2} < ${a}`);
  };
  return wn(t, {
    write: r.write,
    read: r.read,
    validate: e ? o : i2
  });
};
var ie = vt(4, false, {
  read: (t, e) => t.getUint32(e, true),
  write: (t, e) => t.setUint32(0, e, true)
});
var $ = vt(1, false, {
  read: (t, e) => t.getUint8(e),
  write: (t, e) => t.setUint8(0, e)
});
var Ee = x2({
  size: 1,
  encodeStream: (t, e) => t.byte(e ? 1 : 0),
  decodeStream: (t) => {
    const e = t.byte();
    if (e !== 0 && e !== 1)
      throw t.err(`bool: invalid value ${e}`);
    return e === 1;
  },
  validate: (t) => {
    if (typeof t != "boolean")
      throw new Error(`bool: invalid value ${t}`);
    return t;
  }
});
var le = (t, e = false) => {
  if (typeof e != "boolean")
    throw new Error(`bytes/le: expected boolean, got ${typeof e}`);
  const r = _t(t), n = R(t);
  return x2({
    size: typeof t == "number" ? t : void 0,
    encodeStream: (s2, o) => {
      n || r.encodeStream(s2, o.length), s2.bytes(e ? Ae(o) : o), n && s2.bytes(t);
    },
    decodeStream: (s2) => {
      let o;
      if (n) {
        const a = s2.find(t);
        if (!a)
          throw s2.err("bytes: cannot find terminator");
        o = s2.bytes(a - s2.pos), s2.bytes(t.length);
      } else
        o = s2.bytes(t === null ? s2.leftBytes : r.decodeStream(s2));
      return e ? Ae(o) : o;
    },
    validate: (s2) => {
      if (!R(s2))
        throw new Error(`bytes: invalid value ${s2}`);
      return s2;
    }
  });
};
var pn = (t, e = false) => Et(yn(le(t, e), rn), (r) => {
  if (typeof r != "string")
    throw new Error(`expected string, got ${typeof r}`);
  return r;
});
function yn(t, e) {
  if (!I(t))
    throw new Error(`apply: invalid inner value ${t}`);
  if (!ce(e))
    throw new Error(`apply: invalid base value ${t}`);
  return x2({
    size: t.size,
    encodeStream: (r, n) => {
      let s2;
      try {
        s2 = e.decode(n);
      } catch (o) {
        throw r.err("" + o);
      }
      return t.encodeStream(r, s2);
    },
    decodeStream: (r) => {
      const n = t.decodeStream(r);
      try {
        return e.encode(n);
      } catch (s2) {
        throw r.err("" + s2);
      }
    }
  });
}
function q(t, e, r) {
  if (!I(t) || !I(e))
    throw new Error(`optional: invalid flag or inner value flag=${t} inner=${e}`);
  return x2({
    size: r !== void 0 && t.size && e.size ? t.size + e.size : void 0,
    encodeStream: (n, s2) => {
      t.encodeStream(n, !!s2), s2 ? e.encodeStream(n, s2) : r !== void 0 && e.encodeStream(n, r);
    },
    decodeStream: (n) => {
      if (t.decodeStream(n))
        return e.decodeStream(n);
      r !== void 0 && e.decodeStream(n);
    }
  });
}
function mn(t) {
  return x2({
    encodeStream: (e, r) => {
      if (r !== t)
        throw new Error(`constant: invalid value ${r} (exp: ${t})`);
    },
    decodeStream: (e) => t
  });
}
function bn(t) {
  let e = 0;
  for (const r of t) {
    if (r.size === void 0)
      return;
    if (!B(r.size))
      throw new Error(`sizeof: wrong element size=${e}`);
    e += r.size;
  }
  return e;
}
function g(t) {
  if (!L2(t))
    throw new Error(`struct: expected plain object, got ${t}`);
  for (const e in t)
    if (!I(t[e]))
      throw new Error(`struct: field ${e} is not CoderType`);
  return x2({
    size: bn(Object.values(t)),
    encodeStream: (e, r) => {
      e.pushObj(r, (n) => {
        for (const s2 in t)
          n(s2, () => t[s2].encodeStream(e, r[s2]));
      });
    },
    decodeStream: (e) => {
      const r = {};
      return e.pushObj(r, (n) => {
        for (const s2 in t)
          n(s2, () => r[s2] = t[s2].decodeStream(e));
      }), r;
    },
    validate: (e) => {
      if (typeof e != "object" || e === null)
        throw new Error(`struct: invalid value ${e}`);
      return e;
    }
  });
}
function te(t, e) {
  if (!I(e))
    throw new Error(`array: invalid inner value ${e}`);
  const r = _t(typeof t == "string" ? `../${t}` : t);
  return x2({
    size: typeof t == "number" && e.size ? t * e.size : void 0,
    encodeStream: (n, s2) => {
      const o = n;
      o.pushObj(s2, (a) => {
        R(t) || r.encodeStream(n, s2.length);
        for (let i2 = 0; i2 < s2.length; i2++)
          a(`${i2}`, () => {
            const l2 = s2[i2], c = n.pos;
            if (e.encodeStream(n, l2), R(t)) {
              if (t.length > o.pos - c)
                return;
              const d2 = o.finish(false).subarray(c, o.pos);
              if (_e(d2.subarray(0, t.length), t))
                throw o.err(`array: inner element encoding same as separator. elm=${l2} data=${d2}`);
            }
          });
      }), R(t) && n.bytes(t);
    },
    decodeStream: (n) => {
      const s2 = [];
      return n.pushObj(s2, (o) => {
        if (t === null)
          for (let a = 0; !n.isEnd() && (o(`${a}`, () => s2.push(e.decodeStream(n))), !(e.size && n.leftBytes < e.size)); a++)
            ;
        else if (R(t))
          for (let a = 0; ; a++) {
            if (_e(n.bytes(t.length, true), t)) {
              n.bytes(t.length);
              break;
            }
            o(`${a}`, () => s2.push(e.decodeStream(n)));
          }
        else {
          let a;
          o("arrayLen", () => a = r.decodeStream(n));
          for (let i2 = 0; i2 < a; i2++)
            o(`${i2}`, () => s2.push(e.decodeStream(n)));
        }
      }), s2;
    },
    validate: (n) => {
      if (!Array.isArray(n))
        throw new Error(`array: invalid value ${n}`);
      return n;
    }
  });
}
function Te(t, e) {
  if (!I(t))
    throw new Error(`map: invalid inner value ${t}`);
  if (!L2(e))
    throw new Error("map: variants should be plain object");
  const r = /* @__PURE__ */ new Map();
  for (const n in e)
    r.set(e[n], n);
  return x2({
    size: t.size,
    encodeStream: (n, s2) => t.encodeStream(n, e[s2]),
    decodeStream: (n) => {
      const s2 = t.decodeStream(n), o = r.get(s2);
      if (o === void 0)
        throw n.err(`Enum: unknown value: ${s2} ${Array.from(r.keys())}`);
      return o;
    },
    validate: (n) => {
      if (typeof n != "string")
        throw new Error(`map: invalid value ${n}`);
      if (!(n in e))
        throw new Error(`Map: unknown variant: ${n}`);
      return n;
    }
  });
}
function kn(t, e) {
  if (!I(t))
    throw new Error(`tag: invalid tag value ${t}`);
  if (!L2(e))
    throw new Error("tag: variants should be plain object");
  for (const r in e)
    if (!I(e[r]))
      throw new Error(`tag: variant ${r} is not CoderType`);
  return x2({
    size: t.size,
    encodeStream: (r, n) => {
      const { TAG: s2, data: o } = n, a = e[s2];
      t.encodeStream(r, s2), a.encodeStream(r, o);
    },
    decodeStream: (r) => {
      const n = t.decodeStream(r), s2 = e[n];
      if (!s2)
        throw r.err(`Tag: invalid tag ${n}`);
      return { TAG: n, data: s2.decodeStream(r) };
    },
    validate: (r) => {
      const { TAG: n } = r;
      if (!e[n])
        throw new Error(`Tag: invalid tag ${n.toString()}`);
      return r;
    }
  });
}
var _n = (t) => 0;
function we(t, e) {
  return e % t === 0 ? 0 : t - e % t;
}
function xt(t, e, r) {
  if (!I(e))
    throw new Error(`padRight: invalid inner value ${e}`);
  if (!B(t) || t <= 0)
    throw new Error(`padLeft: wrong blockSize=${t}`);
  if (r !== void 0 && typeof r != "function")
    throw new Error(`padRight: wrong padFn=${typeof r}`);
  const n = r || _n;
  return x2({
    size: e.size ? e.size + we(t, e.size) : void 0,
    encodeStream: (s2, o) => {
      const a = s2, i2 = a.pos;
      e.encodeStream(s2, o);
      const l2 = we(t, a.pos - i2);
      for (let c = 0; c < l2; c++)
        s2.byte(n(c));
    },
    decodeStream: (s2) => {
      const o = s2.pos, a = e.decodeStream(s2);
      return s2.bytes(we(t, s2.pos - o)), a;
    }
  });
}
var An = 9;
var pe = H.decimal(An);
var K = x2({
  encodeStream: (t, e) => {
    if (!e)
      return t.byte(0);
    for (; e; e >>= 7)
      t.bits(e > 127 ? 1 : 0, 1), t.bits(e & 127, 7);
  },
  decodeStream: (t) => {
    let e = 0;
    for (let r = 0; !t.isEnd(); r++) {
      const n = !t.bits(1);
      if (e |= t.bits(7) << r * 7, n)
        break;
    }
    return e;
  }
});
var ee = pn(xt(8, ie, void 0));
var En = () => {
  const t = le(32);
  return x2({
    size: t.size,
    encodeStream: (e, r) => t.encodeStream(e, ke.decode(r)),
    decodeStream: (e) => ke.encode(t.decodeStream(e))
  });
};
var y = En();
var vn = g({
  requiredSignatures: $,
  readSigned: $,
  readUnsigned: $,
  keys: te(K, y),
  blockhash: y,
  instructions: te(K, g({ programIdx: $, keys: te(K, $), data: le(K) }))
});
function xn(t) {
  if (ke.decode(t).length !== 32)
    throw new Error("Invalid Solana address");
}
var $n = (t, e, r, n, s2) => ({
  sign: t < e,
  write: t < e - r || t >= e && t < s2 - n
});
var Ze = g({
  signatures: te(K, le(64)),
  msg: vn
});
var ve = x2({
  encodeStream: (t, e) => {
    const { msg: r, signatures: n } = e, s2 = {}, o = (h2, f2, u2) => {
      let w2 = s2[h2] || (s2[h2] = { sign: false, write: false });
      w2.write || (w2.write = u2), w2.sign || (w2.sign = f2);
    };
    o(r.feePayer, true, true);
    for (let h2 of r.instructions)
      for (let f2 of h2.keys)
        o(f2.address, f2.sign, f2.write);
    for (let h2 of r.instructions)
      o(h2.program, false, false);
    const a = Object.keys(s2), i2 = [
      r.feePayer,
      ...a.filter((h2) => s2[h2].sign && s2[h2].write && h2 !== r.feePayer),
      ...a.filter((h2) => s2[h2].sign && !s2[h2].write),
      ...a.filter((h2) => !s2[h2].sign && s2[h2].write),
      ...a.filter((h2) => !s2[h2].sign && !s2[h2].write)
    ];
    let l2 = 0, c = 0, d2 = 0;
    for (let h2 of i2)
      s2[h2].sign && l2++, !s2[h2].write && (s2[h2].sign ? c++ : d2++);
    Ze.encodeStream(t, {
      signatures: i2.filter((h2) => s2[h2].sign).map((h2) => n[h2] || new Uint8Array(64)),
      msg: {
        requiredSignatures: l2,
        readSigned: c,
        readUnsigned: d2,
        keys: i2,
        // indexOf potentially can be slow, but for most tx there will be ~3-5 keys, so doesn't matter much
        instructions: r.instructions.map((h2) => ({
          programIdx: i2.indexOf(h2.program),
          keys: h2.keys.map((f2) => i2.indexOf(f2.address)),
          data: h2.data
        })),
        blockhash: r.blockhash
      }
    });
  },
  decodeStream: (t) => {
    const { signatures: e, msg: r } = Ze.decodeStream(t);
    if (e.length !== r.requiredSignatures)
      throw new Error("SOL.tx: wrong signatures length");
    if (r.keys.length < e.length)
      throw new Error("SOL.tx: invalid keys length");
    const n = {};
    for (let o = 0; o < e.length; o++)
      n[r.keys[o]] = e[o];
    let s2 = [];
    for (let o = 0; o < r.keys.length; o++)
      s2.push({
        address: r.keys[o],
        ...$n(o, r.requiredSignatures, r.readSigned, r.readUnsigned, r.keys.length)
      });
    if (!s2.length)
      throw new Error("SOL.tx: empty accounts array");
    return {
      msg: {
        feePayer: s2[0].address,
        blockhash: r.blockhash,
        instructions: r.instructions.map((o) => ({
          program: s2[o.programIdx].address,
          keys: o.keys.map((a) => s2[a]),
          data: o.data
        }))
      },
      signatures: n
    };
  }
});
var et = {};
function Ue(t, e, r) {
  if (et[t])
    throw new Error("SOL: program for this address already defined");
  const n = Te(e, Object.keys(r).reduce((i2, l2, c) => ({ ...i2, [l2]: c }), {})), s2 = Object.keys(r).reduce((i2, l2) => ({ ...i2, [l2]: r[l2].coder }), {}), o = kn(n, s2);
  et[t] = (i2, l2) => {
    if (i2.program !== t)
      throw new Error("SOL.parseInstruction: Wrong instruction program address");
    const { TAG: c, data: d2 } = o.decode(i2.data), h2 = { type: c, info: d2 }, f2 = Object.keys(r[c].keys);
    if (f2.length !== i2.keys.length)
      throw new Error("SOL.parseInstruction: Keys length mismatch");
    for (let u2 = 0; u2 < f2.length; u2++) {
      const w2 = f2[u2];
      if (r[c].keys[w2].address) {
        if (r[c].keys[w2].address !== i2.keys[u2].address)
          throw new Error(`SOL.parseInstruction(${t}/${c}): Invalid constant address for key exp=${r[c].keys[w2].address} got=${i2.keys[u2].address}`);
        continue;
      }
      h2.info[f2[u2]] = i2.keys[u2].address;
    }
    return r[c].hint && (h2.hint = r[c].hint(d2, l2)), h2;
  };
  const a = {};
  for (const i2 in r)
    a[i2] = (l2) => ({
      program: t,
      data: o.encode({ TAG: i2, data: l2 }),
      keys: Object.keys(r[i2].keys).map((c) => {
        let { sign: d2, write: h2, address: f2 } = r[i2].keys[c];
        return f2 || (f2 = l2[c]), xn(f2), { address: f2, sign: d2, write: h2 };
      })
    });
  return a;
}
var ye = "SysvarRecentB1ockHashes11111111111111111111";
var D = "SysvarRent111111111111111111111111111111111";
var $t = "11111111111111111111111111111111";
var It = Ue($t, ie, {
  createAccount: {
    coder: g({ lamports: b2, space: b2, owner: y }),
    keys: {
      source: { sign: true, write: true },
      newAccount: { sign: true, write: true }
    },
    hint: (t) => `Create new account=${t.newAccount} with balance of ${pe.encode(t.lamports)} and owner program ${t.owner}, using funding account ${t.source}`
  },
  assign: {
    coder: g({ owner: y }),
    keys: { account: { sign: true, write: true } },
    hint: (t) => `Assign account=${t.account} to owner program=${t.owner}`
  },
  transfer: {
    coder: g({ lamports: b2 }),
    keys: { source: { sign: true, write: true }, destination: { sign: false, write: true } },
    hint: (t) => `Transfer ${pe.encode(t.lamports)} SOL from ${t.source} to ${t.destination}`
  },
  createAccountWithSeed: {
    coder: g({
      base: y,
      seed: ee,
      lamports: b2,
      space: b2,
      owner: y
    }),
    keys: {
      source: { sign: true, write: true },
      newAccount: { sign: false, write: true },
      base: { sign: true, write: false }
    }
  },
  advanceNonce: {
    coder: g({}),
    keys: {
      nonceAccount: { sign: false, write: true },
      _recent_bh: { address: ye, sign: false, write: false },
      nonceAuthority: { sign: true, write: false }
    },
    hint: (t) => `Consume nonce in nonce account=${t.nonceAccount} (owner: ${t.nonceAuthority})`
  },
  withdrawFromNonce: {
    coder: g({ lamports: b2 }),
    keys: {
      nonceAccount: { sign: false, write: true },
      destination: { sign: false, write: true },
      _recent_bh: { address: ye, sign: false, write: false },
      _rent: { address: D, sign: false, write: false },
      nonceAuthority: { sign: true, write: false }
    },
    hint: (t) => `Withdraw ${pe.encode(t.lamports)} SOL from nonce account=${t.nonceAccount} (owner: ${t.nonceAuthority}) to ${t.destination}`
  },
  initializeNonce: {
    coder: g({ nonceAuthority: y }),
    keys: {
      nonceAccount: { sign: false, write: true },
      _recent_bh: { address: ye, sign: false, write: false },
      _rent: { address: D, sign: false, write: false }
    }
  },
  authorizeNonce: {
    coder: g({ newAuthorized: y }),
    keys: {
      nonceAccount: { sign: false, write: true },
      nonceAuthority: { sign: true, write: false }
    },
    hint: (t) => `Change owner of nonce account=${t.nonceAccount} from ${t.nonceAuthority} to ${t.newAuthorized}`
  },
  allocate: {
    coder: g({ space: b2 }),
    keys: {
      account: { sign: true, write: true }
    }
  },
  allocateWithSeed: {
    coder: g({
      base: y,
      seed: ee,
      space: b2,
      owner: y
    }),
    keys: {
      account: { sign: false, write: true },
      base: { sign: true, write: false }
    }
  },
  assignWithSeed: {
    coder: g({
      base: y,
      seed: ee,
      owner: y
    }),
    keys: {
      account: { sign: false, write: true },
      base: { sign: true, write: false }
    }
  },
  transferWithSeed: {
    coder: g({
      lamports: b2,
      sourceSeed: ee,
      sourceOwner: y
    }),
    keys: {
      source: { sign: false, write: true },
      sourceBase: { sign: true, write: false },
      destination: { sign: false, write: true }
    }
  }
});
var St = (t) => {
};
St(It.transfer);
St(It.advanceNonce);
var In = Te($, {
  MintTokens: 0,
  FreezeAccount: 1,
  AccountOwner: 2,
  CloseAccount: 3
});
var U2 = (t, e) => e[t]?.symbol || t;
var Ct = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
Ue(Ct, $, {
  initializeMint: {
    coder: g({
      decimals: $,
      mintAuthority: y,
      freezeAuthority: q(Ee, y, "11111111111111111111111111111111")
    }),
    keys: {
      mint: { sign: false, write: true },
      _rent: { address: D, sign: false, write: false }
    }
  },
  initializeAccount: {
    coder: g({}),
    keys: {
      account: { sign: false, write: true },
      mint: { sign: false, write: false },
      owner: { sign: false, write: false },
      _rent: { address: D, sign: false, write: false }
    },
    hint: (t, e) => `Initialize token account=${t.account} with owner=${t.owner} token=${U2(t.mint, e)}`
  },
  // TODO: multisig support?
  initializeMultisig: {
    coder: g({ m: $ }),
    keys: {
      account: { sign: false, write: true },
      _rent: { address: D, sign: false, write: false }
    },
    hint: (t, e) => `Initialize multi-sig token account=${t.account} with signatures=${t.m}`
  },
  transfer: {
    coder: g({ amount: b2 }),
    keys: {
      source: { sign: false, write: true },
      destination: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Transfer ${t.amount} from token account=${t.source} of owner=${t.owner} to ${t.destination}`
  },
  approve: {
    coder: g({ amount: b2 }),
    keys: {
      account: { sign: false, write: true },
      delegate: { sign: false, write: false },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Approve authority of delegate=${t.delegate} over tokens on account=${t.account} on behalf of owner=${t.owner}`
  },
  revoke: {
    coder: g({}),
    keys: {
      account: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Revoke delegate's authority over tokens on account=${t.account} on behalf of owner=${t.owner}`
  },
  setAuthority: {
    coder: g({
      authorityType: In,
      newAuthority: q(Ee, y, "11111111111111111111111111111111")
    }),
    keys: {
      account: { sign: false, write: true },
      currentAuthority: { sign: true, write: false }
    },
    hint: (t, e) => `Sets a new authority=${t.newAuthority} of a mint or account=${t.account}. Current authority=${t.currentAuthority}. Authority Type: ${t.authorityType}`
  },
  mintTo: {
    coder: g({ amount: b2 }),
    keys: {
      mint: { sign: false, write: true },
      dest: { sign: false, write: true },
      authority: { sign: true, write: false }
    }
  },
  burn: {
    coder: g({ amount: b2 }),
    keys: {
      account: { sign: false, write: true },
      mint: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Burn ${t.amount} tokens from account=${t.account} of owner=${t.owner} mint=${t.mint}`
  },
  closeAccount: {
    coder: g({}),
    keys: {
      account: { sign: false, write: true },
      dest: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Close token account=${t.account} of owner=${t.owner}, transferring all its SOL to destionation account=${t.dest}`
  },
  freezeAccount: {
    coder: g({}),
    keys: {
      account: { sign: false, write: true },
      mint: { sign: false, write: true },
      authority: { sign: true, write: false }
    },
    hint: (t, e) => `Freeze token account=${t.account} of mint=${t.mint} using freeze_authority=${t.authority}`
  },
  thawAccount: {
    coder: g({}),
    keys: {
      account: { sign: false, write: true },
      mint: { sign: false, write: false },
      authority: { sign: true, write: false }
    },
    hint: (t, e) => `Thaw a frozne token account=${t.account} of mint=${t.mint} using freeze_authority=${t.authority}`
  },
  transferChecked: {
    coder: g({ amount: b2, decimals: $ }),
    keys: {
      source: { sign: false, write: true },
      mint: { sign: false, write: false },
      destination: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Transfer ${H.decimal(t.decimals).encode(t.amount)} ${U2(t.mint, e)} from token account=${t.source} of owner=${t.owner} to ${t.destination}`
  },
  approveChecked: {
    coder: g({ amount: b2, decimals: $ }),
    keys: {
      source: { sign: false, write: true },
      mint: { sign: false, write: false },
      delegate: { sign: false, write: false },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Approve delgate=${t.delegate} authority on behalf account=${t.source} owner=${t.owner} over ${H.decimal(t.decimals).encode(t.amount)} ${U2(t.mint, e)}`
  },
  mintToChecked: {
    coder: g({ amount: b2, decimals: $ }),
    keys: {
      mint: { sign: false, write: true },
      dest: { sign: false, write: true },
      authority: { sign: true, write: false }
    },
    hint: (t, e) => `Mint new tokens (${H.decimal(t.decimals).encode(t.amount)} ${U2(t.mint, e)}) to account=${t.dest} using authority=${t.authority}`
  },
  burnChecked: {
    coder: g({ amount: b2, decimals: $ }),
    keys: {
      mint: { sign: false, write: true },
      account: { sign: false, write: true },
      owner: { sign: true, write: false }
    },
    hint: (t, e) => `Burn tokens (${H.decimal(t.decimals).encode(t.amount)} ${U2(t.mint, e)}) on account=${t.account} of owner=${t.owner}`
  },
  initializeAccount2: {
    coder: g({ owner: y }),
    keys: {
      account: { sign: false, write: true },
      mint: { sign: false, write: false },
      _rent: { address: D, sign: false, write: false }
    },
    hint: (t, e) => `Initialize token account=${t.account} with owner=${t.owner} token=${U2(t.mint, e)}`
  },
  syncNative: {
    coder: g({}),
    keys: { nativeAccount: { sign: false, write: true } },
    hint: (t) => `Sync SOL balance for wrapped account ${t.nativeAccount}`
  }
});
g({
  version: ie,
  state: ie,
  authority: y,
  nonce: y,
  lamportPerSignature: b2
});
var Sn = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
Ue(Sn, mn(0), {
  create: {
    coder: g({}),
    keys: {
      source: { sign: true, write: true },
      account: { sign: false, write: true },
      wallet: { sign: false, write: false },
      mint: { sign: false, write: false },
      _sys: { address: $t, sign: false, write: false },
      _token: { address: Ct, sign: false, write: false },
      _rent: { address: D, sign: false, write: false }
    },
    hint: (t, e) => `Initialize associated token account=${t.account} with owner=${t.wallet} for token=${U2(t.mint, e)}, payed by ${t.source}`
  }
});
var me = xt(4, Ee, () => 0);
g({
  mint: y,
  owner: y,
  amount: b2,
  delegate: q(me, y, "11111111111111111111111111111111"),
  state: Te($, {
    uninitialized: 0,
    initialized: 1,
    frozen: 2
  }),
  isNative: q(me, b2, 0n),
  delegateAmount: b2,
  closeAuthority: q(me, y, "11111111111111111111111111111111")
});
function tt(t, e, r) {
  if (!e.length)
    throw new Error("SOLPublic: empty instructions array");
  return en.encode(ve.encode({
    msg: { feePayer: t, blockhash: r, instructions: e },
    signatures: {}
  }));
}
function Cn(t) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  const e = new Uint8Array(256);
  for (let c = 0; c < e.length; c++)
    e[c] = 255;
  for (let c = 0; c < t.length; c++) {
    const d2 = t.charAt(c), h2 = d2.charCodeAt(0);
    if (e[h2] !== 255)
      throw new TypeError(d2 + " is ambiguous");
    e[h2] = c;
  }
  const r = t.length, n = t.charAt(0), s2 = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function a(c) {
    if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c.length === 0)
      return "";
    let d2 = 0, h2 = 0, f2 = 0;
    const u2 = c.length;
    for (; f2 !== u2 && c[f2] === 0; )
      f2++, d2++;
    const w2 = (u2 - f2) * o + 1 >>> 0, k2 = new Uint8Array(w2);
    for (; f2 !== u2; ) {
      let _ = c[f2], p2 = 0;
      for (let E2 = w2 - 1; (_ !== 0 || p2 < h2) && E2 !== -1; E2--, p2++)
        _ += 256 * k2[E2] >>> 0, k2[E2] = _ % r >>> 0, _ = _ / r >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      h2 = p2, f2++;
    }
    let m2 = w2 - h2;
    for (; m2 !== w2 && k2[m2] === 0; )
      m2++;
    let S2 = n.repeat(d2);
    for (; m2 < w2; ++m2)
      S2 += t.charAt(k2[m2]);
    return S2;
  }
  function i2(c) {
    if (typeof c != "string")
      throw new TypeError("Expected String");
    if (c.length === 0)
      return new Uint8Array();
    let d2 = 0, h2 = 0, f2 = 0;
    for (; c[d2] === n; )
      h2++, d2++;
    const u2 = (c.length - d2) * s2 + 1 >>> 0, w2 = new Uint8Array(u2);
    for (; d2 < c.length; ) {
      const _ = c.charCodeAt(d2);
      if (_ > 255)
        return;
      let p2 = e[_];
      if (p2 === 255)
        return;
      let E2 = 0;
      for (let C2 = u2 - 1; (p2 !== 0 || E2 < f2) && C2 !== -1; C2--, E2++)
        p2 += r * w2[C2] >>> 0, w2[C2] = p2 % 256 >>> 0, p2 = p2 / 256 >>> 0;
      if (p2 !== 0)
        throw new Error("Non-zero carry");
      f2 = E2, d2++;
    }
    let k2 = u2 - f2;
    for (; k2 !== u2 && w2[k2] === 0; )
      k2++;
    const m2 = new Uint8Array(h2 + (u2 - k2));
    let S2 = h2;
    for (; k2 !== u2; )
      m2[S2++] = w2[k2++];
    return m2;
  }
  function l2(c) {
    const d2 = i2(c);
    if (d2)
      return d2;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: a,
    decodeUnsafe: i2,
    decode: l2
  };
}
var Bn = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
Cn(Bn);
var ze = class _ze {
  _transaction;
  signatures = [];
  feePayer;
  recentBlockhash;
  _instructions;
  constructor() {
    this._instructions = [];
  }
  add(...e) {
    return this._instructions.push(...e), this;
  }
  static from(e) {
    const r = e instanceof Uint8Array ? e : new Uint8Array(e), n = ve.decode(r), s2 = new _ze();
    return s2._transaction = n, s2;
  }
  serialize(e) {
    if (this._transaction)
      return Buffer.from(ve.encode(this._transaction));
    if (!this.feePayer || !this.recentBlockhash)
      throw new Error("Transaction requires feePayer and recentBlockhash");
    const r = tt(
      this.feePayer.toString(),
      this._instructions,
      this.recentBlockhash
    );
    return Buffer.from(r, "hex");
  }
  serializeMessage() {
    if (!this.feePayer || !this.recentBlockhash)
      throw new Error("Transaction requires feePayer and recentBlockhash");
    const e = tt(
      this.feePayer.toString(),
      this._instructions,
      this.recentBlockhash
    );
    return Buffer.from(e, "hex");
  }
};
var Pn = class {
  type = "phantom";
  platform = "solana";
  account = void 0;
  connectedAccounts = [];
  getProvider() {
    if (typeof window > "u")
      throw new Error("Not ready");
    const e = window.solana;
    if (!e?.isPhantom)
      throw new Error("Phantom is not available");
    return e;
  }
  isAvailable() {
    return typeof window < "u" && !!window.solana?.isPhantom;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: "Unknown",
      name: "Phantom",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Phantom is not available");
      const e = await this.getProvider().connect();
      if (e.publicKey)
        return this.account = e.publicKey.toString(), { success: true, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e) {
      return console.error("Error connecting to Phantom:", e), {
        success: false,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signMessage(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      const r = new TextEncoder().encode(e), n = await this.getProvider().signMessage(
        r,
        "utf8"
      );
      return { success: true, wallet: this.type, result: n };
    } catch (r) {
      return console.error("Error signing message with Phantom:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    if (!this.isAvailable() || !this.account)
      throw new Error("Phantom is not connected");
    try {
      const r = ze.from(e), s2 = await this.getProvider().signAndSendTransaction(r);
      return {
        success: true,
        wallet: this.type,
        result: s2
      };
    } catch (r) {
      return console.error("Error sending transaction with Phantom:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async switchChain(e) {
    return console.warn("Chain switching not supported for Phantom"), false;
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      return {
        success: true,
        wallet: this.type,
        result: "Implement based on Phantom API"
      };
    } catch (r) {
      return console.error("Error getting balance from Phantom:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async waitForTransaction(e, r) {
    return {
      success: false,
      wallet: this.type,
      error: "waitForTransaction not supported for Phantom wallet"
    };
  }
};
var Nn = class extends Se {
  type = "rabby";
  rdns = "io.rabby";
  displayName = "Rabby";
};
var Rn = class {
  type = "braavos";
  platform = "starknet";
  wallet = void 0;
  account = void 0;
  connectedAccounts = [];
  accountChangeListener = void 0;
  isAvailable() {
    return typeof window < "u" && !!window.starknet_braavos;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.starknet_braavos?.version || "Unknown" : void 0,
      chainId: e ? window.starknet_braavos?.chainId : void 0,
      name: "Braavos",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Braavos is not available");
      const e = window.starknet_braavos;
      if (!e)
        throw new Error("No wallet found");
      const r = await e.request({
        type: "wallet_requestAccounts",
        params: { silent_mode: false }
      });
      if (!r || r.length === 0)
        throw new Error("No accounts found");
      return this.removeAccountChangeListener(), this.wallet = e, this.account = r[0], this.connectedAccounts = r, this.setupAccountChangeListener(), { success: true, wallet: this.type, account: this.account };
    } catch (e) {
      return console.error("Error connecting to Braavos:", e), {
        success: false,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Braavos is not connected");
      const r = await this.wallet.request({
        type: "wallet_signTypedData",
        params: e
      });
      return { success: true, wallet: this.type, result: r };
    } catch (r) {
      return console.error("Error signing typed data with Braavos:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    if (!this.wallet)
      throw new Error("No wallet found");
    try {
      const r = await this.wallet.request({
        type: "wallet_addInvokeTransaction",
        params: {
          calls: e
        }
      });
      return {
        success: true,
        wallet: this.type,
        result: r
      };
    } catch (r) {
      return console.error("Error sending transaction with Braavos:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async switchChain(e) {
    if (!this.wallet)
      throw new Error("No wallet found");
    return await this.wallet.request({
      type: "wallet_switchStarknetChain",
      params: {
        chainId: e
      }
    });
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Braavos is not connected");
      return {
        success: true,
        wallet: this.type,
        result: "Implement based on Braavos API"
      };
    } catch (r) {
      return console.error("Error getting balance from Braavos:", r), {
        success: false,
        wallet: this.type,
        error: r.message || "Unknown error"
      };
    }
  }
  async waitForTransaction(e, r) {
    return {
      success: false,
      wallet: this.type,
      error: "waitForTransaction not supported for Braavos wallet"
    };
  }
  setupAccountChangeListener() {
    this.wallet && (this.accountChangeListener = (e) => {
      e && e.length > 0 ? (this.account = e[0], this.connectedAccounts = e) : (this.account = void 0, this.connectedAccounts = []);
    }, this.wallet.on("accountsChanged", this.accountChangeListener));
  }
  removeAccountChangeListener() {
    this.wallet && this.accountChangeListener && (this.wallet.off("accountsChanged", this.accountChangeListener), this.accountChangeListener = void 0);
  }
  disconnect() {
    this.removeAccountChangeListener(), this.wallet = void 0, this.account = void 0, this.connectedAccounts = [];
  }
};
var Tn = class {
  walletAdapters;
  constructor() {
    if (this.walletAdapters = /* @__PURE__ */ new Map(), typeof window > "u")
      return;
    const e = new Vr();
    this.walletAdapters.set("metamask", e);
    const r = new Pn();
    this.walletAdapters.set("phantom", r);
    const n = new jr();
    this.walletAdapters.set("argent", n);
    const s2 = new Rn();
    this.walletAdapters.set("braavos", s2);
    const o = new Nn();
    this.walletAdapters.set("rabby", o);
    const a = new Kr();
    this.walletAdapters.set("base", a), window.wallet_bridge = this;
  }
  getIFrameMethods() {
    return {
      externalDetectWallets: (e) => () => this.detectWallets(),
      externalConnectWallet: (e) => (r) => this.connectWallet(r),
      externalSignMessage: (e) => (r, n) => this.signMessage(r, n),
      externalSignTypedData: (e) => (r, n) => this.signTypedData(r, n),
      externalSendTransaction: (e) => (r, n) => this.sendTransaction(r, n),
      externalGetBalance: (e) => (r, n) => this.getBalance(r, n),
      externalSwitchChain: (e) => (r, n) => this.switchChain(r, n),
      externalWaitForTransaction: (e) => (r, n, s2) => this.waitForTransaction(r, n, s2)
    };
  }
  async detectWallets() {
    return Array.from(this.walletAdapters.values()).map(
      (r) => r.getInfo()
    );
  }
  getWalletAdapterByType(e) {
    const r = this.walletAdapters.get(e);
    if (!r)
      throw new Error(`Unsupported wallet type: ${e}`);
    return r;
  }
  handleError(e, r, n, s2) {
    const o = r instanceof Error ? r.message : "Unknown error";
    let a = "unknown";
    if (typeof e == "string") {
      const i2 = this.getConnectedWalletAdapter(e);
      a = s2 ?? i2?.type ?? e;
    } else
      a = e;
    return console.error(`Error ${n} with ${e} wallet:`, r), {
      success: false,
      wallet: a,
      error: o
    };
  }
  async connectWallet(e) {
    try {
      const n = await this.getWalletAdapterByType(e).connect();
      if (n.success && n.account)
        console.log(
          `Wallet ${e} connected with address ${n.account}`
        );
      else if (n.success && !n.account)
        return console.error(
          `Wallet ${e} connected successfully but did not provide an address.`
        ), {
          ...n,
          success: false,
          error: "Wallet connected but address not found."
        };
      return n;
    } catch (r) {
      return this.handleError(e, r, "connecting to");
    }
  }
  getConnectedWalletAdapter(e) {
    let r, n;
    try {
      n = N(e);
    } catch {
      if (r = this.walletAdapters.get(e), !r)
        throw new Error(`Wallet ${e} is not connected or supported`);
      return r;
    }
    if (r = this.walletAdapters.values().find((s2) => s2.getConnectedAccounts().includes(n)), !r)
      throw new Error(`No wallet found with connected address ${e}`);
    return r;
  }
  async signMessage(e, r) {
    let n;
    try {
      if (n = this.getConnectedWalletAdapter(e), !n.signMessage)
        throw new Error(
          `Wallet type ${n.type} (identifier: ${e}) does not support signing messages`
        );
      return await n.signMessage(r, e);
    } catch (s2) {
      return this.handleError(
        e,
        s2,
        "signing message with",
        n?.type
      );
    }
  }
  async signTypedData(e, r) {
    let n;
    try {
      if (n = this.getConnectedWalletAdapter(e), !n.signTypedData)
        throw new Error(
          `Wallet type ${n.type} (identifier: ${e}) does not support signing typed data`
        );
      return await n.signTypedData(r);
    } catch (s2) {
      return this.handleError(
        e,
        s2,
        "signing typed data with",
        n?.type
      );
    }
  }
  async sendTransaction(e, r) {
    let n;
    try {
      return n = this.getConnectedWalletAdapter(e), await n.sendTransaction(r);
    } catch (s2) {
      return this.handleError(
        e,
        s2,
        "sending transaction with",
        n?.type
      );
    }
  }
  async getBalance(e, r) {
    let n;
    try {
      return n = this.getConnectedWalletAdapter(e), await n.getBalance(r);
    } catch (s2) {
      return this.handleError(
        e,
        s2,
        "getting balance from",
        n?.type
      );
    }
  }
  async switchChain(e, r) {
    try {
      return await this.getConnectedWalletAdapter(e).switchChain(r);
    } catch (n) {
      return console.error(`Error switching chain for ${e} wallet:`, n), false;
    }
  }
  async waitForTransaction(e, r, n) {
    let s2;
    try {
      return s2 = this.getConnectedWalletAdapter(e), await s2.waitForTransaction(r, n);
    } catch (o) {
      return this.handleError(
        e,
        o,
        "waiting for transaction with",
        s2?.type
      );
    }
  }
};
var Un = class extends ar {
  walletBridge;
  constructor({
    url: e,
    policies: r,
    version: n,
    slot: s2,
    namespace: o,
    tokens: a,
    ...i2
  }) {
    const l2 = new URL(e ?? P), c = new Tn();
    r && l2.searchParams.set(
      "policies",
      encodeURIComponent(JSON.stringify(r))
    ), n && l2.searchParams.set("v", encodeURIComponent(n)), s2 && l2.searchParams.set("ps", encodeURIComponent(s2)), o && l2.searchParams.set("ns", encodeURIComponent(o)), a?.erc20 && l2.searchParams.set(
      "erc20",
      encodeURIComponent(a.erc20.toString())
    ), super({
      ...i2,
      id: "controller-keychain",
      url: l2,
      methods: c.getIFrameMethods()
    }), this.walletBridge = c, typeof window < "u" && (window.external_wallets = this.walletBridge);
  }
  getWalletBridge() {
    return this.walletBridge;
  }
};
var Ln = class extends Z {
  keychain;
  options;
  iframes;
  selectedChain;
  chains;
  isReady() {
    return !!this.keychain;
  }
  constructor(e = {}) {
    super();
    const n = [...[
      { rpcUrl: "https://api.cartridge.gg/x/starknet/sepolia/rpc/v0_9" },
      { rpcUrl: "https://api.cartridge.gg/x/starknet/mainnet/rpc/v0_9" }
    ], ...e.chains || []], s2 = e.defaultChainId || constants_exports.StarknetChainId.SN_MAIN;
    this.selectedChain = s2, this.chains = /* @__PURE__ */ new Map(), this.options = { ...e, chains: n, defaultChainId: s2 }, this.iframes = {
      keychain: e.lazyload ? void 0 : this.createKeychainIframe()
    }, this.initializeChains(n), typeof window < "u" && (window.starknet_controller = this);
  }
  async logout() {
    if (!this.keychain) {
      console.error(new u().message);
      return;
    }
    try {
      await this.disconnect(), document.querySelectorAll('iframe[id^="controller-"]').forEach((r) => {
        const n = r.parentElement;
        n && (n.style.opacity = "0", setTimeout(() => {
          n.style.display = "none";
        }, 200));
      }), document.body && (document.body.style.overflow = "auto"), window.location.reload();
    } catch (e) {
      throw console.error("Logout failed:", e), e;
    }
  }
  async probe() {
    try {
      if (this.iframes.keychain || (this.iframes.keychain = this.createKeychainIframe()), await this.waitForKeychain(), !this.keychain) {
        console.error(new u().message);
        return;
      }
      const e = await this.keychain.probe(this.rpcUrl());
      let r = e?.rpcUrl || this.rpcUrl();
      this.account = new Le(
        this,
        r,
        e.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      );
    } catch (e) {
      console.error(e);
      return;
    }
    return this.account;
  }
  async connect() {
    if (this.account)
      return this.account;
    if (this.iframes.keychain || (this.iframes.keychain = this.createKeychainIframe(), await this.waitForKeychain()), !this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.iframes.keychain.open();
    try {
      let e = await this.keychain.connect(
        // Policy precedence logic:
        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies
        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)
        // 3. Otherwise, use provided policies or empty object
        this.options.shouldOverridePresetPolicies && this.options.policies ? this.options.policies : this.options.preset ? {} : this.options.policies || {},
        this.rpcUrl(),
        this.options.signupOptions
      );
      if (e.code !== w.SUCCESS)
        throw new Error(e.message);
      return e = e, this.account = new Le(
        this,
        this.rpcUrl(),
        e.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      ), this.account;
    } catch (e) {
      console.log(e);
    } finally {
      this.iframes.keychain.close();
    }
  }
  async switchStarknetChain(e) {
    if (!this.keychain || !this.iframes.keychain)
      return console.error(new u().message), false;
    const r = this.selectedChain;
    try {
      this.selectedChain = e, await this.keychain.switchChain(this.rpcUrl());
    } catch (n) {
      return console.error(n), this.selectedChain = r, false;
    }
    return this.emitNetworkChanged(e), true;
  }
  addStarknetChain(e) {
    return Promise.resolve(true);
  }
  async disconnect() {
    if (!this.keychain) {
      console.error(new u().message);
      return;
    }
    return typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.account = void 0, this.keychain.disconnect();
  }
  async openProfile(e = "inventory") {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const r = await this.keychain.username(), n = [];
    this.options.slot && n.push(`ps=${this.options.slot}`), await this.keychain.navigate(
      `/account/${r}/${e}?${n.join("&")}`
    ), this.iframes.keychain.open();
  }
  async openProfileTo(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const r = await this.keychain.username(), n = [];
    this.options.slot && n.push(`ps=${this.options.slot}`), await this.keychain.navigate(
      `/account/${r}/${e}?${n.join("&")}`
    ), this.iframes.keychain.open();
  }
  async openProfileAt(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    await this.keychain.navigate(e), this.iframes.keychain.open();
  }
  openSettings() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    this.iframes.keychain.open(), this.keychain.openSettings();
  }
  revoke(e, r) {
    return this.keychain ? this.keychain.revoke(e) : (console.error(new u().message), null);
  }
  rpcUrl() {
    const e = this.chains.get(this.selectedChain);
    if (!e) {
      const r = Array.from(this.chains.keys()).map(
        (n) => shortString_exports.decodeShortString(n)
      );
      throw new Error(
        `Chain not found: ${shortString_exports.decodeShortString(this.selectedChain)}. Available chains: ${r.join(", ")}`
      );
    }
    return e.rpcUrl;
  }
  username() {
    if (!this.keychain) {
      console.error(new u().message);
      return;
    }
    return this.keychain.username();
  }
  openPurchaseCredits() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    this.keychain.navigate("/purchase/credits").then(() => {
      this.iframes.keychain?.open();
    });
  }
  async openStarterPack(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    await this.keychain.openStarterPack(e), this.iframes.keychain?.open();
  }
  async openExecute(e, r) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new u().message);
      return;
    }
    let n = this.selectedChain;
    r && this.switchStarknetChain(r), this.iframes.keychain.open();
    const s2 = await this.keychain.execute(e, void 0, void 0, true);
    return this.iframes.keychain.close(), r && this.switchStarknetChain(n), {
      status: !(s2 && (s2.code === w.NOT_CONNECTED || s2.code === w.CANCELED)),
      transactionHash: s2?.transaction_hash
    };
  }
  async delegateAccount() {
    return this.keychain ? await this.keychain.delegateAccount() : (console.error(new u().message), null);
  }
  initializeChains(e) {
    for (const r of e)
      try {
        const n = new URL(r.rpcUrl), s2 = f(n), o = s2 === constants_exports.StarknetChainId.SN_MAIN, a = s2 === constants_exports.StarknetChainId.SN_SEPOLIA, i2 = n.hostname === "api.cartridge.gg", l2 = n.hostname === "localhost" || n.hostname === "127.0.0.1";
        if ((o || a) && !(i2 || l2))
          throw new Error(
            `Only Cartridge RPC providers are allowed for ${o ? "mainnet" : "sepolia"}. Please use: https://api.cartridge.gg/x/starknet/${o ? "mainnet" : "sepolia"}/rpc/v0_9`
          );
        this.chains.set(s2, r);
      } catch (n) {
        throw console.error(`Failed to parse chainId for ${r.rpcUrl}:`, n), n;
      }
    this.chains.has(this.selectedChain) || console.warn(
      `Selected chain ${this.selectedChain} not found in configured chains. Available chains: ${Array.from(this.chains.keys()).join(", ")}`
    );
  }
  createKeychainIframe() {
    return new Un({
      ...this.options,
      onClose: this.keychain?.reset,
      onConnect: (e) => {
        this.keychain = e;
      },
      version: T
    });
  }
  waitForKeychain({
    timeout: e = 5e4,
    interval: r = 100
  } = {}) {
    return new Promise((n, s2) => {
      const o = Date.now(), a = setInterval(() => {
        if (Date.now() - o > e) {
          clearInterval(a), s2(new Error("Timeout waiting for keychain"));
          return;
        }
        this.keychain && (clearInterval(a), n());
      }, r);
    });
  }
};
var F = /* @__PURE__ */ new Map();
async function Bt(t) {
  if (!t.addresses?.length && !t.usernames?.length)
    return { results: [] };
  const e = await fetch(`${b}/lookup`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(t)
  });
  if (!e.ok)
    throw new Error(`HTTP error! status: ${e.status}`);
  return e.json();
}
async function Mn(t) {
  const e = t.filter((r) => !F.has(r));
  return e.length > 0 && (await Bt({ usernames: e })).results.forEach((n) => {
    F.set(n.username, n.addresses[0]);
  }), new Map(
    t.map((r) => [r, F.get(r)]).filter((r) => r[1] !== void 0)
  );
}
async function Qn(t) {
  t = t.map(num_exports.toHex);
  const e = t.filter((r) => !F.has(r));
  return e.length > 0 && (await Bt({
    addresses: e
  })).results.forEach((n) => {
    F.set(n.addresses[0], n.username);
  }), new Map(
    t.map((r) => [r, F.get(r)]).filter((r) => r[1] !== void 0)
  );
}
var zn = [
  {
    name: "Wrapped BTC",
    symbol: "WBTC",
    decimals: 8,
    l2_token_address: "0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac",
    sort_order: 0,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo"
  },
  {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6,
    l2_token_address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8",
    sort_order: 5,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo"
  },
  {
    name: "LUSD Stablecoin",
    symbol: "LUSD",
    decimals: 18,
    l2_token_address: "0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac",
    sort_order: 3,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo"
  },
  {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6,
    l2_token_address: "0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo"
  },
  {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    l2_token_address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    sort_order: 3,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAIv0",
    decimals: 18,
    l2_token_address: "0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3",
    sort_order: 4,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAI",
    decimals: 18,
    l2_token_address: "0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Legacy Starknet Wrapped Staked Ether",
    symbol: "wstETH-legacy",
    decimals: 18,
    l2_token_address: "0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/26162dcc-29c2-4f5e-3acd-5e6be1f07a00/logo"
  },
  {
    name: "Wrapped Staked Ether",
    symbol: "wstETH",
    decimals: 18,
    l2_token_address: "0x0057912720381af14b0e5c87aa4718ed5e527eab60b3801ebf702ab09139e38b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo"
  },
  {
    name: "Rocket Pool ETH",
    symbol: "rETH",
    decimals: 18,
    l2_token_address: "0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo"
  },
  {
    name: "LORDS",
    symbol: "LORDS",
    decimals: 18,
    l2_token_address: "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49",
    sort_order: 1,
    total_supply: 509e5,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo"
  },
  {
    name: "R Stablecoin",
    symbol: "R",
    decimals: 18,
    l2_token_address: "0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333",
    sort_order: 3,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo"
  },
  {
    name: "Frax",
    symbol: "FRAX",
    decimals: 18,
    l2_token_address: "0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406",
    sort_order: 1,
    total_supply: 649462235,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo"
  },
  {
    name: "Frax Share",
    symbol: "FXS",
    decimals: 18,
    l2_token_address: "0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo"
  },
  {
    name: "Staked Frax Ether",
    symbol: "sfrxETH",
    decimals: 18,
    l2_token_address: "0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo"
  },
  {
    name: "Uniswap",
    symbol: "UNI",
    decimals: 18,
    l2_token_address: "0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee",
    sort_order: 1,
    total_supply: 1e9,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo"
  },
  {
    name: "Paper",
    symbol: "PAPER",
    decimals: 18,
    l2_token_address: "0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo"
  },
  {
    name: "StarkPepe",
    symbol: "xSPEPE",
    decimals: 18,
    l2_token_address: "0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    disabled: true
  },
  {
    name: "StarkNet Token",
    symbol: "STRK",
    decimals: 18,
    l2_token_address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d",
    sort_order: 2,
    total_supply: 1e10,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo"
  },
  {
    name: "zkLend Token",
    symbol: "ZEND",
    decimals: 18,
    l2_token_address: "0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo"
  },
  {
    name: "Ekubo Protocol",
    symbol: "EKUBO",
    decimals: 18,
    l2_token_address: "0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87",
    sort_order: 1,
    total_supply: 1e7,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo"
  },
  {
    name: "SOCKS",
    symbol: "SOCKS",
    decimals: 18,
    l2_token_address: "0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015",
    sort_order: 1,
    total_supply: 1e11,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo"
  },
  {
    name: "Nostra",
    symbol: "NSTR",
    decimals: 18,
    l2_token_address: "0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo"
  },
  {
    name: "Carmine",
    symbol: "CRM",
    decimals: 18,
    l2_token_address: "0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo"
  },
  {
    name: "Cash",
    symbol: "CASH",
    decimals: 18,
    l2_token_address: "0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada",
    sort_order: 3,
    total_supply: null,
    hidden: false,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo"
  },
  {
    name: "Nums",
    symbol: "NUMS",
    decimals: 18,
    l2_token_address: "0xe5f10eddc01699dc899a30dbc3c9858148fa4aa0a47c0ffd85f887ffc4653e",
    sort_order: 1,
    total_supply: 1,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/90868d05-cb75-4c42-278c-5a540db2cf00/logo"
  },
  {
    name: "Flip",
    symbol: "FLIP",
    decimals: 18,
    l2_token_address: "0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo"
  },
  {
    name: "Eternum Stone",
    symbol: "STONE",
    decimals: 18,
    l2_token_address: "0x439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/932e7f83-a4c2-40f0-3048-35af3b194100/logo"
  },
  {
    name: "Eternum Coal",
    symbol: "COAL",
    decimals: 18,
    l2_token_address: "0xce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cf2ee180-06bf-4443-e3aa-724d7c28e800/logo"
  },
  {
    name: "Eternum Wood",
    symbol: "WOOD",
    decimals: 18,
    l2_token_address: "0x40d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1db5f954-c1ef-447e-9f8f-05bd9f3b2b00/logo"
  },
  {
    name: "Eternum Copper",
    symbol: "COPPER",
    decimals: 18,
    l2_token_address: "0x66ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bbcdcc9-6146-404d-9501-92a664cf3100/logo"
  },
  {
    name: "Eternum Ironwood",
    symbol: "IRONWOOD",
    decimals: 18,
    l2_token_address: "0x1720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5af7c03b-e4ae-4aee-eba4-a4e2160a1d00/logo"
  },
  {
    name: "Eternum Obsidian",
    symbol: "OBSIDIAN",
    decimals: 18,
    l2_token_address: "0x3b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8be9bc66-486b-4181-6804-725a1db8ad00/logo"
  },
  {
    name: "Eternum Gold",
    symbol: "GOLD",
    decimals: 18,
    l2_token_address: "0xdff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fb9e90f7-3c2f-4c64-7e43-c3f694f35e00/logo"
  },
  {
    name: "Eternum Silver",
    symbol: "SILVER",
    decimals: 18,
    l2_token_address: "0x6fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e443afeb-850b-46a0-a7ba-a473306d6b00/logo"
  },
  {
    name: "Eternum Mithral",
    symbol: "MITHRAL",
    decimals: 18,
    l2_token_address: "0x67ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33dc517f-8a66-45eb-f2c5-de5388e47500/logo"
  },
  {
    name: "Eternum Alchemical Silver",
    symbol: "ALCHEMICALSILVER",
    decimals: 18,
    l2_token_address: "0x3956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3d2e0fd8-4af8-49a0-4bdb-691a4d6ef800/logo"
  },
  {
    name: "Eternum Cold Iron",
    symbol: "COLDIRON",
    decimals: 18,
    l2_token_address: "0x555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/878c0d8a-8e2c-4281-0896-9cbbb2ef9400/logo"
  },
  {
    name: "Eternum Deep Crystal",
    symbol: "DEEPCRYSTAL",
    decimals: 18,
    l2_token_address: "0x1d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1c2c954f-448c-476b-a4a6-19b52efe3e00/logo"
  },
  {
    name: "Eternum Ruby",
    symbol: "RUBY",
    decimals: 18,
    l2_token_address: "0x3d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6a45b34d-3bfe-4994-45b0-f2bee8abac00/logo"
  },
  {
    name: "Eternum Diamonds",
    symbol: "DIAMONDS",
    decimals: 18,
    l2_token_address: "0xe03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/b1fa609d-8799-4754-cdea-ab69514ca700/logo"
  },
  {
    name: "Eternum Hartwood",
    symbol: "HARTWOOD",
    decimals: 18,
    l2_token_address: "0x5620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/27e37e85-91bd-4ee1-0552-1e0795077400/logo"
  },
  {
    name: "Eternum Ignium",
    symbol: "IGNIUM",
    decimals: 18,
    l2_token_address: "0x625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/58591e20-24fb-4353-417a-81d877a5a200/logo"
  },
  {
    name: "Eternum Twilight Quartz",
    symbol: "TWILIGHTQUARTZ",
    decimals: 18,
    l2_token_address: "0x35e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2f8cb892-e82a-4af3-bd09-316061faec00/logo"
  },
  {
    name: "Eternum True Ice",
    symbol: "TRUEICE",
    decimals: 18,
    l2_token_address: "0x4485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fe4bfc17-6553-4dc5-58d2-f452b4aa8a00/logo"
  },
  {
    name: "Eternum Adamantine",
    symbol: "ADAMANTINE",
    decimals: 18,
    l2_token_address: "0x367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/13bd026b-3612-480e-0119-04cf4c505a00/logo"
  },
  {
    name: "Eternum Sapphire",
    symbol: "SAPPHIRE",
    decimals: 18,
    l2_token_address: "0x2f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0ebf555f-e732-4054-f8e5-55b2ed49ba00/logo"
  },
  {
    name: "Eternum Ethereal Silica",
    symbol: "ETHEREALSILICA",
    decimals: 18,
    l2_token_address: "0x68b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f02a5b43-bfcf-408c-7d1b-fcfe68b02d00/logo"
  },
  {
    name: "Eternum Dragon Hide",
    symbol: "DRAGONHIDE",
    decimals: 18,
    l2_token_address: "0x3bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e74955fc-5c8a-4dff-4882-a49a46a5a800/logo"
  },
  {
    name: "Eternum Ancient Fragment",
    symbol: "ANCIENTFRAGMENT",
    decimals: 18,
    l2_token_address: "0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9af855b7-4790-4390-9466-6bed4481ab00/logo"
  },
  {
    name: "Eternum Donkey",
    symbol: "DONKEY",
    decimals: 18,
    l2_token_address: "0x264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/20817378-a45e-4521-f464-10f6dd13c500/logo"
  },
  {
    name: "Eternum Knight",
    symbol: "KNIGHT",
    decimals: 18,
    l2_token_address: "0xac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8787ed1f-af5c-4873-c01a-55f05e999a00/logo"
  },
  {
    name: "Eternum Crossbowman",
    symbol: "CROSSBOWMAN",
    decimals: 18,
    l2_token_address: "0x67e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dec7f31b-4b1d-46bb-4fca-c0253cf55a00/logo"
  },
  {
    name: "Eternum Paladin",
    symbol: "PALADIN",
    decimals: 18,
    l2_token_address: "0x3bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7d2cd5a5-f38a-49f6-11f8-ba3b59a59e00/logo"
  },
  {
    name: "Eternum Wheat",
    symbol: "WHEAT",
    decimals: 18,
    l2_token_address: "0x57a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c338b6a8-77c4-4dd6-34f5-1af0d3fb1e00/logo"
  },
  {
    name: "Eternum Fish",
    symbol: "FISH",
    decimals: 18,
    l2_token_address: "0x27719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6deef27f-df40-4248-4e1b-ed1d79a3f000/logo"
  },
  {
    name: "Fools",
    symbol: "FOOLS",
    decimals: 18,
    l2_token_address: "0x068a7a07e08fc3e723a878223d00f669106780d5ea6665eb15d893476d47bf3b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fools.svg"
  },
  {
    name: "Fame",
    symbol: "FAME",
    decimals: 18,
    l2_token_address: "0x02549653a4ae1ff8d04a20b8820a49cbe97486c536ec0e4c8f68aa33d80067cf",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fame.svg"
  },
  {
    name: "Survivor",
    symbol: "SURVIVOR",
    decimals: 18,
    l2_token_address: "0x42dd777885ad2c116be96d4d634abc90a26a790ffb5871e037dd5ae7d2ec86b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://lootsurvivor.io/images/survivor_token.png"
  }
];
var Pt = {
  theme: {
    name: "Cartridge",
    icon: "icon.svg"
  }
};
var ae = "https://static.cartridge.gg/presets";
async function De() {
  try {
    const t = await fetch(`${ae}/index.json`);
    if (!t.ok)
      throw new Error(`Failed to load configs index: ${t.statusText}`);
    return await t.json();
  } catch (t) {
    return console.error("Error loading configs index:", t), { configs: [], baseUrl: ae };
  }
}
async function Fn() {
  return (await De()).configs;
}
async function jn(t) {
  try {
    const n = `${(await De()).baseUrl || ae}/${t}`, s2 = await fetch(`${n}/config.json`);
    if (!s2.ok)
      throw new Error(
        `Failed to load config ${t}: ${s2.statusText}`
      );
    const o = await s2.json();
    if (o && o.theme) {
      o.theme.icon && !o.theme.icon.startsWith("http") && (o.theme.icon = `${n}/${o.theme.icon}`), o.theme.cover && (typeof o.theme.cover == "string" ? o.theme.cover.startsWith("http") || (o.theme.cover = `${n}/${o.theme.cover}`) : (o.theme.cover.light && !o.theme.cover.light.startsWith("http") && (o.theme.cover.light = `${n}/${o.theme.cover.light}`), o.theme.cover.dark && !o.theme.cover.dark.startsWith("http") && (o.theme.cover.dark = `${n}/${o.theme.cover.dark}`)));
      const a = (i2) => {
        if (i2) {
          for (const l2 in i2)
            if (i2[l2])
              for (const c in i2[l2])
                i2[l2][c] && !i2[l2][c].startsWith("http") && (i2[l2][c] = `${n}/${i2[l2][c]}`);
        }
      };
      if (o.theme.optimizedIcon && a(o.theme.optimizedIcon), o.theme.optimizedCover)
        if (typeof o.theme.optimizedCover == "string")
          o.theme.optimizedCover.startsWith("http") || (o.theme.optimizedCover = `${n}/${o.theme.optimizedCover}`);
        else if (o.theme.optimizedCover.light || o.theme.optimizedCover.dark) {
          const i2 = o.theme.optimizedCover;
          i2.light && a(i2.light), i2.dark && a(i2.dark);
        } else
          a(o.theme.optimizedCover);
    }
    return o;
  } catch (e) {
    return console.error(`Error loading config ${t}:`, e), null;
  }
}
async function Wn() {
  const t = await De(), e = t.configs, r = t.baseUrl || ae, n = {};
  return await Promise.all(
    e.map(async (s2) => {
      try {
        const o = await fetch(`${r}/${s2}/config.json`);
        if (o.ok) {
          const a = await o.json();
          n[s2] = a;
        }
      } catch (o) {
        console.error(`Error loading config ${s2}:`, o);
      }
    })
  ), n;
}
Pt.theme.icon = "https://static.cartridge.gg/presets/cartridge/icon.svg";
var Yn = zn;
var Hn = Pt.theme;
export {
  jr as ArgentWallet,
  Kr as BaseWallet,
  Rn as BraavosWallet,
  Se as EthereumWalletBase,
  l as FeeSource,
  Vr as MetaMaskWallet,
  u as NotReadyToConnect,
  Pn as PhantomWallet,
  Nn as RabbyWallet,
  w as ResponseCodes,
  C as StarterPackItemType,
  Tn as WalletBridge,
  fe as chainIdToPlatform,
  Ln as default,
  Hn as defaultTheme,
  Yn as erc20Metadata,
  Fn as getAvailableConfigs,
  De as getConfigsIndex,
  O as humanizeString,
  Wn as loadAllConfigs,
  jn as loadConfig,
  Qn as lookupAddresses,
  Mn as lookupUsernames,
  x as normalizeCalls,
  f as parseChainId,
  i as toArray,
  U as toSessionPolicies,
  k as toWasmPolicies
};
/*! Bundled license information:

@cartridge/controller/dist/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@cartridge_controller.js.map
