{
  "version": 3,
  "sources": ["../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/types.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/utils.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/errors.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/constants.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@starknet-io+types-js@0.8.4/node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/icon.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/mutex.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/provider.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/account.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/enums.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/createDestructor.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/createLogger.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/getOriginFromSrc.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/errorSerialization.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/connectCallReceiver.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/generateId.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/methodSerialization.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/connectCallSender.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/handleAckMessageFactory.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/handleSynMessageFactory.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/monitorIframeRemoval.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/startConnectionTimeout.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/connectToChild.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/iframe/base.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/argent/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/mipd@0.0.7_typescript@5.8.3/node_modules/mipd/dist/esm/utils.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/mipd@0.0.7_typescript@5.8.3/node_modules/mipd/dist/esm/store.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/platform.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/ethereum-base.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/base/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/metamask/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@scure+base@1.2.5/node_modules/@scure/base/lib/esm/index.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/micro-packed@0.7.3/node_modules/micro-packed/lib/esm/index.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/micro-sol-signer@0.5.0/node_modules/micro-sol-signer/lib/esm/index.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/esm/index.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/utils/solana/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/phantom/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/rabby/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/braavos/index.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/wallets/bridge.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/iframe/keychain.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/controller.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/@cartridge/controller/src/lookup.ts", "../../.pnpm/@cartridge+controller@0.10.5_@types+react@18.3.24_bufferutil@4.0.9_react@18.3.1_typescr_3f8ad5a91938162933854b9787c8bad7/node_modules/node_modules/.pnpm/@cartridge+presets@https+++codeload.github.com+cartridge-gg+presets+tar.gz+f60358b/node_modules/@cartridge/presets/dist/index.js"],
  "sourcesContent": ["import { Policy, SessionPolicies } from \"@cartridge/presets\";\nimport {\n  AddInvokeTransactionResult,\n  ChainId,\n  Signature,\n  TypedData,\n} from \"@starknet-io/types-js\";\nimport {\n  Abi,\n  BigNumberish,\n  Call,\n  constants,\n  InvocationsDetails,\n} from \"starknet\";\nimport { KeychainIFrame } from \"./iframe\";\nimport {\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n} from \"./wallets/types\";\n\nexport type KeychainSession = {\n  chainId: constants.StarknetChainId;\n  policies: Policy[];\n  maxFee: BigNumberish;\n  expiresAt: bigint;\n  credentials: {\n    authorization: string[];\n    privateKey: string;\n  };\n};\n\nexport type AuthOption =\n  | \"google\"\n  | \"webauthn\"\n  | \"discord\"\n  | \"walletconnect\"\n  | \"password\"\n  | ExternalWalletType;\n\nexport type AuthOptions = Omit<AuthOption, \"phantom\" | \"argent\">[];\n\nexport enum ResponseCodes {\n  SUCCESS = \"SUCCESS\",\n  NOT_CONNECTED = \"NOT_CONNECTED\",\n  ERROR = \"ERROR\",\n  CANCELED = \"CANCELED\",\n  USER_INTERACTION_REQUIRED = \"USER_INTERACTION_REQUIRED\",\n}\n\nexport type ConnectError = {\n  code: ResponseCodes;\n  message: string;\n  error?: ControllerError;\n};\n\nexport type ControllerError = {\n  code: Number;\n  message: string;\n  data?: any;\n};\n\nexport type ConnectReply = {\n  code: ResponseCodes.SUCCESS;\n  address: string;\n  policies?: SessionPolicies;\n};\n\nexport type ExecuteReply =\n  | (AddInvokeTransactionResult & {\n      code: ResponseCodes.SUCCESS;\n    })\n  | {\n      code: ResponseCodes.USER_INTERACTION_REQUIRED;\n    };\n\nexport type ProbeReply = {\n  code: ResponseCodes.SUCCESS;\n  address: string;\n  rpcUrl?: string;\n};\n\nexport type DeployReply = {\n  code: ResponseCodes.SUCCESS;\n  transaction_hash: string;\n};\n\nexport type IFrames = {\n  keychain?: KeychainIFrame;\n  version?: number;\n};\n\nexport interface LookupRequest {\n  usernames?: string[];\n  addresses?: string[];\n}\n\nexport interface LookupResult {\n  username: string;\n  addresses: string[];\n}\n\nexport interface LookupResponse {\n  results: LookupResult[];\n}\n\nexport enum FeeSource {\n  PAYMASTER = \"PAYMASTER\",\n  CREDITS = \"CREDITS\",\n}\n\ntype ContractAddress = string;\ntype CartridgeID = string;\nexport type ControllerAccounts = Record<ContractAddress, CartridgeID>;\n\nexport interface Keychain {\n  probe(rpcUrl: string): Promise<ProbeReply | ConnectError>;\n  connect(\n    policies: SessionPolicies,\n    rpcUrl: string,\n    signupOptions?: AuthOptions,\n  ): Promise<ConnectReply | ConnectError>;\n  disconnect(): void;\n\n  reset(): void;\n  revoke(origin: string): void;\n\n  deploy(): Promise<DeployReply | ConnectError>;\n  execute(\n    calls: Call | Call[],\n    abis?: Abi[],\n    transactionsDetail?: InvocationsDetails,\n    sync?: boolean,\n    feeSource?: any,\n    error?: ControllerError,\n  ): Promise<ExecuteReply | ConnectError>;\n  signMessage(\n    typedData: TypedData,\n    account: string,\n    async?: boolean,\n  ): Promise<Signature | ConnectError>;\n  openSettings(): Promise<void | ConnectError>;\n  session(): Promise<KeychainSession>;\n  sessions(): Promise<{\n    [key: string]: KeychainSession;\n  }>;\n  delegateAccount(): string;\n  username(): string;\n  openPurchaseCredits(): void;\n  openExecute(calls: Call[]): Promise<void>;\n  switchChain(rpcUrl: string): Promise<void>;\n  openStarterPack(options: string | StarterPack): Promise<void>;\n  navigate(path: string): Promise<void>;\n\n  // External wallet methods\n  externalDetectWallets(): Promise<ExternalWallet[]>;\n  externalConnectWallet(\n    type: ExternalWalletType,\n    address?: string,\n  ): Promise<ExternalWalletResponse>;\n  externalSignMessage(\n    type: ExternalWalletType,\n    message: string,\n  ): Promise<ExternalWalletResponse>;\n  externalSignTypedData(\n    type: ExternalWalletType,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n  ): Promise<ExternalWalletResponse>;\n  externalGetBalance(\n    type: ExternalWalletType,\n    tokenAddress?: string,\n  ): Promise<ExternalWalletResponse>;\n  externalSwitchChain(\n    type: ExternalWalletType,\n    chainId: string,\n  ): Promise<boolean>;\n}\n\nexport interface Profile {\n  navigate(path: string): void;\n  switchChain(rpcUrl: string): Promise<void>;\n}\n\nexport interface Modal {\n  open: () => void;\n  close: () => void;\n}\n\n/**\n * Options for configuring the controller\n */\nexport type ControllerOptions = ProviderOptions & KeychainOptions;\n\nexport type IFrameOptions = {\n  /** The ID of the starter pack to use */\n  starterPackId?: string;\n  /** The preset to use */\n  preset?: string;\n};\n\nexport type Chain = {\n  rpcUrl: string;\n};\n\nexport type ProviderOptions = {\n  defaultChainId?: ChainId;\n  chains?: Chain[];\n};\n\nexport type KeychainOptions = IFrameOptions & {\n  policies?: SessionPolicies;\n  /** The URL of keychain */\n  url?: string;\n  /** The origin of keychain */\n  origin?: string;\n  /** Propagate transaction errors back to caller instead of showing modal */\n  propagateSessionErrors?: boolean;\n  /** The fee source to use for execute from outside */\n  feeSource?: FeeSource;\n  /** Signup options (the order of the options is reflected in the UI. It's recommended to group socials and wallets together ) */\n  signupOptions?: AuthOptions;\n  /** When true, manually provided policies will override preset policies. Default is false. */\n  shouldOverridePresetPolicies?: boolean;\n  /** The project name of Slot instance. */\n  slot?: string;\n  /** The namespace to use to fetch trophies data from indexer. Will be mandatory once profile page is in production */\n  namespace?: string;\n  /** The tokens to be listed on Inventory modal */\n  tokens?: Tokens;\n  /** When true, defer iframe mounting until connect() is called. Reduces initial load and resource fetching. */\n  lazyload?: boolean;\n};\n\nexport type ProfileContextTypeVariant =\n  | \"inventory\"\n  | \"trophies\"\n  | \"achievements\"\n  | \"leaderboard\"\n  | \"activity\";\n\nexport type Token = \"eth\" | \"strk\" | \"lords\" | \"usdc\" | \"usdt\";\n\nexport type Tokens = {\n  erc20?: Token[];\n};\n\nexport enum StarterPackItemType {\n  NONFUNGIBLE = \"NONFUNGIBLE\",\n  FUNGIBLE = \"FUNGIBLE\",\n}\n\nexport interface StarterPackItem {\n  type: StarterPackItemType;\n  name: string;\n  description: string;\n  iconURL?: string;\n  amount?: number;\n  price?: bigint;\n  call?: Call[];\n}\n\nexport interface StarterPack {\n  name: string;\n  description: string;\n  iconURL?: string;\n  items: StarterPackItem[];\n}\n", "import {\n  addAddressPadding,\n  Call,\n  CallData,\n  constants,\n  getChecksumAddress,\n  hash,\n  shortString,\n  typedData,\n  TypedDataRevision,\n} from \"starknet\";\nimport { Policy } from \"@cartridge/controller-wasm/controller\";\nimport { Policies, SessionPolicies } from \"@cartridge/presets\";\nimport { ChainId } from \"@starknet-io/types-js\";\nimport { ParsedSessionPolicies } from \"./policies\";\n\n// Whitelist of allowed property names to prevent prototype pollution\nconst ALLOWED_PROPERTIES = new Set([\n  \"contracts\",\n  \"messages\",\n  \"target\",\n  \"method\",\n  \"name\",\n  \"description\",\n  \"types\",\n  \"domain\",\n  \"primaryType\",\n]);\n\nfunction validatePropertyName(prop: string): void {\n  if (!ALLOWED_PROPERTIES.has(prop)) {\n    throw new Error(`Invalid property name: ${prop}`);\n  }\n}\n\nfunction safeObjectAccess<T>(obj: any, prop: string): T {\n  validatePropertyName(prop);\n  return obj[prop];\n}\n\nexport function normalizeCalls(calls: Call | Call[]) {\n  return toArray(calls).map((call) => {\n    return {\n      entrypoint: call.entrypoint,\n      contractAddress: addAddressPadding(call.contractAddress),\n      calldata: CallData.toHex(call.calldata),\n    };\n  });\n}\n\nexport function toSessionPolicies(policies: Policies): SessionPolicies {\n  return Array.isArray(policies)\n    ? policies.reduce<SessionPolicies>(\n        (prev, p) => {\n          if (safeObjectAccess<string>(p, \"target\")) {\n            const target = getChecksumAddress(\n              safeObjectAccess<string>(p, \"target\"),\n            );\n            const entrypoint = safeObjectAccess<string>(p, \"method\");\n            const contracts = safeObjectAccess<Record<string, any>>(\n              prev,\n              \"contracts\",\n            );\n            const item = {\n              name: humanizeString(entrypoint),\n              entrypoint: entrypoint,\n              description: safeObjectAccess<string>(p, \"description\"),\n            };\n\n            if (target in contracts) {\n              const methods = toArray(contracts[target].methods);\n              contracts[target] = {\n                methods: [...methods, item],\n              };\n            } else {\n              contracts[target] = {\n                methods: [item],\n              };\n            }\n          } else {\n            const messages = safeObjectAccess<any[]>(prev, \"messages\");\n            messages.push(p);\n          }\n\n          return prev;\n        },\n        { contracts: {}, messages: [] },\n      )\n    : policies;\n}\n\nexport function toWasmPolicies(policies: ParsedSessionPolicies): Policy[] {\n  return [\n    ...Object.entries(policies.contracts ?? {}).flatMap(\n      ([target, { methods }]) =>\n        toArray(methods).map((m) => ({\n          target,\n          method: hash.getSelectorFromName(m.entrypoint),\n          authorized: m.authorized,\n        })),\n    ),\n    ...(policies.messages ?? []).map((p) => {\n      const domainHash = typedData.getStructHash(\n        p.types,\n        \"StarknetDomain\",\n        p.domain,\n        TypedDataRevision.ACTIVE,\n      );\n      const typeHash = typedData.getTypeHash(\n        p.types,\n        p.primaryType,\n        TypedDataRevision.ACTIVE,\n      );\n\n      return {\n        scope_hash: hash.computePoseidonHash(domainHash, typeHash),\n        authorized: p.authorized,\n      };\n    }),\n  ];\n}\n\nexport function toArray<T>(val: T | T[]): T[] {\n  return Array.isArray(val) ? val : [val];\n}\n\nexport function humanizeString(str: string): string {\n  return (\n    str\n      // Convert from camelCase or snake_case\n      .replace(/([a-z])([A-Z])/g, \"$1 $2\") // camelCase to spaces\n      .replace(/_/g, \" \") // snake_case to spaces\n      .toLowerCase()\n      // Capitalize first letter\n      .replace(/^\\w/, (c) => c.toUpperCase())\n  );\n}\n\nexport function parseChainId(url: URL): ChainId {\n  const parts = url.pathname.split(\"/\");\n\n  // Handle localhost URLs by making a synchronous call to getChainId\n  if (\n    url.hostname === \"localhost\" ||\n    url.hostname === \"127.0.0.1\" ||\n    url.hostname === \"0.0.0.0\"\n  ) {\n    // Check if we're in a browser environment\n    if (typeof XMLHttpRequest === \"undefined\") {\n      // In Node.js environment (like tests), we can't make synchronous HTTP calls\n      // For now, we'll use a placeholder chainId for localhost in tests\n      console.warn(\n        `Cannot make synchronous HTTP call in Node.js environment for ${url.toString()}`,\n      );\n      return shortString.encodeShortString(\"LOCALHOST\") as ChainId;\n    }\n\n    // Use a synchronous XMLHttpRequest to get the chain ID\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", url.toString(), false); // false makes it synchronous\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n    const requestBody = JSON.stringify({\n      jsonrpc: \"2.0\",\n      method: \"starknet_chainId\",\n      params: [],\n      id: 1,\n    });\n\n    try {\n      xhr.send(requestBody);\n\n      if (xhr.status === 200) {\n        const response = JSON.parse(xhr.responseText);\n        if (response.result) {\n          return response.result as ChainId;\n        }\n      }\n\n      throw new Error(\n        `Failed to get chain ID from ${url.toString()}: ${xhr.status} ${xhr.statusText}`,\n      );\n    } catch (error) {\n      throw new Error(`Failed to connect to ${url.toString()}: ${error}`);\n    }\n  }\n\n  if (parts.includes(\"starknet\")) {\n    if (parts.includes(\"mainnet\")) {\n      return constants.StarknetChainId.SN_MAIN;\n    } else if (parts.includes(\"sepolia\")) {\n      return constants.StarknetChainId.SN_SEPOLIA;\n    }\n  } else if (parts.length >= 3) {\n    const projectName = parts[2];\n    if (parts.includes(\"katana\")) {\n      return shortString.encodeShortString(\n        `WP_${projectName.toUpperCase().replace(/-/g, \"_\")}`,\n      ) as ChainId;\n    } else if (parts.includes(\"mainnet\")) {\n      return shortString.encodeShortString(\n        `GG_${projectName.toUpperCase().replace(/-/g, \"_\")}`,\n      ) as ChainId;\n    }\n  }\n\n  throw new Error(`Chain ${url.toString()} not supported`);\n}\n", "export class NotReadyToConnect extends Error {\n  constructor() {\n    super(\"Not ready to connect\");\n\n    Object.setPrototypeOf(this, NotReadyToConnect.prototype);\n  }\n}\n", "export const KEYCHAIN_URL = \"https://x.cartridge.gg\";\nexport const PROFILE_URL = \"https://profile.cartridge.gg\";\nexport const API_URL = \"https://api.cartridge.gg\";\n", "export const Permission = {\n    ACCOUNTS: 'accounts',\n};\n//# sourceMappingURL=constants.js.map", "export const icon =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K\";\n", "function releaseStub() {}\n\n/**\n * A simple mutual exclusion lock. It allows you to obtain and release a lock,\n *  ensuring that only one task can access a critical section at a time.\n */\nexport class Mutex {\n  private m_lastPromise: Promise<void> = Promise.resolve();\n\n  /**\n   * Acquire lock\n   * @param [bypass=false] option to skip lock acquisition\n   */\n  public async obtain(bypass = false): Promise<() => void> {\n    let release = releaseStub;\n    if (bypass) return release;\n    const lastPromise = this.m_lastPromise;\n    this.m_lastPromise = new Promise<void>((resolve) => (release = resolve));\n    await lastPromise;\n    return release;\n  }\n}\n", "import {\n  AddInvokeTransactionParameters,\n  AddStarknetChainParameters,\n  Permission,\n  RequestAccountsParameters,\n  RequestFn,\n  StarknetWindowObject,\n  SwitchStarknetChainParameters,\n  TypedData,\n  UNEXPECTED_ERROR,\n  WalletEventHandlers,\n  WalletEventListener,\n  WalletEvents,\n} from \"@starknet-io/types-js\";\nimport { WalletAccount } from \"starknet\";\nimport manifest from \"../package.json\";\n\nimport { icon } from \"./icon\";\nimport { Mutex } from \"./mutex\";\n\nconst mutex = new Mutex();\n\nexport default abstract class BaseProvider implements StarknetWindowObject {\n  public id = \"controller\";\n  public name = \"Controller\";\n  public version = manifest.version;\n  public icon = icon;\n\n  public account?: WalletAccount;\n  public subscriptions: WalletEvents[] = [];\n\n  private _probePromise: Promise<WalletAccount | undefined> | null = null;\n\n  protected async safeProbe(): Promise<WalletAccount | undefined> {\n    // If we already have an account, return it\n    if (this.account) {\n      return this.account;\n    }\n\n    // If we're already probing, wait for the existing probe\n    if (this._probePromise) {\n      return this._probePromise;\n    }\n\n    const release = await mutex.obtain();\n    return await new Promise<WalletAccount | undefined>(async (resolve) => {\n      try {\n        this._probePromise = this.probe();\n        const result = await this._probePromise;\n        resolve(result);\n      } finally {\n        this._probePromise = null;\n      }\n    }).finally(() => {\n      release();\n    });\n  }\n\n  request: RequestFn = async (call) => {\n    switch (call.type) {\n      case \"wallet_getPermissions\":\n        await this.safeProbe();\n\n        if (this.account) {\n          return [Permission.ACCOUNTS];\n        }\n\n        return [];\n\n      case \"wallet_requestAccounts\": {\n        if (this.account) {\n          return [this.account.address];\n        }\n\n        const silentMode =\n          call.params && (call.params as RequestAccountsParameters).silent_mode;\n\n        this.account = await this.safeProbe();\n\n        if (!this.account && !silentMode) {\n          this.account = await this.connect();\n        }\n\n        if (this.account) {\n          return [this.account.address];\n        }\n\n        return [];\n      }\n\n      case \"wallet_watchAsset\":\n        throw {\n          code: 63,\n          message: \"An unexpected error occurred\",\n          data: \"wallet_watchAsset not implemented\",\n        } as UNEXPECTED_ERROR;\n\n      case \"wallet_addStarknetChain\": {\n        let params = call.params as AddStarknetChainParameters;\n        return this.addStarknetChain(params);\n      }\n\n      case \"wallet_switchStarknetChain\": {\n        let params = call.params as SwitchStarknetChainParameters;\n        return this.switchStarknetChain(params.chainId);\n      }\n\n      case \"wallet_requestChainId\":\n        if (!this.account) {\n          throw {\n            code: 63,\n            message: \"An unexpected error occurred\",\n            data: \"Account not initialized\",\n          } as UNEXPECTED_ERROR;\n        }\n\n        return await this.account.getChainId();\n\n      case \"wallet_deploymentData\":\n        throw {\n          code: 63,\n          message: \"An unexpected error occurred\",\n          data: \"wallet_deploymentData not implemented\",\n        } as UNEXPECTED_ERROR;\n\n      case \"wallet_addInvokeTransaction\":\n        if (!this.account) {\n          throw {\n            code: 63,\n            message: \"An unexpected error occurred\",\n            data: \"Account not initialized\",\n          } as UNEXPECTED_ERROR;\n        }\n\n        let params = call.params as AddInvokeTransactionParameters;\n        return await this.account.execute(\n          params.calls.map((call) => ({\n            contractAddress: call.contract_address,\n            entrypoint: call.entry_point,\n            calldata: call.calldata,\n          })),\n        );\n\n      case \"wallet_addDeclareTransaction\":\n        throw {\n          code: 63,\n          message: \"An unexpected error occurred\",\n          data: \"wallet_addDeclareTransaction not implemented\",\n        } as UNEXPECTED_ERROR;\n\n      case \"wallet_signTypedData\": {\n        if (!this.account) {\n          throw {\n            code: 63,\n            message: \"An unexpected error occurred\",\n            data: \"Account not initialized\",\n          } as UNEXPECTED_ERROR;\n        }\n\n        return await this.account.signMessage(call.params as TypedData);\n      }\n\n      case \"wallet_supportedSpecs\":\n        return [];\n      case \"wallet_supportedWalletApi\":\n        return [];\n      default:\n        throw {\n          code: 63,\n          message: \"An unexpected error occurred\",\n          data: `Unknown RPC call type: ${call.type}`,\n        } as UNEXPECTED_ERROR;\n    }\n  };\n\n  on: WalletEventListener = <E extends keyof WalletEventHandlers>(\n    event: E,\n    handler: WalletEventHandlers[E],\n  ): void => {\n    if (event !== \"accountsChanged\" && event !== \"networkChanged\") {\n      throw new Error(`Unknown event: ${event}`);\n    }\n    this.subscriptions.push({ type: event, handler } as WalletEvents);\n  };\n\n  off: WalletEventListener = <E extends keyof WalletEventHandlers>(\n    event: E,\n    handler: WalletEventHandlers[E],\n  ): void => {\n    if (event !== \"accountsChanged\" && event !== \"networkChanged\") {\n      throw new Error(`Unknown event: ${event}`);\n    }\n    const idx = this.subscriptions.findIndex(\n      (sub) => sub.type === event && sub.handler === handler,\n    );\n    if (idx >= 0) {\n      this.subscriptions.splice(idx, 1);\n    }\n  };\n\n  protected emitNetworkChanged(chainId: string) {\n    this.subscriptions\n      .filter((sub) => sub.type === \"networkChanged\")\n      .forEach((sub) => {\n        (sub.handler as WalletEventHandlers[\"networkChanged\"])(chainId);\n      });\n  }\n\n  protected emitAccountsChanged(accounts: string[]) {\n    this.subscriptions\n      .filter((sub) => sub.type === \"accountsChanged\")\n      .forEach((sub) => {\n        (sub.handler as WalletEventHandlers[\"accountsChanged\"])(accounts);\n      });\n  }\n\n  abstract probe(): Promise<WalletAccount | undefined>;\n  abstract connect(): Promise<WalletAccount | undefined>;\n  abstract switchStarknetChain(chainId: string): Promise<boolean>;\n  abstract addStarknetChain(\n    chain: AddStarknetChainParameters,\n  ): Promise<boolean>;\n}\n", "import {\n  InvokeFunctionResponse,\n  TypedData,\n  WalletAccount,\n  Call,\n  AllowArray,\n} from \"starknet\";\n\nimport {\n  ConnectError,\n  Keychain,\n  KeychainOptions,\n  Modal,\n  ResponseCodes,\n} from \"./types\";\nimport { AsyncMethodReturns } from \"@cartridge/penpal\";\nimport BaseProvider from \"./provider\";\nimport { toArray } from \"./utils\";\nimport { SIGNATURE } from \"@starknet-io/types-js\";\n\nclass ControllerAccount extends WalletAccount {\n  private keychain: AsyncMethodReturns<Keychain>;\n  private modal: Modal;\n  private options?: KeychainOptions;\n\n  constructor(\n    provider: BaseProvider,\n    rpcUrl: string,\n    address: string,\n    keychain: AsyncMethodReturns<Keychain>,\n    options: KeychainOptions,\n    modal: Modal,\n  ) {\n    super({\n      provider: { nodeUrl: rpcUrl },\n      walletProvider: provider,\n      address,\n    });\n\n    this.keychain = keychain;\n    this.options = options;\n    this.modal = modal;\n  }\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param calls the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abis (optional) the abi of the contract for better displaying\n   *\n   * @returns response from addTransaction\n   */\n  async execute(calls: AllowArray<Call>): Promise<InvokeFunctionResponse> {\n    calls = toArray(calls);\n\n    return new Promise(async (resolve, reject) => {\n      const sessionExecute = await this.keychain.execute(\n        calls,\n        undefined,\n        undefined,\n        false,\n        this.options?.feeSource,\n      );\n\n      // Session call succeeded\n      if (sessionExecute.code === ResponseCodes.SUCCESS) {\n        resolve(sessionExecute as InvokeFunctionResponse);\n        return;\n      }\n\n      // Propagates session txn error back to caller\n      if (\n        this.options?.propagateSessionErrors &&\n        sessionExecute.code !== ResponseCodes.USER_INTERACTION_REQUIRED\n      ) {\n        reject((sessionExecute as ConnectError).error);\n        return;\n      }\n\n      // Session call or Paymaster flow failed.\n      // Session not avaialble, manual flow fallback\n      this.modal.open();\n      const manualExecute = await this.keychain.execute(\n        calls,\n        undefined,\n        undefined,\n        true,\n        (sessionExecute as ConnectError).error,\n      );\n\n      // Manual call succeeded\n      if (manualExecute.code === ResponseCodes.SUCCESS) {\n        resolve(manualExecute as InvokeFunctionResponse);\n        this.modal.close();\n        return;\n      }\n\n      reject((manualExecute as ConnectError).error);\n      return;\n    });\n  }\n\n  /**\n   * Sign an JSON object for off-chain usage with the starknet private key and return the signature\n   * This adds a message prefix so it cant be interchanged with transactions\n   *\n   * @param json - JSON object to be signed\n   * @returns the signature of the JSON object\n   * @throws {Error} if the JSON object is not a valid JSON\n   */\n  async signMessage(typedData: TypedData): Promise<SIGNATURE> {\n    return new Promise(async (resolve, reject) => {\n      const sessionSign = await this.keychain.signMessage(typedData, \"\", true);\n\n      // Session sign succeeded\n      if (!(\"code\" in sessionSign)) {\n        resolve(sessionSign as SIGNATURE);\n        return;\n      }\n\n      // Session not avaialble, manual flow fallback\n      this.modal.open();\n      const manualSign = await this.keychain.signMessage(typedData, \"\", false);\n\n      if (!(\"code\" in manualSign)) {\n        resolve(manualSign as SIGNATURE);\n      } else {\n        reject((manualSign as ConnectError).error);\n      }\n      this.modal.close();\n    });\n  }\n}\n\nexport default ControllerAccount;\n", "export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n", "export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n", "export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n", "const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n", "/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n", "import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName]\n            .call(serializedMethods, event.origin)\n            .apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n", "let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n", "const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n", "import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n", "import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n", "import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        // Under specific timing circumstances, we can receive an event\n        // whose source is null. This seems to happen when the child iframe is\n        // removed from the DOM about the same time it has sent the SYN event.\n        // https://github.com/Aaronius/penpal/issues/85\n        if (!event.source) {\n            return;\n        }\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n", "const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n", "import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n", "import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n", "import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n", "import { AsyncMethodReturns, connectToChild } from \"@cartridge/penpal\";\nimport { ControllerOptions, Modal } from \"../types\";\n\nexport type IFrameOptions<CallSender> = Omit<\n  ConstructorParameters<typeof IFrame>[0],\n  \"id\" | \"url\" | \"onConnect\"\n> & {\n  url?: string;\n  onConnect: (child: AsyncMethodReturns<CallSender>) => void;\n};\n\nexport class IFrame<CallSender extends {}> implements Modal {\n  url?: URL;\n  private iframe?: HTMLIFrameElement;\n  private container?: HTMLDivElement;\n  private onClose?: () => void;\n  private child?: AsyncMethodReturns<CallSender>;\n  private closeTimeout?: NodeJS.Timeout;\n\n  constructor({\n    id,\n    url,\n    preset,\n    onClose,\n    onConnect,\n    methods = {},\n  }: Pick<ControllerOptions, \"preset\"> & {\n    id: string;\n    url: URL;\n    onClose?: () => void;\n    onConnect: (child: AsyncMethodReturns<CallSender>) => void;\n    methods?: { [key: string]: (...args: any[]) => void };\n  }) {\n    if (typeof document === \"undefined\" || typeof window === \"undefined\") {\n      return;\n    }\n\n    if (preset) {\n      url.searchParams.set(\"preset\", preset);\n    }\n\n    this.url = url;\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.src = url.toString();\n    iframe.id = id;\n    iframe.style.border = \"none\";\n    iframe.sandbox.add(\"allow-forms\");\n    iframe.sandbox.add(\"allow-popups\");\n    iframe.sandbox.add(\"allow-popups-to-escape-sandbox\");\n    iframe.sandbox.add(\"allow-scripts\");\n    iframe.sandbox.add(\"allow-same-origin\");\n    iframe.allow =\n      \"publickey-credentials-create *; publickey-credentials-get *; clipboard-write\";\n    if (!!document.hasStorageAccess) {\n      iframe.sandbox.add(\"allow-storage-access-by-user-activation\");\n    }\n\n    const container = document.createElement(\"div\");\n    container.id = \"controller\";\n    container.style.position = \"fixed\";\n    container.style.height = \"100%\";\n    container.style.width = \"100%\";\n    container.style.top = \"0\";\n    container.style.left = \"0\";\n    container.style.zIndex = \"10000\";\n    container.style.backgroundColor = \"rgba(0,0,0,0.6)\";\n    container.style.display = \"none\"; // Use display: none to completely hide from password managers\n    container.style.alignItems = \"center\";\n    container.style.justifyContent = \"center\";\n    container.style.transition = \"opacity 0.2s ease\";\n    container.style.opacity = \"0\";\n    container.style.pointerEvents = \"auto\";\n    container.appendChild(iframe);\n\n    // Add click event listener to close iframe when clicking outside\n    container.addEventListener(\"click\", (e) => {\n      if (e.target === container) {\n        // Attempting to reset(clear context) for keychain iframe (identified by ID)\n        if (id === \"controller-keychain\" && this.child) {\n          // Type assertion for keychain child only\n          (this.child as any)\n            .reset?.()\n            .catch((e: any) => console.error(\"Error resetting context:\", e));\n        }\n        this.close();\n      }\n    });\n\n    this.iframe = iframe;\n    this.container = container;\n\n    connectToChild<CallSender>({\n      iframe: this.iframe,\n      methods: {\n        close: (_origin: string) => () => this.close(),\n        reload: (_origin: string) => () => window.location.reload(),\n        ...methods,\n      },\n    }).promise.then((child) => {\n      this.child = child;\n      onConnect(child);\n    });\n\n    this.resize();\n    window.addEventListener(\"resize\", () => this.resize());\n\n    const observer = new MutationObserver(() => {\n      if (typeof document === \"undefined\") return;\n      const existingController = document.getElementById(\"controller\");\n      if (document.body) {\n        if (id === \"controller-keychain\" && !existingController) {\n          document.body.appendChild(container);\n          observer.disconnect();\n        }\n      }\n    });\n\n    observer.observe(document.documentElement, {\n      childList: true,\n      subtree: true,\n    });\n\n    const existingController = document.getElementById(\"controller\");\n    if (document.body) {\n      if (id === \"controller-keychain\" && !existingController) {\n        document.body.appendChild(container);\n      }\n    }\n\n    this.onClose = onClose;\n  }\n\n  open() {\n    if (!this.container || typeof document === \"undefined\" || !document.body)\n      return;\n\n    // Clear any pending close timeout to prevent race condition\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = undefined;\n    }\n\n    document.body.style.overflow = \"hidden\";\n\n    this.container.style.display = \"flex\";\n    // Use requestAnimationFrame to ensure display change is processed before opacity change\n    requestAnimationFrame(() => {\n      if (this.container) {\n        this.container.style.opacity = \"1\";\n      }\n    });\n  }\n\n  close() {\n    if (!this.container || typeof document === \"undefined\" || !document.body)\n      return;\n    this.onClose?.();\n\n    document.body.style.overflow = \"auto\";\n\n    // Start fade-out transition\n    this.container.style.opacity = \"0\";\n\n    // Set display: none after transition completes (200ms)\n    this.closeTimeout = setTimeout(() => {\n      if (this.container) {\n        this.container.style.display = \"none\";\n      }\n      this.closeTimeout = undefined;\n    }, 200);\n  }\n\n  sendBackward() {\n    if (!this.container) return;\n    this.container.style.zIndex = \"9999\";\n  }\n\n  sendForward() {\n    if (!this.container) return;\n    this.container.style.zIndex = \"10000\";\n  }\n\n  private resize() {\n    if (!this.iframe || typeof window === \"undefined\") return;\n\n    this.iframe.style.userSelect = \"none\";\n\n    if (window.innerWidth < 768) {\n      this.iframe.style.height = \"100%\";\n      this.iframe.style.width = \"100%\";\n      this.iframe.style.borderRadius = \"0\";\n      return;\n    }\n\n    this.iframe.style.height = \"600px\";\n    this.iframe.style.width = \"432px\";\n    this.iframe.style.borderRadius = \"8px\";\n  }\n\n  isOpen() {\n    return this.container?.style.display !== \"none\";\n  }\n}\n", "/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nexport const version = \"6.13.7\";\n//# sourceMappingURL=_version.js.map", "/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map", "/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nimport { version } from \"../_version.js\";\nimport { defineProperties } from \"./properties.js\";\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    defineProperties(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        defineProperties(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexport function assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map", "/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map", "/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\";\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        swap32IfBE(this.state32);\n        keccakP(this.state32, this.rounds);\n        swap32IfBE(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map", "/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\nimport { keccak_256 } from \"@noble/hashes/sha3\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\nconst _keccak256 = function (data) {\n    return keccak_256(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map", "import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map", "import { Call, TypedData, StarknetWindowObject } from \"@starknet-io/types-js\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\nexport class ArgentWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"argent\";\n  readonly platform: ExternalPlatform = \"starknet\";\n  private wallet: StarknetWindowObject | undefined = undefined;\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n  private accountChangeListener: ((accounts?: string[]) => void) | undefined =\n    undefined;\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.starknet_argentX;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available\n        ? window.starknet_argentX?.version || \"Unknown\"\n        : undefined,\n      chainId: available ? window.starknet_argentX?.chainId : undefined,\n      name: \"Argent\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Argent is not available\");\n      }\n\n      const wallet = window.starknet_argentX as StarknetWindowObject;\n      if (!wallet) {\n        throw new Error(\"No wallet found\");\n      }\n\n      // Request accounts from the wallet\n      const accounts = await wallet.request({\n        type: \"wallet_requestAccounts\",\n        params: { silent_mode: false },\n      });\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error(\"No accounts found\");\n      }\n\n      this.removeAccountChangeListener();\n\n      this.wallet = wallet;\n      this.account = accounts[0];\n      this.connectedAccounts = accounts;\n      this.setupAccountChangeListener();\n      return { success: true, wallet: this.type, account: this.account };\n    } catch (error) {\n      console.error(`Error connecting to Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signTypedData(data: TypedData): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Argent is not connected\");\n      }\n\n      const sig = await this.wallet.request({\n        type: \"wallet_signTypedData\",\n        params: data,\n      });\n\n      return { success: true, wallet: this.type, result: sig };\n    } catch (error) {\n      console.error(`Error signing typed data with Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(calls: Call[]): Promise<ExternalWalletResponse> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    try {\n      const result = await this.wallet.request({\n        type: \"wallet_addInvokeTransaction\",\n        params: {\n          calls,\n        },\n      });\n\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    const result = await this.wallet.request({\n      type: \"wallet_switchStarknetChain\",\n      params: {\n        chainId,\n      },\n    });\n\n    return result;\n  }\n\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Argent is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Argent's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Argent API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Argent wallet\",\n    };\n  }\n\n  private setupAccountChangeListener(): void {\n    if (!this.wallet) return;\n\n    this.accountChangeListener = (accounts: string[] | undefined) => {\n      if (accounts && accounts.length > 0) {\n        this.account = accounts[0];\n        this.connectedAccounts = accounts;\n      } else {\n        this.account = undefined;\n        this.connectedAccounts = [];\n      }\n    };\n\n    // Listen for account changes\n    this.wallet.on(\"accountsChanged\", this.accountChangeListener);\n  }\n\n  private removeAccountChangeListener(): void {\n    if (this.wallet && this.accountChangeListener) {\n      this.wallet.off(\"accountsChanged\", this.accountChangeListener);\n      this.accountChangeListener = undefined;\n    }\n  }\n\n  disconnect(): void {\n    this.removeAccountChangeListener();\n    this.wallet = undefined;\n    this.account = undefined;\n    this.connectedAccounts = [];\n  }\n}\n", "/**\n * Announces an EIP-1193 Provider.\n */\nexport function announceProvider(detail) {\n    const event = new CustomEvent('eip6963:announceProvider', { detail: Object.freeze(detail) });\n    window.dispatchEvent(event);\n    const handler = () => window.dispatchEvent(event);\n    window.addEventListener('eip6963:requestProvider', handler);\n    return () => window.removeEventListener('eip6963:requestProvider', handler);\n}\n/**\n * Watches for EIP-1193 Providers to be announced.\n */\nexport function requestProviders(listener) {\n    if (typeof window === 'undefined')\n        return;\n    const handler = (event) => listener(event.detail);\n    window.addEventListener('eip6963:announceProvider', handler);\n    window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));\n    return () => window.removeEventListener('eip6963:announceProvider', handler);\n}\n//# sourceMappingURL=utils.js.map", "import { requestProviders } from './utils.js';\nexport function createStore() {\n    const listeners = new Set();\n    let providerDetails = [];\n    const request = () => requestProviders((providerDetail) => {\n        if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))\n            return;\n        providerDetails = [...providerDetails, providerDetail];\n        listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));\n    });\n    let unwatch = request();\n    return {\n        _listeners() {\n            return listeners;\n        },\n        clear() {\n            listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));\n            providerDetails = [];\n        },\n        destroy() {\n            this.clear();\n            listeners.clear();\n            unwatch?.();\n        },\n        findProvider({ rdns }) {\n            return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);\n        },\n        getProviders() {\n            return providerDetails;\n        },\n        reset() {\n            this.clear();\n            unwatch?.();\n            unwatch = request();\n        },\n        subscribe(listener, { emitImmediately } = {}) {\n            listeners.add(listener);\n            if (emitImmediately)\n                listener(providerDetails, { added: providerDetails });\n            return () => listeners.delete(listener);\n        },\n    };\n}\n//# sourceMappingURL=store.js.map", "import { constants, num } from \"starknet\";\nimport type { ExternalPlatform } from \"./types\";\n\nconst PLATFORMS: Record<string, ExternalPlatform> = {\n  \"0x1\": \"ethereum\", // ethereum mainnet\n  \"0xaa36a7\": \"ethereum\", // ethereum sepolia\n  \"0x14a34\": \"base\", // base mainnet\n  \"0x2105\": \"base\", // base sepolia\n  \"0x66eee\": \"arbitrum\", // arbitrum mainnet\n  \"0xa4b1\": \"arbitrum\", // arbitrum sepolia\n  \"0xa\": \"optimism\", // op mainnet\n  \"0xaa37dc\": \"optimism\", // op sepolia\n  [constants.StarknetChainId.SN_MAIN]: \"starknet\",\n  [constants.StarknetChainId.SN_SEPOLIA]: \"starknet\",\n};\n\nexport const chainIdToPlatform = (\n  chainId: string,\n): ExternalPlatform | undefined => {\n  const hex = num.toHex(chainId);\n  const platform = PLATFORMS[hex];\n  if (!platform) {\n    console.warn(`Unknown chain ID: ${hex}`);\n  }\n  return platform;\n};\n", "import { getAddress } from \"ethers/address\";\nimport { createStore, EIP6963ProviderDetail } from \"mipd\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\nimport { chainIdToPlatform } from \"./platform\";\n\nexport abstract class EthereumWalletBase implements WalletAdapter {\n  abstract readonly type: ExternalWalletType;\n  abstract readonly rdns: string;\n  abstract readonly displayName: string;\n\n  platform: ExternalPlatform | undefined;\n  protected account: string | undefined = undefined;\n  protected store = createStore();\n  protected provider: EIP6963ProviderDetail | undefined;\n  protected connectedAccounts: string[] = [];\n\n  constructor() {\n    this.initializeIfAvailable();\n  }\n\n  private getProvider(): EIP6963ProviderDetail | undefined {\n    if (!this.provider) {\n      this.provider = this.store\n        .getProviders()\n        .find((provider) => provider.info.rdns === this.rdns);\n    }\n    return this.provider;\n  }\n\n  private getEthereumProvider(): any {\n    const provider = this.getProvider();\n    if (provider) {\n      return provider.provider;\n    }\n\n    // Fallback for MetaMask when not announced via EIP-6963\n    if (\n      this.rdns === \"io.metamask\" &&\n      typeof window !== \"undefined\" &&\n      (window as any).ethereum?.isMetaMask\n    ) {\n      return (window as any).ethereum;\n    }\n\n    return null;\n  }\n\n  private initializeIfAvailable(): void {\n    const provider = this.getProvider();\n    if (provider && !this.initialized) {\n      this.initialized = true;\n      this.initializeProvider();\n    }\n  }\n\n  private initialized = false;\n\n  private initializeProvider(): void {\n    const provider = this.getProvider();\n    if (!provider) return;\n\n    provider.provider\n      .request({\n        method: \"eth_accounts\",\n      })\n      .then((accounts) => {\n        this.connectedAccounts = accounts.map(getAddress);\n        if (accounts.length > 0) {\n          this.account = getAddress(accounts[0]);\n        }\n      })\n      .catch(console.error);\n\n    provider.provider\n      .request({\n        method: \"eth_chainId\",\n      })\n      .then((chainId) => {\n        this.platform = chainIdToPlatform(chainId);\n      })\n      .catch(console.error);\n\n    provider.provider?.on(\"chainChanged\", (chainId: string) => {\n      this.platform = chainIdToPlatform(chainId);\n    });\n\n    provider.provider?.on(\"accountsChanged\", (accounts: string[]) => {\n      if (accounts) {\n        this.connectedAccounts = accounts.map((account) => getAddress(account));\n        this.account =\n          accounts.length > 0 ? getAddress(accounts[0]) : undefined;\n      }\n    });\n  }\n\n  isAvailable(): boolean {\n    // Check dynamically each time, as the provider might be announced after instantiation\n    const provider = this.getProvider();\n\n    // Also check for MetaMask via window.ethereum as a fallback for MetaMask specifically\n    if (\n      !provider &&\n      this.rdns === \"io.metamask\" &&\n      typeof window !== \"undefined\"\n    ) {\n      // MetaMask might be available via window.ethereum even if not announced via EIP-6963 yet\n      return !!(window as any).ethereum?.isMetaMask;\n    }\n\n    // Initialize if we just found the provider\n    if (provider && !this.initialized) {\n      this.initializeIfAvailable();\n    }\n\n    return typeof window !== \"undefined\" && !!provider;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available ? window.ethereum?.version || \"Unknown\" : undefined,\n      chainId: available ? window.ethereum?.chainId : undefined,\n      name: this.displayName,\n      platform: this.platform,\n      connectedAccounts: this.connectedAccounts,\n    };\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async connect(address?: string): Promise<ExternalWalletResponse<any>> {\n    if (address && this.connectedAccounts.includes(getAddress(address))) {\n      this.account = getAddress(address);\n    }\n\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not available`);\n      }\n\n      let ethereum: any;\n      const provider = this.getProvider();\n\n      if (provider) {\n        ethereum = provider.provider;\n      } else if (\n        this.rdns === \"io.metamask\" &&\n        (window as any).ethereum?.isMetaMask\n      ) {\n        // Fallback for MetaMask when not announced via EIP-6963\n        ethereum = (window as any).ethereum;\n      }\n\n      if (!ethereum) {\n        throw new Error(`${this.displayName} provider not found`);\n      }\n\n      const accounts = await ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n\n      if (accounts && accounts.length > 0) {\n        this.account = getAddress(accounts[0]);\n        this.connectedAccounts = accounts.map(getAddress);\n\n        // If we used the fallback, store the ethereum provider for future use\n        if (!provider && this.rdns === \"io.metamask\") {\n          // Create a mock EIP6963ProviderDetail for consistency\n          this.provider = {\n            info: {\n              uuid: \"metamask-fallback\",\n              name: \"MetaMask\",\n              icon: \"data:image/svg+xml;base64,\",\n              rdns: \"io.metamask\",\n            },\n            provider: ethereum,\n          } as EIP6963ProviderDetail;\n          this.initializeIfAvailable();\n        }\n\n        return { success: true, wallet: this.type, account: this.account };\n      }\n\n      throw new Error(\"No accounts found\");\n    } catch (error) {\n      console.error(`Error connecting to ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signTransaction(\n    transaction: any,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [transaction],\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error signing transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signMessage(\n    message: string | `0x${string}`,\n    address?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} provider not found`);\n      }\n      const result = await ethereum.request({\n        method: \"personal_sign\",\n        params: [message, address || this.account] as any,\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(`Error signing message with ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signTypedData(data: any): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.account, JSON.stringify(data)] as any,\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error signing typed data with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(txn: any): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [txn],\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error sending transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not available`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      try {\n        await ethereum.request({\n          method: \"wallet_switchEthereumChain\",\n          params: [{ chainId }],\n        });\n\n        this.platform = chainIdToPlatform(chainId);\n        return true;\n      } catch (error) {\n        if ((error as any).code === 4902) {\n          console.warn(`Chain not added to ${this.displayName}`);\n        }\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error switching chain for ${this.displayName}:`, error);\n      return false;\n    }\n  }\n\n  async getBalance(\n    tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      if (tokenAddress) {\n        return {\n          success: false,\n          wallet: this.type,\n          error: \"Not implemented for ERC20\",\n        };\n      } else {\n        const ethereum = this.getEthereumProvider();\n        if (!ethereum) {\n          throw new Error(`${this.displayName} is not connected`);\n        }\n\n        const balance = await ethereum.request({\n          method: \"eth_getBalance\",\n          params: [this.account, \"latest\"] as any,\n        });\n        return { success: true, wallet: this.type, result: balance };\n      }\n    } catch (error) {\n      console.error(`Error getting balance from ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    txHash: string,\n    timeoutMs: number = 60000,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const startTime = Date.now();\n      const pollInterval = 1000; // 1 second\n\n      while (Date.now() - startTime < timeoutMs) {\n        const receipt = await ethereum.request({\n          method: \"eth_getTransactionReceipt\",\n          params: [txHash as `0x${string}`],\n        });\n\n        if (receipt) {\n          return {\n            success: true,\n            wallet: this.type,\n            result: receipt,\n          };\n        }\n\n        // Wait before polling again\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n      }\n\n      throw new Error(\"Transaction confirmation timed out\");\n    } catch (error) {\n      console.error(\n        `Error waiting for transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n}\n", "import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class BaseWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"base\";\n  readonly rdns = \"com.coinbase.wallet\";\n  readonly displayName = \"Base Wallet\";\n}\n", "import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class MetaMaskWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"metamask\";\n  readonly rdns = \"io.metamask\";\n  readonly displayName = \"MetaMask\";\n}\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// TODO: temporarily set to false, trying to understand bugs\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) {\n        astr('base64', s);\n        return Uint8Array.fromBase64(s, { lastChunkHandling: 'strict' });\n    },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { astr('base64', s); return Uint8Array.fromBase64(s, { alphabet: 'base64url' }); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nexport const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map", "import { hex as baseHex, utf8 } from '@scure/base';\n/**\n * Define complex binary structures using composable primitives.\n * Main ideas:\n * - Encode / decode can be chained, same as in `scure-base`\n * - A complex structure can be created from an array and struct of primitive types\n * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly\n *   without creating plain array first and reading each byte separately.\n * - Types are inferred from definition\n * @module\n * @example\n * import * as P from 'micro-packed';\n * const s = P.struct({\n *   field1: P.U32BE, // 32-bit unsigned big-endian integer\n *   field2: P.string(P.U8), // String with U8 length prefix\n *   field3: P.bytes(32), // 32 bytes\n *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length\n *     subField1: P.U64BE, // 64-bit unsigned big-endian integer\n *     subField2: P.string(10) // 10-byte string\n *   }))\n * });\n */\n// TODO: remove dependency on scure-base & inline?\n/*\nExports can be groupped like this:\n\n- Primitive types: P.bytes, P.string, P.hex, P.constant, P.pointer\n- Complex types: P.array, P.struct, P.tuple, P.map, P.tag, P.mappedTag\n- Padding, prefix, magic: P.padLeft, P.padRight, P.prefix, P.magic, P.magicBytes\n- Flags: P.flag, P.flagged, P.optional\n- Wrappers: P.apply, P.wrap, P.lazy\n- Bit fiddling: P.bits, P.bitset\n- utils: P.validate, coders.decimal\n- Debugger\n*/\n/** Shortcut to zero-length (empty) byte array */\nexport const EMPTY = /* @__PURE__ */ new Uint8Array();\n/** Shortcut to one-element (element is 0) byte array */\nexport const NULL = /* @__PURE__ */ new Uint8Array([0]);\n/** Checks if two Uint8Arrays are equal. Not constant-time. */\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\n/** Checks if the given value is a Uint8Array. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/**\n * Concatenates multiple Uint8Arrays.\n * Engines limit functions to 65K+ arguments.\n * @param arrays Array of Uint8Array elements\n * @returns Concatenated Uint8Array\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/**\n * Creates DataView from Uint8Array\n * @param arr - bytes\n * @returns DataView\n */\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n/**\n * Checks if the provided value is a plain object, not created from any class or special constructor.\n * Array, Uint8Array and others are not plain objects.\n * @param obj - The value to be checked.\n */\nfunction isPlainObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\nfunction isNum(num) {\n    return Number.isSafeInteger(num);\n}\nexport const utils = {\n    equalBytes,\n    isBytes,\n    isCoder,\n    checkBounds,\n    concatBytes,\n    createView,\n    isPlainObject,\n};\n// NOTE: we can't have terminator separate function, since it won't know about boundaries\n// E.g. array of U16LE ([1,2,3]) would be [1, 0, 2, 0, 3, 0]\n// But terminator will find array at index '1', which happens to be inside of an element itself\n/**\n * Can be:\n * - Dynamic (CoderType)\n * - Fixed (number)\n * - Terminated (usually zero): Uint8Array with terminator\n * - Field path to field with length (string)\n * - Infinity (null) - decodes until end of buffer\n * Used in:\n * - bytes (string, prefix is implementation of bytes)\n * - array\n */\nconst lengthCoder = (len) => {\n    if (len !== null && typeof len !== 'string' && !isCoder(len) && !isBytes(len) && !isNum(len)) {\n        throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${len} (${typeof len})`);\n    }\n    return {\n        encodeStream(w, value) {\n            if (len === null)\n                return;\n            if (isCoder(len))\n                return len.encodeStream(w, value);\n            let byteLen;\n            if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(w.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (byteLen === undefined || byteLen !== value)\n                throw w.err(`Wrong length: ${byteLen} len=${len} exp=${value} (${typeof value})`);\n        },\n        decodeStream(r) {\n            let byteLen;\n            if (isCoder(len))\n                byteLen = Number(len.decodeStream(r));\n            else if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(r.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (typeof byteLen !== 'number')\n                throw r.err(`Wrong length: ${byteLen}`);\n            return byteLen;\n        },\n    };\n};\n/**\n * Small bitset structure to store position of ranges that have been read.\n * Can be more efficient when internal trees are utilized at the cost of complexity.\n * Needs `O(N/8)` memory for parsing.\n * Purpose: if there are pointers in parsed structure,\n * they can cause read of two distinct ranges:\n * [0-32, 64-128], which means 'pos' is not enough to handle them\n */\nconst Bitset = {\n    BITS: 32,\n    FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n    len: (len) => Math.ceil(len / 32),\n    create: (len) => new Uint32Array(Bitset.len(len)),\n    clean: (bs) => bs.fill(0),\n    debug: (bs) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n    checkLen: (bs, len) => {\n        if (Bitset.len(len) === bs.length)\n            return;\n        throw new Error(`wrong length=${bs.length}. Expected: ${Bitset.len(len)}`);\n    },\n    chunkLen: (bsLen, pos, len) => {\n        if (pos < 0)\n            throw new Error(`wrong pos=${pos}`);\n        if (pos + len > bsLen)\n            throw new Error(`wrong range=${pos}/${len} of ${bsLen}`);\n    },\n    set: (bs, chunk, value, allowRewrite = true) => {\n        if (!allowRewrite && (bs[chunk] & value) !== 0)\n            return false;\n        bs[chunk] |= value;\n        return true;\n    },\n    pos: (pos, i) => ({\n        chunk: Math.floor((pos + i) / 32),\n        mask: 1 << (32 - ((pos + i) % 32) - 1),\n    }),\n    indices: (bs, len, invert = false) => {\n        Bitset.checkLen(bs, len);\n        const { FULL_MASK, BITS } = Bitset;\n        const left = BITS - (len % BITS);\n        const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n        const res = [];\n        for (let i = 0; i < bs.length; i++) {\n            let c = bs[i];\n            if (invert)\n                c = ~c; // allows to gen unset elements\n            // apply mask to last element, so we won't iterate non-existent items\n            if (i === bs.length - 1)\n                c &= lastMask;\n            if (c === 0)\n                continue; // fast-path\n            for (let j = 0; j < BITS; j++) {\n                const m = 1 << (BITS - j - 1);\n                if (c & m)\n                    res.push(i * BITS + j);\n            }\n        }\n        return res;\n    },\n    range: (arr) => {\n        const res = [];\n        let cur;\n        for (const i of arr) {\n            if (cur === undefined || i !== cur.pos + cur.length)\n                res.push((cur = { pos: i, length: 1 }));\n            else\n                cur.length += 1;\n        }\n        return res;\n    },\n    rangeDebug: (bs, len, invert = false) => `[${Bitset.range(Bitset.indices(bs, len, invert))\n        .map((i) => `(${i.pos}/${i.length})`)\n        .join(', ')}]`,\n    setRange: (bs, bsLen, pos, len, allowRewrite = true) => {\n        Bitset.chunkLen(bsLen, pos, len);\n        const { FULL_MASK, BITS } = Bitset;\n        // Try to set range with maximum efficiency:\n        // - first chunk is always    '0000[1111]' (only right ones)\n        // - middle chunks are set to '[1111 1111]' (all ones)\n        // - last chunk is always     '[1111]0000' (only left ones)\n        // - max operations:          (N/32) + 2 (first and last)\n        const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n        const lastPos = pos + len;\n        const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n        // special case, whole range inside single chunk\n        if (first !== undefined && first === last)\n            return Bitset.set(bs, first, (FULL_MASK >>> (BITS - len)) << (BITS - len - pos), allowRewrite);\n        if (first !== undefined) {\n            if (!Bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite))\n                return false; // first chunk\n        }\n        // middle chunks\n        const start = first !== undefined ? first + 1 : pos / BITS;\n        const end = last !== undefined ? last : lastPos / BITS;\n        for (let i = start; i < end; i++)\n            if (!Bitset.set(bs, i, FULL_MASK, allowRewrite))\n                return false;\n        if (last !== undefined && first !== last)\n            if (!Bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite))\n                return false; // last chunk\n        return true;\n    },\n};\nconst Path = {\n    /**\n     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n     * Also, this makes impossible:\n     * - pushing field when stack is empty\n     * - pushing field inside of field (real bug)\n     * NOTE: we don't want to do '.pop' on error!\n     */\n    pushObj: (stack, obj, objFn) => {\n        const last = { obj };\n        stack.push(last);\n        objFn((field, fieldFn) => {\n            last.field = field;\n            fieldFn();\n            last.field = undefined;\n        });\n        stack.pop();\n    },\n    path: (stack) => {\n        const res = [];\n        for (const i of stack)\n            if (i.field !== undefined)\n                res.push(i.field);\n        return res.join('/');\n    },\n    err: (name, stack, msg) => {\n        const err = new Error(`${name}(${Path.path(stack)}): ${typeof msg === 'string' ? msg : msg.message}`);\n        if (msg instanceof Error && msg.stack)\n            err.stack = msg.stack;\n        return err;\n    },\n    resolve: (stack, path) => {\n        const parts = path.split('/');\n        const objPath = stack.map((i) => i.obj);\n        let i = 0;\n        for (; i < parts.length; i++) {\n            if (parts[i] === '..')\n                objPath.pop();\n            else\n                break;\n        }\n        let cur = objPath.pop();\n        for (; i < parts.length; i++) {\n            if (!cur || cur[parts[i]] === undefined)\n                return undefined;\n            cur = cur[parts[i]];\n        }\n        return cur;\n    },\n};\n/**\n * Internal structure. Reader class for reading from a byte array.\n * `stack` is internal: for debugger and logging\n * @class Reader\n */\nclass _Reader {\n    constructor(data, opts = {}, stack = [], parent = undefined, parentOffset = 0) {\n        this.pos = 0;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.data = data;\n        this.opts = opts;\n        this.stack = stack;\n        this.parent = parent;\n        this.parentOffset = parentOffset;\n        this.view = createView(data);\n    }\n    /** Internal method for pointers. */\n    _enablePointers() {\n        if (this.parent)\n            return this.parent._enablePointers();\n        if (this.bs)\n            return;\n        this.bs = Bitset.create(this.data.length);\n        Bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n    }\n    markBytesBS(pos, len) {\n        if (this.parent)\n            return this.parent.markBytesBS(this.parentOffset + pos, len);\n        if (!len)\n            return true;\n        if (!this.bs)\n            return true;\n        return Bitset.setRange(this.bs, this.data.length, pos, len, false);\n    }\n    markBytes(len) {\n        const pos = this.pos;\n        this.pos += len;\n        const res = this.markBytesBS(pos, len);\n        if (!this.opts.allowMultipleReads && !res)\n            throw this.err(`multiple read pos=${this.pos} len=${len}`);\n        return res;\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    readView(n, fn) {\n        if (!Number.isFinite(n))\n            throw this.err(`readView: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readView: Unexpected end of buffer');\n        const res = fn(this.view, this.pos);\n        this.markBytes(n);\n        return res;\n    }\n    // read bytes by absolute offset\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    finish() {\n        if (this.opts.allowUnreadBytes)\n            return;\n        if (this.bitPos) {\n            throw this.err(`${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n        if (this.bs && !this.parent) {\n            const notRead = Bitset.indices(this.bs, this.data.length, true);\n            if (notRead.length) {\n                const formatted = Bitset.range(notRead)\n                    .map(({ pos, length }) => `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`)\n                    .join(', ');\n                throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n            }\n            else\n                return; // all bytes read, everything is ok\n        }\n        // Default: no pointers enabled\n        if (!this.isEnd()) {\n            throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n    }\n    // User methods\n    err(msg) {\n        return Path.err('Reader', this.stack, msg);\n    }\n    offsetReader(n) {\n        if (n > this.data.length)\n            throw this.err('offsetReader: Unexpected end of buffer');\n        return new _Reader(this.absBytes(n), this.opts, this.stack, this, n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.markBytes(n);\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        if (this.pos + 1 > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const data = this.data[this.pos];\n        if (!peek)\n            this.markBytes(1);\n        return data;\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    get totalBytes() {\n        return this.data.length;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.byte();\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        // Fix signed integers\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        // indexOf should be faster than full equalBytes check\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n        return;\n    }\n}\n/**\n * Internal structure. Writer class for writing to a byte array.\n * The `stack` argument of constructor is internal, for debugging and logs.\n * @class Writer\n */\nclass _Writer {\n    constructor(stack = []) {\n        this.pos = 0;\n        // We could have a single buffer here and re-alloc it with\n        // x1.5-2 size each time it full, but it will be slower:\n        // basic/encode bench: 395ns -> 560ns\n        this.buffers = [];\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.viewBuf = new Uint8Array(8);\n        this.finished = false;\n        this.stack = stack;\n        this.view = createView(this.viewBuf);\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    writeView(len, fn) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (!isNum(len) || len > 8)\n            throw new Error(`wrong writeView length=${len}`);\n        fn(this.view);\n        this.bytes(this.viewBuf.slice(0, len));\n        this.viewBuf.fill(0);\n    }\n    // User methods\n    err(msg) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        return Path.err('Reader', this.stack, msg);\n    }\n    bytes(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    finish(clean = true) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        // Can't use concatBytes, because it limits amount of arguments (65K).\n        const buffers = this.buffers.concat(this.ptrs.map((i) => i.buffer));\n        const sum = buffers.map((b) => b.length).reduce((a, b) => a + b, 0);\n        const buf = new Uint8Array(sum);\n        for (let i = 0, pad = 0; i < buffers.length; i++) {\n            const a = buffers[i];\n            buf.set(a, pad);\n            pad += a.length;\n        }\n        for (let pos = this.pos, i = 0; i < this.ptrs.length; i++) {\n            const ptr = this.ptrs[i];\n            buf.set(ptr.ptr.encode(pos), ptr.pos);\n            pos += ptr.buffer.length;\n        }\n        // Cleanup\n        if (clean) {\n            // We cannot cleanup buffers here, since it can be static user provided buffer.\n            // Only '.byte' and '.bits' create buffer which we can safely clean.\n            // for (const b of this.buffers) b.fill(0);\n            this.buffers = [];\n            for (const p of this.ptrs)\n                p.buffer.fill(0);\n            this.ptrs = [];\n            this.finished = true;\n            this.bitBuf = 0;\n        }\n        return buf;\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n}\n// Immutable LE<->BE\nconst swapEndianness = (b) => Uint8Array.from(b).reverse();\n/** Internal function for checking bit bounds of bigint in signed/unsinged form */\nfunction checkBounds(value, bits, signed) {\n    if (signed) {\n        // [-(2**(32-1)), 2**(32-1)-1]\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw new Error(`value out of signed bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n    }\n    else {\n        // [0, 2**32-1]\n        if (0n > value || value >= 2n ** bits)\n            throw new Error(`value out of unsigned bounds. Expected 0 <= ${value} < ${2n ** bits}`);\n    }\n}\nfunction _wrap(inner) {\n    return {\n        // NOTE: we cannot export validate here, since it is likely mistake.\n        encodeStream: inner.encodeStream,\n        decodeStream: inner.decodeStream,\n        size: inner.size,\n        encode: (value) => {\n            const w = new _Writer();\n            inner.encodeStream(w, value);\n            return w.finish();\n        },\n        decode: (data, opts = {}) => {\n            const r = new _Reader(data, opts);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\n/**\n * Validates a value before encoding and after decoding using a provided function.\n * @param inner - The inner CoderType.\n * @param fn - The validation function.\n * @returns CoderType which check value with validation function.\n * @example\n * const val = (n: number) => {\n *   if (n > 10) throw new Error(`${n} > 10`);\n *   return n;\n * };\n *\n * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding\n */\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    if (typeof fn !== 'function')\n        throw new Error('validate: fn should be function');\n    return _wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let res;\n            try {\n                res = fn(value);\n            }\n            catch (e) {\n                throw w.err(e);\n            }\n            inner.encodeStream(w, res);\n        },\n        decodeStream: (r) => {\n            const res = inner.decodeStream(r);\n            try {\n                return fn(res);\n            }\n            catch (e) {\n                throw r.err(e);\n            }\n        },\n    });\n}\n/**\n * Wraps a stream encoder into a generic encoder and optionally validation function\n * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.\n * @returns The wrapped CoderType.\n * @example\n * const U8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n * });\n * const checkedU8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n *   validate: (n: number) => {\n *    if (n > 10) throw new Error(`${n} > 10`);\n *    return n;\n *   }\n * });\n */\nexport const wrap = (inner) => {\n    const res = _wrap(inner);\n    return inner.validate ? validate(res, inner.validate) : res;\n};\nconst isBaseCoder = (elm) => isPlainObject(elm) && typeof elm.decode === 'function' && typeof elm.encode === 'function';\n/**\n * Checks if the given value is a CoderType.\n * @param elm - The value to check.\n * @returns True if the value is a CoderType, false otherwise.\n */\nexport function isCoder(elm) {\n    return (isPlainObject(elm) &&\n        isBaseCoder(elm) &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decodeStream === 'function' &&\n        (elm.size === undefined || isNum(elm.size)));\n}\n// Coders (like in @scure/base) for common operations\n/**\n * Base coder for working with dictionaries (records, objects, key-value map)\n * Dictionary is dynamic type like: `[key: string, value: any][]`\n * @returns base coder that encodes/decodes between arrays of key-value tuples and dictionaries.\n * @example\n * const dict: P.CoderType<Record<string, number>> = P.apply(\n *  P.array(P.U16BE, P.tuple([P.cstring, P.U32LE] as const)),\n *  P.coders.dict()\n * );\n */\nfunction dict() {\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from))\n                throw new Error('array expected');\n            const to = {};\n            for (const item of from) {\n                if (!Array.isArray(item) || item.length !== 2)\n                    throw new Error(`array of two elements expected`);\n                const name = item[0];\n                const value = item[1];\n                if (to[name] !== undefined)\n                    throw new Error(`key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => {\n            if (!isPlainObject(to))\n                throw new Error(`expected plain object, got ${to}`);\n            return Object.entries(to);\n        },\n    };\n}\n/**\n * Safely converts bigint to number.\n * Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n * but we still can use them since real value will be smaller than u32\n */\nconst numberBigint = {\n    encode: (from) => {\n        if (typeof from !== 'bigint')\n            throw new Error(`expected bigint, got ${typeof from}`);\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => {\n        if (!isNum(to))\n            throw new Error('element is not a safe integer');\n        return BigInt(to);\n    },\n};\n/**\n * Base coder for working with TypeScript enums.\n * @param e - TypeScript enum.\n * @returns base coder that encodes/decodes between numbers and enum keys.\n * @example\n * enum Color { Red, Green, Blue }\n * const colorCoder = P.coders.tsEnum(Color);\n * colorCoder.encode(Color.Red); // 'Red'\n * colorCoder.decode('Green'); // 1\n */\nfunction tsEnum(e) {\n    if (!isPlainObject(e))\n        throw new Error('plain object expected');\n    return {\n        encode: (from) => {\n            if (!isNum(from) || !(from in e))\n                throw new Error(`wrong value ${from}`);\n            return e[from];\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`wrong value ${typeof to}`);\n            return e[to];\n        },\n    };\n}\n/**\n * Base coder for working with decimal numbers.\n * @param precision - Number of decimal places.\n * @param round - Round fraction part if bigger than precision (throws error by default)\n * @returns base coder that encodes/decodes between bigints and decimal strings.\n * @example\n * const decimal8 = P.coders.decimal(8);\n * decimal8.encode(630880845n); // '6.30880845'\n * decimal8.decode('6.30880845'); // 630880845n\n */\nfunction decimal(precision, round = false) {\n    if (!isNum(precision))\n        throw new Error(`decimal/precision: wrong value ${precision}`);\n    if (typeof round !== 'boolean')\n        throw new Error(`decimal/round: expected boolean, got ${typeof round}`);\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            if (typeof from !== 'bigint')\n                throw new Error(`expected bigint, got ${typeof from}`);\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let int = s.slice(0, sep);\n            let frac = s.slice(sep, i + 1);\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`expected string, got ${typeof to}`);\n            if (to === '-0')\n                throw new Error(`negative zero is not allowed`);\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(to))\n                throw new Error(`wrong string value=${to}`);\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            // split by separator and strip trailing zeros from fraction. always returns [string, string] (.split doesn't).\n            const intS = to.slice(0, sep);\n            const fracS = to.slice(sep + 1).replace(/0+$/, '');\n            const int = BigInt(intS) * decimalMask;\n            if (!round && fracS.length > precision) {\n                throw new Error(`fractional part cannot be represented with this precision (num=${to}, prec=${precision})`);\n            }\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\n/**\n * Combines multiple coders into a single coder, allowing conditional encoding/decoding based on input.\n * Acts as a parser combinator, splitting complex conditional coders into smaller parts.\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * @param lst - Array of coders to match.\n * @returns Combined coder for conditional encoding/decoding.\n */\nfunction match(lst) {\n    if (!Array.isArray(lst))\n        throw new Error(`expected array, got ${typeof lst}`);\n    for (const i of lst)\n        if (!isBaseCoder(i))\n            throw new Error(`wrong base coder ${i}`);\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\n/** Reverses direction of coder */\nconst reverse = (coder) => {\n    if (!isBaseCoder(coder))\n        throw new Error('BaseCoder expected');\n    return { encode: coder.decode, decode: coder.encode };\n};\nexport const coders = { dict, numberBigint, tsEnum, decimal, match, reverse };\n/**\n * CoderType for parsing individual bits.\n * NOTE: Structure should parse whole amount of bytes before it can start parsing byte-level elements.\n * @param len - Number of bits to parse.\n * @returns CoderType representing the parsed bits.\n * @example\n * const s = P.struct({ magic: P.bits(1), version: P.bits(1), tag: P.bits(4), len: P.bits(2) });\n */\nexport const bits = (len) => {\n    if (!isNum(len))\n        throw new Error(`bits: wrong length ${len} (${typeof len})`);\n    return wrap({\n        encodeStream: (w, value) => w.bits(value, len),\n        decodeStream: (r) => r.bits(len),\n        validate: (value) => {\n            if (!isNum(value))\n                throw new Error(`bits: wrong value ${value}`);\n            return value;\n        },\n    });\n};\n/**\n * CoderType for working with bigint values.\n * Unsized bigint values should be wrapped in a container (e.g., bytes or string).\n *\n * `0n = new Uint8Array([])`\n *\n * `1n = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the bigint in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the bigint is signed.\n * @param sized - Whether the bigint should have a fixed size.\n * @returns CoderType representing the bigint value.\n * @example\n * const U512BE = P.bigint(64, false, true, true); // Define a CoderType for a 512-bit unsigned big-endian integer\n */\nexport const bigint = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`bigint/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`bigint/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`bigint/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`bigint/sized: expected boolean, got ${typeof sized}`);\n    const bLen = BigInt(size);\n    const signBit = 2n ** (8n * bLen - 1n);\n    return wrap({\n        size: sized ? size : undefined,\n        encodeStream: (w, value) => {\n            if (signed && value < 0)\n                value = value | signBit;\n            const b = [];\n            for (let i = 0; i < size; i++) {\n                b.push(Number(value & 255n));\n                value >>= 8n;\n            }\n            let res = new Uint8Array(b).reverse();\n            if (!sized) {\n                let pos = 0;\n                for (pos = 0; pos < res.length; pos++)\n                    if (res[pos] !== 0)\n                        break;\n                res = res.subarray(pos); // remove leading zeros\n            }\n            w.bytes(le ? res.reverse() : res);\n        },\n        decodeStream: (r) => {\n            // TODO: for le we can read until first zero?\n            const value = r.bytes(sized ? size : Math.min(size, r.leftBytes));\n            const b = le ? value : swapEndianness(value);\n            let res = 0n;\n            for (let i = 0; i < b.length; i++)\n                res |= BigInt(b[i]) << (8n * BigInt(i));\n            if (signed && res & signBit)\n                res = (res ^ signBit) - signBit;\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'bigint')\n                throw new Error(`bigint: invalid value: ${value}`);\n            checkBounds(value, 8n * bLen, !!signed);\n            return value;\n        },\n    });\n};\n/** Unsigned 256-bit little-endian integer CoderType. */\nexport const U256LE = /* @__PURE__ */ bigint(32, true);\n/** Unsigned 256-bit big-endian integer CoderType. */\nexport const U256BE = /* @__PURE__ */ bigint(32, false);\n/** Signed 256-bit little-endian integer CoderType. */\nexport const I256LE = /* @__PURE__ */ bigint(32, true, true);\n/** Signed 256-bit big-endian integer CoderType. */\nexport const I256BE = /* @__PURE__ */ bigint(32, false, true);\n/** Unsigned 128-bit little-endian integer CoderType. */\nexport const U128LE = /* @__PURE__ */ bigint(16, true);\n/** Unsigned 128-bit big-endian integer CoderType. */\nexport const U128BE = /* @__PURE__ */ bigint(16, false);\n/** Signed 128-bit little-endian integer CoderType. */\nexport const I128LE = /* @__PURE__ */ bigint(16, true, true);\n/** Signed 128-bit big-endian integer CoderType. */\nexport const I128BE = /* @__PURE__ */ bigint(16, false, true);\n/** Unsigned 64-bit little-endian integer CoderType. */\nexport const U64LE = /* @__PURE__ */ bigint(8, true);\n/** Unsigned 64-bit big-endian integer CoderType. */\nexport const U64BE = /* @__PURE__ */ bigint(8, false);\n/** Signed 64-bit little-endian integer CoderType. */\nexport const I64LE = /* @__PURE__ */ bigint(8, true, true);\n/** Signed 64-bit big-endian integer CoderType. */\nexport const I64BE = /* @__PURE__ */ bigint(8, false, true);\n/**\n * CoderType for working with numbber values (up to 6 bytes/48 bits).\n * Unsized int values should be wrapped in a container (e.g., bytes or string).\n *\n * `0 = new Uint8Array([])`\n *\n * `1 = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the number in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the number is signed.\n * @param sized - Whether the number should have a fixed size.\n * @returns CoderType representing the number value.\n * @example\n * const uint64BE = P.bigint(8, false, true); // Define a CoderType for a 64-bit unsigned big-endian integer\n */\nexport const int = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`int/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`int/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`int/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`int/sized: expected boolean, got ${typeof sized}`);\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits): use bigints instead');\n    return apply(bigint(size, le, signed, sized), coders.numberBigint);\n};\nconst view = (len, opts) => wrap({\n    size: len,\n    encodeStream: (w, value) => w.writeView(len, (view) => opts.write(view, value)),\n    decodeStream: (r) => r.readView(len, opts.read),\n    validate: (value) => {\n        if (typeof value !== 'number')\n            throw new Error(`viewCoder: expected number, got ${typeof value}`);\n        if (opts.validate)\n            opts.validate(value);\n        return value;\n    },\n});\nconst intView = (len, signed, opts) => {\n    const bits = len * 8;\n    const signBit = 2 ** (bits - 1);\n    // Inlined checkBounds for integer\n    const validateSigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`sintView: value is not safe integer: ${value}`);\n        if (value < -signBit || value >= signBit) {\n            throw new Error(`sintView: value out of bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n        }\n    };\n    const maxVal = 2 ** bits;\n    const validateUnsigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`uintView: value is not safe integer: ${value}`);\n        if (0 > value || value >= maxVal) {\n            throw new Error(`uintView: value out of bounds. Expected 0 <= ${value} < ${maxVal}`);\n        }\n    };\n    return view(len, {\n        write: opts.write,\n        read: opts.read,\n        validate: signed ? validateSigned : validateUnsigned,\n    });\n};\n/** Unsigned 32-bit little-endian integer CoderType. */\nexport const U32LE = /* @__PURE__ */ intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, true),\n    write: (view, value) => view.setUint32(0, value, true),\n});\n/** Unsigned 32-bit big-endian integer CoderType. */\nexport const U32BE = /* @__PURE__ */ intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, false),\n    write: (view, value) => view.setUint32(0, value, false),\n});\n/** Signed 32-bit little-endian integer CoderType. */\nexport const I32LE = /* @__PURE__ */ intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, true),\n    write: (view, value) => view.setInt32(0, value, true),\n});\n/** Signed 32-bit big-endian integer CoderType. */\nexport const I32BE = /* @__PURE__ */ intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, false),\n    write: (view, value) => view.setInt32(0, value, false),\n});\n/** Unsigned 16-bit little-endian integer CoderType. */\nexport const U16LE = /* @__PURE__ */ intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, true),\n    write: (view, value) => view.setUint16(0, value, true),\n});\n/** Unsigned 16-bit big-endian integer CoderType. */\nexport const U16BE = /* @__PURE__ */ intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, false),\n    write: (view, value) => view.setUint16(0, value, false),\n});\n/** Signed 16-bit little-endian integer CoderType. */\nexport const I16LE = /* @__PURE__ */ intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, true),\n    write: (view, value) => view.setInt16(0, value, true),\n});\n/** Signed 16-bit big-endian integer CoderType. */\nexport const I16BE = /* @__PURE__ */ intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, false),\n    write: (view, value) => view.setInt16(0, value, false),\n});\n/** Unsigned 8-bit integer CoderType. */\nexport const U8 = /* @__PURE__ */ intView(1, false, {\n    read: (view, pos) => view.getUint8(pos),\n    write: (view, value) => view.setUint8(0, value),\n});\n/** Signed 8-bit integer CoderType. */\nexport const I8 = /* @__PURE__ */ intView(1, true, {\n    read: (view, pos) => view.getInt8(pos),\n    write: (view, value) => view.setInt8(0, value),\n});\n// Floats\nconst f32 = (le) => view(4, {\n    read: (view, pos) => view.getFloat32(pos, le),\n    write: (view, value) => view.setFloat32(0, value, le),\n    validate: (value) => {\n        if (Math.fround(value) !== value && !Number.isNaN(value))\n            throw new Error(`f32: wrong value=${value}`);\n    },\n});\nconst f64 = (le) => view(8, {\n    read: (view, pos) => view.getFloat64(pos, le),\n    write: (view, value) => view.setFloat64(0, value, le),\n});\n/** 32-bit big-endian floating point CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32BE = /* @__PURE__ */ f32(false);\n/** 32-bit little-endian floating point  CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32LE = /* @__PURE__ */ f32(true);\n/** A 64-bit big-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64BE = /* @__PURE__ */ f64(false);\n/** A 64-bit little-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64LE = /* @__PURE__ */ f64(true);\n/** Boolean CoderType. */\nexport const bool = /* @__PURE__ */ wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n    validate: (value) => {\n        if (typeof value !== 'boolean')\n            throw new Error(`bool: invalid value ${value}`);\n        return value;\n    },\n});\n/**\n * Bytes CoderType with a specified length and endianness.\n * The bytes can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - CoderType, number, Uint8Array (terminator) or null\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the bytes.\n * @example\n * // Dynamic size bytes (prefixed with P.U16BE number of bytes length)\n * const dynamicBytes = P.bytes(P.U16BE, false);\n * const fixedBytes = P.bytes(32, false); // Fixed size bytes\n * const unknownBytes = P.bytes(null, false); // Unknown size bytes, will parse until end of buffer\n * const zeroTerminatedBytes = P.bytes(new Uint8Array([0]), false); // Zero-terminated bytes\n */\nconst createBytes = (len, le = false) => {\n    if (typeof le !== 'boolean')\n        throw new Error(`bytes/le: expected boolean, got ${typeof le}`);\n    const _length = lengthCoder(len);\n    const _isb = isBytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            if (!_isb)\n                _length.encodeStream(w, value.length);\n            w.bytes(le ? swapEndianness(value) : value);\n            if (_isb)\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let bytes;\n            if (_isb) {\n                const tPos = r.find(len);\n                if (!tPos)\n                    throw r.err(`bytes: cannot find terminator`);\n                bytes = r.bytes(tPos - r.pos);\n                r.bytes(len.length);\n            }\n            else {\n                bytes = r.bytes(len === null ? r.leftBytes : _length.decodeStream(r));\n            }\n            return le ? swapEndianness(bytes) : bytes;\n        },\n        validate: (value) => {\n            if (!isBytes(value))\n                throw new Error(`bytes: invalid value ${value}`);\n            return value;\n        },\n    });\n};\nexport { createBytes as bytes, createHex as hex };\n/**\n * Prefix-encoded value using a length prefix and an inner CoderType.\n * The prefix can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for the actual value to be prefix-encoded.\n * @returns CoderType representing the prefix-encoded value.\n * @example\n * const dynamicPrefix = P.prefix(P.U16BE, P.bytes(null)); // Dynamic size prefix (prefixed with P.U16BE number of bytes length)\n * const fixedPrefix = P.prefix(10, P.bytes(null)); // Fixed size prefix (always 10 bytes)\n */\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    return apply(createBytes(len), reverse(inner));\n}\n/**\n * String CoderType with a specified length and endianness.\n * The string can be:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the string.\n * @example\n * const dynamicString = P.string(P.U16BE, false); // Dynamic size string (prefixed with P.U16BE number of string length)\n * const fixedString = P.string(10, false); // Fixed size string\n * const unknownString = P.string(null, false); // Unknown size string, will parse until end of buffer\n * const nullTerminatedString = P.cstring; // NUL-terminated string\n * const _cstring = P.string(new Uint8Array([0])); // Same thing\n */\nexport const string = (len, le = false) => validate(apply(createBytes(len, le), utf8), (value) => {\n    // TextEncoder/TextDecoder will fail on non-string, but we create more readable errors earlier\n    if (typeof value !== 'string')\n        throw new Error(`expected string, got ${typeof value}`);\n    return value;\n});\n/** NUL-terminated string CoderType. */\nexport const cstring = /* @__PURE__ */ string(NULL);\n/**\n * Hexadecimal string CoderType with a specified length, endianness, and optional 0x prefix.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @param withZero - Whether to include the 0x prefix.\n * @returns CoderType representing the hexadecimal string.\n * @example\n * const dynamicHex = P.hex(P.U16BE, {isLE: false, with0x: true}); // Hex string with 0x prefix and U16BE length\n * const fixedHex = P.hex(32, {isLE: false, with0x: false}); // Fixed-length 32-byte hex string without 0x prefix\n */\nconst createHex = (len, options = { isLE: false, with0x: false }) => {\n    let inner = apply(createBytes(len, options.isLE), baseHex);\n    const prefix = options.with0x;\n    if (typeof prefix !== 'boolean')\n        throw new Error(`hex/with0x: expected boolean, got ${typeof prefix}`);\n    if (prefix) {\n        inner = apply(inner, {\n            encode: (value) => `0x${value}`,\n            decode: (value) => {\n                if (!value.startsWith('0x'))\n                    throw new Error('hex(with0x=true).encode input should start with 0x');\n                return value.slice(2);\n            },\n        });\n    }\n    return inner;\n};\n/**\n * Applies a base coder to a CoderType.\n * @param inner - The inner CoderType.\n * @param b - The base coder to apply.\n * @returns CoderType representing the transformed value.\n * @example\n * import { hex } from '@scure/base';\n * const hex = P.apply(P.bytes(32), hex); // will decode bytes into a hex string\n */\nexport function apply(inner, base) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    if (!isBaseCoder(base))\n        throw new Error(`apply: invalid base value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = base.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return base.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\n/**\n * Lazy CoderType that is evaluated at runtime.\n * @param fn - A function that returns the CoderType.\n * @returns CoderType representing the lazy value.\n * @example\n * type Tree = { name: string; children: Tree[] };\n * const tree = P.struct({\n *   name: P.cstring,\n *   children: P.array(\n *     P.U16BE,\n *     P.lazy((): P.CoderType<Tree> => tree)\n *   ),\n * });\n */\nexport function lazy(fn) {\n    if (typeof fn !== 'function')\n        throw new Error(`lazy: expected function, got ${typeof fn}`);\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\n/**\n * Flag CoderType that encodes/decodes a boolean value based on the presence of a marker.\n * @param flagValue - Marker value.\n * @param xor - Whether to invert the flag behavior.\n * @returns CoderType representing the flag value.\n * @example\n * const flag = P.flag(new Uint8Array([0x01, 0x02])); // Encodes true as u8a([0x01, 0x02]), false as u8a([])\n * const flagXor = P.flag(new Uint8Array([0x01, 0x02]), true); // Encodes true as u8a([]), false as u8a([0x01, 0x02])\n * // Conditional encoding with flagged\n * const s = P.struct({ f: P.flag(new Uint8Array([0x0, 0x1])), f2: P.flagged('f', P.U32BE) });\n */\nexport const flag = (flagValue, xor = false) => {\n    if (!isBytes(flagValue))\n        throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof flagValue}`);\n    if (typeof xor !== 'boolean')\n        throw new Error(`flag/xor: expected boolean, got ${typeof xor}`);\n    return wrap({\n        size: flagValue.length,\n        encodeStream: (w, value) => {\n            if (!!value !== xor)\n                w.bytes(flagValue);\n        },\n        decodeStream: (r) => {\n            let hasFlag = r.leftBytes >= flagValue.length;\n            if (hasFlag) {\n                hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n                // Found flag, advance cursor position\n                if (hasFlag)\n                    r.bytes(flagValue.length);\n            }\n            return hasFlag !== xor; // hasFlag ^ xor\n        },\n        validate: (value) => {\n            if (value !== undefined && typeof value !== 'boolean')\n                throw new Error(`flag: expected boolean value or undefined, got ${typeof value}`);\n            return value;\n        },\n    });\n};\n/**\n * Conditional CoderType that encodes/decodes a value only if a flag is present.\n * @param path - Path to the flag value or a CoderType for the flag.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the conditional value.\n * @example\n * const s = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE)\n * });\n *\n * @example\n * const s2 = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE, 123)\n * });\n */\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    if (typeof path !== 'string' && !isCoder(inner))\n        throw new Error(`flagged: wrong path=${path}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (Path.resolve(w.stack, path))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = !!Path.resolve(r.stack, path);\n            else\n                hasFlag = path.decodeStream(r);\n            // If there is a flag -- decode and return value\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Optional CoderType that encodes/decodes a value based on a flag.\n * @param flag - CoderType for the flag value.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the optional value.\n * @example\n * // Will decode into P.U32BE only if flag present\n * const optional = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE);\n *\n * @example\n * // If no flag present, will decode into default value\n * const optionalWithDefault = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE, 123);\n */\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Magic value CoderType that encodes/decodes a constant value.\n * This can be used to check for a specific magic value or sequence of bytes at the beginning of a data structure.\n * @param inner - Inner CoderType for the value.\n * @param constant - Constant value.\n * @param check - Whether to check the decoded value against the constant.\n * @returns CoderType representing the magic value.\n * @example\n * // Always encodes constant as bytes using inner CoderType, throws if encoded value is not present\n * const magicU8 = P.magic(P.U8, 0x42);\n */\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`magic: invalid inner value ${inner}`);\n    if (typeof check !== 'boolean')\n        throw new Error(`magic: expected boolean, got ${typeof check}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, _value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n        validate: (value) => {\n            if (value !== undefined)\n                throw new Error(`magic: wrong value=${typeof value}`);\n            return value;\n        },\n    });\n}\n/**\n * Magic bytes CoderType that encodes/decodes a constant byte array or string.\n * @param constant - Constant byte array or string.\n * @returns CoderType representing the magic bytes.\n * @example\n * // Always encodes undefined into byte representation of string 'MAGIC'\n * const magicBytes = P.magicBytes('MAGIC');\n */\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n    return magic(createBytes(c.length), c);\n};\n/**\n * Creates a CoderType for a constant value. The function enforces this value during encoding,\n * ensuring it matches the provided constant. During decoding, it always returns the constant value.\n * The actual value is not written to or read from any byte stream; it's used only for validation.\n *\n * @param c - Constant value.\n * @returns CoderType representing the constant value.\n * @example\n * // Always return 123 on decode, throws on encoding anything other than 123\n * const constantU8 = P.constant(123);\n */\nexport function constant(c) {\n    return wrap({\n        encodeStream: (_w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (_r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (const f of fields) {\n        if (f.size === undefined)\n            return;\n        if (!isNum(f.size))\n            throw new Error(`sizeof: wrong element size=${size}`);\n        size += f.size;\n    }\n    return size;\n}\n/**\n * Structure of composable primitives (C/Rust struct)\n * @param fields - Object mapping field names to CoderTypes.\n * @returns CoderType representing the structure.\n * @example\n * // Define a structure with a 32-bit big-endian unsigned integer, a string, and a nested structure\n * const myStruct = P.struct({\n *   id: P.U32BE,\n *   name: P.string(P.U8),\n *   nested: P.struct({\n *     flag: P.bool,\n *     value: P.I16LE\n *   })\n * });\n */\nexport function struct(fields) {\n    if (!isPlainObject(fields))\n        throw new Error(`struct: expected plain object, got ${fields}`);\n    for (const name in fields) {\n        if (!isCoder(fields[name]))\n            throw new Error(`struct: field ${name} is not CoderType`);\n    }\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            w.pushObj(value, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => fields[name].encodeStream(w, value[name]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = {};\n            r.pushObj(res, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => (res[name] = fields[name].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'object' || value === null)\n                throw new Error(`struct: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tuple (unnamed structure) of CoderTypes. Same as struct but with unnamed fields.\n * @param fields - Array of CoderTypes.\n * @returns CoderType representing the tuple.\n * @example\n * const myTuple = P.tuple([P.U8, P.U16LE, P.string(P.U8)]);\n */\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    for (let i = 0; i < fields.length; i++) {\n        if (!isCoder(fields[i]))\n            throw new Error(`tuple: field ${i} is not CoderType`);\n    }\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            // TODO: fix types\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.pushObj(value, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => fields[i].encodeStream(w, value[i]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => res.push(fields[i].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`tuple: invalid value ${value}`);\n            if (value.length !== fields.length)\n                throw new Error(`tuple: wrong length=${value.length}, expected ${fields.length}`);\n            return value;\n        },\n    });\n}\n/**\n * Array of items (inner type) with a specified length.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for encoding/decoding each array item.\n * @returns CoderType representing the array.\n * @example\n * const a1 = P.array(P.U16BE, child); // Dynamic size array (prefixed with P.U16BE number of array length)\n * const a2 = P.array(4, child); // Fixed size array\n * const a3 = P.array(null, child); // Unknown size array, will parse until end of buffer\n * const a4 = P.array(new Uint8Array([0]), child); // zero-terminated array (NOTE: terminator can be any buffer)\n */\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    // By construction length is inside array (otherwise there will be various incorrect stack states)\n    // But forcing users always write '..' seems like bad idea. Also, breaking change.\n    const _length = lengthCoder(typeof len === 'string' ? `../${len}` : len);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            _w.pushObj(value, (fieldFn) => {\n                if (!isBytes(len))\n                    _length.encodeStream(w, value.length);\n                for (let i = 0; i < value.length; i++) {\n                    fieldFn(`${i}`, () => {\n                        const elm = value[i];\n                        const startPos = w.pos;\n                        inner.encodeStream(w, elm);\n                        if (isBytes(len)) {\n                            // Terminator is bigger than elm size, so skip\n                            if (len.length > _w.pos - startPos)\n                                return;\n                            const data = _w.finish(false).subarray(startPos, _w.pos);\n                            // There is still possible case when multiple elements create terminator,\n                            // but it is hard to catch here, will be very slow\n                            if (equalBytes(data.subarray(0, len.length), len))\n                                throw _w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                        }\n                    });\n                }\n            });\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                if (len === null) {\n                    for (let i = 0; !r.isEnd(); i++) {\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                        if (inner.size && r.leftBytes < inner.size)\n                            break;\n                    }\n                }\n                else if (isBytes(len)) {\n                    for (let i = 0;; i++) {\n                        if (equalBytes(r.bytes(len.length, true), len)) {\n                            // Advance cursor position if terminator found\n                            r.bytes(len.length);\n                            break;\n                        }\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                    }\n                }\n                else {\n                    let length;\n                    fieldFn('arrayLen', () => (length = _length.decodeStream(r)));\n                    for (let i = 0; i < length; i++)\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                }\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`array: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values and string representations.\n * @param inner - CoderType for encoded values.\n * @param variants - Object mapping string representations to encoded values.\n * @returns CoderType representing the mapping.\n * @example\n * // Map between numbers and strings\n * const numberMap = P.map(P.U8, {\n *   'one': 1,\n *   'two': 2,\n *   'three': 3\n * });\n *\n * // Map between byte arrays and strings\n * const byteMap = P.map(P.bytes(2, false), {\n *   'ab': Uint8Array.from([0x61, 0x62]),\n *   'cd': Uint8Array.from([0x63, 0x64])\n * });\n */\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    if (!isPlainObject(variants))\n        throw new Error(`map: variants should be plain object`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, variants[value]),\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string')\n                throw new Error(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw new Error(`Map: unknown variant: ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tagged union of CoderTypes, where the tag value determines which CoderType to use.\n * The decoded value will have the structure `{ TAG: number, data: ... }`.\n * @param tag - CoderType for the tag value.\n * @param variants - Object mapping tag values to CoderTypes.\n * @returns CoderType representing the tagged union.\n * @example\n * // Tagged union of array, string, and number\n * // Depending on the value of the first byte, it will be decoded as an array, string, or number.\n * const taggedUnion = P.tag(P.U8, {\n *   0x01: P.array(P.U16LE, P.U8),\n *   0x02: P.string(P.U8),\n *   0x03: P.U32BE\n * });\n *\n * const encoded = taggedUnion.encode({ TAG: 0x01, data: 'hello' }); // Encodes the string 'hello' with tag 0x01\n * const decoded = taggedUnion.decode(encoded); // Decodes the encoded value back to { TAG: 0x01, data: 'hello' }\n */\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`tag: variants should be plain object`);\n    for (const name in variants) {\n        if (!isCoder(variants[name]))\n            throw new Error(`tag: variant ${name} is not CoderType`);\n    }\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n        validate: (value) => {\n            const { TAG } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw new Error(`Tag: invalid tag ${TAG.toString()}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values, string representations, and CoderTypes using a tag CoderType.\n * @param tagCoder - CoderType for the tag value.\n * @param variants - Object mapping string representations to [tag value, CoderType] pairs.\n *  * @returns CoderType representing the mapping.\n * @example\n * const cborValue: P.CoderType<CborValue> = P.mappedTag(P.bits(3), {\n *   uint: [0, cborUint], // An unsigned integer in the range 0..264-1 inclusive.\n *   negint: [1, cborNegint], // A negative integer in the range -264..-1 inclusive\n *   bytes: [2, P.lazy(() => cborLength(P.bytes, cborValue))], // A byte string.\n *   string: [3, P.lazy(() => cborLength(P.string, cborValue))], // A text string (utf8)\n *   array: [4, cborArrLength(P.lazy(() => cborValue))], // An array of data items\n *   map: [5, P.lazy(() => cborArrLength(P.tuple([cborValue, cborValue])))], // A map of pairs of data items\n *   tag: [6, P.tuple([cborUint, P.lazy(() => cborValue)] as const)], // A tagged data item (\"tag\") whose tag number\n *   simple: [7, cborSimple], // Floating-point numbers and simple values, as well as the \"break\" stop code\n * });\n */\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`mappedTag: variants should be plain object`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        const v = variants[key];\n        mapValue[key] = v[0];\n        tagValue[key] = v[1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\n/**\n * Bitset of boolean values with optional padding.\n * @param names - An array of string names for the bitset values.\n * @param pad - Whether to pad the bitset to a multiple of 8 bits.\n * @returns CoderType representing the bitset.\n * @template Names\n * @example\n * const myBitset = P.bitset(['flag1', 'flag2', 'flag3', 'flag4'], true);\n */\nexport function bitset(names, pad = false) {\n    if (typeof pad !== 'boolean')\n        throw new Error(`bitset/pad: expected boolean, got ${typeof pad}`);\n    if (!Array.isArray(names))\n        throw new Error('bitset/names: expected array');\n    for (const name of names) {\n        if (typeof name !== 'string')\n            throw new Error('bitset/names: expected array of strings');\n    }\n    return wrap({\n        encodeStream: (w, value) => {\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            const out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n        validate: (value) => {\n            if (!isPlainObject(value))\n                throw new Error(`bitset: invalid value ${value}`);\n            for (const v of Object.values(value)) {\n                if (typeof v !== 'boolean')\n                    throw new Error('expected boolean');\n            }\n            return value;\n        },\n    });\n}\n/** Padding function which always returns zero */\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the left side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U32BE with a block size of 4 and zero padding\n * const paddedU32BE = P.padLeft(4, P.U32BE);\n *\n * // Pad a string with a block size of 16 and custom padding\n * const paddedString = P.padLeft(16, P.string(P.U8), (i) => i + 1);\n */\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padLeft: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft cannot have dynamic size');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the right side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U16BE with a block size of 2 and zero padding\n * const paddedU16BE = P.padRight(2, P.U16BE);\n *\n * // Pad a bytes with a block size of 8 and custom padding\n * const paddedBytes = P.padRight(8, P.bytes(null), (i) => i + 1);\n */\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padRight: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const pos = _w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, _w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\n1;\n/**\n * Pointer to a value using a pointer CoderType and an inner CoderType.\n * Pointers are scoped, and the next pointer in the dereference chain is offset by the previous one.\n * By default (if no 'allowMultipleReads' in ReaderOpts is set) is safe, since\n * same region of memory cannot be read multiple times.\n * @param ptr - CoderType for the pointer value.\n * @param inner - CoderType for encoding/decoding the pointed value.\n * @param sized - Whether the pointer should have a fixed size.\n * @returns CoderType representing the pointer to the value.\n * @example\n * const pointerToU8 = P.pointer(P.U16BE, P.U8); // Pointer to a single U8 value\n */\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`pointer/sized: expected boolean, got ${typeof sized}`);\n    if (!ptr.size)\n        throw new Error('unsized pointer');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const start = _w.pos;\n            ptr.encodeStream(w, 0);\n            _w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            r._enablePointers();\n            return inner.decodeStream(r.offsetReader(ptrVal));\n        },\n    });\n}\n// Internal methods for test purposes only\nexport const _TEST = { _bitset: Bitset, _Reader, _Writer, Path };\n//# sourceMappingURL=index.js.map", "import { ed25519 } from '@noble/curves/ed25519';\nimport { base58, base64, hex, utf8 } from '@scure/base';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as P from 'micro-packed';\nexport const PRECISION = 9;\nexport const Decimal = P.coders.decimal(PRECISION);\n// first bit -- terminator (1 -- continue, 0 -- last)\nexport const shortVec = P.wrap({\n    encodeStream: (w, value) => {\n        if (!value)\n            return w.byte(0);\n        for (; value; value >>= 7) {\n            w.bits(value > 0x7f ? 1 : 0, 1);\n            w.bits(value & 0x7f, 7);\n        }\n    },\n    decodeStream: (r) => {\n        let len = 0;\n        for (let pos = 0; !r.isEnd(); pos++) {\n            const last = !r.bits(1);\n            len |= r.bits(7) << (pos * 7);\n            if (last)\n                break;\n        }\n        return len;\n    },\n});\nconst rustString = P.string(P.padRight(8, P.U32LE, undefined));\nconst b58 = () => {\n    const inner = P.bytes(32);\n    return P.wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base58.decode(value)),\n        decodeStream: (r) => base58.encode(inner.decodeStream(r)),\n    });\n};\nconst pubKey = b58();\nexport const Message = P.struct({\n    requiredSignatures: P.U8,\n    readSigned: P.U8,\n    readUnsigned: P.U8,\n    keys: P.array(shortVec, pubKey),\n    blockhash: pubKey,\n    instructions: P.array(shortVec, P.struct({ programIdx: P.U8, keys: P.array(shortVec, P.U8), data: P.bytes(shortVec) })),\n});\nexport function validateAddress(address) {\n    const pubkey = base58.decode(address);\n    if (pubkey.length !== 32)\n        throw new Error('Invalid Solana address');\n}\nconst keyParams = (i, req, signed, unsigned, total) => ({\n    sign: i < req ? true : false,\n    write: i < req - signed || (i >= req && i < total - unsigned) ? true : false,\n});\nexport const TransactionRaw = P.struct({\n    signatures: P.array(shortVec, P.bytes(64)),\n    msg: Message,\n});\n// Keys position is implementation specific, Transaction.encode(Transaction.decode(tx)) not neccessary equals to tx,\n// since there is information loss for readability purposes. Use TransactionRaw in case you need exactly same encoding\nexport const Transaction = P.wrap({\n    encodeStream: (w, value) => {\n        const { msg, signatures } = value;\n        const accounts = {};\n        const add = (address, sign, write) => {\n            let acc = accounts[address] || (accounts[address] = { sign: false, write: false });\n            acc.write || (acc.write = write);\n            acc.sign || (acc.sign = sign);\n        };\n        add(msg.feePayer, true, true);\n        for (let i of msg.instructions)\n            for (let k of i.keys)\n                add(k.address, k.sign, k.write);\n        // Same loop as above, but cannot be merged since it will change implementation specific key positions inside transaction.\n        // This doesn't invalidate transaction, but can be used for fingerprinting.\n        for (let i of msg.instructions)\n            add(i.program, false, false);\n        const _keys = Object.keys(accounts);\n        // [feePayer, ...sign+write, ...sign+read, ...nosign+write, ...nosign+read]\n        const keys = [\n            msg.feePayer,\n            ..._keys.filter((i) => accounts[i].sign && accounts[i].write && i !== msg.feePayer),\n            ..._keys.filter((i) => accounts[i].sign && !accounts[i].write),\n            ..._keys.filter((i) => !accounts[i].sign && accounts[i].write),\n            ..._keys.filter((i) => !accounts[i].sign && !accounts[i].write),\n        ];\n        let requiredSignatures = 0;\n        let readSigned = 0;\n        let readUnsigned = 0;\n        for (let k of keys) {\n            if (accounts[k].sign)\n                requiredSignatures++;\n            if (accounts[k].write)\n                continue;\n            if (accounts[k].sign)\n                readSigned++;\n            else\n                readUnsigned++;\n        }\n        TransactionRaw.encodeStream(w, {\n            signatures: keys\n                .filter((i) => accounts[i].sign)\n                .map((i) => signatures[i] || new Uint8Array(64)),\n            msg: {\n                requiredSignatures,\n                readSigned,\n                readUnsigned,\n                keys,\n                // indexOf potentially can be slow, but for most tx there will be ~3-5 keys, so doesn't matter much\n                instructions: msg.instructions.map((i) => ({\n                    programIdx: keys.indexOf(i.program),\n                    keys: i.keys.map((j) => keys.indexOf(j.address)),\n                    data: i.data,\n                })),\n                blockhash: msg.blockhash,\n            },\n        });\n    },\n    decodeStream: (r) => {\n        const { signatures, msg } = TransactionRaw.decodeStream(r);\n        if (signatures.length !== msg.requiredSignatures)\n            throw new Error('SOL.tx: wrong signatures length');\n        if (msg.keys.length < signatures.length)\n            throw new Error('SOL.tx: invalid keys length');\n        const sigs = {};\n        for (let i = 0; i < signatures.length; i++)\n            sigs[msg.keys[i]] = signatures[i];\n        let accounts = [];\n        for (let i = 0; i < msg.keys.length; i++) {\n            accounts.push({\n                address: msg.keys[i],\n                ...keyParams(i, msg.requiredSignatures, msg.readSigned, msg.readUnsigned, msg.keys.length),\n            });\n        }\n        if (!accounts.length)\n            throw new Error('SOL.tx: empty accounts array');\n        return {\n            msg: {\n                feePayer: accounts[0].address,\n                blockhash: msg.blockhash,\n                instructions: msg.instructions.map((i) => ({\n                    program: accounts[i.programIdx].address,\n                    keys: i.keys.map((j) => accounts[j]),\n                    data: i.data,\n                })),\n            },\n            signatures: sigs,\n        };\n    },\n});\nconst registry = {};\n// Basic ABI thing. There is IDL which is kinda ABI, but not official and system accounts doesn't have offical types for it.\n// Later we can add support to conversion IDL -> defineProgram\nexport function defineProgram(address, tagType, methods) {\n    if (registry[address])\n        throw new Error('SOL: program for this address already defined');\n    const variants = P.map(tagType, Object.keys(methods).reduce((acc, k, i) => ({ ...acc, [k]: i }), {}));\n    const coders = Object.keys(methods).reduce((acc, k) => ({ ...acc, [k]: methods[k].coder }), {});\n    const mainCoder = P.tag(variants, coders);\n    registry[address] = (instr, tl) => {\n        if (instr.program !== address)\n            throw new Error('SOL.parseInstruction: Wrong instruction program address');\n        const { TAG, data } = mainCoder.decode(instr.data);\n        // Should be close to node parser (https://github.com/solana-labs/solana/tree/master/transaction-status/src)\n        const res = { type: TAG, info: data };\n        const keys = Object.keys(methods[TAG].keys);\n        if (keys.length !== instr.keys.length)\n            throw new Error('SOL.parseInstruction: Keys length mismatch');\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            if (methods[TAG].keys[key].address) {\n                if (methods[TAG].keys[key].address !== instr.keys[i].address) {\n                    throw new Error(`SOL.parseInstruction(${address}/${TAG}): Invalid constant address for key exp=${methods[TAG].keys[key].address} got=${instr.keys[i].address}`);\n                }\n                continue;\n            }\n            res.info[keys[i]] = instr.keys[i].address;\n        }\n        if (methods[TAG].hint)\n            res.hint = methods[TAG].hint(data, tl);\n        return res;\n    };\n    const program = {};\n    for (const m in methods) {\n        program[m] = (data) => ({\n            program: address,\n            data: mainCoder.encode({ TAG: m, data }),\n            keys: Object.keys(methods[m].keys).map((name) => {\n                let { sign, write, address } = methods[m].keys[name];\n                address || (address = data[name]);\n                validateAddress(address);\n                return { address, sign, write };\n            }),\n        });\n    }\n    return program;\n}\nexport function parseInstruction(instr, tl) {\n    if (!registry[instr.program])\n        return;\n    return registry[instr.program](instr, tl);\n}\nexport const SYS_RECENT_BLOCKHASHES = 'SysvarRecentB1ockHashes11111111111111111111';\nexport const SYS_RENT = 'SysvarRent111111111111111111111111111111111';\nexport const SYS_PROGRAM = '11111111111111111111111111111111';\nexport const sys = defineProgram(SYS_PROGRAM, P.U32LE, {\n    createAccount: {\n        coder: P.struct({ lamports: P.U64LE, space: P.U64LE, owner: pubKey }),\n        keys: {\n            source: { sign: true, write: true },\n            newAccount: { sign: true, write: true },\n        },\n        hint: (o) => `Create new account=${o.newAccount} with balance of ${Decimal.encode(o.lamports)} and owner program ${o.owner}, using funding account ${o.source}`,\n    },\n    assign: {\n        coder: P.struct({ owner: pubKey }),\n        keys: { account: { sign: true, write: true } },\n        hint: (o) => `Assign account=${o.account} to owner program=${o.owner}`,\n    },\n    transfer: {\n        coder: P.struct({ lamports: P.U64LE }),\n        keys: { source: { sign: true, write: true }, destination: { sign: false, write: true } },\n        hint: (o) => `Transfer ${Decimal.encode(o.lamports)} SOL from ${o.source} to ${o.destination}`,\n    },\n    createAccountWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            lamports: P.U64LE,\n            space: P.U64LE,\n            owner: pubKey,\n        }),\n        keys: {\n            source: { sign: true, write: true },\n            newAccount: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    advanceNonce: {\n        coder: P.struct({}),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Consume nonce in nonce account=${o.nonceAccount} (owner: ${o.nonceAuthority})`,\n    },\n    withdrawFromNonce: {\n        coder: P.struct({ lamports: P.U64LE }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            destination: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Withdraw ${Decimal.encode(o.lamports)} SOL from nonce account=${o.nonceAccount} (owner: ${o.nonceAuthority}) to ${o.destination}`,\n    },\n    initializeNonce: {\n        coder: P.struct({ nonceAuthority: pubKey }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n    },\n    authorizeNonce: {\n        coder: P.struct({ newAuthorized: pubKey }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Change owner of nonce account=${o.nonceAccount} from ${o.nonceAuthority} to ${o.newAuthorized}`,\n    },\n    allocate: {\n        coder: P.struct({ space: P.U64LE }),\n        keys: {\n            account: { sign: true, write: true },\n        },\n    },\n    allocateWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            space: P.U64LE,\n            owner: pubKey,\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    assignWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            owner: pubKey,\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    transferWithSeed: {\n        coder: P.struct({\n            lamports: P.U64LE,\n            sourceSeed: rustString,\n            sourceOwner: pubKey,\n        }),\n        keys: {\n            source: { sign: false, write: true },\n            sourceBase: { sign: true, write: false },\n            destination: { sign: false, write: true },\n        },\n    },\n});\n// Type tests\nconst assertType = (_value) => { };\nassertType(sys.transfer);\nassertType(sys.advanceNonce);\nconst authorityType = P.map(P.U8, {\n    MintTokens: 0,\n    FreezeAccount: 1,\n    AccountOwner: 2,\n    CloseAccount: 3,\n});\nconst tokenName = (address, tl) => tl[address]?.symbol || address;\nexport const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';\nexport const token = defineProgram(TOKEN_PROGRAM, P.U8, {\n    initializeMint: {\n        coder: P.struct({\n            decimals: P.U8,\n            mintAuthority: pubKey,\n            freezeAuthority: P.optional(P.bool, pubKey, '11111111111111111111111111111111'),\n        }),\n        keys: {\n            mint: { sign: false, write: true },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n    },\n    initializeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            owner: { sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize token account=${o.account} with owner=${o.owner} token=${tokenName(o.mint, tl)}`,\n    },\n    // TODO: multisig support?\n    initializeMultisig: {\n        coder: P.struct({ m: P.U8 }),\n        keys: {\n            account: { sign: false, write: true },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, _) => `Initialize multi-sig token account=${o.account} with signatures=${o.m}`,\n    },\n    transfer: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            source: { sign: false, write: true },\n            destination: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Transfer ${o.amount} from token account=${o.source} of owner=${o.owner} to ${o.destination}`,\n    },\n    approve: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            account: { sign: false, write: true },\n            delegate: { sign: false, write: false },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Approve authority of delegate=${o.delegate} over tokens on account=${o.account} on behalf of owner=${o.owner}`,\n    },\n    revoke: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Revoke delegate's authority over tokens on account=${o.account} on behalf of owner=${o.owner}`,\n    },\n    setAuthority: {\n        coder: P.struct({\n            authorityType,\n            newAuthority: P.optional(P.bool, pubKey, '11111111111111111111111111111111'),\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            currentAuthority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Sets a new authority=${o.newAuthority} of a mint or account=${o.account}. Current authority=${o.currentAuthority}. Authority Type: ${o.authorityType}`,\n    },\n    mintTo: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            mint: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n    },\n    burn: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Burn ${o.amount} tokens from account=${o.account} of owner=${o.owner} mint=${o.mint}`,\n    },\n    closeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Close token account=${o.account} of owner=${o.owner}, transferring all its SOL to destionation account=${o.dest}`,\n    },\n    freezeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Freeze token account=${o.account} of mint=${o.mint} using freeze_authority=${o.authority}`,\n    },\n    thawAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Thaw a frozne token account=${o.account} of mint=${o.mint} using freeze_authority=${o.authority}`,\n    },\n    transferChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            source: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            destination: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Transfer ${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)} from token account=${o.source} of owner=${o.owner} to ${o.destination}`,\n    },\n    approveChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            source: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            delegate: { sign: false, write: false },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Approve delgate=${o.delegate} authority on behalf account=${o.source} owner=${o.owner} over ${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}`,\n    },\n    mintToChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            mint: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Mint new tokens (${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}) to account=${o.dest} using authority=${o.authority}`,\n    },\n    burnChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            mint: { sign: false, write: true },\n            account: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Burn tokens (${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}) on account=${o.account} of owner=${o.owner}`,\n    },\n    initializeAccount2: {\n        coder: P.struct({ owner: pubKey }),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize token account=${o.account} with owner=${o.owner} token=${tokenName(o.mint, tl)}`,\n    },\n    syncNative: {\n        coder: P.struct({}),\n        keys: { nativeAccount: { sign: false, write: true } },\n        hint: (o) => `Sync SOL balance for wrapped account ${o.nativeAccount}`,\n    },\n});\nexport const NonceAccount = P.struct({\n    version: P.U32LE,\n    state: P.U32LE,\n    authority: pubKey,\n    nonce: pubKey,\n    lamportPerSignature: P.U64LE,\n});\nfunction mod(a, b = ed25519.CURVE.Fp.ORDER) {\n    const res = a % b;\n    return res >= 0n ? res : b + res;\n}\nexport function isOnCurve(bytes) {\n    if (typeof bytes === 'string')\n        bytes = base58.decode(bytes);\n    try {\n        // noble-ed25519 checks that publicKey is < P, but dalek (ed25519-dalek.CompressedEdwardsY) is not, so we do modulo here.\n        // first bit in last byte is x oddity flag\n        const last = bytes[31];\n        const normedLast = last & ~0x80;\n        const normed = Uint8Array.from(Array.from(bytes.slice(0, 31)).concat(normedLast));\n        const modBytes = P.U256LE.encode(mod(P.U256LE.decode(normed)));\n        if ((last & 0x80) !== 0)\n            modBytes[31] |= 0x80;\n        ed25519.ExtendedPoint.fromHex(modBytes);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexport function programAddress(program, ...seeds) {\n    let seed = P.utils.concatBytes(...seeds);\n    const noncePos = seed.length;\n    seed = P.utils.concatBytes(seed, new Uint8Array([0]), base58.decode(program), utf8.decode('ProgramDerivedAddress'));\n    for (let i = 255; i >= 0; i--) {\n        seed[noncePos] = i;\n        const hash = sha256(seed);\n        if (isOnCurve(hash))\n            continue;\n        return base58.encode(hash);\n    }\n    throw new Error('SOL.programAddress: nonce exhausted, cannot find program address');\n}\nexport const ASSOCIATED_TOKEN_PROGRAM = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL';\nexport const associatedToken = defineProgram(ASSOCIATED_TOKEN_PROGRAM, P.constant(0), {\n    create: {\n        coder: P.struct({}),\n        keys: {\n            source: { sign: true, write: true },\n            account: { sign: false, write: true },\n            wallet: { sign: false, write: false },\n            mint: { sign: false, write: false },\n            _sys: { address: SYS_PROGRAM, sign: false, write: false },\n            _token: { address: TOKEN_PROGRAM, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize associated token account=${o.account} with owner=${o.wallet} for token=${tokenName(o.mint, tl)}, payed by ${o.source}`,\n    },\n});\nexport function tokenAddress(mint, owner, allowOffCurveOwner = false) {\n    if (!allowOffCurveOwner && !isOnCurve(owner))\n        throw new Error('Owner is off curve (cannot sign)');\n    return programAddress(ASSOCIATED_TOKEN_PROGRAM, ...[owner, TOKEN_PROGRAM, mint].map((i) => base58.decode(i)));\n}\n// https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json\nexport const COMMON_TOKENS = {\n    So11111111111111111111111111111111111111112: { decimals: 9, symbol: 'SOL' }, // Wrapped SOL\n    Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: { decimals: 6, symbol: 'USDT', price: 1 },\n    EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: { decimals: 6, symbol: 'USDC', price: 1 },\n};\nexport function tokenFromSymbol(symbol, tokens = COMMON_TOKENS) {\n    for (let c in tokens)\n        if (tokens[c].symbol === symbol)\n            return { ...tokens[c], contract: c };\n    return;\n}\n// [1, 0, 0, 0] -> true\n// [0, 0, 0, 0] -> false\nconst U32LEBOOL = P.padRight(4, P.bool, () => 0);\nexport const TokenAccount = P.struct({\n    mint: pubKey,\n    owner: pubKey,\n    amount: P.U64LE,\n    delegate: P.optional(U32LEBOOL, pubKey, '11111111111111111111111111111111'),\n    state: P.map(P.U8, {\n        uninitialized: 0,\n        initialized: 1,\n        frozen: 2,\n    }),\n    isNative: P.optional(U32LEBOOL, P.U64LE, 0n),\n    delegateAmount: P.U64LE,\n    closeAuthority: P.optional(U32LEBOOL, pubKey, '11111111111111111111111111111111'),\n});\nexport const swapProgram = 'SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8';\nexport function verifyTx(tx) {\n    if (typeof tx === 'string')\n        tx = base64.decode(tx);\n    if (tx.length > 1280 - 40 - 8)\n        throw new Error('sol: transaction too big');\n    const parsed = Transaction.decode(tx);\n    const raw = TransactionRaw.decode(tx);\n    const msg = Message.encode(TransactionRaw.decode(tx).msg);\n    for (let i = 0; i < raw.msg.requiredSignatures; i++) {\n        const address = raw.msg.keys[i];\n        const pubKey = base58.decode(address);\n        const sig = parsed.signatures[address];\n        if (!ed25519.verify(sig, msg, pubKey))\n            throw new Error(`sol: invalid signature sig=${sig} msg=${msg}`);\n    }\n}\nexport function getPublicKey(privateKey) {\n    return ed25519.getPublicKey(privateKey);\n}\nexport function getAddress(privateKey) {\n    const publicKey = getPublicKey(privateKey);\n    return base58.encode(publicKey);\n}\nexport function getAddressFromPublicKey(publicKey) {\n    return base58.encode(publicKey);\n}\nexport function formatPrivate(privateKey, format = 'base58') {\n    const publicKey = getPublicKey(privateKey);\n    const fullKey = P.utils.concatBytes(privateKey, publicKey);\n    switch (format) {\n        case 'base58': {\n            return base58.encode(fullKey);\n        }\n        case 'hex': {\n            return hex.encode(fullKey);\n        }\n        case 'array': {\n            return Array.from(fullKey);\n        }\n        default: {\n            throw new Error('sol: unsupported format');\n        }\n    }\n}\nexport function createTxComplex(address, instructions, blockhash) {\n    if (!instructions.length)\n        throw new Error('SOLPublic: empty instructions array');\n    return base64.encode(Transaction.encode({\n        msg: { feePayer: address, blockhash, instructions },\n        signatures: {},\n    }));\n}\nexport function createTx(from, to, amount, _fee, blockhash) {\n    const amountNum = Decimal.decode(amount);\n    return createTxComplex(from, [sys.transfer({ source: from, destination: to, lamports: amountNum })], blockhash);\n}\nexport function signTx(privateKey, data) {\n    if (typeof data === 'string')\n        data = base64.decode(data);\n    const address = getAddress(privateKey);\n    const raw = TransactionRaw.decode(data);\n    const reqSignatures = raw.msg.keys.slice(0, raw.msg.requiredSignatures);\n    if (!reqSignatures.filter((i) => i == address).length)\n        throw new Error(`SOLPrivate: tx doesn't require signature for address=${address}`);\n    const sig = ed25519.sign(Message.encode(raw.msg), privateKey);\n    for (let i = 0; i < reqSignatures.length; i++)\n        if (reqSignatures[i] === address)\n            raw.signatures[i] = sig;\n    // Base58 encoding for tx is deprecated\n    const tx = base64.encode(TransactionRaw.encode(raw));\n    // first signature is txHash\n    return [base58.encode(sig), tx];\n}\n//# sourceMappingURL=index.js.map", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n", "import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n", "import * as sol from \"micro-sol-signer\";\nimport bs58 from \"bs58\";\n\n// Re-export from micro-sol-signer\nexport * from \"micro-sol-signer\";\n\n// Export our custom utilities\nexport { Connection } from \"./connection\";\nexport * from \"./spl-token\";\n\n// Additional compatibility layer for easier migration\nexport class PublicKey {\n  private _publicKey: string;\n\n  constructor(value: string | Uint8Array | number[] | Buffer | PublicKey) {\n    if (value instanceof PublicKey) {\n      this._publicKey = value.toString();\n    } else if (typeof value === \"string\") {\n      this._publicKey = value;\n    } else if (\n      value instanceof Uint8Array ||\n      Array.isArray(value) ||\n      Buffer.isBuffer(value)\n    ) {\n      const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n      this._publicKey = bs58.encode(bytes);\n    } else {\n      throw new Error(\"Invalid public key input\");\n    }\n  }\n\n  toString(): string {\n    return this._publicKey;\n  }\n\n  toBytes(): Uint8Array {\n    return bs58.decode(this._publicKey);\n  }\n\n  toBuffer(): Buffer {\n    return Buffer.from(this.toBytes());\n  }\n\n  equals(other: PublicKey | string): boolean {\n    const otherKey = other instanceof PublicKey ? other.toString() : other;\n    return this._publicKey === otherKey;\n  }\n\n  toBase58(): string {\n    return this._publicKey;\n  }\n}\n\n// Transaction compatibility wrapper\nexport class Transaction {\n  private _transaction: any;\n  public signatures: Array<{\n    signature: Uint8Array | null;\n    publicKey: PublicKey;\n  }> = [];\n  public feePayer?: PublicKey;\n  public recentBlockhash?: string;\n  private _instructions: sol.Instruction[];\n\n  constructor() {\n    // We'll build instructions array and serialize using micro-sol-signer\n    this._instructions = [];\n  }\n\n  add(...instructions: sol.Instruction[]): Transaction {\n    this._instructions.push(...instructions);\n    return this;\n  }\n\n  static from(buffer: Uint8Array | Buffer | number[]): Transaction {\n    // Decode using micro-sol-signer\n    const bytes =\n      buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n    const decoded = sol.Transaction.decode(bytes);\n\n    // Create a new Transaction and populate it\n    const tx = new Transaction();\n    // Note: This would need proper mapping from decoded to our wrapper\n    // For now, storing the raw decoded transaction\n    tx._transaction = decoded;\n    return tx;\n  }\n\n  serialize(_options?: { requireAllSignatures?: boolean }): Buffer {\n    // Build transaction using micro-sol-signer\n    if (this._transaction) {\n      // If we have a decoded transaction, re-serialize it\n      return Buffer.from(sol.Transaction.encode(this._transaction));\n    }\n\n    // Build from instructions\n    if (!this.feePayer || !this.recentBlockhash) {\n      throw new Error(\"Transaction requires feePayer and recentBlockhash\");\n    }\n\n    const txHex = sol.createTxComplex(\n      this.feePayer.toString(),\n      this._instructions,\n      this.recentBlockhash,\n    );\n\n    return Buffer.from(txHex, \"hex\");\n  }\n\n  serializeMessage(): Buffer {\n    // Serialize just the message part\n    if (!this.feePayer || !this.recentBlockhash) {\n      throw new Error(\"Transaction requires feePayer and recentBlockhash\");\n    }\n\n    const txHex = sol.createTxComplex(\n      this.feePayer.toString(),\n      this._instructions,\n      this.recentBlockhash,\n    );\n\n    // Return the message part of the transaction\n    return Buffer.from(txHex, \"hex\");\n  }\n}\n\n// Versioned transaction support\nexport class VersionedTransaction {\n  constructor(\n    public message: any,\n    public signatures: Uint8Array[],\n  ) {}\n\n  static deserialize(serialized: Uint8Array): VersionedTransaction {\n    const decoded = sol.Transaction.decode(serialized);\n    // Map to VersionedTransaction format\n    return new VersionedTransaction(decoded, []);\n  }\n\n  serialize(): Uint8Array {\n    return sol.Transaction.encode(this.message);\n  }\n}\n", "import {\n  PublicKey,\n  Transaction,\n  VersionedTransaction,\n} from \"../../utils/solana\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\ninterface PhantomProvider {\n  isPhantom: boolean;\n  publicKey: PublicKey | null;\n  isConnected: boolean;\n  connect(opts?: { onlyIfTrusted: boolean }): Promise<{ publicKey: PublicKey }>;\n  disconnect(): Promise<void>;\n  signTransaction(\n    transaction: Transaction | VersionedTransaction,\n  ): Promise<Transaction | VersionedTransaction>;\n  signAllTransactions(\n    transactions: (Transaction | VersionedTransaction)[],\n  ): Promise<(Transaction | VersionedTransaction)[]>;\n  signAndSendTransaction(\n    transaction: Transaction | VersionedTransaction,\n    opts?: { skipPreflight?: boolean; maxRetries?: number },\n  ): Promise<{ signature: string }>;\n  signMessage(\n    message: Uint8Array,\n    display?: \"utf8\" | \"hex\",\n  ): Promise<{ signature: Uint8Array }>;\n  on(\n    event: \"connect\" | \"disconnect\" | \"accountChanged\",\n    handler: (args: unknown) => void,\n  ): void;\n  request(args: { method: string; params?: unknown }): Promise<unknown>;\n}\n\nexport class PhantomWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"phantom\";\n  readonly platform: ExternalPlatform = \"solana\";\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n\n  private getProvider(): PhantomProvider {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"Not ready\");\n    }\n\n    const provider = window.solana;\n\n    if (!provider?.isPhantom) {\n      throw new Error(\"Phantom is not available\");\n    }\n\n    return provider;\n  }\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.solana?.isPhantom;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: \"Unknown\",\n      name: \"Phantom\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Phantom is not available\");\n      }\n\n      const response = await this.getProvider().connect();\n      if (response.publicKey) {\n        this.account = response.publicKey.toString();\n        return { success: true, wallet: this.type, account: this.account };\n      }\n\n      throw new Error(\"No accounts found\");\n    } catch (error) {\n      console.error(`Error connecting to Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signMessage(message: string): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(\"Phantom is not connected\");\n      }\n\n      const encodedMessage = new TextEncoder().encode(message);\n      const result = await this.getProvider().signMessage(\n        encodedMessage,\n        \"utf8\",\n      );\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(`Error signing message with Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(\n    serailized_txn: Uint8Array,\n  ): Promise<ExternalWalletResponse<any>> {\n    if (!this.isAvailable() || !this.account) {\n      throw new Error(\"Phantom is not connected\");\n    }\n\n    try {\n      const txn = Transaction.from(serailized_txn);\n      const provider = this.getProvider();\n      const result = await provider.signAndSendTransaction(txn);\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(_chainId: string): Promise<boolean> {\n    console.warn(\"Chain switching not supported for Phantom\");\n    return false;\n  }\n\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(\"Phantom is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Phantom's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Phantom API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Phantom wallet\",\n    };\n  }\n}\n", "import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class RabbyWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"rabby\";\n  readonly rdns = \"io.rabby\";\n  readonly displayName = \"Rabby\";\n}\n", "import { Call, TypedData, StarknetWindowObject } from \"@starknet-io/types-js\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\nexport class BraavosWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"braavos\";\n  readonly platform: ExternalPlatform = \"starknet\";\n  private wallet: StarknetWindowObject | undefined = undefined;\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n  private accountChangeListener: ((accounts?: string[]) => void) | undefined =\n    undefined;\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.starknet_braavos;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available\n        ? window.starknet_braavos?.version || \"Unknown\"\n        : undefined,\n      chainId: available ? window.starknet_braavos?.chainId : undefined,\n      name: \"Braavos\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Braavos is not available\");\n      }\n\n      const wallet = window.starknet_braavos as StarknetWindowObject;\n      if (!wallet) {\n        throw new Error(\"No wallet found\");\n      }\n\n      // Request accounts from the wallet\n      const accounts = await wallet.request({\n        type: \"wallet_requestAccounts\",\n        params: { silent_mode: false },\n      });\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error(\"No accounts found\");\n      }\n\n      this.removeAccountChangeListener();\n\n      this.wallet = wallet;\n      this.account = accounts[0];\n      this.connectedAccounts = accounts;\n      this.setupAccountChangeListener();\n      return { success: true, wallet: this.type, account: this.account };\n    } catch (error) {\n      console.error(`Error connecting to Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signTypedData(data: TypedData): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Braavos is not connected\");\n      }\n\n      const sig = await this.wallet.request({\n        type: \"wallet_signTypedData\",\n        params: data,\n      });\n\n      return { success: true, wallet: this.type, result: sig };\n    } catch (error) {\n      console.error(`Error signing typed data with Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(calls: Call[]): Promise<ExternalWalletResponse> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    try {\n      const result = await this.wallet.request({\n        type: \"wallet_addInvokeTransaction\",\n        params: {\n          calls,\n        },\n      });\n\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    const result = await this.wallet.request({\n      type: \"wallet_switchStarknetChain\",\n      params: {\n        chainId,\n      },\n    });\n\n    return result;\n  }\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Braavos is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Braavos's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Braavos API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Braavos wallet\",\n    };\n  }\n\n  private setupAccountChangeListener(): void {\n    if (!this.wallet) return;\n\n    this.accountChangeListener = (accounts: string[] | undefined) => {\n      if (accounts && accounts.length > 0) {\n        this.account = accounts[0];\n        this.connectedAccounts = accounts;\n      } else {\n        this.account = undefined;\n        this.connectedAccounts = [];\n      }\n    };\n\n    // Listen for account changes\n    this.wallet.on(\"accountsChanged\", this.accountChangeListener);\n  }\n\n  private removeAccountChangeListener(): void {\n    if (this.wallet && this.accountChangeListener) {\n      this.wallet.off(\"accountsChanged\", this.accountChangeListener);\n      this.accountChangeListener = undefined;\n    }\n  }\n\n  disconnect(): void {\n    this.removeAccountChangeListener();\n    this.wallet = undefined;\n    this.account = undefined;\n    this.connectedAccounts = [];\n  }\n}\n", "import { getAddress } from \"ethers\";\nimport { ArgentWallet } from \"./argent\";\nimport { BaseWallet } from \"./base\";\nimport { MetaMaskWallet } from \"./metamask\";\nimport { PhantomWallet } from \"./phantom\";\nimport { RabbyWallet } from \"./rabby\";\nimport {\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\nimport { BraavosWallet } from \"./braavos\";\n\nexport class WalletBridge {\n  private readonly walletAdapters: Map<ExternalWalletType, WalletAdapter>;\n\n  constructor() {\n    this.walletAdapters = new Map<ExternalWalletType, WalletAdapter>();\n\n    if (typeof window == \"undefined\") {\n      return;\n    }\n\n    const metamask = new MetaMaskWallet();\n    this.walletAdapters.set(\"metamask\", metamask);\n\n    const phantom = new PhantomWallet();\n    this.walletAdapters.set(\"phantom\", phantom);\n\n    const argent = new ArgentWallet();\n    this.walletAdapters.set(\"argent\", argent);\n\n    const braavos = new BraavosWallet();\n    this.walletAdapters.set(\"braavos\", braavos);\n\n    const rabby = new RabbyWallet();\n    this.walletAdapters.set(\"rabby\", rabby);\n\n    const base = new BaseWallet();\n    this.walletAdapters.set(\"base\", base);\n\n    window.wallet_bridge = this;\n  }\n\n  getIFrameMethods() {\n    return {\n      externalDetectWallets: (_origin: string) => () => this.detectWallets(),\n      externalConnectWallet: (_origin: string) => (type: ExternalWalletType) =>\n        this.connectWallet(type),\n      externalSignMessage:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, message: string) =>\n          this.signMessage(identifier, message),\n      externalSignTypedData:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, data: any) =>\n          this.signTypedData(identifier, data),\n      externalSendTransaction:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, txn: any) =>\n          this.sendTransaction(identifier, txn),\n      externalGetBalance:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, tokenAddress?: string) =>\n          this.getBalance(identifier, tokenAddress),\n      externalSwitchChain:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, chainId: string) =>\n          this.switchChain(identifier, chainId),\n      externalWaitForTransaction:\n        (_origin: string) =>\n        (\n          identifier: ExternalWalletType | string,\n          txHash: string,\n          timeoutMs?: number,\n        ) =>\n          this.waitForTransaction(identifier, txHash, timeoutMs),\n    };\n  }\n\n  async detectWallets(): Promise<ExternalWallet[]> {\n    const wallets = Array.from(this.walletAdapters.values()).map((adapter) =>\n      adapter.getInfo(),\n    ) as ExternalWallet[];\n\n    return wallets;\n  }\n\n  private getWalletAdapterByType(type: ExternalWalletType): WalletAdapter {\n    const adapter = this.walletAdapters.get(type);\n    if (!adapter) {\n      throw new Error(`Unsupported wallet type: ${type}`);\n    }\n    return adapter;\n  }\n\n  private handleError(\n    identifier: ExternalWalletType | string,\n    error: unknown,\n    operation: string,\n    responseType?: ExternalWalletType,\n  ): ExternalWalletResponse {\n    const errorMessage =\n      error instanceof Error ? error.message : \"Unknown error\";\n    let walletType: ExternalWalletType | string = \"unknown\";\n    if (typeof identifier === \"string\") {\n      const adapter = this.getConnectedWalletAdapter(identifier);\n      walletType = responseType ?? adapter?.type ?? identifier;\n    } else {\n      walletType = identifier;\n    }\n\n    console.error(`Error ${operation} with ${identifier} wallet:`, error);\n    return {\n      success: false,\n      wallet: walletType as ExternalWalletType,\n      error: errorMessage,\n    };\n  }\n\n  async connectWallet(\n    type: ExternalWalletType,\n  ): Promise<ExternalWalletResponse> {\n    try {\n      const wallet = this.getWalletAdapterByType(type);\n      const response = await wallet.connect();\n\n      if (response.success && response.account) {\n        console.log(\n          `Wallet ${type} connected with address ${response.account}`,\n        );\n      } else if (response.success && !response.account) {\n        console.error(\n          `Wallet ${type} connected successfully but did not provide an address.`,\n        );\n        return {\n          ...response,\n          success: false,\n          error: \"Wallet connected but address not found.\",\n        };\n      }\n\n      return response;\n    } catch (error) {\n      return this.handleError(type, error, \"connecting to\");\n    }\n  }\n\n  private getConnectedWalletAdapter(\n    identifier: ExternalWalletType | string,\n  ): WalletAdapter {\n    let wallet: WalletAdapter | undefined;\n    let checkSummedAddress: string;\n\n    try {\n      checkSummedAddress = getAddress(identifier);\n    } catch {\n      // getAddress failed, so this must be a wallet type\n      wallet = this.walletAdapters.get(identifier as ExternalWalletType);\n      if (!wallet) {\n        throw new Error(`Wallet ${identifier} is not connected or supported`);\n      }\n      return wallet;\n    }\n\n    wallet = this.walletAdapters.values().find((adapter) => {\n      return adapter.getConnectedAccounts().includes(checkSummedAddress);\n    });\n\n    if (!wallet) {\n      throw new Error(`No wallet found with connected address ${identifier}`);\n    }\n\n    return wallet;\n  }\n\n  async signMessage(\n    identifier: ExternalWalletType | string,\n    message: string,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      if (!wallet.signMessage) {\n        throw new Error(\n          `Wallet type ${wallet.type} (identifier: ${identifier}) does not support signing messages`,\n        );\n      }\n      return await wallet.signMessage(message, identifier);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"signing message with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async signTypedData(\n    identifier: ExternalWalletType | string,\n    data: any,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      if (!wallet.signTypedData) {\n        throw new Error(\n          `Wallet type ${wallet.type} (identifier: ${identifier}) does not support signing typed data`,\n        );\n      }\n      return await wallet.signTypedData(data);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"signing typed data with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async sendTransaction(\n    identifier: ExternalWalletType | string,\n    txn: any,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.sendTransaction(txn);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"sending transaction with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async getBalance(\n    identifier: ExternalWalletType | string,\n    tokenAddress?: string,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.getBalance(tokenAddress);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"getting balance from\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async switchChain(\n    identifier: ExternalWalletType | string,\n    chainId: string,\n  ): Promise<boolean> {\n    try {\n      const wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.switchChain(chainId);\n    } catch (error) {\n      console.error(`Error switching chain for ${identifier} wallet:`, error);\n      return false;\n    }\n  }\n\n  async waitForTransaction(\n    identifier: ExternalWalletType | string,\n    txHash: string,\n    timeoutMs?: number,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.waitForTransaction(txHash, timeoutMs);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"waiting for transaction with\",\n        wallet?.type,\n      );\n    }\n  }\n}\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n    solana?: any;\n    starknet_argentX?: any;\n    starknet_braavos?: any;\n    wallet_bridge?: WalletBridge;\n  }\n}\n\nexport type {\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\n", "import { KEYCHAIN_URL } from \"../constants\";\nimport { Keychain, KeychainOptions } from \"../types\";\nimport { WalletBridge } from \"../wallets/bridge\";\nimport { IFrame, IFrameOptions } from \"./base\";\n\ntype KeychainIframeOptions = IFrameOptions<Keychain> &\n  KeychainOptions & {\n    version?: string;\n  };\n\nexport class KeychainIFrame extends IFrame<Keychain> {\n  private walletBridge: WalletBridge;\n\n  constructor({\n    url,\n    policies,\n    version,\n    slot,\n    namespace,\n    tokens,\n    ...iframeOptions\n  }: KeychainIframeOptions) {\n    const _url = new URL(url ?? KEYCHAIN_URL);\n    const walletBridge = new WalletBridge();\n\n    if (policies) {\n      _url.searchParams.set(\n        \"policies\",\n        encodeURIComponent(JSON.stringify(policies)),\n      );\n    }\n\n    if (version) {\n      _url.searchParams.set(\"v\", encodeURIComponent(version));\n    }\n\n    if (slot) {\n      _url.searchParams.set(\"ps\", encodeURIComponent(slot));\n    }\n\n    if (namespace) {\n      _url.searchParams.set(\"ns\", encodeURIComponent(namespace));\n    }\n\n    if (tokens?.erc20) {\n      _url.searchParams.set(\n        \"erc20\",\n        encodeURIComponent(tokens.erc20.toString()),\n      );\n    }\n\n    super({\n      ...iframeOptions,\n      id: \"controller-keychain\",\n      url: _url,\n      methods: walletBridge.getIFrameMethods(),\n    });\n\n    this.walletBridge = walletBridge;\n\n    // Expose the wallet bridge instance globally for WASM interop\n    if (typeof window !== \"undefined\") {\n      (window as any).external_wallets = this.walletBridge;\n    }\n  }\n\n  getWalletBridge(): WalletBridge {\n    return this.walletBridge;\n  }\n}\n", "import { AsyncMethodReturns } from \"@cartridge/penpal\";\n\nimport { Policy } from \"@cartridge/presets\";\nimport {\n  AddInvokeTransactionResult,\n  AddStarknetChainParameters,\n  ChainId,\n} from \"@starknet-io/types-js\";\nimport { constants, shortString, WalletAccount } from \"starknet\";\nimport { version } from \"../package.json\";\nimport ControllerAccount from \"./account\";\nimport { NotReadyToConnect } from \"./errors\";\nimport { KeychainIFrame } from \"./iframe\";\nimport BaseProvider from \"./provider\";\nimport {\n  Chain,\n  ConnectError,\n  ConnectReply,\n  ControllerOptions,\n  IFrames,\n  Keychain,\n  ProbeReply,\n  ProfileContextTypeVariant,\n  ResponseCodes,\n  StarterPack,\n} from \"./types\";\nimport { parseChainId } from \"./utils\";\n\nexport default class ControllerProvider extends BaseProvider {\n  private keychain?: AsyncMethodReturns<Keychain>;\n  private options: ControllerOptions;\n  private iframes: IFrames;\n  private selectedChain: ChainId;\n  private chains: Map<ChainId, Chain>;\n\n  isReady(): boolean {\n    return !!this.keychain;\n  }\n\n  constructor(options: ControllerOptions = {}) {\n    super();\n\n    // Default Cartridge chains that are always available\n    const cartridgeChains: Chain[] = [\n      { rpcUrl: \"https://api.cartridge.gg/x/starknet/sepolia/rpc/v0_9\" },\n      { rpcUrl: \"https://api.cartridge.gg/x/starknet/mainnet/rpc/v0_9\" },\n    ];\n\n    // Merge user chains with default chains\n    // User chains take precedence if they specify the same network\n    const chains = [...cartridgeChains, ...(options.chains || [])];\n    const defaultChainId =\n      options.defaultChainId || constants.StarknetChainId.SN_MAIN;\n\n    this.selectedChain = defaultChainId;\n    this.chains = new Map<ChainId, Chain>();\n    this.options = { ...options, chains, defaultChainId };\n\n    this.iframes = {\n      keychain: options.lazyload ? undefined : this.createKeychainIframe(),\n    };\n\n    this.initializeChains(chains);\n\n    if (typeof window !== \"undefined\") {\n      (window as any).starknet_controller = this;\n    }\n  }\n\n  async logout() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    try {\n      // Disconnect the controller/keychain first\n      await this.disconnect();\n\n      // Close all controller iframes\n      const iframes = document.querySelectorAll('iframe[id^=\"controller-\"]');\n      iframes.forEach((iframe) => {\n        const container = iframe.parentElement;\n        if (container) {\n          // Start fade-out transition\n          container.style.opacity = \"0\";\n          // Set display: none after transition completes\n          setTimeout(() => {\n            container.style.display = \"none\";\n          }, 200);\n        }\n      });\n\n      // Reset body overflow\n      if (document.body) {\n        document.body.style.overflow = \"auto\";\n      }\n\n      // Reload the page to complete logout\n      window.location.reload();\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      throw err;\n    }\n  }\n\n  async probe(): Promise<WalletAccount | undefined> {\n    try {\n      // Ensure iframe is created if using lazy loading\n      if (!this.iframes.keychain) {\n        this.iframes.keychain = this.createKeychainIframe();\n      }\n\n      await this.waitForKeychain();\n\n      if (!this.keychain) {\n        console.error(new NotReadyToConnect().message);\n        return;\n      }\n\n      const response = (await this.keychain.probe(this.rpcUrl())) as ProbeReply;\n\n      // For backwards compat with controller <=0.6.0\n      let rpcUrl = response?.rpcUrl || this.rpcUrl();\n      this.account = new ControllerAccount(\n        this,\n        rpcUrl,\n        response.address,\n        this.keychain,\n        this.options,\n        this.iframes.keychain,\n      );\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n\n    return this.account;\n  }\n\n  async connect(): Promise<WalletAccount | undefined> {\n    if (this.account) {\n      return this.account;\n    }\n\n    // Ensure iframe is created if using lazy loading\n    if (!this.iframes.keychain) {\n      this.iframes.keychain = this.createKeychainIframe();\n      // Wait for the keychain to be ready\n      await this.waitForKeychain();\n    }\n\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    if (typeof document !== \"undefined\" && !!document.hasStorageAccess) {\n      const ok = await document.hasStorageAccess();\n      if (!ok) {\n        await document.requestStorageAccess();\n      }\n    }\n\n    this.iframes.keychain.open();\n\n    try {\n      let response = await this.keychain.connect(\n        // Policy precedence logic:\n        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies\n        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)\n        // 3. Otherwise, use provided policies or empty object\n        this.options.shouldOverridePresetPolicies && this.options.policies\n          ? this.options.policies\n          : this.options.preset\n            ? {}\n            : this.options.policies || {},\n        this.rpcUrl(),\n        this.options.signupOptions,\n      );\n      if (response.code !== ResponseCodes.SUCCESS) {\n        throw new Error(response.message);\n      }\n\n      response = response as ConnectReply;\n      this.account = new ControllerAccount(\n        this,\n        this.rpcUrl(),\n        response.address,\n        this.keychain,\n        this.options,\n        this.iframes.keychain,\n      );\n\n      return this.account;\n    } catch (e) {\n      console.log(e);\n    } finally {\n      this.iframes.keychain.close();\n    }\n  }\n\n  async switchStarknetChain(chainId: string): Promise<boolean> {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return false;\n    }\n\n    const currentChain = this.selectedChain;\n\n    try {\n      this.selectedChain = chainId;\n      await this.keychain.switchChain(this.rpcUrl());\n    } catch (e) {\n      console.error(e);\n      this.selectedChain = currentChain;\n      return false;\n    }\n\n    this.emitNetworkChanged(chainId);\n    return true;\n  }\n\n  addStarknetChain(_chain: AddStarknetChainParameters): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n\n  async disconnect() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    if (typeof document !== \"undefined\" && !!document.hasStorageAccess) {\n      const ok = await document.hasStorageAccess();\n      if (!ok) {\n        await document.requestStorageAccess();\n      }\n    }\n\n    this.account = undefined;\n    return this.keychain.disconnect();\n  }\n\n  async openProfile(tab: ProfileContextTypeVariant = \"inventory\") {\n    // Profile functionality is now integrated into keychain\n    // Navigate keychain iframe to profile page\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n    const username = await this.keychain.username();\n\n    // Navigate first, then open to avoid flash\n    const options = [];\n    if (this.options.slot) {\n      options.push(`ps=${this.options.slot}`);\n    }\n    await this.keychain.navigate(\n      `/account/${username}/${tab}?${options.join(\"&\")}`,\n    );\n    this.iframes.keychain.open();\n  }\n\n  async openProfileTo(to: string) {\n    // Profile functionality is now integrated into keychain\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n\n    const username = await this.keychain.username();\n    const options = [];\n    if (this.options.slot) {\n      options.push(`ps=${this.options.slot}`);\n    }\n    await this.keychain.navigate(\n      `/account/${username}/${to}?${options.join(\"&\")}`,\n    );\n    this.iframes.keychain.open();\n  }\n\n  async openProfileAt(at: string) {\n    // Profile functionality is now integrated into keychain\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n\n    await this.keychain.navigate(at);\n    this.iframes.keychain.open();\n  }\n\n  openSettings() {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    this.iframes.keychain.open();\n    this.keychain.openSettings();\n  }\n\n  revoke(origin: string, _policy: Policy[]) {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return null;\n    }\n\n    return this.keychain.revoke(origin);\n  }\n\n  rpcUrl(): string {\n    const chain = this.chains.get(this.selectedChain);\n    if (!chain) {\n      const availableChains = Array.from(this.chains.keys()).map((chain) =>\n        shortString.decodeShortString(chain),\n      );\n      throw new Error(\n        `Chain not found: ${shortString.decodeShortString(this.selectedChain)}. Available chains: ${availableChains.join(\", \")}`,\n      );\n    }\n    return chain.rpcUrl;\n  }\n\n  username() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    return this.keychain.username();\n  }\n\n  openPurchaseCredits() {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    this.keychain.navigate(\"/purchase/credits\").then(() => {\n      this.iframes.keychain?.open();\n    });\n  }\n\n  async openStarterPack(options: string | StarterPack): Promise<void> {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    // Pass options directly to keychain's unified openStarterPack method\n    await this.keychain.openStarterPack(options);\n    this.iframes.keychain?.open();\n  }\n\n  async openExecute(calls: any, chainId?: string) {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    // Switch to the chain if provided\n    let currentChainId = this.selectedChain;\n    if (chainId) {\n      this.switchStarknetChain(chainId);\n    }\n    // Open keychain\n    this.iframes.keychain.open();\n    // Invoke execute\n    const res = await this.keychain.execute(calls, undefined, undefined, true);\n    // Close keychain\n    this.iframes.keychain.close();\n    // Switch back to the original chain\n    if (chainId) {\n      this.switchStarknetChain(currentChainId);\n    }\n    const status = !(\n      res &&\n      ((res as ConnectError).code === ResponseCodes.NOT_CONNECTED ||\n        (res as ConnectError).code === ResponseCodes.CANCELED)\n    );\n    return {\n      status,\n      transactionHash: (res as AddInvokeTransactionResult)?.transaction_hash,\n    };\n  }\n\n  async delegateAccount() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return null;\n    }\n\n    return await this.keychain.delegateAccount();\n  }\n\n  private initializeChains(chains: Chain[]) {\n    for (const chain of chains) {\n      try {\n        const url = new URL(chain.rpcUrl);\n        const chainId = parseChainId(url);\n\n        // Validate that mainnet and sepolia must use Cartridge RPC\n        const isMainnet = chainId === constants.StarknetChainId.SN_MAIN;\n        const isSepolia = chainId === constants.StarknetChainId.SN_SEPOLIA;\n        const isCartridgeRpc = url.hostname === \"api.cartridge.gg\";\n        const isLocalhost =\n          url.hostname === \"localhost\" || url.hostname === \"127.0.0.1\";\n\n        if ((isMainnet || isSepolia) && !(isCartridgeRpc || isLocalhost)) {\n          throw new Error(\n            `Only Cartridge RPC providers are allowed for ${isMainnet ? \"mainnet\" : \"sepolia\"}. ` +\n              `Please use: https://api.cartridge.gg/x/starknet/${isMainnet ? \"mainnet\" : \"sepolia\"}/rpc/v0_9`,\n          );\n        }\n\n        this.chains.set(chainId, chain);\n      } catch (error) {\n        console.error(`Failed to parse chainId for ${chain.rpcUrl}:`, error);\n        throw error; // Re-throw to ensure invalid chains fail fast\n      }\n    }\n\n    if (!this.chains.has(this.selectedChain)) {\n      console.warn(\n        `Selected chain ${this.selectedChain} not found in configured chains. ` +\n          `Available chains: ${Array.from(this.chains.keys()).join(\", \")}`,\n      );\n    }\n  }\n\n  private createKeychainIframe(): KeychainIFrame {\n    return new KeychainIFrame({\n      ...this.options,\n      onClose: this.keychain?.reset,\n      onConnect: (keychain) => {\n        this.keychain = keychain;\n      },\n      version: version,\n    });\n  }\n\n  private waitForKeychain({\n    timeout = 50000,\n    interval = 100,\n  }:\n    | {\n        timeout?: number;\n        interval?: number;\n      }\n    | undefined = {}) {\n    return new Promise<void>((resolve, reject) => {\n      const startTime = Date.now();\n      const id = setInterval(() => {\n        if (Date.now() - startTime > timeout) {\n          clearInterval(id);\n          reject(new Error(\"Timeout waiting for keychain\"));\n          return;\n        }\n\n        if (!this.keychain) return;\n\n        clearInterval(id);\n        resolve();\n      }, interval);\n    });\n  }\n}\n", "import { LookupRequest, LookupResponse } from \"./types\";\nimport { num } from \"starknet\";\nimport { API_URL } from \"./constants\";\n\nconst cache = new Map<string, string>();\n\nasync function lookup(request: LookupRequest): Promise<LookupResponse> {\n  if (!request.addresses?.length && !request.usernames?.length) {\n    return { results: [] };\n  }\n\n  const response = await fetch(`${API_URL}/lookup`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(request),\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  return response.json();\n}\n\nexport async function lookupUsernames(\n  usernames: string[],\n): Promise<Map<string, string>> {\n  const uncachedUsernames = usernames.filter((name) => !cache.has(name));\n\n  if (uncachedUsernames.length > 0) {\n    const response = await lookup({ usernames: uncachedUsernames });\n\n    response.results.forEach((result) => {\n      cache.set(result.username, result.addresses[0]); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    usernames\n      .map((name) => [name, cache.get(name)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n\nexport async function lookupAddresses(\n  addresses: string[],\n): Promise<Map<string, string>> {\n  addresses = addresses.map(num.toHex);\n  const uncachedAddresses = addresses.filter((addr) => !cache.has(addr));\n\n  if (uncachedAddresses.length > 0) {\n    const response = await lookup({\n      addresses: uncachedAddresses,\n    });\n\n    response.results.forEach((result) => {\n      cache.set(result.addresses[0], result.username); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    addresses\n      .map((addr) => [addr, cache.get(addr)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n", "// src/generated/erc20-metadata.ts\nvar metadata = [\n  {\n    name: \"Wrapped BTC\",\n    symbol: \"WBTC\",\n    decimals: 8,\n    l2_token_address: \"0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac\",\n    sort_order: 0,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo\"\n  },\n  {\n    name: \"USD Coin\",\n    symbol: \"USDC\",\n    decimals: 6,\n    l2_token_address: \"0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8\",\n    sort_order: 5,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo\"\n  },\n  {\n    name: \"LUSD Stablecoin\",\n    symbol: \"LUSD\",\n    decimals: 18,\n    l2_token_address: \"0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo\"\n  },\n  {\n    name: \"Tether USD\",\n    symbol: \"USDT\",\n    decimals: 6,\n    l2_token_address: \"0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8\",\n    sort_order: 4,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo\"\n  },\n  {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    l2_token_address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    sort_order: 3,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo\"\n  },\n  {\n    name: \"Dai Stablecoin\",\n    symbol: \"DAIv0\",\n    decimals: 18,\n    l2_token_address: \"0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3\",\n    sort_order: 4,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo\"\n  },\n  {\n    name: \"Dai Stablecoin\",\n    symbol: \"DAI\",\n    decimals: 18,\n    l2_token_address: \"0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad\",\n    sort_order: 4,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo\"\n  },\n  {\n    name: \"Legacy Starknet Wrapped Staked Ether\",\n    symbol: \"wstETH-legacy\",\n    decimals: 18,\n    l2_token_address: \"0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/26162dcc-29c2-4f5e-3acd-5e6be1f07a00/logo\"\n  },\n  {\n    name: \"Wrapped Staked Ether\",\n    symbol: \"wstETH\",\n    decimals: 18,\n    l2_token_address: \"0x0057912720381af14b0e5c87aa4718ed5e527eab60b3801ebf702ab09139e38b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo\"\n  },\n  {\n    name: \"Rocket Pool ETH\",\n    symbol: \"rETH\",\n    decimals: 18,\n    l2_token_address: \"0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo\"\n  },\n  {\n    name: \"LORDS\",\n    symbol: \"LORDS\",\n    decimals: 18,\n    l2_token_address: \"0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49\",\n    sort_order: 1,\n    total_supply: 509e5,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo\"\n  },\n  {\n    name: \"R Stablecoin\",\n    symbol: \"R\",\n    decimals: 18,\n    l2_token_address: \"0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo\"\n  },\n  {\n    name: \"Frax\",\n    symbol: \"FRAX\",\n    decimals: 18,\n    l2_token_address: \"0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406\",\n    sort_order: 1,\n    total_supply: 649462235,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo\"\n  },\n  {\n    name: \"Frax Share\",\n    symbol: \"FXS\",\n    decimals: 18,\n    l2_token_address: \"0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo\"\n  },\n  {\n    name: \"Staked Frax Ether\",\n    symbol: \"sfrxETH\",\n    decimals: 18,\n    l2_token_address: \"0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo\"\n  },\n  {\n    name: \"Uniswap\",\n    symbol: \"UNI\",\n    decimals: 18,\n    l2_token_address: \"0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee\",\n    sort_order: 1,\n    total_supply: 1e9,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo\"\n  },\n  {\n    name: \"Paper\",\n    symbol: \"PAPER\",\n    decimals: 18,\n    l2_token_address: \"0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo\"\n  },\n  {\n    name: \"StarkPepe\",\n    symbol: \"xSPEPE\",\n    decimals: 18,\n    l2_token_address: \"0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    disabled: true\n  },\n  {\n    name: \"StarkNet Token\",\n    symbol: \"STRK\",\n    decimals: 18,\n    l2_token_address: \"0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d\",\n    sort_order: 2,\n    total_supply: 1e10,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo\"\n  },\n  {\n    name: \"zkLend Token\",\n    symbol: \"ZEND\",\n    decimals: 18,\n    l2_token_address: \"0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo\"\n  },\n  {\n    name: \"Ekubo Protocol\",\n    symbol: \"EKUBO\",\n    decimals: 18,\n    l2_token_address: \"0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87\",\n    sort_order: 1,\n    total_supply: 1e7,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo\"\n  },\n  {\n    name: \"SOCKS\",\n    symbol: \"SOCKS\",\n    decimals: 18,\n    l2_token_address: \"0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015\",\n    sort_order: 1,\n    total_supply: 1e11,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo\"\n  },\n  {\n    name: \"Nostra\",\n    symbol: \"NSTR\",\n    decimals: 18,\n    l2_token_address: \"0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007\",\n    sort_order: 1,\n    total_supply: 1e8,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo\"\n  },\n  {\n    name: \"Carmine\",\n    symbol: \"CRM\",\n    decimals: 18,\n    l2_token_address: \"0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe\",\n    sort_order: 1,\n    total_supply: 1e8,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo\"\n  },\n  {\n    name: \"Cash\",\n    symbol: \"CASH\",\n    decimals: 18,\n    l2_token_address: \"0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: false,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo\"\n  },\n  {\n    name: \"Nums\",\n    symbol: \"NUMS\",\n    decimals: 18,\n    l2_token_address: \"0xe5f10eddc01699dc899a30dbc3c9858148fa4aa0a47c0ffd85f887ffc4653e\",\n    sort_order: 1,\n    total_supply: 1,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/90868d05-cb75-4c42-278c-5a540db2cf00/logo\"\n  },\n  {\n    name: \"Flip\",\n    symbol: \"FLIP\",\n    decimals: 18,\n    l2_token_address: \"0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo\"\n  },\n  {\n    name: \"Eternum Stone\",\n    symbol: \"STONE\",\n    decimals: 18,\n    l2_token_address: \"0x439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/932e7f83-a4c2-40f0-3048-35af3b194100/logo\"\n  },\n  {\n    name: \"Eternum Coal\",\n    symbol: \"COAL\",\n    decimals: 18,\n    l2_token_address: \"0xce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cf2ee180-06bf-4443-e3aa-724d7c28e800/logo\"\n  },\n  {\n    name: \"Eternum Wood\",\n    symbol: \"WOOD\",\n    decimals: 18,\n    l2_token_address: \"0x40d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1db5f954-c1ef-447e-9f8f-05bd9f3b2b00/logo\"\n  },\n  {\n    name: \"Eternum Copper\",\n    symbol: \"COPPER\",\n    decimals: 18,\n    l2_token_address: \"0x66ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bbcdcc9-6146-404d-9501-92a664cf3100/logo\"\n  },\n  {\n    name: \"Eternum Ironwood\",\n    symbol: \"IRONWOOD\",\n    decimals: 18,\n    l2_token_address: \"0x1720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5af7c03b-e4ae-4aee-eba4-a4e2160a1d00/logo\"\n  },\n  {\n    name: \"Eternum Obsidian\",\n    symbol: \"OBSIDIAN\",\n    decimals: 18,\n    l2_token_address: \"0x3b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8be9bc66-486b-4181-6804-725a1db8ad00/logo\"\n  },\n  {\n    name: \"Eternum Gold\",\n    symbol: \"GOLD\",\n    decimals: 18,\n    l2_token_address: \"0xdff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fb9e90f7-3c2f-4c64-7e43-c3f694f35e00/logo\"\n  },\n  {\n    name: \"Eternum Silver\",\n    symbol: \"SILVER\",\n    decimals: 18,\n    l2_token_address: \"0x6fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e443afeb-850b-46a0-a7ba-a473306d6b00/logo\"\n  },\n  {\n    name: \"Eternum Mithral\",\n    symbol: \"MITHRAL\",\n    decimals: 18,\n    l2_token_address: \"0x67ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33dc517f-8a66-45eb-f2c5-de5388e47500/logo\"\n  },\n  {\n    name: \"Eternum Alchemical Silver\",\n    symbol: \"ALCHEMICALSILVER\",\n    decimals: 18,\n    l2_token_address: \"0x3956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3d2e0fd8-4af8-49a0-4bdb-691a4d6ef800/logo\"\n  },\n  {\n    name: \"Eternum Cold Iron\",\n    symbol: \"COLDIRON\",\n    decimals: 18,\n    l2_token_address: \"0x555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/878c0d8a-8e2c-4281-0896-9cbbb2ef9400/logo\"\n  },\n  {\n    name: \"Eternum Deep Crystal\",\n    symbol: \"DEEPCRYSTAL\",\n    decimals: 18,\n    l2_token_address: \"0x1d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1c2c954f-448c-476b-a4a6-19b52efe3e00/logo\"\n  },\n  {\n    name: \"Eternum Ruby\",\n    symbol: \"RUBY\",\n    decimals: 18,\n    l2_token_address: \"0x3d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6a45b34d-3bfe-4994-45b0-f2bee8abac00/logo\"\n  },\n  {\n    name: \"Eternum Diamonds\",\n    symbol: \"DIAMONDS\",\n    decimals: 18,\n    l2_token_address: \"0xe03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/b1fa609d-8799-4754-cdea-ab69514ca700/logo\"\n  },\n  {\n    name: \"Eternum Hartwood\",\n    symbol: \"HARTWOOD\",\n    decimals: 18,\n    l2_token_address: \"0x5620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/27e37e85-91bd-4ee1-0552-1e0795077400/logo\"\n  },\n  {\n    name: \"Eternum Ignium\",\n    symbol: \"IGNIUM\",\n    decimals: 18,\n    l2_token_address: \"0x625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/58591e20-24fb-4353-417a-81d877a5a200/logo\"\n  },\n  {\n    name: \"Eternum Twilight Quartz\",\n    symbol: \"TWILIGHTQUARTZ\",\n    decimals: 18,\n    l2_token_address: \"0x35e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2f8cb892-e82a-4af3-bd09-316061faec00/logo\"\n  },\n  {\n    name: \"Eternum True Ice\",\n    symbol: \"TRUEICE\",\n    decimals: 18,\n    l2_token_address: \"0x4485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fe4bfc17-6553-4dc5-58d2-f452b4aa8a00/logo\"\n  },\n  {\n    name: \"Eternum Adamantine\",\n    symbol: \"ADAMANTINE\",\n    decimals: 18,\n    l2_token_address: \"0x367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/13bd026b-3612-480e-0119-04cf4c505a00/logo\"\n  },\n  {\n    name: \"Eternum Sapphire\",\n    symbol: \"SAPPHIRE\",\n    decimals: 18,\n    l2_token_address: \"0x2f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0ebf555f-e732-4054-f8e5-55b2ed49ba00/logo\"\n  },\n  {\n    name: \"Eternum Ethereal Silica\",\n    symbol: \"ETHEREALSILICA\",\n    decimals: 18,\n    l2_token_address: \"0x68b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f02a5b43-bfcf-408c-7d1b-fcfe68b02d00/logo\"\n  },\n  {\n    name: \"Eternum Dragon Hide\",\n    symbol: \"DRAGONHIDE\",\n    decimals: 18,\n    l2_token_address: \"0x3bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e74955fc-5c8a-4dff-4882-a49a46a5a800/logo\"\n  },\n  {\n    name: \"Eternum Ancient Fragment\",\n    symbol: \"ANCIENTFRAGMENT\",\n    decimals: 18,\n    l2_token_address: \"0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9af855b7-4790-4390-9466-6bed4481ab00/logo\"\n  },\n  {\n    name: \"Eternum Donkey\",\n    symbol: \"DONKEY\",\n    decimals: 18,\n    l2_token_address: \"0x264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/20817378-a45e-4521-f464-10f6dd13c500/logo\"\n  },\n  {\n    name: \"Eternum Knight\",\n    symbol: \"KNIGHT\",\n    decimals: 18,\n    l2_token_address: \"0xac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8787ed1f-af5c-4873-c01a-55f05e999a00/logo\"\n  },\n  {\n    name: \"Eternum Crossbowman\",\n    symbol: \"CROSSBOWMAN\",\n    decimals: 18,\n    l2_token_address: \"0x67e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dec7f31b-4b1d-46bb-4fca-c0253cf55a00/logo\"\n  },\n  {\n    name: \"Eternum Paladin\",\n    symbol: \"PALADIN\",\n    decimals: 18,\n    l2_token_address: \"0x3bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7d2cd5a5-f38a-49f6-11f8-ba3b59a59e00/logo\"\n  },\n  {\n    name: \"Eternum Wheat\",\n    symbol: \"WHEAT\",\n    decimals: 18,\n    l2_token_address: \"0x57a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c338b6a8-77c4-4dd6-34f5-1af0d3fb1e00/logo\"\n  },\n  {\n    name: \"Eternum Fish\",\n    symbol: \"FISH\",\n    decimals: 18,\n    l2_token_address: \"0x27719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6deef27f-df40-4248-4e1b-ed1d79a3f000/logo\"\n  },\n  {\n    name: \"Fools\",\n    symbol: \"FOOLS\",\n    decimals: 18,\n    l2_token_address: \"0x068a7a07e08fc3e723a878223d00f669106780d5ea6665eb15d893476d47bf3b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://assets.underware.gg/pistols/fools.svg\"\n  },\n  {\n    name: \"Fame\",\n    symbol: \"FAME\",\n    decimals: 18,\n    l2_token_address: \"0x02549653a4ae1ff8d04a20b8820a49cbe97486c536ec0e4c8f68aa33d80067cf\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://assets.underware.gg/pistols/fame.svg\"\n  },\n  {\n    name: \"Survivor\",\n    symbol: \"SURVIVOR\",\n    decimals: 18,\n    l2_token_address: \"0x42dd777885ad2c116be96d4d634abc90a26a790ffb5871e037dd5ae7d2ec86b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://lootsurvivor.io/images/survivor_token.png\"\n  }\n];\n\n// configs/cartridge/config.json\nvar config_default = {\n  origin: \"*\",\n  theme: {\n    name: \"Cartridge\",\n    icon: \"icon.svg\"\n  },\n  \"apple-app-site-association\": {\n    webcredentials: {\n      apps: [\n        \"FAKETEAMID.com.cartridge.marketplace\",\n        \"F9U4Y5YSTN.com.cartridge.marketplace\"\n      ]\n    }\n  }\n};\n\n// src/config-loader.ts\nvar CONFIG_BASE_URL = \"https://static.cartridge.gg/presets\";\nasync function getConfigsIndex() {\n  try {\n    const response = await fetch(`${CONFIG_BASE_URL}/index.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to load configs index: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(\"Error loading configs index:\", error);\n    return { configs: [], baseUrl: CONFIG_BASE_URL };\n  }\n}\nasync function getAvailableConfigs() {\n  const indexData = await getConfigsIndex();\n  return indexData.configs;\n}\nasync function loadConfig(configName) {\n  try {\n    const indexData = await getConfigsIndex();\n    const baseUrl = indexData.baseUrl || CONFIG_BASE_URL;\n    const prefix = `${baseUrl}/${configName}`;\n    const response = await fetch(`${prefix}/config.json`);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to load config ${configName}: ${response.statusText}`\n      );\n    }\n    const config = await response.json();\n    if (config && config.theme) {\n      if (config.theme.icon && !config.theme.icon.startsWith(\"http\")) {\n        config.theme.icon = `${prefix}/${config.theme.icon}`;\n      }\n      if (config.theme.cover) {\n        if (typeof config.theme.cover === \"string\") {\n          if (!config.theme.cover.startsWith(\"http\")) {\n            config.theme.cover = `${prefix}/${config.theme.cover}`;\n          }\n        } else {\n          if (config.theme.cover.light && !config.theme.cover.light.startsWith(\"http\")) {\n            config.theme.cover.light = `${prefix}/${config.theme.cover.light}`;\n          }\n          if (config.theme.cover.dark && !config.theme.cover.dark.startsWith(\"http\")) {\n            config.theme.cover.dark = `${prefix}/${config.theme.cover.dark}`;\n          }\n        }\n      }\n      const prefixOptimizedImageSet = (imageSet) => {\n        if (!imageSet) return;\n        for (const format in imageSet) {\n          if (imageSet[format]) {\n            for (const size in imageSet[format]) {\n              if (imageSet[format][size] && !imageSet[format][size].startsWith(\"http\")) {\n                imageSet[format][size] = `${prefix}/${imageSet[format][size]}`;\n              }\n            }\n          }\n        }\n      };\n      if (config.theme.optimizedIcon) {\n        prefixOptimizedImageSet(config.theme.optimizedIcon);\n      }\n      if (config.theme.optimizedCover) {\n        if (typeof config.theme.optimizedCover === \"string\") {\n          if (!config.theme.optimizedCover.startsWith(\"http\")) {\n            config.theme.optimizedCover = `${prefix}/${config.theme.optimizedCover}`;\n          }\n        } else if (config.theme.optimizedCover.light || config.theme.optimizedCover.dark) {\n          const themeVal = config.theme.optimizedCover;\n          if (themeVal.light) {\n            prefixOptimizedImageSet(themeVal.light);\n          }\n          if (themeVal.dark) {\n            prefixOptimizedImageSet(themeVal.dark);\n          }\n        } else {\n          prefixOptimizedImageSet(config.theme.optimizedCover);\n        }\n      }\n    }\n    return config;\n  } catch (error) {\n    console.error(`Error loading config ${configName}:`, error);\n    return null;\n  }\n}\nasync function loadAllConfigs() {\n  const indexData = await getConfigsIndex();\n  const availableConfigs = indexData.configs;\n  const baseUrl = indexData.baseUrl || CONFIG_BASE_URL;\n  const configsMap = {};\n  await Promise.all(\n    availableConfigs.map(async (configName) => {\n      try {\n        const response = await fetch(`${baseUrl}/${configName}/config.json`);\n        if (response.ok) {\n          const config = await response.json();\n          configsMap[configName] = config;\n        }\n      } catch (error) {\n        console.error(`Error loading config ${configName}:`, error);\n      }\n    })\n  );\n  return configsMap;\n}\n\n// src/index.ts\nconfig_default.theme.icon = \"https://static.cartridge.gg/presets/cartridge/icon.svg\";\nvar erc20Metadata = metadata;\nvar defaultTheme = config_default.theme;\nexport {\n  defaultTheme,\n  erc20Metadata,\n  getAvailableConfigs,\n  getConfigsIndex,\n  loadAllConfigs,\n  loadConfig\n};\n//# sourceMappingURL=index.js.map"],
  "mappings": "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",
  "names": ["ResponseCodes", "FeeSource", "StarterPackItemType", "ALLOWED_PROPERTIES", "validatePropertyName", "prop", "safeObjectAccess", "obj", "normalizeCalls", "calls", "toArray", "call", "addAddressPadding", "CallData", "toSessionPolicies", "policies", "prev", "p", "target", "getChecksumAddress", "entrypoint", "contracts", "item", "humanizeString", "methods", "toWasmPolicies", "m", "hash", "domainHash", "typedData", "TypedDataRevision", "typeHash", "val", "str", "c", "parseChainId", "url", "parts", "shortString", "xhr", "requestBody", "response", "error", "constants", "projectName", "NotReadyToConnect", "KEYCHAIN_URL", "API_URL", "Permission", "icon", "releaseStub", "Mutex", "bypass", "release", "lastPromise", "resolve", "mutex", "BaseProvider", "manifest", "result", "silentMode", "params", "event", "handler", "idx", "sub", "chainId", "accounts", "ControllerAccount", "WalletAccount", "provider", "rpcUrl", "address", "keychain", "options", "modal", "calls", "toArray", "resolve", "reject", "sessionExecute", "ResponseCodes", "manualExecute", "typedData", "sessionSign", "manualSign", "MessageType", "Resolution", "ErrorCode", "NativeErrorName", "NativeEventType", "createDestructor", "localName", "log", "callbacks", "destroyed", "error", "callback", "createLogger", "debug", "args", "DEFAULT_PORT_BY_PROTOCOL", "URL_REGEX", "opaqueOriginSchemes", "getOriginFromSrc", "src", "scheme", "location", "regexResult", "protocol", "hostname", "port", "portSuffix", "serializeError", "name", "message", "stack", "deserializeError", "obj", "deserializedError", "key", "connectCallReceiver", "info", "serializedMethods", "local", "remote", "originForSending", "originForReceiving", "handleMessageEvent", "event", "callMessage", "methodName", "id", "createPromiseHandler", "resolution", "returnValue", "err", "errorReplyMessage", "generateId", "KEY_PATH_DELIMITER", "keyPathToSegments", "keyPath", "segmentsToKeyPath", "segments", "createKeyPath", "prefix", "setAtKeyPath", "subject", "value", "prevSubject", "idx", "serializeMethods", "methods", "flattenedMethods", "deserializeMethods", "connectCallSender", "callSender", "methodKeyPaths", "destroyConnection", "createMethodProxy", "iframeRemoved", "replyMessage", "api", "handleAckMessageFactory", "childOrigin", "destructor", "destroy", "onDestroy", "destroyCallReceiver", "receiverMethodNames", "receiverMethodName", "destroyCallSender", "handleSynMessageFactory", "synAckMessage", "CHECK_IFRAME_IN_DOC_INTERVAL", "monitorIframeRemoval", "iframe", "checkIframeInDocIntervalId", "startConnectionTimeout", "timeout", "timeoutId", "validateIframeHasSrcOrSrcDoc", "connectToChild", "handleSynMessage", "handleAckMessage", "stopConnectionTimeout", "handleMessage", "IFrame", "url", "preset", "onClose", "onConnect", "container", "e", "_origin", "child", "observer", "existingController", "version", "defineProperties", "target", "values", "types", "stringify", "HEX", "result", "i", "keys", "k", "makeError", "code", "shortMessage", "details", "assert", "check", "assertArgument", "accum", "form", "_getBytes", "copy", "offset", "getBytes", "HexCharacters", "hexlify", "data", "bytes", "v", "isBytes", "a", "anumber", "n", "abytes", "b", "lengths", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "u32", "arr", "clean", "arrays", "isLE", "byteSwap", "word", "byteSwap32", "swap32IfBE", "u", "utf8ToBytes", "str", "toBytes", "Hash", "createHasher", "hashCons", "hashC", "msg", "tmp", "U32_MASK64", "_32n", "fromBig", "le", "split", "lst", "len", "Ah", "Al", "h", "l", "rotlSH", "s", "rotlSL", "rotlBH", "rotlBL", "_0n", "_1n", "_2n", "_7n", "_256n", "_0x71n", "SHA3_PI", "SHA3_ROTL", "_SHA3_IOTA", "round", "R", "x", "y", "t", "j", "IOTAS", "SHA3_IOTA_H", "SHA3_IOTA_L", "rotlH", "rotlL", "keccakP", "rounds", "B", "idx1", "idx0", "B0", "B1", "Th", "Tl", "curH", "curL", "shift", "PI", "Keccak", "blockLen", "suffix", "outputLen", "enableXOF", "state", "pos", "take", "bufferOut", "to", "gen", "keccak_256", "locked", "_keccak256", "__keccak256", "keccak256", "_data", "func", "BN_0", "BN_36", "getChecksumAddress", "chars", "expanded", "hashed", "ibanLookup", "safeDigits", "ibanChecksum", "c", "block", "checksum", "Base36", "fromBase36", "getAddress", "ArgentWallet", "available", "wallet", "accounts", "sig", "chainId", "_tokenAddress", "_txHash", "_timeoutMs", "requestProviders", "listener", "handler", "createStore", "listeners", "providerDetails", "request", "providerDetail", "unwatch", "rdns", "emitImmediately", "PLATFORMS", "constants", "chainIdToPlatform", "hex", "num", "platform", "EthereumWalletBase", "account", "ethereum", "transaction", "txn", "tokenAddress", "balance", "txHash", "timeoutMs", "startTime", "pollInterval", "receipt", "BaseWallet", "MetaMaskWallet", "isArrayOf", "isString", "item", "afn", "input", "astr", "label", "aArr", "astrArr", "anumArr", "chain", "wrap", "encode", "decode", "alphabet", "letters", "lettersA", "indexes", "digits", "letter", "join", "separator", "from", "padding", "bits", "chr", "end", "normalize", "fn", "convertRadix", "res", "d", "dlen", "carry", "done", "digit", "fromCarry", "digitBase", "div", "rounded", "gcd", "radix2carry", "powers", "convertRadix2", "max", "mask", "pow", "radix", "_256", "radix2", "revPadding", "hasBase64Builtin", "base64", "genBase58", "abc", "base58", "utf8", "hasHexBuiltin", "hexBuiltin", "equalBytes", "createView", "isPlainObject", "isNum", "lengthCoder", "isCoder", "w", "byteLen", "Path", "r", "Bitset", "bs", "bsLen", "chunk", "allowRewrite", "invert", "FULL_MASK", "BITS", "left", "lastMask", "m", "cur", "first", "lastPos", "last", "start", "objFn", "field", "fieldFn", "path", "parts", "objPath", "_Reader", "opts", "parent", "parentOffset", "baseHex", "notRead", "formatted", "length", "peek", "slice", "needle", "_Writer", "buffers", "sum", "buf", "pad", "ptr", "p", "swapEndianness", "checkBounds", "signed", "signBit", "_wrap", "inner", "validate", "isBaseCoder", "elm", "dict", "numberBigint", "tsEnum", "decimal", "precision", "decimalMask", "sep", "int", "frac", "neg", "intS", "fracS", "fracLen", "match", "reverse", "coder", "coders", "bigint", "size", "sized", "bLen", "U64LE", "view", "intView", "validateSigned", "maxVal", "validateUnsigned", "U32LE", "U8", "bool", "createBytes", "_length", "_isb", "tPos", "string", "apply", "base", "innerValue", "optional", "flag", "def", "constant", "_w", "_r", "sizeof", "fields", "f", "struct", "array", "startPos", "map", "variants", "variantNames", "variant", "tag", "TAG", "dataType", "ZeroPad", "_", "padLength", "blockSize", "padRight", "padFn", "_padFn", "padBytes", "PRECISION", "Decimal", "P.coders", "shortVec", "P.wrap", "rustString", "P.string", "P.padRight", "P.U32LE", "b58", "P.bytes", "pubKey", "Message", "P.struct", "P.U8", "P.array", "validateAddress", "keyParams", "req", "unsigned", "total", "TransactionRaw", "Transaction", "signatures", "add", "sign", "write", "acc", "_keys", "requiredSignatures", "readSigned", "readUnsigned", "sigs", "registry", "defineProgram", "tagType", "P.map", "mainCoder", "P.tag", "instr", "tl", "program", "SYS_RECENT_BLOCKHASHES", "SYS_RENT", "SYS_PROGRAM", "sys", "P.U64LE", "o", "assertType", "_value", "authorityType", "tokenName", "TOKEN_PROGRAM", "P.optional", "P.bool", "ASSOCIATED_TOKEN_PROGRAM", "P.constant", "U32LEBOOL", "createTxComplex", "instructions", "blockhash", "ALPHABET", "BASE_MAP", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "source", "zeroes", "pbegin", "pend", "it1", "it2", "decodeUnsafe", "psz", "b256", "charCode", "it3", "it4", "vch", "buffer", "basex", "decoded", "sol.Transaction", "tx", "_options", "txHex", "sol.createTxComplex", "PhantomWallet", "response", "encodedMessage", "serailized_txn", "_chainId", "RabbyWallet", "BraavosWallet", "WalletBridge", "metamask", "phantom", "argent", "braavos", "rabby", "type", "identifier", "adapter", "operation", "responseType", "errorMessage", "walletType", "checkSummedAddress", "KeychainIFrame", "policies", "slot", "namespace", "tokens", "iframeOptions", "_url", "KEYCHAIN_URL", "walletBridge", "ControllerProvider", "BaseProvider", "chains", "defaultChainId", "NotReadyToConnect", "currentChain", "_chain", "tab", "username", "at", "origin", "_policy", "availableChains", "shortString", "currentChainId", "parseChainId", "isMainnet", "isSepolia", "isCartridgeRpc", "isLocalhost", "interval", "cache", "lookup", "API_URL", "lookupUsernames", "usernames", "uncachedUsernames", "entry", "lookupAddresses", "addresses", "uncachedAddresses", "addr", "metadata", "config_default", "CONFIG_BASE_URL", "getConfigsIndex", "getAvailableConfigs", "loadConfig", "configName", "config", "prefixOptimizedImageSet", "imageSet", "format", "themeVal", "loadAllConfigs", "indexData", "availableConfigs", "baseUrl", "configsMap", "erc20Metadata", "defaultTheme"]
}
