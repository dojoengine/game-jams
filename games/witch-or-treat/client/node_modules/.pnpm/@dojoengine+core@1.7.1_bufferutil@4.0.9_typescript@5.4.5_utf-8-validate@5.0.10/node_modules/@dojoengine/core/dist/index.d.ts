import { RawArgs, Calldata, RpcProvider, Contract, Account, AccountInterface, AllowArray, Call, UniversalDetails, InvokeFunctionResponse, CallResult, CallContractResponse, TypedData } from 'starknet';
import { z } from 'zod';

/** Signature of a logging function */
interface LogFn {
    (message?: any, ...optionalParams: any[]): void;
}
/** Basic logger interface */
interface Logger {
    info: LogFn;
    warn: LogFn;
    error: LogFn;
}
/** Log levels */
type LogLevel = "info" | "warn" | "error" | "none";
/** Logger which outputs to the browser console */
declare class ConsoleLogger implements Logger {
    readonly info: LogFn;
    readonly warn: LogFn;
    readonly error: LogFn;
    constructor(options?: {
        level?: LogLevel;
    });
}

/**
 * Enumeration representing various entry points or functions available in the World.
 */
declare enum WorldEntryPoints {
    get = "entity",// Retrieve a single entity
    set = "set_entity",// Set or update a single entity
    entities = "entities",// Retrieve multiple entities
    execute = "execute",// Execute a specific command
    registerSystem = "register_system",// Register a new system
    registerComponent = "register_model",// Register a new component
    model = "model",// Access a component
    system = "system",// Access a system
    metadataUri = "metadata_uri",// Retrieve metadata URI for a resource
    setMetadataUri = "set_metadata_uri",// Set metadata URI for a resource
    registerModel = "register_model",// Register a new model
    deployContract = "deploy_contract",// Deploy a contract and return its address
    upgradeContract = "upgrade_contract",// Upgrade a contract
    uuid = "uuid",// Retrieve the UUID of the world
    emit = "emit",// Emit an event
    entityIds = "entity_ids",// Retrieve entity IDs for a model
    setExecutor = "set_executor",// Set executor for the world
    executor = "executor",// Retrieve the executor's address
    base = "base",// Retrieve base class hash
    deleteEntity = "delete_entity",// Delete an entity
    isOwner = "is_owner",// Check if an address is an owner of a resource
    grantOwner = "grant_owner",// Grant ownership of a resource
    revokeOwner = "revoke_owner",// Revoke ownership of a resource
    isWriter = "is_writer",// Check if a system is a writer for a model
    grantWriter = "grant_writer",// Grant writer permission
    revokeWriter = "revoke_writer"
}
/**
 * World interface: An interface that defines the methods that a world must implement.
 * Dojo v0.4.0
 */
interface IWorld {
    metadataUri?(resource: string): Promise<Array<string>>;
    setMetadataUri?(resource: string, uri: Array<string>): Promise<void>;
    model?(name: string): Promise<string>;
    registerModel?(classHash: string): Promise<void>;
    deployContract?(salt: string, classHash: string): Promise<string>;
    upgradeContract?(address: string, classHash: string): Promise<string>;
    uuid?(): Promise<string>;
    entity?(model: string, keys: Array<string>, offset: number, length: number, layout: Array<number>): Promise<Array<bigint>>;
    setEntity?(model: string, keys: Array<string>, offset: number, values: Array<string>, layout: Array<number>): Promise<void>;
    entities?(model: string, index: string | null, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    entityIds?(model: string): Promise<Array<string>>;
    setExecutor?(contractAddress: string): Promise<void>;
    executor?(): Promise<string>;
    base?(): Promise<string>;
    deleteEntity?(model: string, keys: Array<string>, layout: Array<number>): Promise<void>;
    isOwner?(address: string, resource: string): Promise<boolean>;
    grantOwner?(address: string, resource: string): Promise<void>;
    revokeOwner?(address: string, resource: string): Promise<void>;
    isWriter?(model: string, system: string): Promise<boolean>;
    grantWriter?(model: string, system: string): Promise<void>;
    revokeWriter?(model: string, system: string): Promise<void>;
    worldAge?(): Promise<bigint>;
}
type DojoCall = {
    contractName: string;
    entrypoint: string;
    calldata: RawArgs | Calldata;
};
/**
 * Cairo to TypeScript type mappings
 */
type CairoToTsTypeMap = {
    "core::felt252": string;
    "core::integer::u8": number;
    "core::integer::u16": number;
    "core::integer::u32": number;
    "core::integer::u64": bigint;
    "core::integer::u128": bigint;
    "core::integer::u256": bigint;
    "core::integer::i8": number;
    "core::integer::i16": number;
    "core::integer::i32": number;
    "core::integer::i64": bigint;
    "core::integer::i128": bigint;
    "core::bool": boolean;
    "core::starknet::contract_address::ContractAddress": string;
    "core::starknet::class_hash::ClassHash": string;
    "core::byte_array::ByteArray": string;
    "()": void;
};
/**
 * Map Cairo type to TypeScript type with ABI context
 */
type MapCairoType<T extends string, ABI extends readonly any[] = never> = T extends keyof CairoToTsTypeMap ? CairoToTsTypeMap[T] : T extends `core::array::Array::<${infer Inner}>` ? MapCairoType<Inner, ABI>[] : T extends `core::array::Span::<${infer Inner}>` ? MapCairoType<Inner, ABI>[] : T extends `@core::array::Array::<${infer Inner}>` ? MapCairoType<Inner, ABI>[] : T extends `(${infer Types})` ? MapTupleTypes<Types, ABI> : ABI extends never ? unknown : T extends ExtractStructNames<ABI> ? ExtractStructType<T, ABI> : T extends ExtractEnumNames<ABI> ? ExtractEnumType<T, ABI> : unknown;
/**
 * Extract all struct names from ABI
 */
type ExtractStructNames<ABI extends readonly any[]> = Extract<ABI[number], {
    type: "struct";
    name: string;
}>["name"];
/**
 * Find the first struct with a specific name in the ABI
 * This prevents duplicate struct definitions from creating union types
 */
type FindFirstStructByName<ABI extends readonly any[], Name extends string> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]] ? First extends {
    type: "struct";
    name: Name;
} ? First : FindFirstStructByName<Rest, Name> : never;
/**
 * Extract a specific struct type by name from ABI
 * Only uses the first occurrence of a struct with the given name
 */
type ExtractStructType<Name extends string, ABI extends readonly any[]> = FindFirstStructByName<ABI, Name> extends {
    type: "struct";
    name: Name;
    members: infer M;
} ? M extends readonly {
    name: string;
    type: string;
}[] ? {
    [P in M[number] as P["name"]]: MapCairoType<P["type"], ABI>;
} : never : never;
/**
 * Map tuple types
 */
type MapTupleTypes<T extends string, ABI extends readonly any[] = never> = T extends `${infer First}, ${infer Rest}` ? [MapCairoType<First, ABI>, ...MapTupleTypes<Rest, ABI>] : T extends "" ? [] : [MapCairoType<T, ABI>];
/**
 * Extract function signature from a function item
 */
type ExtractFunctionSignature<F, ABI extends readonly any[] = never> = F extends {
    type: "function";
    name: string;
    inputs: infer I;
    outputs: infer O;
} ? {
    inputs: I extends readonly {
        name: string;
        type: string;
    }[] ? {
        [P in I[number] as P["name"]]: MapCairoType<P["type"], ABI>;
    } : never;
    outputs: O extends readonly {
        type: string;
    }[] ? O["length"] extends 0 ? void : O["length"] extends 1 ? MapCairoType<O[0]["type"], ABI> : {
        [Index in keyof O]: O[Index] extends {
            type: string;
        } ? MapCairoType<O[Index]["type"], ABI> : never;
    } : void;
} : never;
/**
 * Extract all types from ABI array
 */
type ExtractAbiTypesFromArray<ABI> = ABI extends readonly any[] ? {
    structs: ExtractStructs<ABI>;
    enums: ExtractEnums<ABI>;
    functions: ExtractFunctions<ABI>;
    interfaces: ExtractInterfaces<ABI>;
} : never;
/**
 * Helper type to extract structs from ABI
 */
type ExtractStructs<ABI extends readonly any[]> = {
    [StructName in ExtractStructNames<ABI>]: ExtractStructType<StructName, ABI>;
};
/**
 * Find the first enum with a specific name in the ABI
 * This prevents duplicate enum definitions from creating union types
 */
type FindFirstEnumByName<ABI extends readonly any[], Name extends string> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]] ? First extends {
    type: "enum";
    name: Name;
} ? First : FindFirstEnumByName<Rest, Name> : never;
/**
 * Extract all enum names from ABI
 */
type ExtractEnumNames<ABI extends readonly any[]> = Extract<ABI[number], {
    type: "enum";
    name: string;
}>["name"];
/**
 * Extract just the type union of an enum by name
 * This is used for type mapping in function parameters
 */
type ExtractEnumType<Name extends string, ABI extends readonly any[]> = FindFirstEnumByName<ABI, Name> extends {
    type: "enum";
    name: Name;
    variants: infer V;
} ? V extends readonly {
    name: string;
    type: string;
}[] ? V[number]["name"] : never : never;
/**
 * Helper type to extract enums from ABI
 */
type ExtractEnums<ABI extends readonly any[]> = {
    [EnumName in ExtractEnumNames<ABI>]: FindFirstEnumByName<ABI, EnumName> extends {
        type: "enum";
        name: EnumName;
        variants: infer V;
    } ? V extends readonly {
        name: string;
        type: string;
    }[] ? {
        variants: {
            [P in V[number] as P["name"]]: MapCairoType<P["type"], ABI>;
        };
        type: V[number]["name"];
    } : never : never;
};
/**
 * Find the first function with a specific name in the ABI
 * This prevents duplicate function definitions from creating union types
 */
type FindFirstFunctionByName<ABI extends readonly any[], Name extends string> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]] ? First extends {
    type: "function";
    name: Name;
} ? First : FindFirstFunctionByName<Rest, Name> : never;
/**
 * Extract all function names from ABI
 */
type ExtractFunctionNames<ABI extends readonly any[]> = Extract<ABI[number], {
    type: "function";
    name: string;
}>["name"];
/**
 * Helper type to extract functions from ABI
 */
type ExtractFunctions<ABI extends readonly any[]> = {
    [FunctionName in ExtractFunctionNames<ABI>]: ExtractFunctionSignature<FindFirstFunctionByName<ABI, FunctionName>, ABI>;
};
/**
 * Find the first interface with a specific name in the ABI
 * This prevents duplicate interface definitions from creating union types
 */
type FindFirstInterfaceByName<ABI extends readonly any[], Name extends string> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]] ? First extends {
    type: "interface";
    name: Name;
} ? First : FindFirstInterfaceByName<Rest, Name> : never;
/**
 * Extract all interface names from ABI
 */
type ExtractInterfaceNames<ABI extends readonly any[]> = Extract<ABI[number], {
    type: "interface";
    name: string;
}>["name"];
/**
 * Helper type to extract interfaces from ABI
 */
type ExtractInterfaces<ABI extends readonly any[]> = {
    [InterfaceName in ExtractInterfaceNames<ABI>]: FindFirstInterfaceByName<ABI, InterfaceName> extends {
        type: "interface";
        name: InterfaceName;
        items: infer Items;
    } ? Items extends readonly any[] ? {
        [F in Items[number] as F extends {
            type: "function";
            name: infer FN;
        } ? FN extends string ? FN : never : never]: ExtractFunctionSignature<F, ABI>;
    } : {} : never;
};
/**
 * Main exported type for extracting ABI types
 * Usage:
 * - Compiled ABI: type MyAbi = ExtractAbiTypes<typeof compiledAbi>
 * - Raw ABI array: type MyAbi = ExtractAbiTypes<typeof abi>
 */
type ExtractAbiTypes<T> = T extends {
    abi: infer ABI;
} ? ABI extends readonly any[] ? ExtractAbiTypesFromArray<ABI> : never : T extends readonly any[] ? ExtractAbiTypesFromArray<T> : never;

/**
 * Provider class: An abstract base class for all providers.
 * It implements the ICommands interface, ensuring that any class deriving from Provider
 * will have implementations for the entity and entities methods.
 */
declare abstract class Provider implements IWorld {
    private readonly worldAddress;
    /**
     * Constructor: Initializes the Provider with a given world address.
     *
     * @param {string} worldAddress - The address of the world.
     */
    constructor(worldAddress: string);
    /**
     * Abstract method to retrieve a single entity's details.
     * Classes extending Provider should provide a concrete implementation for this method.
     *
     * @param {string} component - The component to query.
     * @param {Query} query - The query details.
     * @param {number} offset - Starting offset.
     * @param {number} length - Length to retrieve.
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
     */
    abstract entity(model: string, keys: Array<string>, offset: number, length: number, layout: Array<number>): Promise<Array<bigint>>;
    /**
     * Abstract method to retrieve multiple entities' details.
     * Classes extending Provider should provide a concrete implementation for this method.
     *
     * @param {string} component - The component to query.
     * @param {number} length - Number of entities to retrieve.
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entities' details.
     */
    abstract entities(model: string, index: string | null, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    /**
     * Retrieves the stored world address.
     *
     * @returns {string} - The address of the world.
     */
    getWorldAddress(): string;
}

/**
 * DojoProvider: The DojoProvider is an execution provider for dojo worlds. It allows you to easily interact with a dojo world via the Starknet.js library.
 * ```ts
 * import { DojoProvider } from "@dojoengine/core";
 *
 * const provider = new DojoProvider(
 *      manifest
 * );
 * ```
 */
declare class DojoProvider extends Provider {
    provider: RpcProvider;
    contract: Contract;
    manifest: any;
    logger: ConsoleLogger;
    /**
     * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.
     *
     * @param {string} world_address - Address of the world.
     * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).
     */
    constructor(manifest?: any, url?: string, logLevel?: LogLevel);
    /**
     * Retrieves a single entity's details.
     *
     * @param {string} model - The component to query.
     * @param {Array<string>} keys - The keys to query.
     * @param {number} [offset=0] - Starting offset (defaults to 0).
     * @param {number} [length=0] - Length to retrieve (defaults to 0).
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
     */
    entity(model: string, keys: Array<string>, offset: number | undefined, length: number | undefined, layout: Array<number>): Promise<Array<bigint>>;
    /**
     * Retrieves multiple entities' details.
     *
     * @param {string} model - The component to query.
     * @param {number} index - The index to query.
     * @param {Array<string>} values - The values to query.
     * @param {number} valuesLength - The values length to query.
     * @param {Array<number>} valuesLayout - The values layout to query.
     */
    entities(model: string, index: string, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    /**
     * Retrieves a models
     *
     * @param {string} name - Name of the model.
     * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.
     */
    model(name: string): Promise<bigint>;
    /**
     * Retrieves current uuid from the world contract.
     *
     * @returns {Promise<number>} - A promise that resolves to the world uuid
     * @throws {Error} - Throws an error if the call fails.
     *
     * @example
     * const uuid = await provider.uuid();
     * console.log(uuid);
     * // => 6
     *
     */
    uuid(): Promise<number>;
    /**
     * Executes a function with the given parameters.
     * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.
     *
     * ```ts
     * await provider.execute(signer, { contractName, entrypoint, calldata });
     * await provider.execute(signer, { contractAddress, entrypoint, calldata });
     * await provider.execute(signer, [{ contractName, entrypoint, calldata }, { contractAddress, entrypoint, calldata }]);
     * ```
     * @param {Account} account - The account to use.
     * @param {AllowArray<DojoCall | Call>} call - The call or calls
     * @param {UniversalDetails} details - https://github.com/starknet-io/starknet.js/blob/5efa196017ee8f761ae837ecac9c059da8f3e09a/src/types/account.ts#L26
     * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
     */
    execute(account: Account | AccountInterface, call: AllowArray<DojoCall | Call>, nameSpace: string, details?: UniversalDetails): Promise<InvokeFunctionResponse>;
    /**
     * Calls a function with the given parameters and return parsed results for a DojoCall.
     *
     * ```ts
     * let parsedResult = await provider.call({ contractName, entrypoint, calldata });
     * ```
     * @param {DojoCall | Call} call - The dojoCall or call
     * @returns {Promise<Result>} - A promise that resolves to the response of the function call.
     */
    call(nameSpace: string, call: DojoCall | Call): Promise<CallResult>;
    /**
     * Calls a function with the given parameters.
     *
     * @param {string} nameSpace - The namespace of the contract within the world
     * @param {DojoCall | Call} call - The dojoCall or call
     * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.
     * @throws {Error} - Throws an error if the call fails.
     *
     * @example
     * const result = await provider.callRaw("namespace", { contractAddress, entrypoint, calldata });
     */
    callRaw(nameSpace: string, call: DojoCall | Call): Promise<CallContractResponse>;
}

/**
 * Gets a contract from a manifest by name.
 *
 * @param {any} manifest - The manifest object.
 * @param {string} name - The name of the contract.
 * @returns {any} The contract object.
 *
 */
declare const getContractByName: (manifest: any, nameSpace: string, name: string) => any;
/**
 * Convert a DojoCall to a Call replacing contractName with contractAddress
 *
 * @param {any} manifest - The manifest object.
 * @param {DojoCall | Call} call - A DojoCall or Call
 * @returns {Call} The contract object.
 *
 */
declare const parseDojoCall: (manifest: any, nameSpace: string, call: DojoCall | Call) => Call;
/**
 * Parses a model name into a class name.
 *
 * @param {any} model - The model object.
 * @returns {string} The class name.
 *
 */
declare const parseModelName: (model: any) => any;
/**
 * Creates a model typed data object.
 *
 * @param {any} model - The model object.
 * @returns {any} The model typed data object.
 *
 */
declare const createModelTypedData: (name: string, model: any) => TypedData;

type DojoConfig = ReturnType<typeof createDojoConfig>;
interface DojoConfigParams {
    rpcUrl?: string;
    toriiUrl?: string;
    masterAddress?: string;
    masterPrivateKey?: string;
    accountClassHash?: string;
    feeTokenAddress?: string;
    manifest: any;
}
/**
 * Create Dojo Config: Creates a Dojo Config object. If no parameters are passed, it will use the default values of the current Dojo version.
 */
declare function createDojoConfig({ manifest, ...config }: DojoConfigParams): {
    rpcUrl: string;
    toriiUrl: string;
    masterAddress: string;
    masterPrivateKey: string;
    accountClassHash: string;
    feeTokenAddress: string;
    manifest: any;
};

declare const LOCAL_KATANA = "http://127.0.0.1:5050";
declare const LOCAL_RELAY = "/ip4/127.0.0.1/tcp/9090";
declare const LOCAL_TORII = "http://127.0.0.1:8080";
declare const KATANA_PREFUNDED_ADDRESS = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec";
declare const KATANA_PREFUNDED_PRIVATE_KEY = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912";
declare const KATANA_CLASS_HASH = "0x07dc7899aa655b0aae51eadff6d801a58e97dd99cf4666ee59e704249e51adf2";
declare const KATANA_ETH_CONTRACT_ADDRESS = "0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";

declare const manifestSchema: z.ZodObject<{
    world: z.ZodObject<{
        class_hash: z.ZodString;
        name: z.ZodString;
        abi: z.ZodArray<z.ZodUnion<[z.ZodObject<{
            type: z.ZodLiteral<"impl">;
            name: z.ZodString;
            interface_name: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "impl";
            interface_name: string;
        }, {
            name: string;
            type: "impl";
            interface_name: string;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"struct">;
            name: z.ZodString;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"enum">;
            name: z.ZodString;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"interface">;
            name: z.ZodString;
            items: z.ZodArray<z.ZodObject<{
                type: z.ZodLiteral<"function">;
                name: z.ZodString;
                inputs: z.ZodArray<z.ZodObject<{
                    name: z.ZodString;
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    name: string;
                    type: string;
                }, {
                    name: string;
                    type: string;
                }>, "many">;
                outputs: z.ZodArray<z.ZodObject<{
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    type: string;
                }, {
                    type: string;
                }>, "many">;
                state_mutability: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"constructor">;
            name: z.ZodString;
            inputs: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"struct">;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"enum">;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }>]>, "many">;
    } & {
        kind: z.ZodLiteral<"WorldContract">;
        address: z.ZodString;
        transaction_hash: z.ZodString;
        block_number: z.ZodNumber;
        seed: z.ZodString;
        metadata: z.ZodObject<{
            rpc_url: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            rpc_url: string;
        }, {
            rpc_url: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        block_number: number;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        transaction_hash: string;
        class_hash: string;
        address: string;
        kind: "WorldContract";
        seed: string;
        metadata: {
            rpc_url: string;
        };
    }, {
        name: string;
        block_number: number;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        transaction_hash: string;
        class_hash: string;
        address: string;
        kind: "WorldContract";
        seed: string;
        metadata: {
            rpc_url: string;
        };
    }>;
    base: z.ZodObject<{
        class_hash: z.ZodString;
        name: z.ZodString;
    } & {
        kind: z.ZodLiteral<"Class">;
        abi: z.ZodLiteral<null>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        abi: null;
        class_hash: string;
        kind: "Class";
    }, {
        name: string;
        abi: null;
        class_hash: string;
        kind: "Class";
    }>;
    contracts: z.ZodArray<z.ZodObject<{
        class_hash: z.ZodString;
        name: z.ZodString;
        abi: z.ZodArray<z.ZodUnion<[z.ZodObject<{
            type: z.ZodLiteral<"impl">;
            name: z.ZodString;
            interface_name: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "impl";
            interface_name: string;
        }, {
            name: string;
            type: "impl";
            interface_name: string;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"struct">;
            name: z.ZodString;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"enum">;
            name: z.ZodString;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"interface">;
            name: z.ZodString;
            items: z.ZodArray<z.ZodObject<{
                type: z.ZodLiteral<"function">;
                name: z.ZodString;
                inputs: z.ZodArray<z.ZodObject<{
                    name: z.ZodString;
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    name: string;
                    type: string;
                }, {
                    name: string;
                    type: string;
                }>, "many">;
                outputs: z.ZodArray<z.ZodObject<{
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    type: string;
                }, {
                    type: string;
                }>, "many">;
                state_mutability: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"constructor">;
            name: z.ZodString;
            inputs: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"struct">;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"enum">;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }>]>, "many">;
    } & {
        kind: z.ZodLiteral<"DojoContract">;
        address: z.ZodString;
        reads: z.ZodArray<z.ZodUnknown, "many">;
        writes: z.ZodArray<z.ZodUnknown, "many">;
        computed: z.ZodArray<z.ZodUnknown, "many">;
    }, "strip", z.ZodTypeAny, {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        address: string;
        kind: "DojoContract";
        reads: unknown[];
        writes: unknown[];
        computed: unknown[];
    }, {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        address: string;
        kind: "DojoContract";
        reads: unknown[];
        writes: unknown[];
        computed: unknown[];
    }>, "many">;
    models: z.ZodArray<z.ZodObject<{
        class_hash: z.ZodString;
        name: z.ZodString;
        abi: z.ZodArray<z.ZodUnion<[z.ZodObject<{
            type: z.ZodLiteral<"impl">;
            name: z.ZodString;
            interface_name: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "impl";
            interface_name: string;
        }, {
            name: string;
            type: "impl";
            interface_name: string;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"struct">;
            name: z.ZodString;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"enum">;
            name: z.ZodString;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"interface">;
            name: z.ZodString;
            items: z.ZodArray<z.ZodObject<{
                type: z.ZodLiteral<"function">;
                name: z.ZodString;
                inputs: z.ZodArray<z.ZodObject<{
                    name: z.ZodString;
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    name: string;
                    type: string;
                }, {
                    name: string;
                    type: string;
                }>, "many">;
                outputs: z.ZodArray<z.ZodObject<{
                    type: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    type: string;
                }, {
                    type: string;
                }>, "many">;
                state_mutability: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }, {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }, {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"constructor">;
            name: z.ZodString;
            inputs: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
            }, {
                name: string;
                type: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }, {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"struct">;
            members: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }, {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"event">;
            name: z.ZodString;
            kind: z.ZodLiteral<"enum">;
            variants: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                type: z.ZodString;
                kind: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                type: string;
                kind: string;
            }, {
                name: string;
                type: string;
                kind: string;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }, {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        }>]>, "many">;
    } & {
        kind: z.ZodLiteral<"DojoModel">;
        members: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            type: z.ZodString;
            key: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: string;
            key: boolean;
        }, {
            name: string;
            type: string;
            key: boolean;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        members: {
            name: string;
            type: string;
            key: boolean;
        }[];
        kind: "DojoModel";
    }, {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        members: {
            name: string;
            type: string;
            key: boolean;
        }[];
        kind: "DojoModel";
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    base: {
        name: string;
        abi: null;
        class_hash: string;
        kind: "Class";
    };
    world: {
        name: string;
        block_number: number;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        transaction_hash: string;
        class_hash: string;
        address: string;
        kind: "WorldContract";
        seed: string;
        metadata: {
            rpc_url: string;
        };
    };
    contracts: {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        address: string;
        kind: "DojoContract";
        reads: unknown[];
        writes: unknown[];
        computed: unknown[];
    }[];
    models: {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        members: {
            name: string;
            type: string;
            key: boolean;
        }[];
        kind: "DojoModel";
    }[];
}, {
    base: {
        name: string;
        abi: null;
        class_hash: string;
        kind: "Class";
    };
    world: {
        name: string;
        block_number: number;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        transaction_hash: string;
        class_hash: string;
        address: string;
        kind: "WorldContract";
        seed: string;
        metadata: {
            rpc_url: string;
        };
    };
    contracts: {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        address: string;
        kind: "DojoContract";
        reads: unknown[];
        writes: unknown[];
        computed: unknown[];
    }[];
    models: {
        name: string;
        abi: ({
            name: string;
            type: "impl";
            interface_name: string;
        } | {
            name: string;
            type: "struct";
            members: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "enum";
            variants: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "interface";
            items: {
                name: string;
                type: "function";
                inputs: {
                    name: string;
                    type: string;
                }[];
                outputs: {
                    type: string;
                }[];
                state_mutability: string;
            }[];
        } | {
            name: string;
            type: "constructor";
            inputs: {
                name: string;
                type: string;
            }[];
        } | {
            name: string;
            type: "event";
            members: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "struct";
        } | {
            name: string;
            type: "event";
            variants: {
                name: string;
                type: string;
                kind: string;
            }[];
            kind: "enum";
        })[];
        class_hash: string;
        members: {
            name: string;
            type: string;
            key: boolean;
        }[];
        kind: "DojoModel";
    }[];
}>;
type Manifest = z.infer<typeof manifestSchema>;
declare const createManifestFromJson: (content: any) => Manifest;

export { type DojoCall, type DojoConfig, DojoProvider, type ExtractAbiTypes, type ExtractAbiTypesFromArray, type IWorld, KATANA_CLASS_HASH, KATANA_ETH_CONTRACT_ADDRESS, KATANA_PREFUNDED_ADDRESS, KATANA_PREFUNDED_PRIVATE_KEY, LOCAL_KATANA, LOCAL_RELAY, LOCAL_TORII, type Manifest, type MapCairoType, WorldEntryPoints, createDojoConfig, createManifestFromJson, createModelTypedData, getContractByName, parseDojoCall, parseModelName };
