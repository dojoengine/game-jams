{"version":3,"file":"index.js","sources":["../src/account.ts","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/enums.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/createDestructor.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/createLogger.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/getOriginFromSrc.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/errorSerialization.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/connectCallReceiver.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/generateId.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/methodSerialization.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/connectCallSender.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/handleAckMessageFactory.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/handleSynMessageFactory.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/monitorIframeRemoval.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/startConnectionTimeout.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","../../../node_modules/.pnpm/@cartridge+penpal@6.2.4/node_modules/@cartridge/penpal/lib/parent/connectToChild.js","../src/iframe/base.ts","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/_version.js","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/properties.js","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/errors.js","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js","../../../node_modules/.pnpm/ethers@6.13.7_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js","../src/wallets/argent/index.ts","../../../node_modules/.pnpm/mipd@0.0.7_typescript@5.8.3/node_modules/mipd/dist/esm/utils.js","../../../node_modules/.pnpm/mipd@0.0.7_typescript@5.8.3/node_modules/mipd/dist/esm/store.js","../src/wallets/platform.ts","../src/wallets/ethereum-base.ts","../src/wallets/base/index.ts","../src/wallets/metamask/index.ts","../../../node_modules/.pnpm/@scure+base@1.2.5/node_modules/@scure/base/lib/esm/index.js","../../../node_modules/.pnpm/micro-packed@0.7.3/node_modules/micro-packed/lib/esm/index.js","../../../node_modules/.pnpm/micro-sol-signer@0.5.0/node_modules/micro-sol-signer/lib/esm/index.js","../../../node_modules/.pnpm/base-x@5.0.1/node_modules/base-x/src/esm/index.js","../../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js","../src/utils/solana/index.ts","../src/wallets/phantom/index.ts","../src/wallets/rabby/index.ts","../src/wallets/braavos/index.ts","../src/wallets/bridge.ts","../src/iframe/keychain.ts","../src/controller.ts","../src/lookup.ts","../../../node_modules/.pnpm/@cartridge+presets@https+++codeload.github.com+cartridge-gg+presets+tar.gz+f60358b/node_modules/@cartridge/presets/dist/index.js"],"sourcesContent":["import {\n  InvokeFunctionResponse,\n  TypedData,\n  WalletAccount,\n  Call,\n  AllowArray,\n} from \"starknet\";\n\nimport {\n  ConnectError,\n  Keychain,\n  KeychainOptions,\n  Modal,\n  ResponseCodes,\n} from \"./types\";\nimport { AsyncMethodReturns } from \"@cartridge/penpal\";\nimport BaseProvider from \"./provider\";\nimport { toArray } from \"./utils\";\nimport { SIGNATURE } from \"@starknet-io/types-js\";\n\nclass ControllerAccount extends WalletAccount {\n  private keychain: AsyncMethodReturns<Keychain>;\n  private modal: Modal;\n  private options?: KeychainOptions;\n\n  constructor(\n    provider: BaseProvider,\n    rpcUrl: string,\n    address: string,\n    keychain: AsyncMethodReturns<Keychain>,\n    options: KeychainOptions,\n    modal: Modal,\n  ) {\n    super({\n      provider: { nodeUrl: rpcUrl },\n      walletProvider: provider,\n      address,\n    });\n\n    this.keychain = keychain;\n    this.options = options;\n    this.modal = modal;\n  }\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param calls the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abis (optional) the abi of the contract for better displaying\n   *\n   * @returns response from addTransaction\n   */\n  async execute(calls: AllowArray<Call>): Promise<InvokeFunctionResponse> {\n    calls = toArray(calls);\n\n    return new Promise(async (resolve, reject) => {\n      const sessionExecute = await this.keychain.execute(\n        calls,\n        undefined,\n        undefined,\n        false,\n        this.options?.feeSource,\n      );\n\n      // Session call succeeded\n      if (sessionExecute.code === ResponseCodes.SUCCESS) {\n        resolve(sessionExecute as InvokeFunctionResponse);\n        return;\n      }\n\n      // Propagates session txn error back to caller\n      if (\n        this.options?.propagateSessionErrors &&\n        sessionExecute.code !== ResponseCodes.USER_INTERACTION_REQUIRED\n      ) {\n        reject((sessionExecute as ConnectError).error);\n        return;\n      }\n\n      // Session call or Paymaster flow failed.\n      // Session not avaialble, manual flow fallback\n      this.modal.open();\n      const manualExecute = await this.keychain.execute(\n        calls,\n        undefined,\n        undefined,\n        true,\n        (sessionExecute as ConnectError).error,\n      );\n\n      // Manual call succeeded\n      if (manualExecute.code === ResponseCodes.SUCCESS) {\n        resolve(manualExecute as InvokeFunctionResponse);\n        this.modal.close();\n        return;\n      }\n\n      reject((manualExecute as ConnectError).error);\n      return;\n    });\n  }\n\n  /**\n   * Sign an JSON object for off-chain usage with the starknet private key and return the signature\n   * This adds a message prefix so it cant be interchanged with transactions\n   *\n   * @param json - JSON object to be signed\n   * @returns the signature of the JSON object\n   * @throws {Error} if the JSON object is not a valid JSON\n   */\n  async signMessage(typedData: TypedData): Promise<SIGNATURE> {\n    return new Promise(async (resolve, reject) => {\n      const sessionSign = await this.keychain.signMessage(typedData, \"\", true);\n\n      // Session sign succeeded\n      if (!(\"code\" in sessionSign)) {\n        resolve(sessionSign as SIGNATURE);\n        return;\n      }\n\n      // Session not avaialble, manual flow fallback\n      this.modal.open();\n      const manualSign = await this.keychain.signMessage(typedData, \"\", false);\n\n      if (!(\"code\" in manualSign)) {\n        resolve(manualSign as SIGNATURE);\n      } else {\n        reject((manualSign as ConnectError).error);\n      }\n      this.modal.close();\n    });\n  }\n}\n\nexport default ControllerAccount;\n","export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName]\n            .call(serializedMethods, event.origin)\n            .apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        // Under specific timing circumstances, we can receive an event\n        // whose source is null. This seems to happen when the child iframe is\n        // removed from the DOM about the same time it has sent the SYN event.\n        // https://github.com/Aaronius/penpal/issues/85\n        if (!event.source) {\n            return;\n        }\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","import { AsyncMethodReturns, connectToChild } from \"@cartridge/penpal\";\nimport { ControllerOptions, Modal } from \"../types\";\n\nexport type IFrameOptions<CallSender> = Omit<\n  ConstructorParameters<typeof IFrame>[0],\n  \"id\" | \"url\" | \"onConnect\"\n> & {\n  url?: string;\n  onConnect: (child: AsyncMethodReturns<CallSender>) => void;\n};\n\nexport class IFrame<CallSender extends {}> implements Modal {\n  url?: URL;\n  private iframe?: HTMLIFrameElement;\n  private container?: HTMLDivElement;\n  private onClose?: () => void;\n  private child?: AsyncMethodReturns<CallSender>;\n  private closeTimeout?: NodeJS.Timeout;\n\n  constructor({\n    id,\n    url,\n    preset,\n    onClose,\n    onConnect,\n    methods = {},\n  }: Pick<ControllerOptions, \"preset\"> & {\n    id: string;\n    url: URL;\n    onClose?: () => void;\n    onConnect: (child: AsyncMethodReturns<CallSender>) => void;\n    methods?: { [key: string]: (...args: any[]) => void };\n  }) {\n    if (typeof document === \"undefined\" || typeof window === \"undefined\") {\n      return;\n    }\n\n    if (preset) {\n      url.searchParams.set(\"preset\", preset);\n    }\n\n    this.url = url;\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.src = url.toString();\n    iframe.id = id;\n    iframe.style.border = \"none\";\n    iframe.sandbox.add(\"allow-forms\");\n    iframe.sandbox.add(\"allow-popups\");\n    iframe.sandbox.add(\"allow-popups-to-escape-sandbox\");\n    iframe.sandbox.add(\"allow-scripts\");\n    iframe.sandbox.add(\"allow-same-origin\");\n    iframe.allow =\n      \"publickey-credentials-create *; publickey-credentials-get *; clipboard-write\";\n    if (!!document.hasStorageAccess) {\n      iframe.sandbox.add(\"allow-storage-access-by-user-activation\");\n    }\n\n    const container = document.createElement(\"div\");\n    container.id = \"controller\";\n    container.style.position = \"fixed\";\n    container.style.height = \"100%\";\n    container.style.width = \"100%\";\n    container.style.top = \"0\";\n    container.style.left = \"0\";\n    container.style.zIndex = \"10000\";\n    container.style.backgroundColor = \"rgba(0,0,0,0.6)\";\n    container.style.display = \"none\"; // Use display: none to completely hide from password managers\n    container.style.alignItems = \"center\";\n    container.style.justifyContent = \"center\";\n    container.style.transition = \"opacity 0.2s ease\";\n    container.style.opacity = \"0\";\n    container.style.pointerEvents = \"auto\";\n    container.appendChild(iframe);\n\n    // Add click event listener to close iframe when clicking outside\n    container.addEventListener(\"click\", (e) => {\n      if (e.target === container) {\n        // Attempting to reset(clear context) for keychain iframe (identified by ID)\n        if (id === \"controller-keychain\" && this.child) {\n          // Type assertion for keychain child only\n          (this.child as any)\n            .reset?.()\n            .catch((e: any) => console.error(\"Error resetting context:\", e));\n        }\n        this.close();\n      }\n    });\n\n    this.iframe = iframe;\n    this.container = container;\n\n    connectToChild<CallSender>({\n      iframe: this.iframe,\n      methods: {\n        close: (_origin: string) => () => this.close(),\n        reload: (_origin: string) => () => window.location.reload(),\n        ...methods,\n      },\n    }).promise.then((child) => {\n      this.child = child;\n      onConnect(child);\n    });\n\n    this.resize();\n    window.addEventListener(\"resize\", () => this.resize());\n\n    const observer = new MutationObserver(() => {\n      if (typeof document === \"undefined\") return;\n      const existingController = document.getElementById(\"controller\");\n      if (document.body) {\n        if (id === \"controller-keychain\" && !existingController) {\n          document.body.appendChild(container);\n          observer.disconnect();\n        }\n      }\n    });\n\n    observer.observe(document.documentElement, {\n      childList: true,\n      subtree: true,\n    });\n\n    const existingController = document.getElementById(\"controller\");\n    if (document.body) {\n      if (id === \"controller-keychain\" && !existingController) {\n        document.body.appendChild(container);\n      }\n    }\n\n    this.onClose = onClose;\n  }\n\n  open() {\n    if (!this.container || typeof document === \"undefined\" || !document.body)\n      return;\n\n    // Clear any pending close timeout to prevent race condition\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = undefined;\n    }\n\n    document.body.style.overflow = \"hidden\";\n\n    this.container.style.display = \"flex\";\n    // Use requestAnimationFrame to ensure display change is processed before opacity change\n    requestAnimationFrame(() => {\n      if (this.container) {\n        this.container.style.opacity = \"1\";\n      }\n    });\n  }\n\n  close() {\n    if (!this.container || typeof document === \"undefined\" || !document.body)\n      return;\n    this.onClose?.();\n\n    document.body.style.overflow = \"auto\";\n\n    // Start fade-out transition\n    this.container.style.opacity = \"0\";\n\n    // Set display: none after transition completes (200ms)\n    this.closeTimeout = setTimeout(() => {\n      if (this.container) {\n        this.container.style.display = \"none\";\n      }\n      this.closeTimeout = undefined;\n    }, 200);\n  }\n\n  sendBackward() {\n    if (!this.container) return;\n    this.container.style.zIndex = \"9999\";\n  }\n\n  sendForward() {\n    if (!this.container) return;\n    this.container.style.zIndex = \"10000\";\n  }\n\n  private resize() {\n    if (!this.iframe || typeof window === \"undefined\") return;\n\n    this.iframe.style.userSelect = \"none\";\n\n    if (window.innerWidth < 768) {\n      this.iframe.style.height = \"100%\";\n      this.iframe.style.width = \"100%\";\n      this.iframe.style.borderRadius = \"0\";\n      return;\n    }\n\n    this.iframe.style.height = \"600px\";\n    this.iframe.style.width = \"432px\";\n    this.iframe.style.borderRadius = \"8px\";\n  }\n\n  isOpen() {\n    return this.container?.style.display !== \"none\";\n  }\n}\n","/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nexport const version = \"6.13.7\";\n//# sourceMappingURL=_version.js.map","/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map","/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nimport { version } from \"../_version.js\";\nimport { defineProperties } from \"./properties.js\";\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    defineProperties(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        defineProperties(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexport function assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\";\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        swap32IfBE(this.state32);\n        keccakP(this.state32, this.rounds);\n        swap32IfBE(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map","/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\nimport { keccak_256 } from \"@noble/hashes/sha3\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\nconst _keccak256 = function (data) {\n    return keccak_256(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map","import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map","import { Call, TypedData, StarknetWindowObject } from \"@starknet-io/types-js\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\nexport class ArgentWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"argent\";\n  readonly platform: ExternalPlatform = \"starknet\";\n  private wallet: StarknetWindowObject | undefined = undefined;\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n  private accountChangeListener: ((accounts?: string[]) => void) | undefined =\n    undefined;\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.starknet_argentX;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available\n        ? window.starknet_argentX?.version || \"Unknown\"\n        : undefined,\n      chainId: available ? window.starknet_argentX?.chainId : undefined,\n      name: \"Argent\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Argent is not available\");\n      }\n\n      const wallet = window.starknet_argentX as StarknetWindowObject;\n      if (!wallet) {\n        throw new Error(\"No wallet found\");\n      }\n\n      // Request accounts from the wallet\n      const accounts = await wallet.request({\n        type: \"wallet_requestAccounts\",\n        params: { silent_mode: false },\n      });\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error(\"No accounts found\");\n      }\n\n      this.removeAccountChangeListener();\n\n      this.wallet = wallet;\n      this.account = accounts[0];\n      this.connectedAccounts = accounts;\n      this.setupAccountChangeListener();\n      return { success: true, wallet: this.type, account: this.account };\n    } catch (error) {\n      console.error(`Error connecting to Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signTypedData(data: TypedData): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Argent is not connected\");\n      }\n\n      const sig = await this.wallet.request({\n        type: \"wallet_signTypedData\",\n        params: data,\n      });\n\n      return { success: true, wallet: this.type, result: sig };\n    } catch (error) {\n      console.error(`Error signing typed data with Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(calls: Call[]): Promise<ExternalWalletResponse> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    try {\n      const result = await this.wallet.request({\n        type: \"wallet_addInvokeTransaction\",\n        params: {\n          calls,\n        },\n      });\n\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    const result = await this.wallet.request({\n      type: \"wallet_switchStarknetChain\",\n      params: {\n        chainId,\n      },\n    });\n\n    return result;\n  }\n\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Argent is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Argent's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Argent API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Argent:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Argent wallet\",\n    };\n  }\n\n  private setupAccountChangeListener(): void {\n    if (!this.wallet) return;\n\n    this.accountChangeListener = (accounts: string[] | undefined) => {\n      if (accounts && accounts.length > 0) {\n        this.account = accounts[0];\n        this.connectedAccounts = accounts;\n      } else {\n        this.account = undefined;\n        this.connectedAccounts = [];\n      }\n    };\n\n    // Listen for account changes\n    this.wallet.on(\"accountsChanged\", this.accountChangeListener);\n  }\n\n  private removeAccountChangeListener(): void {\n    if (this.wallet && this.accountChangeListener) {\n      this.wallet.off(\"accountsChanged\", this.accountChangeListener);\n      this.accountChangeListener = undefined;\n    }\n  }\n\n  disconnect(): void {\n    this.removeAccountChangeListener();\n    this.wallet = undefined;\n    this.account = undefined;\n    this.connectedAccounts = [];\n  }\n}\n","/**\n * Announces an EIP-1193 Provider.\n */\nexport function announceProvider(detail) {\n    const event = new CustomEvent('eip6963:announceProvider', { detail: Object.freeze(detail) });\n    window.dispatchEvent(event);\n    const handler = () => window.dispatchEvent(event);\n    window.addEventListener('eip6963:requestProvider', handler);\n    return () => window.removeEventListener('eip6963:requestProvider', handler);\n}\n/**\n * Watches for EIP-1193 Providers to be announced.\n */\nexport function requestProviders(listener) {\n    if (typeof window === 'undefined')\n        return;\n    const handler = (event) => listener(event.detail);\n    window.addEventListener('eip6963:announceProvider', handler);\n    window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));\n    return () => window.removeEventListener('eip6963:announceProvider', handler);\n}\n//# sourceMappingURL=utils.js.map","import { requestProviders } from './utils.js';\nexport function createStore() {\n    const listeners = new Set();\n    let providerDetails = [];\n    const request = () => requestProviders((providerDetail) => {\n        if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))\n            return;\n        providerDetails = [...providerDetails, providerDetail];\n        listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));\n    });\n    let unwatch = request();\n    return {\n        _listeners() {\n            return listeners;\n        },\n        clear() {\n            listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));\n            providerDetails = [];\n        },\n        destroy() {\n            this.clear();\n            listeners.clear();\n            unwatch?.();\n        },\n        findProvider({ rdns }) {\n            return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);\n        },\n        getProviders() {\n            return providerDetails;\n        },\n        reset() {\n            this.clear();\n            unwatch?.();\n            unwatch = request();\n        },\n        subscribe(listener, { emitImmediately } = {}) {\n            listeners.add(listener);\n            if (emitImmediately)\n                listener(providerDetails, { added: providerDetails });\n            return () => listeners.delete(listener);\n        },\n    };\n}\n//# sourceMappingURL=store.js.map","import { constants, num } from \"starknet\";\nimport type { ExternalPlatform } from \"./types\";\n\nconst PLATFORMS: Record<string, ExternalPlatform> = {\n  \"0x1\": \"ethereum\", // ethereum mainnet\n  \"0xaa36a7\": \"ethereum\", // ethereum sepolia\n  \"0x14a34\": \"base\", // base mainnet\n  \"0x2105\": \"base\", // base sepolia\n  \"0x66eee\": \"arbitrum\", // arbitrum mainnet\n  \"0xa4b1\": \"arbitrum\", // arbitrum sepolia\n  \"0xa\": \"optimism\", // op mainnet\n  \"0xaa37dc\": \"optimism\", // op sepolia\n  [constants.StarknetChainId.SN_MAIN]: \"starknet\",\n  [constants.StarknetChainId.SN_SEPOLIA]: \"starknet\",\n};\n\nexport const chainIdToPlatform = (\n  chainId: string,\n): ExternalPlatform | undefined => {\n  const hex = num.toHex(chainId);\n  const platform = PLATFORMS[hex];\n  if (!platform) {\n    console.warn(`Unknown chain ID: ${hex}`);\n  }\n  return platform;\n};\n","import { getAddress } from \"ethers/address\";\nimport { createStore, EIP6963ProviderDetail } from \"mipd\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\nimport { chainIdToPlatform } from \"./platform\";\n\nexport abstract class EthereumWalletBase implements WalletAdapter {\n  abstract readonly type: ExternalWalletType;\n  abstract readonly rdns: string;\n  abstract readonly displayName: string;\n\n  platform: ExternalPlatform | undefined;\n  protected account: string | undefined = undefined;\n  protected store = createStore();\n  protected provider: EIP6963ProviderDetail | undefined;\n  protected connectedAccounts: string[] = [];\n\n  constructor() {\n    this.initializeIfAvailable();\n  }\n\n  private getProvider(): EIP6963ProviderDetail | undefined {\n    if (!this.provider) {\n      this.provider = this.store\n        .getProviders()\n        .find((provider) => provider.info.rdns === this.rdns);\n    }\n    return this.provider;\n  }\n\n  private getEthereumProvider(): any {\n    const provider = this.getProvider();\n    if (provider) {\n      return provider.provider;\n    }\n\n    // Fallback for MetaMask when not announced via EIP-6963\n    if (\n      this.rdns === \"io.metamask\" &&\n      typeof window !== \"undefined\" &&\n      (window as any).ethereum?.isMetaMask\n    ) {\n      return (window as any).ethereum;\n    }\n\n    return null;\n  }\n\n  private initializeIfAvailable(): void {\n    const provider = this.getProvider();\n    if (provider && !this.initialized) {\n      this.initialized = true;\n      this.initializeProvider();\n    }\n  }\n\n  private initialized = false;\n\n  private initializeProvider(): void {\n    const provider = this.getProvider();\n    if (!provider) return;\n\n    provider.provider\n      .request({\n        method: \"eth_accounts\",\n      })\n      .then((accounts) => {\n        this.connectedAccounts = accounts.map(getAddress);\n        if (accounts.length > 0) {\n          this.account = getAddress(accounts[0]);\n        }\n      })\n      .catch(console.error);\n\n    provider.provider\n      .request({\n        method: \"eth_chainId\",\n      })\n      .then((chainId) => {\n        this.platform = chainIdToPlatform(chainId);\n      })\n      .catch(console.error);\n\n    provider.provider?.on(\"chainChanged\", (chainId: string) => {\n      this.platform = chainIdToPlatform(chainId);\n    });\n\n    provider.provider?.on(\"accountsChanged\", (accounts: string[]) => {\n      if (accounts) {\n        this.connectedAccounts = accounts.map((account) => getAddress(account));\n        this.account =\n          accounts.length > 0 ? getAddress(accounts[0]) : undefined;\n      }\n    });\n  }\n\n  isAvailable(): boolean {\n    // Check dynamically each time, as the provider might be announced after instantiation\n    const provider = this.getProvider();\n\n    // Also check for MetaMask via window.ethereum as a fallback for MetaMask specifically\n    if (\n      !provider &&\n      this.rdns === \"io.metamask\" &&\n      typeof window !== \"undefined\"\n    ) {\n      // MetaMask might be available via window.ethereum even if not announced via EIP-6963 yet\n      return !!(window as any).ethereum?.isMetaMask;\n    }\n\n    // Initialize if we just found the provider\n    if (provider && !this.initialized) {\n      this.initializeIfAvailable();\n    }\n\n    return typeof window !== \"undefined\" && !!provider;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available ? window.ethereum?.version || \"Unknown\" : undefined,\n      chainId: available ? window.ethereum?.chainId : undefined,\n      name: this.displayName,\n      platform: this.platform,\n      connectedAccounts: this.connectedAccounts,\n    };\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async connect(address?: string): Promise<ExternalWalletResponse<any>> {\n    if (address && this.connectedAccounts.includes(getAddress(address))) {\n      this.account = getAddress(address);\n    }\n\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not available`);\n      }\n\n      let ethereum: any;\n      const provider = this.getProvider();\n\n      if (provider) {\n        ethereum = provider.provider;\n      } else if (\n        this.rdns === \"io.metamask\" &&\n        (window as any).ethereum?.isMetaMask\n      ) {\n        // Fallback for MetaMask when not announced via EIP-6963\n        ethereum = (window as any).ethereum;\n      }\n\n      if (!ethereum) {\n        throw new Error(`${this.displayName} provider not found`);\n      }\n\n      const accounts = await ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n\n      if (accounts && accounts.length > 0) {\n        this.account = getAddress(accounts[0]);\n        this.connectedAccounts = accounts.map(getAddress);\n\n        // If we used the fallback, store the ethereum provider for future use\n        if (!provider && this.rdns === \"io.metamask\") {\n          // Create a mock EIP6963ProviderDetail for consistency\n          this.provider = {\n            info: {\n              uuid: \"metamask-fallback\",\n              name: \"MetaMask\",\n              icon: \"data:image/svg+xml;base64,\",\n              rdns: \"io.metamask\",\n            },\n            provider: ethereum,\n          } as EIP6963ProviderDetail;\n          this.initializeIfAvailable();\n        }\n\n        return { success: true, wallet: this.type, account: this.account };\n      }\n\n      throw new Error(\"No accounts found\");\n    } catch (error) {\n      console.error(`Error connecting to ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signTransaction(\n    transaction: any,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [transaction],\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error signing transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signMessage(\n    message: string | `0x${string}`,\n    address?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} provider not found`);\n      }\n      const result = await ethereum.request({\n        method: \"personal_sign\",\n        params: [message, address || this.account] as any,\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(`Error signing message with ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async signTypedData(data: any): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.account, JSON.stringify(data)] as any,\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error signing typed data with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(txn: any): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const result = await ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [txn],\n      });\n\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(\n        `Error sending transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not available`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      try {\n        await ethereum.request({\n          method: \"wallet_switchEthereumChain\",\n          params: [{ chainId }],\n        });\n\n        this.platform = chainIdToPlatform(chainId);\n        return true;\n      } catch (error) {\n        if ((error as any).code === 4902) {\n          console.warn(`Chain not added to ${this.displayName}`);\n        }\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error switching chain for ${this.displayName}:`, error);\n      return false;\n    }\n  }\n\n  async getBalance(\n    tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      if (tokenAddress) {\n        return {\n          success: false,\n          wallet: this.type,\n          error: \"Not implemented for ERC20\",\n        };\n      } else {\n        const ethereum = this.getEthereumProvider();\n        if (!ethereum) {\n          throw new Error(`${this.displayName} is not connected`);\n        }\n\n        const balance = await ethereum.request({\n          method: \"eth_getBalance\",\n          params: [this.account, \"latest\"] as any,\n        });\n        return { success: true, wallet: this.type, result: balance };\n      }\n    } catch (error) {\n      console.error(`Error getting balance from ${this.displayName}:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    txHash: string,\n    timeoutMs: number = 60000,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const ethereum = this.getEthereumProvider();\n      if (!ethereum) {\n        throw new Error(`${this.displayName} is not connected`);\n      }\n\n      const startTime = Date.now();\n      const pollInterval = 1000; // 1 second\n\n      while (Date.now() - startTime < timeoutMs) {\n        const receipt = await ethereum.request({\n          method: \"eth_getTransactionReceipt\",\n          params: [txHash as `0x${string}`],\n        });\n\n        if (receipt) {\n          return {\n            success: true,\n            wallet: this.type,\n            result: receipt,\n          };\n        }\n\n        // Wait before polling again\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n      }\n\n      throw new Error(\"Transaction confirmation timed out\");\n    } catch (error) {\n      console.error(\n        `Error waiting for transaction with ${this.displayName}:`,\n        error,\n      );\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n}\n","import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class BaseWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"base\";\n  readonly rdns = \"com.coinbase.wallet\";\n  readonly displayName = \"Base Wallet\";\n}\n","import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class MetaMaskWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"metamask\";\n  readonly rdns = \"io.metamask\";\n  readonly displayName = \"MetaMask\";\n}\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// TODO: temporarily set to false, trying to understand bugs\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) {\n        astr('base64', s);\n        return Uint8Array.fromBase64(s, { lastChunkHandling: 'strict' });\n    },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { astr('base64', s); return Uint8Array.fromBase64(s, { alphabet: 'base64url' }); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nexport const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map","import { hex as baseHex, utf8 } from '@scure/base';\n/**\n * Define complex binary structures using composable primitives.\n * Main ideas:\n * - Encode / decode can be chained, same as in `scure-base`\n * - A complex structure can be created from an array and struct of primitive types\n * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly\n *   without creating plain array first and reading each byte separately.\n * - Types are inferred from definition\n * @module\n * @example\n * import * as P from 'micro-packed';\n * const s = P.struct({\n *   field1: P.U32BE, // 32-bit unsigned big-endian integer\n *   field2: P.string(P.U8), // String with U8 length prefix\n *   field3: P.bytes(32), // 32 bytes\n *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length\n *     subField1: P.U64BE, // 64-bit unsigned big-endian integer\n *     subField2: P.string(10) // 10-byte string\n *   }))\n * });\n */\n// TODO: remove dependency on scure-base & inline?\n/*\nExports can be groupped like this:\n\n- Primitive types: P.bytes, P.string, P.hex, P.constant, P.pointer\n- Complex types: P.array, P.struct, P.tuple, P.map, P.tag, P.mappedTag\n- Padding, prefix, magic: P.padLeft, P.padRight, P.prefix, P.magic, P.magicBytes\n- Flags: P.flag, P.flagged, P.optional\n- Wrappers: P.apply, P.wrap, P.lazy\n- Bit fiddling: P.bits, P.bitset\n- utils: P.validate, coders.decimal\n- Debugger\n*/\n/** Shortcut to zero-length (empty) byte array */\nexport const EMPTY = /* @__PURE__ */ new Uint8Array();\n/** Shortcut to one-element (element is 0) byte array */\nexport const NULL = /* @__PURE__ */ new Uint8Array([0]);\n/** Checks if two Uint8Arrays are equal. Not constant-time. */\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\n/** Checks if the given value is a Uint8Array. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/**\n * Concatenates multiple Uint8Arrays.\n * Engines limit functions to 65K+ arguments.\n * @param arrays Array of Uint8Array elements\n * @returns Concatenated Uint8Array\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/**\n * Creates DataView from Uint8Array\n * @param arr - bytes\n * @returns DataView\n */\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n/**\n * Checks if the provided value is a plain object, not created from any class or special constructor.\n * Array, Uint8Array and others are not plain objects.\n * @param obj - The value to be checked.\n */\nfunction isPlainObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\nfunction isNum(num) {\n    return Number.isSafeInteger(num);\n}\nexport const utils = {\n    equalBytes,\n    isBytes,\n    isCoder,\n    checkBounds,\n    concatBytes,\n    createView,\n    isPlainObject,\n};\n// NOTE: we can't have terminator separate function, since it won't know about boundaries\n// E.g. array of U16LE ([1,2,3]) would be [1, 0, 2, 0, 3, 0]\n// But terminator will find array at index '1', which happens to be inside of an element itself\n/**\n * Can be:\n * - Dynamic (CoderType)\n * - Fixed (number)\n * - Terminated (usually zero): Uint8Array with terminator\n * - Field path to field with length (string)\n * - Infinity (null) - decodes until end of buffer\n * Used in:\n * - bytes (string, prefix is implementation of bytes)\n * - array\n */\nconst lengthCoder = (len) => {\n    if (len !== null && typeof len !== 'string' && !isCoder(len) && !isBytes(len) && !isNum(len)) {\n        throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${len} (${typeof len})`);\n    }\n    return {\n        encodeStream(w, value) {\n            if (len === null)\n                return;\n            if (isCoder(len))\n                return len.encodeStream(w, value);\n            let byteLen;\n            if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(w.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (byteLen === undefined || byteLen !== value)\n                throw w.err(`Wrong length: ${byteLen} len=${len} exp=${value} (${typeof value})`);\n        },\n        decodeStream(r) {\n            let byteLen;\n            if (isCoder(len))\n                byteLen = Number(len.decodeStream(r));\n            else if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(r.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (typeof byteLen !== 'number')\n                throw r.err(`Wrong length: ${byteLen}`);\n            return byteLen;\n        },\n    };\n};\n/**\n * Small bitset structure to store position of ranges that have been read.\n * Can be more efficient when internal trees are utilized at the cost of complexity.\n * Needs `O(N/8)` memory for parsing.\n * Purpose: if there are pointers in parsed structure,\n * they can cause read of two distinct ranges:\n * [0-32, 64-128], which means 'pos' is not enough to handle them\n */\nconst Bitset = {\n    BITS: 32,\n    FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n    len: (len) => Math.ceil(len / 32),\n    create: (len) => new Uint32Array(Bitset.len(len)),\n    clean: (bs) => bs.fill(0),\n    debug: (bs) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n    checkLen: (bs, len) => {\n        if (Bitset.len(len) === bs.length)\n            return;\n        throw new Error(`wrong length=${bs.length}. Expected: ${Bitset.len(len)}`);\n    },\n    chunkLen: (bsLen, pos, len) => {\n        if (pos < 0)\n            throw new Error(`wrong pos=${pos}`);\n        if (pos + len > bsLen)\n            throw new Error(`wrong range=${pos}/${len} of ${bsLen}`);\n    },\n    set: (bs, chunk, value, allowRewrite = true) => {\n        if (!allowRewrite && (bs[chunk] & value) !== 0)\n            return false;\n        bs[chunk] |= value;\n        return true;\n    },\n    pos: (pos, i) => ({\n        chunk: Math.floor((pos + i) / 32),\n        mask: 1 << (32 - ((pos + i) % 32) - 1),\n    }),\n    indices: (bs, len, invert = false) => {\n        Bitset.checkLen(bs, len);\n        const { FULL_MASK, BITS } = Bitset;\n        const left = BITS - (len % BITS);\n        const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n        const res = [];\n        for (let i = 0; i < bs.length; i++) {\n            let c = bs[i];\n            if (invert)\n                c = ~c; // allows to gen unset elements\n            // apply mask to last element, so we won't iterate non-existent items\n            if (i === bs.length - 1)\n                c &= lastMask;\n            if (c === 0)\n                continue; // fast-path\n            for (let j = 0; j < BITS; j++) {\n                const m = 1 << (BITS - j - 1);\n                if (c & m)\n                    res.push(i * BITS + j);\n            }\n        }\n        return res;\n    },\n    range: (arr) => {\n        const res = [];\n        let cur;\n        for (const i of arr) {\n            if (cur === undefined || i !== cur.pos + cur.length)\n                res.push((cur = { pos: i, length: 1 }));\n            else\n                cur.length += 1;\n        }\n        return res;\n    },\n    rangeDebug: (bs, len, invert = false) => `[${Bitset.range(Bitset.indices(bs, len, invert))\n        .map((i) => `(${i.pos}/${i.length})`)\n        .join(', ')}]`,\n    setRange: (bs, bsLen, pos, len, allowRewrite = true) => {\n        Bitset.chunkLen(bsLen, pos, len);\n        const { FULL_MASK, BITS } = Bitset;\n        // Try to set range with maximum efficiency:\n        // - first chunk is always    '0000[1111]' (only right ones)\n        // - middle chunks are set to '[1111 1111]' (all ones)\n        // - last chunk is always     '[1111]0000' (only left ones)\n        // - max operations:          (N/32) + 2 (first and last)\n        const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n        const lastPos = pos + len;\n        const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n        // special case, whole range inside single chunk\n        if (first !== undefined && first === last)\n            return Bitset.set(bs, first, (FULL_MASK >>> (BITS - len)) << (BITS - len - pos), allowRewrite);\n        if (first !== undefined) {\n            if (!Bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite))\n                return false; // first chunk\n        }\n        // middle chunks\n        const start = first !== undefined ? first + 1 : pos / BITS;\n        const end = last !== undefined ? last : lastPos / BITS;\n        for (let i = start; i < end; i++)\n            if (!Bitset.set(bs, i, FULL_MASK, allowRewrite))\n                return false;\n        if (last !== undefined && first !== last)\n            if (!Bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite))\n                return false; // last chunk\n        return true;\n    },\n};\nconst Path = {\n    /**\n     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n     * Also, this makes impossible:\n     * - pushing field when stack is empty\n     * - pushing field inside of field (real bug)\n     * NOTE: we don't want to do '.pop' on error!\n     */\n    pushObj: (stack, obj, objFn) => {\n        const last = { obj };\n        stack.push(last);\n        objFn((field, fieldFn) => {\n            last.field = field;\n            fieldFn();\n            last.field = undefined;\n        });\n        stack.pop();\n    },\n    path: (stack) => {\n        const res = [];\n        for (const i of stack)\n            if (i.field !== undefined)\n                res.push(i.field);\n        return res.join('/');\n    },\n    err: (name, stack, msg) => {\n        const err = new Error(`${name}(${Path.path(stack)}): ${typeof msg === 'string' ? msg : msg.message}`);\n        if (msg instanceof Error && msg.stack)\n            err.stack = msg.stack;\n        return err;\n    },\n    resolve: (stack, path) => {\n        const parts = path.split('/');\n        const objPath = stack.map((i) => i.obj);\n        let i = 0;\n        for (; i < parts.length; i++) {\n            if (parts[i] === '..')\n                objPath.pop();\n            else\n                break;\n        }\n        let cur = objPath.pop();\n        for (; i < parts.length; i++) {\n            if (!cur || cur[parts[i]] === undefined)\n                return undefined;\n            cur = cur[parts[i]];\n        }\n        return cur;\n    },\n};\n/**\n * Internal structure. Reader class for reading from a byte array.\n * `stack` is internal: for debugger and logging\n * @class Reader\n */\nclass _Reader {\n    constructor(data, opts = {}, stack = [], parent = undefined, parentOffset = 0) {\n        this.pos = 0;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.data = data;\n        this.opts = opts;\n        this.stack = stack;\n        this.parent = parent;\n        this.parentOffset = parentOffset;\n        this.view = createView(data);\n    }\n    /** Internal method for pointers. */\n    _enablePointers() {\n        if (this.parent)\n            return this.parent._enablePointers();\n        if (this.bs)\n            return;\n        this.bs = Bitset.create(this.data.length);\n        Bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n    }\n    markBytesBS(pos, len) {\n        if (this.parent)\n            return this.parent.markBytesBS(this.parentOffset + pos, len);\n        if (!len)\n            return true;\n        if (!this.bs)\n            return true;\n        return Bitset.setRange(this.bs, this.data.length, pos, len, false);\n    }\n    markBytes(len) {\n        const pos = this.pos;\n        this.pos += len;\n        const res = this.markBytesBS(pos, len);\n        if (!this.opts.allowMultipleReads && !res)\n            throw this.err(`multiple read pos=${this.pos} len=${len}`);\n        return res;\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    readView(n, fn) {\n        if (!Number.isFinite(n))\n            throw this.err(`readView: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readView: Unexpected end of buffer');\n        const res = fn(this.view, this.pos);\n        this.markBytes(n);\n        return res;\n    }\n    // read bytes by absolute offset\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    finish() {\n        if (this.opts.allowUnreadBytes)\n            return;\n        if (this.bitPos) {\n            throw this.err(`${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n        if (this.bs && !this.parent) {\n            const notRead = Bitset.indices(this.bs, this.data.length, true);\n            if (notRead.length) {\n                const formatted = Bitset.range(notRead)\n                    .map(({ pos, length }) => `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`)\n                    .join(', ');\n                throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n            }\n            else\n                return; // all bytes read, everything is ok\n        }\n        // Default: no pointers enabled\n        if (!this.isEnd()) {\n            throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n    }\n    // User methods\n    err(msg) {\n        return Path.err('Reader', this.stack, msg);\n    }\n    offsetReader(n) {\n        if (n > this.data.length)\n            throw this.err('offsetReader: Unexpected end of buffer');\n        return new _Reader(this.absBytes(n), this.opts, this.stack, this, n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.markBytes(n);\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        if (this.pos + 1 > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const data = this.data[this.pos];\n        if (!peek)\n            this.markBytes(1);\n        return data;\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    get totalBytes() {\n        return this.data.length;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.byte();\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        // Fix signed integers\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        // indexOf should be faster than full equalBytes check\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n        return;\n    }\n}\n/**\n * Internal structure. Writer class for writing to a byte array.\n * The `stack` argument of constructor is internal, for debugging and logs.\n * @class Writer\n */\nclass _Writer {\n    constructor(stack = []) {\n        this.pos = 0;\n        // We could have a single buffer here and re-alloc it with\n        // x1.5-2 size each time it full, but it will be slower:\n        // basic/encode bench: 395ns -> 560ns\n        this.buffers = [];\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.viewBuf = new Uint8Array(8);\n        this.finished = false;\n        this.stack = stack;\n        this.view = createView(this.viewBuf);\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    writeView(len, fn) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (!isNum(len) || len > 8)\n            throw new Error(`wrong writeView length=${len}`);\n        fn(this.view);\n        this.bytes(this.viewBuf.slice(0, len));\n        this.viewBuf.fill(0);\n    }\n    // User methods\n    err(msg) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        return Path.err('Reader', this.stack, msg);\n    }\n    bytes(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    finish(clean = true) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        // Can't use concatBytes, because it limits amount of arguments (65K).\n        const buffers = this.buffers.concat(this.ptrs.map((i) => i.buffer));\n        const sum = buffers.map((b) => b.length).reduce((a, b) => a + b, 0);\n        const buf = new Uint8Array(sum);\n        for (let i = 0, pad = 0; i < buffers.length; i++) {\n            const a = buffers[i];\n            buf.set(a, pad);\n            pad += a.length;\n        }\n        for (let pos = this.pos, i = 0; i < this.ptrs.length; i++) {\n            const ptr = this.ptrs[i];\n            buf.set(ptr.ptr.encode(pos), ptr.pos);\n            pos += ptr.buffer.length;\n        }\n        // Cleanup\n        if (clean) {\n            // We cannot cleanup buffers here, since it can be static user provided buffer.\n            // Only '.byte' and '.bits' create buffer which we can safely clean.\n            // for (const b of this.buffers) b.fill(0);\n            this.buffers = [];\n            for (const p of this.ptrs)\n                p.buffer.fill(0);\n            this.ptrs = [];\n            this.finished = true;\n            this.bitBuf = 0;\n        }\n        return buf;\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n}\n// Immutable LE<->BE\nconst swapEndianness = (b) => Uint8Array.from(b).reverse();\n/** Internal function for checking bit bounds of bigint in signed/unsinged form */\nfunction checkBounds(value, bits, signed) {\n    if (signed) {\n        // [-(2**(32-1)), 2**(32-1)-1]\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw new Error(`value out of signed bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n    }\n    else {\n        // [0, 2**32-1]\n        if (0n > value || value >= 2n ** bits)\n            throw new Error(`value out of unsigned bounds. Expected 0 <= ${value} < ${2n ** bits}`);\n    }\n}\nfunction _wrap(inner) {\n    return {\n        // NOTE: we cannot export validate here, since it is likely mistake.\n        encodeStream: inner.encodeStream,\n        decodeStream: inner.decodeStream,\n        size: inner.size,\n        encode: (value) => {\n            const w = new _Writer();\n            inner.encodeStream(w, value);\n            return w.finish();\n        },\n        decode: (data, opts = {}) => {\n            const r = new _Reader(data, opts);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\n/**\n * Validates a value before encoding and after decoding using a provided function.\n * @param inner - The inner CoderType.\n * @param fn - The validation function.\n * @returns CoderType which check value with validation function.\n * @example\n * const val = (n: number) => {\n *   if (n > 10) throw new Error(`${n} > 10`);\n *   return n;\n * };\n *\n * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding\n */\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    if (typeof fn !== 'function')\n        throw new Error('validate: fn should be function');\n    return _wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let res;\n            try {\n                res = fn(value);\n            }\n            catch (e) {\n                throw w.err(e);\n            }\n            inner.encodeStream(w, res);\n        },\n        decodeStream: (r) => {\n            const res = inner.decodeStream(r);\n            try {\n                return fn(res);\n            }\n            catch (e) {\n                throw r.err(e);\n            }\n        },\n    });\n}\n/**\n * Wraps a stream encoder into a generic encoder and optionally validation function\n * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.\n * @returns The wrapped CoderType.\n * @example\n * const U8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n * });\n * const checkedU8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n *   validate: (n: number) => {\n *    if (n > 10) throw new Error(`${n} > 10`);\n *    return n;\n *   }\n * });\n */\nexport const wrap = (inner) => {\n    const res = _wrap(inner);\n    return inner.validate ? validate(res, inner.validate) : res;\n};\nconst isBaseCoder = (elm) => isPlainObject(elm) && typeof elm.decode === 'function' && typeof elm.encode === 'function';\n/**\n * Checks if the given value is a CoderType.\n * @param elm - The value to check.\n * @returns True if the value is a CoderType, false otherwise.\n */\nexport function isCoder(elm) {\n    return (isPlainObject(elm) &&\n        isBaseCoder(elm) &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decodeStream === 'function' &&\n        (elm.size === undefined || isNum(elm.size)));\n}\n// Coders (like in @scure/base) for common operations\n/**\n * Base coder for working with dictionaries (records, objects, key-value map)\n * Dictionary is dynamic type like: `[key: string, value: any][]`\n * @returns base coder that encodes/decodes between arrays of key-value tuples and dictionaries.\n * @example\n * const dict: P.CoderType<Record<string, number>> = P.apply(\n *  P.array(P.U16BE, P.tuple([P.cstring, P.U32LE] as const)),\n *  P.coders.dict()\n * );\n */\nfunction dict() {\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from))\n                throw new Error('array expected');\n            const to = {};\n            for (const item of from) {\n                if (!Array.isArray(item) || item.length !== 2)\n                    throw new Error(`array of two elements expected`);\n                const name = item[0];\n                const value = item[1];\n                if (to[name] !== undefined)\n                    throw new Error(`key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => {\n            if (!isPlainObject(to))\n                throw new Error(`expected plain object, got ${to}`);\n            return Object.entries(to);\n        },\n    };\n}\n/**\n * Safely converts bigint to number.\n * Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n * but we still can use them since real value will be smaller than u32\n */\nconst numberBigint = {\n    encode: (from) => {\n        if (typeof from !== 'bigint')\n            throw new Error(`expected bigint, got ${typeof from}`);\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => {\n        if (!isNum(to))\n            throw new Error('element is not a safe integer');\n        return BigInt(to);\n    },\n};\n/**\n * Base coder for working with TypeScript enums.\n * @param e - TypeScript enum.\n * @returns base coder that encodes/decodes between numbers and enum keys.\n * @example\n * enum Color { Red, Green, Blue }\n * const colorCoder = P.coders.tsEnum(Color);\n * colorCoder.encode(Color.Red); // 'Red'\n * colorCoder.decode('Green'); // 1\n */\nfunction tsEnum(e) {\n    if (!isPlainObject(e))\n        throw new Error('plain object expected');\n    return {\n        encode: (from) => {\n            if (!isNum(from) || !(from in e))\n                throw new Error(`wrong value ${from}`);\n            return e[from];\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`wrong value ${typeof to}`);\n            return e[to];\n        },\n    };\n}\n/**\n * Base coder for working with decimal numbers.\n * @param precision - Number of decimal places.\n * @param round - Round fraction part if bigger than precision (throws error by default)\n * @returns base coder that encodes/decodes between bigints and decimal strings.\n * @example\n * const decimal8 = P.coders.decimal(8);\n * decimal8.encode(630880845n); // '6.30880845'\n * decimal8.decode('6.30880845'); // 630880845n\n */\nfunction decimal(precision, round = false) {\n    if (!isNum(precision))\n        throw new Error(`decimal/precision: wrong value ${precision}`);\n    if (typeof round !== 'boolean')\n        throw new Error(`decimal/round: expected boolean, got ${typeof round}`);\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            if (typeof from !== 'bigint')\n                throw new Error(`expected bigint, got ${typeof from}`);\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let int = s.slice(0, sep);\n            let frac = s.slice(sep, i + 1);\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`expected string, got ${typeof to}`);\n            if (to === '-0')\n                throw new Error(`negative zero is not allowed`);\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(to))\n                throw new Error(`wrong string value=${to}`);\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            // split by separator and strip trailing zeros from fraction. always returns [string, string] (.split doesn't).\n            const intS = to.slice(0, sep);\n            const fracS = to.slice(sep + 1).replace(/0+$/, '');\n            const int = BigInt(intS) * decimalMask;\n            if (!round && fracS.length > precision) {\n                throw new Error(`fractional part cannot be represented with this precision (num=${to}, prec=${precision})`);\n            }\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\n/**\n * Combines multiple coders into a single coder, allowing conditional encoding/decoding based on input.\n * Acts as a parser combinator, splitting complex conditional coders into smaller parts.\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * @param lst - Array of coders to match.\n * @returns Combined coder for conditional encoding/decoding.\n */\nfunction match(lst) {\n    if (!Array.isArray(lst))\n        throw new Error(`expected array, got ${typeof lst}`);\n    for (const i of lst)\n        if (!isBaseCoder(i))\n            throw new Error(`wrong base coder ${i}`);\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\n/** Reverses direction of coder */\nconst reverse = (coder) => {\n    if (!isBaseCoder(coder))\n        throw new Error('BaseCoder expected');\n    return { encode: coder.decode, decode: coder.encode };\n};\nexport const coders = { dict, numberBigint, tsEnum, decimal, match, reverse };\n/**\n * CoderType for parsing individual bits.\n * NOTE: Structure should parse whole amount of bytes before it can start parsing byte-level elements.\n * @param len - Number of bits to parse.\n * @returns CoderType representing the parsed bits.\n * @example\n * const s = P.struct({ magic: P.bits(1), version: P.bits(1), tag: P.bits(4), len: P.bits(2) });\n */\nexport const bits = (len) => {\n    if (!isNum(len))\n        throw new Error(`bits: wrong length ${len} (${typeof len})`);\n    return wrap({\n        encodeStream: (w, value) => w.bits(value, len),\n        decodeStream: (r) => r.bits(len),\n        validate: (value) => {\n            if (!isNum(value))\n                throw new Error(`bits: wrong value ${value}`);\n            return value;\n        },\n    });\n};\n/**\n * CoderType for working with bigint values.\n * Unsized bigint values should be wrapped in a container (e.g., bytes or string).\n *\n * `0n = new Uint8Array([])`\n *\n * `1n = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the bigint in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the bigint is signed.\n * @param sized - Whether the bigint should have a fixed size.\n * @returns CoderType representing the bigint value.\n * @example\n * const U512BE = P.bigint(64, false, true, true); // Define a CoderType for a 512-bit unsigned big-endian integer\n */\nexport const bigint = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`bigint/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`bigint/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`bigint/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`bigint/sized: expected boolean, got ${typeof sized}`);\n    const bLen = BigInt(size);\n    const signBit = 2n ** (8n * bLen - 1n);\n    return wrap({\n        size: sized ? size : undefined,\n        encodeStream: (w, value) => {\n            if (signed && value < 0)\n                value = value | signBit;\n            const b = [];\n            for (let i = 0; i < size; i++) {\n                b.push(Number(value & 255n));\n                value >>= 8n;\n            }\n            let res = new Uint8Array(b).reverse();\n            if (!sized) {\n                let pos = 0;\n                for (pos = 0; pos < res.length; pos++)\n                    if (res[pos] !== 0)\n                        break;\n                res = res.subarray(pos); // remove leading zeros\n            }\n            w.bytes(le ? res.reverse() : res);\n        },\n        decodeStream: (r) => {\n            // TODO: for le we can read until first zero?\n            const value = r.bytes(sized ? size : Math.min(size, r.leftBytes));\n            const b = le ? value : swapEndianness(value);\n            let res = 0n;\n            for (let i = 0; i < b.length; i++)\n                res |= BigInt(b[i]) << (8n * BigInt(i));\n            if (signed && res & signBit)\n                res = (res ^ signBit) - signBit;\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'bigint')\n                throw new Error(`bigint: invalid value: ${value}`);\n            checkBounds(value, 8n * bLen, !!signed);\n            return value;\n        },\n    });\n};\n/** Unsigned 256-bit little-endian integer CoderType. */\nexport const U256LE = /* @__PURE__ */ bigint(32, true);\n/** Unsigned 256-bit big-endian integer CoderType. */\nexport const U256BE = /* @__PURE__ */ bigint(32, false);\n/** Signed 256-bit little-endian integer CoderType. */\nexport const I256LE = /* @__PURE__ */ bigint(32, true, true);\n/** Signed 256-bit big-endian integer CoderType. */\nexport const I256BE = /* @__PURE__ */ bigint(32, false, true);\n/** Unsigned 128-bit little-endian integer CoderType. */\nexport const U128LE = /* @__PURE__ */ bigint(16, true);\n/** Unsigned 128-bit big-endian integer CoderType. */\nexport const U128BE = /* @__PURE__ */ bigint(16, false);\n/** Signed 128-bit little-endian integer CoderType. */\nexport const I128LE = /* @__PURE__ */ bigint(16, true, true);\n/** Signed 128-bit big-endian integer CoderType. */\nexport const I128BE = /* @__PURE__ */ bigint(16, false, true);\n/** Unsigned 64-bit little-endian integer CoderType. */\nexport const U64LE = /* @__PURE__ */ bigint(8, true);\n/** Unsigned 64-bit big-endian integer CoderType. */\nexport const U64BE = /* @__PURE__ */ bigint(8, false);\n/** Signed 64-bit little-endian integer CoderType. */\nexport const I64LE = /* @__PURE__ */ bigint(8, true, true);\n/** Signed 64-bit big-endian integer CoderType. */\nexport const I64BE = /* @__PURE__ */ bigint(8, false, true);\n/**\n * CoderType for working with numbber values (up to 6 bytes/48 bits).\n * Unsized int values should be wrapped in a container (e.g., bytes or string).\n *\n * `0 = new Uint8Array([])`\n *\n * `1 = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the number in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the number is signed.\n * @param sized - Whether the number should have a fixed size.\n * @returns CoderType representing the number value.\n * @example\n * const uint64BE = P.bigint(8, false, true); // Define a CoderType for a 64-bit unsigned big-endian integer\n */\nexport const int = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`int/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`int/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`int/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`int/sized: expected boolean, got ${typeof sized}`);\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits): use bigints instead');\n    return apply(bigint(size, le, signed, sized), coders.numberBigint);\n};\nconst view = (len, opts) => wrap({\n    size: len,\n    encodeStream: (w, value) => w.writeView(len, (view) => opts.write(view, value)),\n    decodeStream: (r) => r.readView(len, opts.read),\n    validate: (value) => {\n        if (typeof value !== 'number')\n            throw new Error(`viewCoder: expected number, got ${typeof value}`);\n        if (opts.validate)\n            opts.validate(value);\n        return value;\n    },\n});\nconst intView = (len, signed, opts) => {\n    const bits = len * 8;\n    const signBit = 2 ** (bits - 1);\n    // Inlined checkBounds for integer\n    const validateSigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`sintView: value is not safe integer: ${value}`);\n        if (value < -signBit || value >= signBit) {\n            throw new Error(`sintView: value out of bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n        }\n    };\n    const maxVal = 2 ** bits;\n    const validateUnsigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`uintView: value is not safe integer: ${value}`);\n        if (0 > value || value >= maxVal) {\n            throw new Error(`uintView: value out of bounds. Expected 0 <= ${value} < ${maxVal}`);\n        }\n    };\n    return view(len, {\n        write: opts.write,\n        read: opts.read,\n        validate: signed ? validateSigned : validateUnsigned,\n    });\n};\n/** Unsigned 32-bit little-endian integer CoderType. */\nexport const U32LE = /* @__PURE__ */ intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, true),\n    write: (view, value) => view.setUint32(0, value, true),\n});\n/** Unsigned 32-bit big-endian integer CoderType. */\nexport const U32BE = /* @__PURE__ */ intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, false),\n    write: (view, value) => view.setUint32(0, value, false),\n});\n/** Signed 32-bit little-endian integer CoderType. */\nexport const I32LE = /* @__PURE__ */ intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, true),\n    write: (view, value) => view.setInt32(0, value, true),\n});\n/** Signed 32-bit big-endian integer CoderType. */\nexport const I32BE = /* @__PURE__ */ intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, false),\n    write: (view, value) => view.setInt32(0, value, false),\n});\n/** Unsigned 16-bit little-endian integer CoderType. */\nexport const U16LE = /* @__PURE__ */ intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, true),\n    write: (view, value) => view.setUint16(0, value, true),\n});\n/** Unsigned 16-bit big-endian integer CoderType. */\nexport const U16BE = /* @__PURE__ */ intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, false),\n    write: (view, value) => view.setUint16(0, value, false),\n});\n/** Signed 16-bit little-endian integer CoderType. */\nexport const I16LE = /* @__PURE__ */ intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, true),\n    write: (view, value) => view.setInt16(0, value, true),\n});\n/** Signed 16-bit big-endian integer CoderType. */\nexport const I16BE = /* @__PURE__ */ intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, false),\n    write: (view, value) => view.setInt16(0, value, false),\n});\n/** Unsigned 8-bit integer CoderType. */\nexport const U8 = /* @__PURE__ */ intView(1, false, {\n    read: (view, pos) => view.getUint8(pos),\n    write: (view, value) => view.setUint8(0, value),\n});\n/** Signed 8-bit integer CoderType. */\nexport const I8 = /* @__PURE__ */ intView(1, true, {\n    read: (view, pos) => view.getInt8(pos),\n    write: (view, value) => view.setInt8(0, value),\n});\n// Floats\nconst f32 = (le) => view(4, {\n    read: (view, pos) => view.getFloat32(pos, le),\n    write: (view, value) => view.setFloat32(0, value, le),\n    validate: (value) => {\n        if (Math.fround(value) !== value && !Number.isNaN(value))\n            throw new Error(`f32: wrong value=${value}`);\n    },\n});\nconst f64 = (le) => view(8, {\n    read: (view, pos) => view.getFloat64(pos, le),\n    write: (view, value) => view.setFloat64(0, value, le),\n});\n/** 32-bit big-endian floating point CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32BE = /* @__PURE__ */ f32(false);\n/** 32-bit little-endian floating point  CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32LE = /* @__PURE__ */ f32(true);\n/** A 64-bit big-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64BE = /* @__PURE__ */ f64(false);\n/** A 64-bit little-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64LE = /* @__PURE__ */ f64(true);\n/** Boolean CoderType. */\nexport const bool = /* @__PURE__ */ wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n    validate: (value) => {\n        if (typeof value !== 'boolean')\n            throw new Error(`bool: invalid value ${value}`);\n        return value;\n    },\n});\n/**\n * Bytes CoderType with a specified length and endianness.\n * The bytes can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - CoderType, number, Uint8Array (terminator) or null\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the bytes.\n * @example\n * // Dynamic size bytes (prefixed with P.U16BE number of bytes length)\n * const dynamicBytes = P.bytes(P.U16BE, false);\n * const fixedBytes = P.bytes(32, false); // Fixed size bytes\n * const unknownBytes = P.bytes(null, false); // Unknown size bytes, will parse until end of buffer\n * const zeroTerminatedBytes = P.bytes(new Uint8Array([0]), false); // Zero-terminated bytes\n */\nconst createBytes = (len, le = false) => {\n    if (typeof le !== 'boolean')\n        throw new Error(`bytes/le: expected boolean, got ${typeof le}`);\n    const _length = lengthCoder(len);\n    const _isb = isBytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            if (!_isb)\n                _length.encodeStream(w, value.length);\n            w.bytes(le ? swapEndianness(value) : value);\n            if (_isb)\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let bytes;\n            if (_isb) {\n                const tPos = r.find(len);\n                if (!tPos)\n                    throw r.err(`bytes: cannot find terminator`);\n                bytes = r.bytes(tPos - r.pos);\n                r.bytes(len.length);\n            }\n            else {\n                bytes = r.bytes(len === null ? r.leftBytes : _length.decodeStream(r));\n            }\n            return le ? swapEndianness(bytes) : bytes;\n        },\n        validate: (value) => {\n            if (!isBytes(value))\n                throw new Error(`bytes: invalid value ${value}`);\n            return value;\n        },\n    });\n};\nexport { createBytes as bytes, createHex as hex };\n/**\n * Prefix-encoded value using a length prefix and an inner CoderType.\n * The prefix can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for the actual value to be prefix-encoded.\n * @returns CoderType representing the prefix-encoded value.\n * @example\n * const dynamicPrefix = P.prefix(P.U16BE, P.bytes(null)); // Dynamic size prefix (prefixed with P.U16BE number of bytes length)\n * const fixedPrefix = P.prefix(10, P.bytes(null)); // Fixed size prefix (always 10 bytes)\n */\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    return apply(createBytes(len), reverse(inner));\n}\n/**\n * String CoderType with a specified length and endianness.\n * The string can be:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the string.\n * @example\n * const dynamicString = P.string(P.U16BE, false); // Dynamic size string (prefixed with P.U16BE number of string length)\n * const fixedString = P.string(10, false); // Fixed size string\n * const unknownString = P.string(null, false); // Unknown size string, will parse until end of buffer\n * const nullTerminatedString = P.cstring; // NUL-terminated string\n * const _cstring = P.string(new Uint8Array([0])); // Same thing\n */\nexport const string = (len, le = false) => validate(apply(createBytes(len, le), utf8), (value) => {\n    // TextEncoder/TextDecoder will fail on non-string, but we create more readable errors earlier\n    if (typeof value !== 'string')\n        throw new Error(`expected string, got ${typeof value}`);\n    return value;\n});\n/** NUL-terminated string CoderType. */\nexport const cstring = /* @__PURE__ */ string(NULL);\n/**\n * Hexadecimal string CoderType with a specified length, endianness, and optional 0x prefix.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @param withZero - Whether to include the 0x prefix.\n * @returns CoderType representing the hexadecimal string.\n * @example\n * const dynamicHex = P.hex(P.U16BE, {isLE: false, with0x: true}); // Hex string with 0x prefix and U16BE length\n * const fixedHex = P.hex(32, {isLE: false, with0x: false}); // Fixed-length 32-byte hex string without 0x prefix\n */\nconst createHex = (len, options = { isLE: false, with0x: false }) => {\n    let inner = apply(createBytes(len, options.isLE), baseHex);\n    const prefix = options.with0x;\n    if (typeof prefix !== 'boolean')\n        throw new Error(`hex/with0x: expected boolean, got ${typeof prefix}`);\n    if (prefix) {\n        inner = apply(inner, {\n            encode: (value) => `0x${value}`,\n            decode: (value) => {\n                if (!value.startsWith('0x'))\n                    throw new Error('hex(with0x=true).encode input should start with 0x');\n                return value.slice(2);\n            },\n        });\n    }\n    return inner;\n};\n/**\n * Applies a base coder to a CoderType.\n * @param inner - The inner CoderType.\n * @param b - The base coder to apply.\n * @returns CoderType representing the transformed value.\n * @example\n * import { hex } from '@scure/base';\n * const hex = P.apply(P.bytes(32), hex); // will decode bytes into a hex string\n */\nexport function apply(inner, base) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    if (!isBaseCoder(base))\n        throw new Error(`apply: invalid base value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = base.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return base.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\n/**\n * Lazy CoderType that is evaluated at runtime.\n * @param fn - A function that returns the CoderType.\n * @returns CoderType representing the lazy value.\n * @example\n * type Tree = { name: string; children: Tree[] };\n * const tree = P.struct({\n *   name: P.cstring,\n *   children: P.array(\n *     P.U16BE,\n *     P.lazy((): P.CoderType<Tree> => tree)\n *   ),\n * });\n */\nexport function lazy(fn) {\n    if (typeof fn !== 'function')\n        throw new Error(`lazy: expected function, got ${typeof fn}`);\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\n/**\n * Flag CoderType that encodes/decodes a boolean value based on the presence of a marker.\n * @param flagValue - Marker value.\n * @param xor - Whether to invert the flag behavior.\n * @returns CoderType representing the flag value.\n * @example\n * const flag = P.flag(new Uint8Array([0x01, 0x02])); // Encodes true as u8a([0x01, 0x02]), false as u8a([])\n * const flagXor = P.flag(new Uint8Array([0x01, 0x02]), true); // Encodes true as u8a([]), false as u8a([0x01, 0x02])\n * // Conditional encoding with flagged\n * const s = P.struct({ f: P.flag(new Uint8Array([0x0, 0x1])), f2: P.flagged('f', P.U32BE) });\n */\nexport const flag = (flagValue, xor = false) => {\n    if (!isBytes(flagValue))\n        throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof flagValue}`);\n    if (typeof xor !== 'boolean')\n        throw new Error(`flag/xor: expected boolean, got ${typeof xor}`);\n    return wrap({\n        size: flagValue.length,\n        encodeStream: (w, value) => {\n            if (!!value !== xor)\n                w.bytes(flagValue);\n        },\n        decodeStream: (r) => {\n            let hasFlag = r.leftBytes >= flagValue.length;\n            if (hasFlag) {\n                hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n                // Found flag, advance cursor position\n                if (hasFlag)\n                    r.bytes(flagValue.length);\n            }\n            return hasFlag !== xor; // hasFlag ^ xor\n        },\n        validate: (value) => {\n            if (value !== undefined && typeof value !== 'boolean')\n                throw new Error(`flag: expected boolean value or undefined, got ${typeof value}`);\n            return value;\n        },\n    });\n};\n/**\n * Conditional CoderType that encodes/decodes a value only if a flag is present.\n * @param path - Path to the flag value or a CoderType for the flag.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the conditional value.\n * @example\n * const s = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE)\n * });\n *\n * @example\n * const s2 = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE, 123)\n * });\n */\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    if (typeof path !== 'string' && !isCoder(inner))\n        throw new Error(`flagged: wrong path=${path}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (Path.resolve(w.stack, path))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = !!Path.resolve(r.stack, path);\n            else\n                hasFlag = path.decodeStream(r);\n            // If there is a flag -- decode and return value\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Optional CoderType that encodes/decodes a value based on a flag.\n * @param flag - CoderType for the flag value.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the optional value.\n * @example\n * // Will decode into P.U32BE only if flag present\n * const optional = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE);\n *\n * @example\n * // If no flag present, will decode into default value\n * const optionalWithDefault = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE, 123);\n */\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Magic value CoderType that encodes/decodes a constant value.\n * This can be used to check for a specific magic value or sequence of bytes at the beginning of a data structure.\n * @param inner - Inner CoderType for the value.\n * @param constant - Constant value.\n * @param check - Whether to check the decoded value against the constant.\n * @returns CoderType representing the magic value.\n * @example\n * // Always encodes constant as bytes using inner CoderType, throws if encoded value is not present\n * const magicU8 = P.magic(P.U8, 0x42);\n */\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`magic: invalid inner value ${inner}`);\n    if (typeof check !== 'boolean')\n        throw new Error(`magic: expected boolean, got ${typeof check}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, _value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n        validate: (value) => {\n            if (value !== undefined)\n                throw new Error(`magic: wrong value=${typeof value}`);\n            return value;\n        },\n    });\n}\n/**\n * Magic bytes CoderType that encodes/decodes a constant byte array or string.\n * @param constant - Constant byte array or string.\n * @returns CoderType representing the magic bytes.\n * @example\n * // Always encodes undefined into byte representation of string 'MAGIC'\n * const magicBytes = P.magicBytes('MAGIC');\n */\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n    return magic(createBytes(c.length), c);\n};\n/**\n * Creates a CoderType for a constant value. The function enforces this value during encoding,\n * ensuring it matches the provided constant. During decoding, it always returns the constant value.\n * The actual value is not written to or read from any byte stream; it's used only for validation.\n *\n * @param c - Constant value.\n * @returns CoderType representing the constant value.\n * @example\n * // Always return 123 on decode, throws on encoding anything other than 123\n * const constantU8 = P.constant(123);\n */\nexport function constant(c) {\n    return wrap({\n        encodeStream: (_w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (_r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (const f of fields) {\n        if (f.size === undefined)\n            return;\n        if (!isNum(f.size))\n            throw new Error(`sizeof: wrong element size=${size}`);\n        size += f.size;\n    }\n    return size;\n}\n/**\n * Structure of composable primitives (C/Rust struct)\n * @param fields - Object mapping field names to CoderTypes.\n * @returns CoderType representing the structure.\n * @example\n * // Define a structure with a 32-bit big-endian unsigned integer, a string, and a nested structure\n * const myStruct = P.struct({\n *   id: P.U32BE,\n *   name: P.string(P.U8),\n *   nested: P.struct({\n *     flag: P.bool,\n *     value: P.I16LE\n *   })\n * });\n */\nexport function struct(fields) {\n    if (!isPlainObject(fields))\n        throw new Error(`struct: expected plain object, got ${fields}`);\n    for (const name in fields) {\n        if (!isCoder(fields[name]))\n            throw new Error(`struct: field ${name} is not CoderType`);\n    }\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            w.pushObj(value, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => fields[name].encodeStream(w, value[name]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = {};\n            r.pushObj(res, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => (res[name] = fields[name].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'object' || value === null)\n                throw new Error(`struct: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tuple (unnamed structure) of CoderTypes. Same as struct but with unnamed fields.\n * @param fields - Array of CoderTypes.\n * @returns CoderType representing the tuple.\n * @example\n * const myTuple = P.tuple([P.U8, P.U16LE, P.string(P.U8)]);\n */\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    for (let i = 0; i < fields.length; i++) {\n        if (!isCoder(fields[i]))\n            throw new Error(`tuple: field ${i} is not CoderType`);\n    }\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            // TODO: fix types\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.pushObj(value, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => fields[i].encodeStream(w, value[i]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => res.push(fields[i].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`tuple: invalid value ${value}`);\n            if (value.length !== fields.length)\n                throw new Error(`tuple: wrong length=${value.length}, expected ${fields.length}`);\n            return value;\n        },\n    });\n}\n/**\n * Array of items (inner type) with a specified length.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for encoding/decoding each array item.\n * @returns CoderType representing the array.\n * @example\n * const a1 = P.array(P.U16BE, child); // Dynamic size array (prefixed with P.U16BE number of array length)\n * const a2 = P.array(4, child); // Fixed size array\n * const a3 = P.array(null, child); // Unknown size array, will parse until end of buffer\n * const a4 = P.array(new Uint8Array([0]), child); // zero-terminated array (NOTE: terminator can be any buffer)\n */\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    // By construction length is inside array (otherwise there will be various incorrect stack states)\n    // But forcing users always write '..' seems like bad idea. Also, breaking change.\n    const _length = lengthCoder(typeof len === 'string' ? `../${len}` : len);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            _w.pushObj(value, (fieldFn) => {\n                if (!isBytes(len))\n                    _length.encodeStream(w, value.length);\n                for (let i = 0; i < value.length; i++) {\n                    fieldFn(`${i}`, () => {\n                        const elm = value[i];\n                        const startPos = w.pos;\n                        inner.encodeStream(w, elm);\n                        if (isBytes(len)) {\n                            // Terminator is bigger than elm size, so skip\n                            if (len.length > _w.pos - startPos)\n                                return;\n                            const data = _w.finish(false).subarray(startPos, _w.pos);\n                            // There is still possible case when multiple elements create terminator,\n                            // but it is hard to catch here, will be very slow\n                            if (equalBytes(data.subarray(0, len.length), len))\n                                throw _w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                        }\n                    });\n                }\n            });\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                if (len === null) {\n                    for (let i = 0; !r.isEnd(); i++) {\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                        if (inner.size && r.leftBytes < inner.size)\n                            break;\n                    }\n                }\n                else if (isBytes(len)) {\n                    for (let i = 0;; i++) {\n                        if (equalBytes(r.bytes(len.length, true), len)) {\n                            // Advance cursor position if terminator found\n                            r.bytes(len.length);\n                            break;\n                        }\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                    }\n                }\n                else {\n                    let length;\n                    fieldFn('arrayLen', () => (length = _length.decodeStream(r)));\n                    for (let i = 0; i < length; i++)\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                }\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`array: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values and string representations.\n * @param inner - CoderType for encoded values.\n * @param variants - Object mapping string representations to encoded values.\n * @returns CoderType representing the mapping.\n * @example\n * // Map between numbers and strings\n * const numberMap = P.map(P.U8, {\n *   'one': 1,\n *   'two': 2,\n *   'three': 3\n * });\n *\n * // Map between byte arrays and strings\n * const byteMap = P.map(P.bytes(2, false), {\n *   'ab': Uint8Array.from([0x61, 0x62]),\n *   'cd': Uint8Array.from([0x63, 0x64])\n * });\n */\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    if (!isPlainObject(variants))\n        throw new Error(`map: variants should be plain object`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, variants[value]),\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string')\n                throw new Error(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw new Error(`Map: unknown variant: ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tagged union of CoderTypes, where the tag value determines which CoderType to use.\n * The decoded value will have the structure `{ TAG: number, data: ... }`.\n * @param tag - CoderType for the tag value.\n * @param variants - Object mapping tag values to CoderTypes.\n * @returns CoderType representing the tagged union.\n * @example\n * // Tagged union of array, string, and number\n * // Depending on the value of the first byte, it will be decoded as an array, string, or number.\n * const taggedUnion = P.tag(P.U8, {\n *   0x01: P.array(P.U16LE, P.U8),\n *   0x02: P.string(P.U8),\n *   0x03: P.U32BE\n * });\n *\n * const encoded = taggedUnion.encode({ TAG: 0x01, data: 'hello' }); // Encodes the string 'hello' with tag 0x01\n * const decoded = taggedUnion.decode(encoded); // Decodes the encoded value back to { TAG: 0x01, data: 'hello' }\n */\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`tag: variants should be plain object`);\n    for (const name in variants) {\n        if (!isCoder(variants[name]))\n            throw new Error(`tag: variant ${name} is not CoderType`);\n    }\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n        validate: (value) => {\n            const { TAG } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw new Error(`Tag: invalid tag ${TAG.toString()}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values, string representations, and CoderTypes using a tag CoderType.\n * @param tagCoder - CoderType for the tag value.\n * @param variants - Object mapping string representations to [tag value, CoderType] pairs.\n *  * @returns CoderType representing the mapping.\n * @example\n * const cborValue: P.CoderType<CborValue> = P.mappedTag(P.bits(3), {\n *   uint: [0, cborUint], // An unsigned integer in the range 0..264-1 inclusive.\n *   negint: [1, cborNegint], // A negative integer in the range -264..-1 inclusive\n *   bytes: [2, P.lazy(() => cborLength(P.bytes, cborValue))], // A byte string.\n *   string: [3, P.lazy(() => cborLength(P.string, cborValue))], // A text string (utf8)\n *   array: [4, cborArrLength(P.lazy(() => cborValue))], // An array of data items\n *   map: [5, P.lazy(() => cborArrLength(P.tuple([cborValue, cborValue])))], // A map of pairs of data items\n *   tag: [6, P.tuple([cborUint, P.lazy(() => cborValue)] as const)], // A tagged data item (\"tag\") whose tag number\n *   simple: [7, cborSimple], // Floating-point numbers and simple values, as well as the \"break\" stop code\n * });\n */\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`mappedTag: variants should be plain object`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        const v = variants[key];\n        mapValue[key] = v[0];\n        tagValue[key] = v[1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\n/**\n * Bitset of boolean values with optional padding.\n * @param names - An array of string names for the bitset values.\n * @param pad - Whether to pad the bitset to a multiple of 8 bits.\n * @returns CoderType representing the bitset.\n * @template Names\n * @example\n * const myBitset = P.bitset(['flag1', 'flag2', 'flag3', 'flag4'], true);\n */\nexport function bitset(names, pad = false) {\n    if (typeof pad !== 'boolean')\n        throw new Error(`bitset/pad: expected boolean, got ${typeof pad}`);\n    if (!Array.isArray(names))\n        throw new Error('bitset/names: expected array');\n    for (const name of names) {\n        if (typeof name !== 'string')\n            throw new Error('bitset/names: expected array of strings');\n    }\n    return wrap({\n        encodeStream: (w, value) => {\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            const out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n        validate: (value) => {\n            if (!isPlainObject(value))\n                throw new Error(`bitset: invalid value ${value}`);\n            for (const v of Object.values(value)) {\n                if (typeof v !== 'boolean')\n                    throw new Error('expected boolean');\n            }\n            return value;\n        },\n    });\n}\n/** Padding function which always returns zero */\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the left side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U32BE with a block size of 4 and zero padding\n * const paddedU32BE = P.padLeft(4, P.U32BE);\n *\n * // Pad a string with a block size of 16 and custom padding\n * const paddedString = P.padLeft(16, P.string(P.U8), (i) => i + 1);\n */\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padLeft: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft cannot have dynamic size');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the right side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U16BE with a block size of 2 and zero padding\n * const paddedU16BE = P.padRight(2, P.U16BE);\n *\n * // Pad a bytes with a block size of 8 and custom padding\n * const paddedBytes = P.padRight(8, P.bytes(null), (i) => i + 1);\n */\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padRight: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const pos = _w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, _w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\n1;\n/**\n * Pointer to a value using a pointer CoderType and an inner CoderType.\n * Pointers are scoped, and the next pointer in the dereference chain is offset by the previous one.\n * By default (if no 'allowMultipleReads' in ReaderOpts is set) is safe, since\n * same region of memory cannot be read multiple times.\n * @param ptr - CoderType for the pointer value.\n * @param inner - CoderType for encoding/decoding the pointed value.\n * @param sized - Whether the pointer should have a fixed size.\n * @returns CoderType representing the pointer to the value.\n * @example\n * const pointerToU8 = P.pointer(P.U16BE, P.U8); // Pointer to a single U8 value\n */\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`pointer/sized: expected boolean, got ${typeof sized}`);\n    if (!ptr.size)\n        throw new Error('unsized pointer');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const start = _w.pos;\n            ptr.encodeStream(w, 0);\n            _w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            r._enablePointers();\n            return inner.decodeStream(r.offsetReader(ptrVal));\n        },\n    });\n}\n// Internal methods for test purposes only\nexport const _TEST = { _bitset: Bitset, _Reader, _Writer, Path };\n//# sourceMappingURL=index.js.map","import { ed25519 } from '@noble/curves/ed25519';\nimport { base58, base64, hex, utf8 } from '@scure/base';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as P from 'micro-packed';\nexport const PRECISION = 9;\nexport const Decimal = P.coders.decimal(PRECISION);\n// first bit -- terminator (1 -- continue, 0 -- last)\nexport const shortVec = P.wrap({\n    encodeStream: (w, value) => {\n        if (!value)\n            return w.byte(0);\n        for (; value; value >>= 7) {\n            w.bits(value > 0x7f ? 1 : 0, 1);\n            w.bits(value & 0x7f, 7);\n        }\n    },\n    decodeStream: (r) => {\n        let len = 0;\n        for (let pos = 0; !r.isEnd(); pos++) {\n            const last = !r.bits(1);\n            len |= r.bits(7) << (pos * 7);\n            if (last)\n                break;\n        }\n        return len;\n    },\n});\nconst rustString = P.string(P.padRight(8, P.U32LE, undefined));\nconst b58 = () => {\n    const inner = P.bytes(32);\n    return P.wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base58.decode(value)),\n        decodeStream: (r) => base58.encode(inner.decodeStream(r)),\n    });\n};\nconst pubKey = b58();\nexport const Message = P.struct({\n    requiredSignatures: P.U8,\n    readSigned: P.U8,\n    readUnsigned: P.U8,\n    keys: P.array(shortVec, pubKey),\n    blockhash: pubKey,\n    instructions: P.array(shortVec, P.struct({ programIdx: P.U8, keys: P.array(shortVec, P.U8), data: P.bytes(shortVec) })),\n});\nexport function validateAddress(address) {\n    const pubkey = base58.decode(address);\n    if (pubkey.length !== 32)\n        throw new Error('Invalid Solana address');\n}\nconst keyParams = (i, req, signed, unsigned, total) => ({\n    sign: i < req ? true : false,\n    write: i < req - signed || (i >= req && i < total - unsigned) ? true : false,\n});\nexport const TransactionRaw = P.struct({\n    signatures: P.array(shortVec, P.bytes(64)),\n    msg: Message,\n});\n// Keys position is implementation specific, Transaction.encode(Transaction.decode(tx)) not neccessary equals to tx,\n// since there is information loss for readability purposes. Use TransactionRaw in case you need exactly same encoding\nexport const Transaction = P.wrap({\n    encodeStream: (w, value) => {\n        const { msg, signatures } = value;\n        const accounts = {};\n        const add = (address, sign, write) => {\n            let acc = accounts[address] || (accounts[address] = { sign: false, write: false });\n            acc.write || (acc.write = write);\n            acc.sign || (acc.sign = sign);\n        };\n        add(msg.feePayer, true, true);\n        for (let i of msg.instructions)\n            for (let k of i.keys)\n                add(k.address, k.sign, k.write);\n        // Same loop as above, but cannot be merged since it will change implementation specific key positions inside transaction.\n        // This doesn't invalidate transaction, but can be used for fingerprinting.\n        for (let i of msg.instructions)\n            add(i.program, false, false);\n        const _keys = Object.keys(accounts);\n        // [feePayer, ...sign+write, ...sign+read, ...nosign+write, ...nosign+read]\n        const keys = [\n            msg.feePayer,\n            ..._keys.filter((i) => accounts[i].sign && accounts[i].write && i !== msg.feePayer),\n            ..._keys.filter((i) => accounts[i].sign && !accounts[i].write),\n            ..._keys.filter((i) => !accounts[i].sign && accounts[i].write),\n            ..._keys.filter((i) => !accounts[i].sign && !accounts[i].write),\n        ];\n        let requiredSignatures = 0;\n        let readSigned = 0;\n        let readUnsigned = 0;\n        for (let k of keys) {\n            if (accounts[k].sign)\n                requiredSignatures++;\n            if (accounts[k].write)\n                continue;\n            if (accounts[k].sign)\n                readSigned++;\n            else\n                readUnsigned++;\n        }\n        TransactionRaw.encodeStream(w, {\n            signatures: keys\n                .filter((i) => accounts[i].sign)\n                .map((i) => signatures[i] || new Uint8Array(64)),\n            msg: {\n                requiredSignatures,\n                readSigned,\n                readUnsigned,\n                keys,\n                // indexOf potentially can be slow, but for most tx there will be ~3-5 keys, so doesn't matter much\n                instructions: msg.instructions.map((i) => ({\n                    programIdx: keys.indexOf(i.program),\n                    keys: i.keys.map((j) => keys.indexOf(j.address)),\n                    data: i.data,\n                })),\n                blockhash: msg.blockhash,\n            },\n        });\n    },\n    decodeStream: (r) => {\n        const { signatures, msg } = TransactionRaw.decodeStream(r);\n        if (signatures.length !== msg.requiredSignatures)\n            throw new Error('SOL.tx: wrong signatures length');\n        if (msg.keys.length < signatures.length)\n            throw new Error('SOL.tx: invalid keys length');\n        const sigs = {};\n        for (let i = 0; i < signatures.length; i++)\n            sigs[msg.keys[i]] = signatures[i];\n        let accounts = [];\n        for (let i = 0; i < msg.keys.length; i++) {\n            accounts.push({\n                address: msg.keys[i],\n                ...keyParams(i, msg.requiredSignatures, msg.readSigned, msg.readUnsigned, msg.keys.length),\n            });\n        }\n        if (!accounts.length)\n            throw new Error('SOL.tx: empty accounts array');\n        return {\n            msg: {\n                feePayer: accounts[0].address,\n                blockhash: msg.blockhash,\n                instructions: msg.instructions.map((i) => ({\n                    program: accounts[i.programIdx].address,\n                    keys: i.keys.map((j) => accounts[j]),\n                    data: i.data,\n                })),\n            },\n            signatures: sigs,\n        };\n    },\n});\nconst registry = {};\n// Basic ABI thing. There is IDL which is kinda ABI, but not official and system accounts doesn't have offical types for it.\n// Later we can add support to conversion IDL -> defineProgram\nexport function defineProgram(address, tagType, methods) {\n    if (registry[address])\n        throw new Error('SOL: program for this address already defined');\n    const variants = P.map(tagType, Object.keys(methods).reduce((acc, k, i) => ({ ...acc, [k]: i }), {}));\n    const coders = Object.keys(methods).reduce((acc, k) => ({ ...acc, [k]: methods[k].coder }), {});\n    const mainCoder = P.tag(variants, coders);\n    registry[address] = (instr, tl) => {\n        if (instr.program !== address)\n            throw new Error('SOL.parseInstruction: Wrong instruction program address');\n        const { TAG, data } = mainCoder.decode(instr.data);\n        // Should be close to node parser (https://github.com/solana-labs/solana/tree/master/transaction-status/src)\n        const res = { type: TAG, info: data };\n        const keys = Object.keys(methods[TAG].keys);\n        if (keys.length !== instr.keys.length)\n            throw new Error('SOL.parseInstruction: Keys length mismatch');\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            if (methods[TAG].keys[key].address) {\n                if (methods[TAG].keys[key].address !== instr.keys[i].address) {\n                    throw new Error(`SOL.parseInstruction(${address}/${TAG}): Invalid constant address for key exp=${methods[TAG].keys[key].address} got=${instr.keys[i].address}`);\n                }\n                continue;\n            }\n            res.info[keys[i]] = instr.keys[i].address;\n        }\n        if (methods[TAG].hint)\n            res.hint = methods[TAG].hint(data, tl);\n        return res;\n    };\n    const program = {};\n    for (const m in methods) {\n        program[m] = (data) => ({\n            program: address,\n            data: mainCoder.encode({ TAG: m, data }),\n            keys: Object.keys(methods[m].keys).map((name) => {\n                let { sign, write, address } = methods[m].keys[name];\n                address || (address = data[name]);\n                validateAddress(address);\n                return { address, sign, write };\n            }),\n        });\n    }\n    return program;\n}\nexport function parseInstruction(instr, tl) {\n    if (!registry[instr.program])\n        return;\n    return registry[instr.program](instr, tl);\n}\nexport const SYS_RECENT_BLOCKHASHES = 'SysvarRecentB1ockHashes11111111111111111111';\nexport const SYS_RENT = 'SysvarRent111111111111111111111111111111111';\nexport const SYS_PROGRAM = '11111111111111111111111111111111';\nexport const sys = defineProgram(SYS_PROGRAM, P.U32LE, {\n    createAccount: {\n        coder: P.struct({ lamports: P.U64LE, space: P.U64LE, owner: pubKey }),\n        keys: {\n            source: { sign: true, write: true },\n            newAccount: { sign: true, write: true },\n        },\n        hint: (o) => `Create new account=${o.newAccount} with balance of ${Decimal.encode(o.lamports)} and owner program ${o.owner}, using funding account ${o.source}`,\n    },\n    assign: {\n        coder: P.struct({ owner: pubKey }),\n        keys: { account: { sign: true, write: true } },\n        hint: (o) => `Assign account=${o.account} to owner program=${o.owner}`,\n    },\n    transfer: {\n        coder: P.struct({ lamports: P.U64LE }),\n        keys: { source: { sign: true, write: true }, destination: { sign: false, write: true } },\n        hint: (o) => `Transfer ${Decimal.encode(o.lamports)} SOL from ${o.source} to ${o.destination}`,\n    },\n    createAccountWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            lamports: P.U64LE,\n            space: P.U64LE,\n            owner: pubKey,\n        }),\n        keys: {\n            source: { sign: true, write: true },\n            newAccount: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    advanceNonce: {\n        coder: P.struct({}),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Consume nonce in nonce account=${o.nonceAccount} (owner: ${o.nonceAuthority})`,\n    },\n    withdrawFromNonce: {\n        coder: P.struct({ lamports: P.U64LE }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            destination: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Withdraw ${Decimal.encode(o.lamports)} SOL from nonce account=${o.nonceAccount} (owner: ${o.nonceAuthority}) to ${o.destination}`,\n    },\n    initializeNonce: {\n        coder: P.struct({ nonceAuthority: pubKey }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            _recent_bh: { address: SYS_RECENT_BLOCKHASHES, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n    },\n    authorizeNonce: {\n        coder: P.struct({ newAuthorized: pubKey }),\n        keys: {\n            nonceAccount: { sign: false, write: true },\n            nonceAuthority: { sign: true, write: false },\n        },\n        hint: (o) => `Change owner of nonce account=${o.nonceAccount} from ${o.nonceAuthority} to ${o.newAuthorized}`,\n    },\n    allocate: {\n        coder: P.struct({ space: P.U64LE }),\n        keys: {\n            account: { sign: true, write: true },\n        },\n    },\n    allocateWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            space: P.U64LE,\n            owner: pubKey,\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    assignWithSeed: {\n        coder: P.struct({\n            base: pubKey,\n            seed: rustString,\n            owner: pubKey,\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            base: { sign: true, write: false },\n        },\n    },\n    transferWithSeed: {\n        coder: P.struct({\n            lamports: P.U64LE,\n            sourceSeed: rustString,\n            sourceOwner: pubKey,\n        }),\n        keys: {\n            source: { sign: false, write: true },\n            sourceBase: { sign: true, write: false },\n            destination: { sign: false, write: true },\n        },\n    },\n});\n// Type tests\nconst assertType = (_value) => { };\nassertType(sys.transfer);\nassertType(sys.advanceNonce);\nconst authorityType = P.map(P.U8, {\n    MintTokens: 0,\n    FreezeAccount: 1,\n    AccountOwner: 2,\n    CloseAccount: 3,\n});\nconst tokenName = (address, tl) => tl[address]?.symbol || address;\nexport const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';\nexport const token = defineProgram(TOKEN_PROGRAM, P.U8, {\n    initializeMint: {\n        coder: P.struct({\n            decimals: P.U8,\n            mintAuthority: pubKey,\n            freezeAuthority: P.optional(P.bool, pubKey, '11111111111111111111111111111111'),\n        }),\n        keys: {\n            mint: { sign: false, write: true },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n    },\n    initializeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            owner: { sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize token account=${o.account} with owner=${o.owner} token=${tokenName(o.mint, tl)}`,\n    },\n    // TODO: multisig support?\n    initializeMultisig: {\n        coder: P.struct({ m: P.U8 }),\n        keys: {\n            account: { sign: false, write: true },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, _) => `Initialize multi-sig token account=${o.account} with signatures=${o.m}`,\n    },\n    transfer: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            source: { sign: false, write: true },\n            destination: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Transfer ${o.amount} from token account=${o.source} of owner=${o.owner} to ${o.destination}`,\n    },\n    approve: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            account: { sign: false, write: true },\n            delegate: { sign: false, write: false },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Approve authority of delegate=${o.delegate} over tokens on account=${o.account} on behalf of owner=${o.owner}`,\n    },\n    revoke: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Revoke delegate's authority over tokens on account=${o.account} on behalf of owner=${o.owner}`,\n    },\n    setAuthority: {\n        coder: P.struct({\n            authorityType,\n            newAuthority: P.optional(P.bool, pubKey, '11111111111111111111111111111111'),\n        }),\n        keys: {\n            account: { sign: false, write: true },\n            currentAuthority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Sets a new authority=${o.newAuthority} of a mint or account=${o.account}. Current authority=${o.currentAuthority}. Authority Type: ${o.authorityType}`,\n    },\n    mintTo: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            mint: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n    },\n    burn: {\n        coder: P.struct({ amount: P.U64LE }),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Burn ${o.amount} tokens from account=${o.account} of owner=${o.owner} mint=${o.mint}`,\n    },\n    closeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, _) => `Close token account=${o.account} of owner=${o.owner}, transferring all its SOL to destionation account=${o.dest}`,\n    },\n    freezeAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Freeze token account=${o.account} of mint=${o.mint} using freeze_authority=${o.authority}`,\n    },\n    thawAccount: {\n        coder: P.struct({}),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, _) => `Thaw a frozne token account=${o.account} of mint=${o.mint} using freeze_authority=${o.authority}`,\n    },\n    transferChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            source: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            destination: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Transfer ${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)} from token account=${o.source} of owner=${o.owner} to ${o.destination}`,\n    },\n    approveChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            source: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            delegate: { sign: false, write: false },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Approve delgate=${o.delegate} authority on behalf account=${o.source} owner=${o.owner} over ${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}`,\n    },\n    mintToChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            mint: { sign: false, write: true },\n            dest: { sign: false, write: true },\n            authority: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Mint new tokens (${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}) to account=${o.dest} using authority=${o.authority}`,\n    },\n    burnChecked: {\n        coder: P.struct({ amount: P.U64LE, decimals: P.U8 }),\n        keys: {\n            mint: { sign: false, write: true },\n            account: { sign: false, write: true },\n            owner: { sign: true, write: false },\n        },\n        hint: (o, tl) => `Burn tokens (${P.coders.decimal(o.decimals).encode(o.amount)} ${tokenName(o.mint, tl)}) on account=${o.account} of owner=${o.owner}`,\n    },\n    initializeAccount2: {\n        coder: P.struct({ owner: pubKey }),\n        keys: {\n            account: { sign: false, write: true },\n            mint: { sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize token account=${o.account} with owner=${o.owner} token=${tokenName(o.mint, tl)}`,\n    },\n    syncNative: {\n        coder: P.struct({}),\n        keys: { nativeAccount: { sign: false, write: true } },\n        hint: (o) => `Sync SOL balance for wrapped account ${o.nativeAccount}`,\n    },\n});\nexport const NonceAccount = P.struct({\n    version: P.U32LE,\n    state: P.U32LE,\n    authority: pubKey,\n    nonce: pubKey,\n    lamportPerSignature: P.U64LE,\n});\nfunction mod(a, b = ed25519.CURVE.Fp.ORDER) {\n    const res = a % b;\n    return res >= 0n ? res : b + res;\n}\nexport function isOnCurve(bytes) {\n    if (typeof bytes === 'string')\n        bytes = base58.decode(bytes);\n    try {\n        // noble-ed25519 checks that publicKey is < P, but dalek (ed25519-dalek.CompressedEdwardsY) is not, so we do modulo here.\n        // first bit in last byte is x oddity flag\n        const last = bytes[31];\n        const normedLast = last & ~0x80;\n        const normed = Uint8Array.from(Array.from(bytes.slice(0, 31)).concat(normedLast));\n        const modBytes = P.U256LE.encode(mod(P.U256LE.decode(normed)));\n        if ((last & 0x80) !== 0)\n            modBytes[31] |= 0x80;\n        ed25519.ExtendedPoint.fromHex(modBytes);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexport function programAddress(program, ...seeds) {\n    let seed = P.utils.concatBytes(...seeds);\n    const noncePos = seed.length;\n    seed = P.utils.concatBytes(seed, new Uint8Array([0]), base58.decode(program), utf8.decode('ProgramDerivedAddress'));\n    for (let i = 255; i >= 0; i--) {\n        seed[noncePos] = i;\n        const hash = sha256(seed);\n        if (isOnCurve(hash))\n            continue;\n        return base58.encode(hash);\n    }\n    throw new Error('SOL.programAddress: nonce exhausted, cannot find program address');\n}\nexport const ASSOCIATED_TOKEN_PROGRAM = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL';\nexport const associatedToken = defineProgram(ASSOCIATED_TOKEN_PROGRAM, P.constant(0), {\n    create: {\n        coder: P.struct({}),\n        keys: {\n            source: { sign: true, write: true },\n            account: { sign: false, write: true },\n            wallet: { sign: false, write: false },\n            mint: { sign: false, write: false },\n            _sys: { address: SYS_PROGRAM, sign: false, write: false },\n            _token: { address: TOKEN_PROGRAM, sign: false, write: false },\n            _rent: { address: SYS_RENT, sign: false, write: false },\n        },\n        hint: (o, tl) => `Initialize associated token account=${o.account} with owner=${o.wallet} for token=${tokenName(o.mint, tl)}, payed by ${o.source}`,\n    },\n});\nexport function tokenAddress(mint, owner, allowOffCurveOwner = false) {\n    if (!allowOffCurveOwner && !isOnCurve(owner))\n        throw new Error('Owner is off curve (cannot sign)');\n    return programAddress(ASSOCIATED_TOKEN_PROGRAM, ...[owner, TOKEN_PROGRAM, mint].map((i) => base58.decode(i)));\n}\n// https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json\nexport const COMMON_TOKENS = {\n    So11111111111111111111111111111111111111112: { decimals: 9, symbol: 'SOL' }, // Wrapped SOL\n    Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: { decimals: 6, symbol: 'USDT', price: 1 },\n    EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: { decimals: 6, symbol: 'USDC', price: 1 },\n};\nexport function tokenFromSymbol(symbol, tokens = COMMON_TOKENS) {\n    for (let c in tokens)\n        if (tokens[c].symbol === symbol)\n            return { ...tokens[c], contract: c };\n    return;\n}\n// [1, 0, 0, 0] -> true\n// [0, 0, 0, 0] -> false\nconst U32LEBOOL = P.padRight(4, P.bool, () => 0);\nexport const TokenAccount = P.struct({\n    mint: pubKey,\n    owner: pubKey,\n    amount: P.U64LE,\n    delegate: P.optional(U32LEBOOL, pubKey, '11111111111111111111111111111111'),\n    state: P.map(P.U8, {\n        uninitialized: 0,\n        initialized: 1,\n        frozen: 2,\n    }),\n    isNative: P.optional(U32LEBOOL, P.U64LE, 0n),\n    delegateAmount: P.U64LE,\n    closeAuthority: P.optional(U32LEBOOL, pubKey, '11111111111111111111111111111111'),\n});\nexport const swapProgram = 'SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8';\nexport function verifyTx(tx) {\n    if (typeof tx === 'string')\n        tx = base64.decode(tx);\n    if (tx.length > 1280 - 40 - 8)\n        throw new Error('sol: transaction too big');\n    const parsed = Transaction.decode(tx);\n    const raw = TransactionRaw.decode(tx);\n    const msg = Message.encode(TransactionRaw.decode(tx).msg);\n    for (let i = 0; i < raw.msg.requiredSignatures; i++) {\n        const address = raw.msg.keys[i];\n        const pubKey = base58.decode(address);\n        const sig = parsed.signatures[address];\n        if (!ed25519.verify(sig, msg, pubKey))\n            throw new Error(`sol: invalid signature sig=${sig} msg=${msg}`);\n    }\n}\nexport function getPublicKey(privateKey) {\n    return ed25519.getPublicKey(privateKey);\n}\nexport function getAddress(privateKey) {\n    const publicKey = getPublicKey(privateKey);\n    return base58.encode(publicKey);\n}\nexport function getAddressFromPublicKey(publicKey) {\n    return base58.encode(publicKey);\n}\nexport function formatPrivate(privateKey, format = 'base58') {\n    const publicKey = getPublicKey(privateKey);\n    const fullKey = P.utils.concatBytes(privateKey, publicKey);\n    switch (format) {\n        case 'base58': {\n            return base58.encode(fullKey);\n        }\n        case 'hex': {\n            return hex.encode(fullKey);\n        }\n        case 'array': {\n            return Array.from(fullKey);\n        }\n        default: {\n            throw new Error('sol: unsupported format');\n        }\n    }\n}\nexport function createTxComplex(address, instructions, blockhash) {\n    if (!instructions.length)\n        throw new Error('SOLPublic: empty instructions array');\n    return base64.encode(Transaction.encode({\n        msg: { feePayer: address, blockhash, instructions },\n        signatures: {},\n    }));\n}\nexport function createTx(from, to, amount, _fee, blockhash) {\n    const amountNum = Decimal.decode(amount);\n    return createTxComplex(from, [sys.transfer({ source: from, destination: to, lamports: amountNum })], blockhash);\n}\nexport function signTx(privateKey, data) {\n    if (typeof data === 'string')\n        data = base64.decode(data);\n    const address = getAddress(privateKey);\n    const raw = TransactionRaw.decode(data);\n    const reqSignatures = raw.msg.keys.slice(0, raw.msg.requiredSignatures);\n    if (!reqSignatures.filter((i) => i == address).length)\n        throw new Error(`SOLPrivate: tx doesn't require signature for address=${address}`);\n    const sig = ed25519.sign(Message.encode(raw.msg), privateKey);\n    for (let i = 0; i < reqSignatures.length; i++)\n        if (reqSignatures[i] === address)\n            raw.signatures[i] = sig;\n    // Base58 encoding for tx is deprecated\n    const tx = base64.encode(TransactionRaw.encode(raw));\n    // first signature is txHash\n    return [base58.encode(sig), tx];\n}\n//# sourceMappingURL=index.js.map","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","import * as sol from \"micro-sol-signer\";\nimport bs58 from \"bs58\";\n\n// Re-export from micro-sol-signer\nexport * from \"micro-sol-signer\";\n\n// Export our custom utilities\nexport { Connection } from \"./connection\";\nexport * from \"./spl-token\";\n\n// Additional compatibility layer for easier migration\nexport class PublicKey {\n  private _publicKey: string;\n\n  constructor(value: string | Uint8Array | number[] | Buffer | PublicKey) {\n    if (value instanceof PublicKey) {\n      this._publicKey = value.toString();\n    } else if (typeof value === \"string\") {\n      this._publicKey = value;\n    } else if (\n      value instanceof Uint8Array ||\n      Array.isArray(value) ||\n      Buffer.isBuffer(value)\n    ) {\n      const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n      this._publicKey = bs58.encode(bytes);\n    } else {\n      throw new Error(\"Invalid public key input\");\n    }\n  }\n\n  toString(): string {\n    return this._publicKey;\n  }\n\n  toBytes(): Uint8Array {\n    return bs58.decode(this._publicKey);\n  }\n\n  toBuffer(): Buffer {\n    return Buffer.from(this.toBytes());\n  }\n\n  equals(other: PublicKey | string): boolean {\n    const otherKey = other instanceof PublicKey ? other.toString() : other;\n    return this._publicKey === otherKey;\n  }\n\n  toBase58(): string {\n    return this._publicKey;\n  }\n}\n\n// Transaction compatibility wrapper\nexport class Transaction {\n  private _transaction: any;\n  public signatures: Array<{\n    signature: Uint8Array | null;\n    publicKey: PublicKey;\n  }> = [];\n  public feePayer?: PublicKey;\n  public recentBlockhash?: string;\n  private _instructions: sol.Instruction[];\n\n  constructor() {\n    // We'll build instructions array and serialize using micro-sol-signer\n    this._instructions = [];\n  }\n\n  add(...instructions: sol.Instruction[]): Transaction {\n    this._instructions.push(...instructions);\n    return this;\n  }\n\n  static from(buffer: Uint8Array | Buffer | number[]): Transaction {\n    // Decode using micro-sol-signer\n    const bytes =\n      buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n    const decoded = sol.Transaction.decode(bytes);\n\n    // Create a new Transaction and populate it\n    const tx = new Transaction();\n    // Note: This would need proper mapping from decoded to our wrapper\n    // For now, storing the raw decoded transaction\n    tx._transaction = decoded;\n    return tx;\n  }\n\n  serialize(_options?: { requireAllSignatures?: boolean }): Buffer {\n    // Build transaction using micro-sol-signer\n    if (this._transaction) {\n      // If we have a decoded transaction, re-serialize it\n      return Buffer.from(sol.Transaction.encode(this._transaction));\n    }\n\n    // Build from instructions\n    if (!this.feePayer || !this.recentBlockhash) {\n      throw new Error(\"Transaction requires feePayer and recentBlockhash\");\n    }\n\n    const txHex = sol.createTxComplex(\n      this.feePayer.toString(),\n      this._instructions,\n      this.recentBlockhash,\n    );\n\n    return Buffer.from(txHex, \"hex\");\n  }\n\n  serializeMessage(): Buffer {\n    // Serialize just the message part\n    if (!this.feePayer || !this.recentBlockhash) {\n      throw new Error(\"Transaction requires feePayer and recentBlockhash\");\n    }\n\n    const txHex = sol.createTxComplex(\n      this.feePayer.toString(),\n      this._instructions,\n      this.recentBlockhash,\n    );\n\n    // Return the message part of the transaction\n    return Buffer.from(txHex, \"hex\");\n  }\n}\n\n// Versioned transaction support\nexport class VersionedTransaction {\n  constructor(\n    public message: any,\n    public signatures: Uint8Array[],\n  ) {}\n\n  static deserialize(serialized: Uint8Array): VersionedTransaction {\n    const decoded = sol.Transaction.decode(serialized);\n    // Map to VersionedTransaction format\n    return new VersionedTransaction(decoded, []);\n  }\n\n  serialize(): Uint8Array {\n    return sol.Transaction.encode(this.message);\n  }\n}\n","import {\n  PublicKey,\n  Transaction,\n  VersionedTransaction,\n} from \"../../utils/solana\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\ninterface PhantomProvider {\n  isPhantom: boolean;\n  publicKey: PublicKey | null;\n  isConnected: boolean;\n  connect(opts?: { onlyIfTrusted: boolean }): Promise<{ publicKey: PublicKey }>;\n  disconnect(): Promise<void>;\n  signTransaction(\n    transaction: Transaction | VersionedTransaction,\n  ): Promise<Transaction | VersionedTransaction>;\n  signAllTransactions(\n    transactions: (Transaction | VersionedTransaction)[],\n  ): Promise<(Transaction | VersionedTransaction)[]>;\n  signAndSendTransaction(\n    transaction: Transaction | VersionedTransaction,\n    opts?: { skipPreflight?: boolean; maxRetries?: number },\n  ): Promise<{ signature: string }>;\n  signMessage(\n    message: Uint8Array,\n    display?: \"utf8\" | \"hex\",\n  ): Promise<{ signature: Uint8Array }>;\n  on(\n    event: \"connect\" | \"disconnect\" | \"accountChanged\",\n    handler: (args: unknown) => void,\n  ): void;\n  request(args: { method: string; params?: unknown }): Promise<unknown>;\n}\n\nexport class PhantomWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"phantom\";\n  readonly platform: ExternalPlatform = \"solana\";\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n\n  private getProvider(): PhantomProvider {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"Not ready\");\n    }\n\n    const provider = window.solana;\n\n    if (!provider?.isPhantom) {\n      throw new Error(\"Phantom is not available\");\n    }\n\n    return provider;\n  }\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.solana?.isPhantom;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: \"Unknown\",\n      name: \"Phantom\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Phantom is not available\");\n      }\n\n      const response = await this.getProvider().connect();\n      if (response.publicKey) {\n        this.account = response.publicKey.toString();\n        return { success: true, wallet: this.type, account: this.account };\n      }\n\n      throw new Error(\"No accounts found\");\n    } catch (error) {\n      console.error(`Error connecting to Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signMessage(message: string): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(\"Phantom is not connected\");\n      }\n\n      const encodedMessage = new TextEncoder().encode(message);\n      const result = await this.getProvider().signMessage(\n        encodedMessage,\n        \"utf8\",\n      );\n      return { success: true, wallet: this.type, result };\n    } catch (error) {\n      console.error(`Error signing message with Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(\n    serailized_txn: Uint8Array,\n  ): Promise<ExternalWalletResponse<any>> {\n    if (!this.isAvailable() || !this.account) {\n      throw new Error(\"Phantom is not connected\");\n    }\n\n    try {\n      const txn = Transaction.from(serailized_txn);\n      const provider = this.getProvider();\n      const result = await provider.signAndSendTransaction(txn);\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(_chainId: string): Promise<boolean> {\n    console.warn(\"Chain switching not supported for Phantom\");\n    return false;\n  }\n\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.account) {\n        throw new Error(\"Phantom is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Phantom's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Phantom API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Phantom:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Phantom wallet\",\n    };\n  }\n}\n","import { ExternalWalletType } from \"../types\";\nimport { EthereumWalletBase } from \"../ethereum-base\";\n\nexport class RabbyWallet extends EthereumWalletBase {\n  readonly type: ExternalWalletType = \"rabby\";\n  readonly rdns = \"io.rabby\";\n  readonly displayName = \"Rabby\";\n}\n","import { Call, TypedData, StarknetWindowObject } from \"@starknet-io/types-js\";\nimport {\n  ExternalPlatform,\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"../types\";\n\nexport class BraavosWallet implements WalletAdapter {\n  readonly type: ExternalWalletType = \"braavos\";\n  readonly platform: ExternalPlatform = \"starknet\";\n  private wallet: StarknetWindowObject | undefined = undefined;\n  private account: string | undefined = undefined;\n  private connectedAccounts: string[] = [];\n  private accountChangeListener: ((accounts?: string[]) => void) | undefined =\n    undefined;\n\n  isAvailable(): boolean {\n    return typeof window !== \"undefined\" && !!window.starknet_braavos;\n  }\n\n  getInfo(): ExternalWallet {\n    const available = this.isAvailable();\n\n    return {\n      type: this.type,\n      available,\n      version: available\n        ? window.starknet_braavos?.version || \"Unknown\"\n        : undefined,\n      chainId: available ? window.starknet_braavos?.chainId : undefined,\n      name: \"Braavos\",\n      platform: this.platform,\n    };\n  }\n\n  async connect(): Promise<ExternalWalletResponse<any>> {\n    if (this.account) {\n      return { success: true, wallet: this.type, account: this.account };\n    }\n\n    try {\n      if (!this.isAvailable()) {\n        throw new Error(\"Braavos is not available\");\n      }\n\n      const wallet = window.starknet_braavos as StarknetWindowObject;\n      if (!wallet) {\n        throw new Error(\"No wallet found\");\n      }\n\n      // Request accounts from the wallet\n      const accounts = await wallet.request({\n        type: \"wallet_requestAccounts\",\n        params: { silent_mode: false },\n      });\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error(\"No accounts found\");\n      }\n\n      this.removeAccountChangeListener();\n\n      this.wallet = wallet;\n      this.account = accounts[0];\n      this.connectedAccounts = accounts;\n      this.setupAccountChangeListener();\n      return { success: true, wallet: this.type, account: this.account };\n    } catch (error) {\n      console.error(`Error connecting to Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  getConnectedAccounts(): string[] {\n    return this.connectedAccounts;\n  }\n\n  async signTypedData(data: TypedData): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Braavos is not connected\");\n      }\n\n      const sig = await this.wallet.request({\n        type: \"wallet_signTypedData\",\n        params: data,\n      });\n\n      return { success: true, wallet: this.type, result: sig };\n    } catch (error) {\n      console.error(`Error signing typed data with Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async sendTransaction(calls: Call[]): Promise<ExternalWalletResponse> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    try {\n      const result = await this.wallet.request({\n        type: \"wallet_addInvokeTransaction\",\n        params: {\n          calls,\n        },\n      });\n\n      return {\n        success: true,\n        wallet: this.type,\n        result,\n      };\n    } catch (error) {\n      console.error(`Error sending transaction with Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async switchChain(chainId: string): Promise<boolean> {\n    if (!this.wallet) {\n      throw new Error(\"No wallet found\");\n    }\n\n    const result = await this.wallet.request({\n      type: \"wallet_switchStarknetChain\",\n      params: {\n        chainId,\n      },\n    });\n\n    return result;\n  }\n  async getBalance(\n    _tokenAddress?: string,\n  ): Promise<ExternalWalletResponse<any>> {\n    try {\n      if (!this.isAvailable() || !this.wallet) {\n        throw new Error(\"Braavos is not connected\");\n      }\n\n      // TODO: Implement balance fetching based on Braavos's API\n      return {\n        success: true,\n        wallet: this.type,\n        result: \"Implement based on Braavos API\",\n      };\n    } catch (error) {\n      console.error(`Error getting balance from Braavos:`, error);\n      return {\n        success: false,\n        wallet: this.type,\n        error: (error as Error).message || \"Unknown error\",\n      };\n    }\n  }\n\n  async waitForTransaction(\n    _txHash: string,\n    _timeoutMs?: number,\n  ): Promise<ExternalWalletResponse<any>> {\n    return {\n      success: false,\n      wallet: this.type,\n      error: \"waitForTransaction not supported for Braavos wallet\",\n    };\n  }\n\n  private setupAccountChangeListener(): void {\n    if (!this.wallet) return;\n\n    this.accountChangeListener = (accounts: string[] | undefined) => {\n      if (accounts && accounts.length > 0) {\n        this.account = accounts[0];\n        this.connectedAccounts = accounts;\n      } else {\n        this.account = undefined;\n        this.connectedAccounts = [];\n      }\n    };\n\n    // Listen for account changes\n    this.wallet.on(\"accountsChanged\", this.accountChangeListener);\n  }\n\n  private removeAccountChangeListener(): void {\n    if (this.wallet && this.accountChangeListener) {\n      this.wallet.off(\"accountsChanged\", this.accountChangeListener);\n      this.accountChangeListener = undefined;\n    }\n  }\n\n  disconnect(): void {\n    this.removeAccountChangeListener();\n    this.wallet = undefined;\n    this.account = undefined;\n    this.connectedAccounts = [];\n  }\n}\n","import { getAddress } from \"ethers\";\nimport { ArgentWallet } from \"./argent\";\nimport { BaseWallet } from \"./base\";\nimport { MetaMaskWallet } from \"./metamask\";\nimport { PhantomWallet } from \"./phantom\";\nimport { RabbyWallet } from \"./rabby\";\nimport {\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\nimport { BraavosWallet } from \"./braavos\";\n\nexport class WalletBridge {\n  private readonly walletAdapters: Map<ExternalWalletType, WalletAdapter>;\n\n  constructor() {\n    this.walletAdapters = new Map<ExternalWalletType, WalletAdapter>();\n\n    if (typeof window == \"undefined\") {\n      return;\n    }\n\n    const metamask = new MetaMaskWallet();\n    this.walletAdapters.set(\"metamask\", metamask);\n\n    const phantom = new PhantomWallet();\n    this.walletAdapters.set(\"phantom\", phantom);\n\n    const argent = new ArgentWallet();\n    this.walletAdapters.set(\"argent\", argent);\n\n    const braavos = new BraavosWallet();\n    this.walletAdapters.set(\"braavos\", braavos);\n\n    const rabby = new RabbyWallet();\n    this.walletAdapters.set(\"rabby\", rabby);\n\n    const base = new BaseWallet();\n    this.walletAdapters.set(\"base\", base);\n\n    window.wallet_bridge = this;\n  }\n\n  getIFrameMethods() {\n    return {\n      externalDetectWallets: (_origin: string) => () => this.detectWallets(),\n      externalConnectWallet: (_origin: string) => (type: ExternalWalletType) =>\n        this.connectWallet(type),\n      externalSignMessage:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, message: string) =>\n          this.signMessage(identifier, message),\n      externalSignTypedData:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, data: any) =>\n          this.signTypedData(identifier, data),\n      externalSendTransaction:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, txn: any) =>\n          this.sendTransaction(identifier, txn),\n      externalGetBalance:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, tokenAddress?: string) =>\n          this.getBalance(identifier, tokenAddress),\n      externalSwitchChain:\n        (_origin: string) =>\n        (identifier: ExternalWalletType | string, chainId: string) =>\n          this.switchChain(identifier, chainId),\n      externalWaitForTransaction:\n        (_origin: string) =>\n        (\n          identifier: ExternalWalletType | string,\n          txHash: string,\n          timeoutMs?: number,\n        ) =>\n          this.waitForTransaction(identifier, txHash, timeoutMs),\n    };\n  }\n\n  async detectWallets(): Promise<ExternalWallet[]> {\n    const wallets = Array.from(this.walletAdapters.values()).map((adapter) =>\n      adapter.getInfo(),\n    ) as ExternalWallet[];\n\n    return wallets;\n  }\n\n  private getWalletAdapterByType(type: ExternalWalletType): WalletAdapter {\n    const adapter = this.walletAdapters.get(type);\n    if (!adapter) {\n      throw new Error(`Unsupported wallet type: ${type}`);\n    }\n    return adapter;\n  }\n\n  private handleError(\n    identifier: ExternalWalletType | string,\n    error: unknown,\n    operation: string,\n    responseType?: ExternalWalletType,\n  ): ExternalWalletResponse {\n    const errorMessage =\n      error instanceof Error ? error.message : \"Unknown error\";\n    let walletType: ExternalWalletType | string = \"unknown\";\n    if (typeof identifier === \"string\") {\n      const adapter = this.getConnectedWalletAdapter(identifier);\n      walletType = responseType ?? adapter?.type ?? identifier;\n    } else {\n      walletType = identifier;\n    }\n\n    console.error(`Error ${operation} with ${identifier} wallet:`, error);\n    return {\n      success: false,\n      wallet: walletType as ExternalWalletType,\n      error: errorMessage,\n    };\n  }\n\n  async connectWallet(\n    type: ExternalWalletType,\n  ): Promise<ExternalWalletResponse> {\n    try {\n      const wallet = this.getWalletAdapterByType(type);\n      const response = await wallet.connect();\n\n      if (response.success && response.account) {\n        console.log(\n          `Wallet ${type} connected with address ${response.account}`,\n        );\n      } else if (response.success && !response.account) {\n        console.error(\n          `Wallet ${type} connected successfully but did not provide an address.`,\n        );\n        return {\n          ...response,\n          success: false,\n          error: \"Wallet connected but address not found.\",\n        };\n      }\n\n      return response;\n    } catch (error) {\n      return this.handleError(type, error, \"connecting to\");\n    }\n  }\n\n  private getConnectedWalletAdapter(\n    identifier: ExternalWalletType | string,\n  ): WalletAdapter {\n    let wallet: WalletAdapter | undefined;\n    let checkSummedAddress: string;\n\n    try {\n      checkSummedAddress = getAddress(identifier);\n    } catch {\n      // getAddress failed, so this must be a wallet type\n      wallet = this.walletAdapters.get(identifier as ExternalWalletType);\n      if (!wallet) {\n        throw new Error(`Wallet ${identifier} is not connected or supported`);\n      }\n      return wallet;\n    }\n\n    wallet = this.walletAdapters.values().find((adapter) => {\n      return adapter.getConnectedAccounts().includes(checkSummedAddress);\n    });\n\n    if (!wallet) {\n      throw new Error(`No wallet found with connected address ${identifier}`);\n    }\n\n    return wallet;\n  }\n\n  async signMessage(\n    identifier: ExternalWalletType | string,\n    message: string,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      if (!wallet.signMessage) {\n        throw new Error(\n          `Wallet type ${wallet.type} (identifier: ${identifier}) does not support signing messages`,\n        );\n      }\n      return await wallet.signMessage(message, identifier);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"signing message with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async signTypedData(\n    identifier: ExternalWalletType | string,\n    data: any,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      if (!wallet.signTypedData) {\n        throw new Error(\n          `Wallet type ${wallet.type} (identifier: ${identifier}) does not support signing typed data`,\n        );\n      }\n      return await wallet.signTypedData(data);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"signing typed data with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async sendTransaction(\n    identifier: ExternalWalletType | string,\n    txn: any,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.sendTransaction(txn);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"sending transaction with\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async getBalance(\n    identifier: ExternalWalletType | string,\n    tokenAddress?: string,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.getBalance(tokenAddress);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"getting balance from\",\n        wallet?.type,\n      );\n    }\n  }\n\n  async switchChain(\n    identifier: ExternalWalletType | string,\n    chainId: string,\n  ): Promise<boolean> {\n    try {\n      const wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.switchChain(chainId);\n    } catch (error) {\n      console.error(`Error switching chain for ${identifier} wallet:`, error);\n      return false;\n    }\n  }\n\n  async waitForTransaction(\n    identifier: ExternalWalletType | string,\n    txHash: string,\n    timeoutMs?: number,\n  ): Promise<ExternalWalletResponse> {\n    let wallet: WalletAdapter | undefined;\n    try {\n      wallet = this.getConnectedWalletAdapter(identifier);\n      return await wallet.waitForTransaction(txHash, timeoutMs);\n    } catch (error) {\n      return this.handleError(\n        identifier,\n        error,\n        \"waiting for transaction with\",\n        wallet?.type,\n      );\n    }\n  }\n}\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n    solana?: any;\n    starknet_argentX?: any;\n    starknet_braavos?: any;\n    wallet_bridge?: WalletBridge;\n  }\n}\n\nexport type {\n  ExternalWallet,\n  ExternalWalletResponse,\n  ExternalWalletType,\n  WalletAdapter,\n} from \"./types\";\n","import { KEYCHAIN_URL } from \"../constants\";\nimport { Keychain, KeychainOptions } from \"../types\";\nimport { WalletBridge } from \"../wallets/bridge\";\nimport { IFrame, IFrameOptions } from \"./base\";\n\ntype KeychainIframeOptions = IFrameOptions<Keychain> &\n  KeychainOptions & {\n    version?: string;\n  };\n\nexport class KeychainIFrame extends IFrame<Keychain> {\n  private walletBridge: WalletBridge;\n\n  constructor({\n    url,\n    policies,\n    version,\n    slot,\n    namespace,\n    tokens,\n    ...iframeOptions\n  }: KeychainIframeOptions) {\n    const _url = new URL(url ?? KEYCHAIN_URL);\n    const walletBridge = new WalletBridge();\n\n    if (policies) {\n      _url.searchParams.set(\n        \"policies\",\n        encodeURIComponent(JSON.stringify(policies)),\n      );\n    }\n\n    if (version) {\n      _url.searchParams.set(\"v\", encodeURIComponent(version));\n    }\n\n    if (slot) {\n      _url.searchParams.set(\"ps\", encodeURIComponent(slot));\n    }\n\n    if (namespace) {\n      _url.searchParams.set(\"ns\", encodeURIComponent(namespace));\n    }\n\n    if (tokens?.erc20) {\n      _url.searchParams.set(\n        \"erc20\",\n        encodeURIComponent(tokens.erc20.toString()),\n      );\n    }\n\n    super({\n      ...iframeOptions,\n      id: \"controller-keychain\",\n      url: _url,\n      methods: walletBridge.getIFrameMethods(),\n    });\n\n    this.walletBridge = walletBridge;\n\n    // Expose the wallet bridge instance globally for WASM interop\n    if (typeof window !== \"undefined\") {\n      (window as any).external_wallets = this.walletBridge;\n    }\n  }\n\n  getWalletBridge(): WalletBridge {\n    return this.walletBridge;\n  }\n}\n","import { AsyncMethodReturns } from \"@cartridge/penpal\";\n\nimport { Policy } from \"@cartridge/presets\";\nimport {\n  AddInvokeTransactionResult,\n  AddStarknetChainParameters,\n  ChainId,\n} from \"@starknet-io/types-js\";\nimport { constants, shortString, WalletAccount } from \"starknet\";\nimport { version } from \"../package.json\";\nimport ControllerAccount from \"./account\";\nimport { NotReadyToConnect } from \"./errors\";\nimport { KeychainIFrame } from \"./iframe\";\nimport BaseProvider from \"./provider\";\nimport {\n  Chain,\n  ConnectError,\n  ConnectReply,\n  ControllerOptions,\n  IFrames,\n  Keychain,\n  ProbeReply,\n  ProfileContextTypeVariant,\n  ResponseCodes,\n  StarterPack,\n} from \"./types\";\nimport { parseChainId } from \"./utils\";\n\nexport default class ControllerProvider extends BaseProvider {\n  private keychain?: AsyncMethodReturns<Keychain>;\n  private options: ControllerOptions;\n  private iframes: IFrames;\n  private selectedChain: ChainId;\n  private chains: Map<ChainId, Chain>;\n\n  isReady(): boolean {\n    return !!this.keychain;\n  }\n\n  constructor(options: ControllerOptions = {}) {\n    super();\n\n    // Default Cartridge chains that are always available\n    const cartridgeChains: Chain[] = [\n      { rpcUrl: \"https://api.cartridge.gg/x/starknet/sepolia/rpc/v0_9\" },\n      { rpcUrl: \"https://api.cartridge.gg/x/starknet/mainnet/rpc/v0_9\" },\n    ];\n\n    // Merge user chains with default chains\n    // User chains take precedence if they specify the same network\n    const chains = [...cartridgeChains, ...(options.chains || [])];\n    const defaultChainId =\n      options.defaultChainId || constants.StarknetChainId.SN_MAIN;\n\n    this.selectedChain = defaultChainId;\n    this.chains = new Map<ChainId, Chain>();\n    this.options = { ...options, chains, defaultChainId };\n\n    this.iframes = {\n      keychain: options.lazyload ? undefined : this.createKeychainIframe(),\n    };\n\n    this.initializeChains(chains);\n\n    if (typeof window !== \"undefined\") {\n      (window as any).starknet_controller = this;\n    }\n  }\n\n  async logout() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    try {\n      // Disconnect the controller/keychain first\n      await this.disconnect();\n\n      // Close all controller iframes\n      const iframes = document.querySelectorAll('iframe[id^=\"controller-\"]');\n      iframes.forEach((iframe) => {\n        const container = iframe.parentElement;\n        if (container) {\n          // Start fade-out transition\n          container.style.opacity = \"0\";\n          // Set display: none after transition completes\n          setTimeout(() => {\n            container.style.display = \"none\";\n          }, 200);\n        }\n      });\n\n      // Reset body overflow\n      if (document.body) {\n        document.body.style.overflow = \"auto\";\n      }\n\n      // Reload the page to complete logout\n      window.location.reload();\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      throw err;\n    }\n  }\n\n  async probe(): Promise<WalletAccount | undefined> {\n    try {\n      // Ensure iframe is created if using lazy loading\n      if (!this.iframes.keychain) {\n        this.iframes.keychain = this.createKeychainIframe();\n      }\n\n      await this.waitForKeychain();\n\n      if (!this.keychain) {\n        console.error(new NotReadyToConnect().message);\n        return;\n      }\n\n      const response = (await this.keychain.probe(this.rpcUrl())) as ProbeReply;\n\n      // For backwards compat with controller <=0.6.0\n      let rpcUrl = response?.rpcUrl || this.rpcUrl();\n      this.account = new ControllerAccount(\n        this,\n        rpcUrl,\n        response.address,\n        this.keychain,\n        this.options,\n        this.iframes.keychain,\n      );\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n\n    return this.account;\n  }\n\n  async connect(): Promise<WalletAccount | undefined> {\n    if (this.account) {\n      return this.account;\n    }\n\n    // Ensure iframe is created if using lazy loading\n    if (!this.iframes.keychain) {\n      this.iframes.keychain = this.createKeychainIframe();\n      // Wait for the keychain to be ready\n      await this.waitForKeychain();\n    }\n\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    if (typeof document !== \"undefined\" && !!document.hasStorageAccess) {\n      const ok = await document.hasStorageAccess();\n      if (!ok) {\n        await document.requestStorageAccess();\n      }\n    }\n\n    this.iframes.keychain.open();\n\n    try {\n      let response = await this.keychain.connect(\n        // Policy precedence logic:\n        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies\n        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)\n        // 3. Otherwise, use provided policies or empty object\n        this.options.shouldOverridePresetPolicies && this.options.policies\n          ? this.options.policies\n          : this.options.preset\n            ? {}\n            : this.options.policies || {},\n        this.rpcUrl(),\n        this.options.signupOptions,\n      );\n      if (response.code !== ResponseCodes.SUCCESS) {\n        throw new Error(response.message);\n      }\n\n      response = response as ConnectReply;\n      this.account = new ControllerAccount(\n        this,\n        this.rpcUrl(),\n        response.address,\n        this.keychain,\n        this.options,\n        this.iframes.keychain,\n      );\n\n      return this.account;\n    } catch (e) {\n      console.log(e);\n    } finally {\n      this.iframes.keychain.close();\n    }\n  }\n\n  async switchStarknetChain(chainId: string): Promise<boolean> {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return false;\n    }\n\n    const currentChain = this.selectedChain;\n\n    try {\n      this.selectedChain = chainId;\n      await this.keychain.switchChain(this.rpcUrl());\n    } catch (e) {\n      console.error(e);\n      this.selectedChain = currentChain;\n      return false;\n    }\n\n    this.emitNetworkChanged(chainId);\n    return true;\n  }\n\n  addStarknetChain(_chain: AddStarknetChainParameters): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n\n  async disconnect() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    if (typeof document !== \"undefined\" && !!document.hasStorageAccess) {\n      const ok = await document.hasStorageAccess();\n      if (!ok) {\n        await document.requestStorageAccess();\n      }\n    }\n\n    this.account = undefined;\n    return this.keychain.disconnect();\n  }\n\n  async openProfile(tab: ProfileContextTypeVariant = \"inventory\") {\n    // Profile functionality is now integrated into keychain\n    // Navigate keychain iframe to profile page\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n    const username = await this.keychain.username();\n\n    // Navigate first, then open to avoid flash\n    const options = [];\n    if (this.options.slot) {\n      options.push(`ps=${this.options.slot}`);\n    }\n    await this.keychain.navigate(\n      `/account/${username}/${tab}?${options.join(\"&\")}`,\n    );\n    this.iframes.keychain.open();\n  }\n\n  async openProfileTo(to: string) {\n    // Profile functionality is now integrated into keychain\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n\n    const username = await this.keychain.username();\n    const options = [];\n    if (this.options.slot) {\n      options.push(`ps=${this.options.slot}`);\n    }\n    await this.keychain.navigate(\n      `/account/${username}/${to}?${options.join(\"&\")}`,\n    );\n    this.iframes.keychain.open();\n  }\n\n  async openProfileAt(at: string) {\n    // Profile functionality is now integrated into keychain\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    if (!this.account) {\n      console.error(\"Account is not ready\");\n      return;\n    }\n\n    await this.keychain.navigate(at);\n    this.iframes.keychain.open();\n  }\n\n  openSettings() {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    this.iframes.keychain.open();\n    this.keychain.openSettings();\n  }\n\n  revoke(origin: string, _policy: Policy[]) {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return null;\n    }\n\n    return this.keychain.revoke(origin);\n  }\n\n  rpcUrl(): string {\n    const chain = this.chains.get(this.selectedChain);\n    if (!chain) {\n      const availableChains = Array.from(this.chains.keys()).map((chain) =>\n        shortString.decodeShortString(chain),\n      );\n      throw new Error(\n        `Chain not found: ${shortString.decodeShortString(this.selectedChain)}. Available chains: ${availableChains.join(\", \")}`,\n      );\n    }\n    return chain.rpcUrl;\n  }\n\n  username() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    return this.keychain.username();\n  }\n\n  openPurchaseCredits() {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    this.keychain.navigate(\"/purchase/credits\").then(() => {\n      this.iframes.keychain?.open();\n    });\n  }\n\n  async openStarterPack(options: string | StarterPack): Promise<void> {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n\n    // Pass options directly to keychain's unified openStarterPack method\n    await this.keychain.openStarterPack(options);\n    this.iframes.keychain?.open();\n  }\n\n  async openExecute(calls: any, chainId?: string) {\n    if (!this.keychain || !this.iframes.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return;\n    }\n    // Switch to the chain if provided\n    let currentChainId = this.selectedChain;\n    if (chainId) {\n      this.switchStarknetChain(chainId);\n    }\n    // Open keychain\n    this.iframes.keychain.open();\n    // Invoke execute\n    const res = await this.keychain.execute(calls, undefined, undefined, true);\n    // Close keychain\n    this.iframes.keychain.close();\n    // Switch back to the original chain\n    if (chainId) {\n      this.switchStarknetChain(currentChainId);\n    }\n    const status = !(\n      res &&\n      ((res as ConnectError).code === ResponseCodes.NOT_CONNECTED ||\n        (res as ConnectError).code === ResponseCodes.CANCELED)\n    );\n    return {\n      status,\n      transactionHash: (res as AddInvokeTransactionResult)?.transaction_hash,\n    };\n  }\n\n  async delegateAccount() {\n    if (!this.keychain) {\n      console.error(new NotReadyToConnect().message);\n      return null;\n    }\n\n    return await this.keychain.delegateAccount();\n  }\n\n  private initializeChains(chains: Chain[]) {\n    for (const chain of chains) {\n      try {\n        const url = new URL(chain.rpcUrl);\n        const chainId = parseChainId(url);\n\n        // Validate that mainnet and sepolia must use Cartridge RPC\n        const isMainnet = chainId === constants.StarknetChainId.SN_MAIN;\n        const isSepolia = chainId === constants.StarknetChainId.SN_SEPOLIA;\n        const isCartridgeRpc = url.hostname === \"api.cartridge.gg\";\n        const isLocalhost =\n          url.hostname === \"localhost\" || url.hostname === \"127.0.0.1\";\n\n        if ((isMainnet || isSepolia) && !(isCartridgeRpc || isLocalhost)) {\n          throw new Error(\n            `Only Cartridge RPC providers are allowed for ${isMainnet ? \"mainnet\" : \"sepolia\"}. ` +\n              `Please use: https://api.cartridge.gg/x/starknet/${isMainnet ? \"mainnet\" : \"sepolia\"}/rpc/v0_9`,\n          );\n        }\n\n        this.chains.set(chainId, chain);\n      } catch (error) {\n        console.error(`Failed to parse chainId for ${chain.rpcUrl}:`, error);\n        throw error; // Re-throw to ensure invalid chains fail fast\n      }\n    }\n\n    if (!this.chains.has(this.selectedChain)) {\n      console.warn(\n        `Selected chain ${this.selectedChain} not found in configured chains. ` +\n          `Available chains: ${Array.from(this.chains.keys()).join(\", \")}`,\n      );\n    }\n  }\n\n  private createKeychainIframe(): KeychainIFrame {\n    return new KeychainIFrame({\n      ...this.options,\n      onClose: this.keychain?.reset,\n      onConnect: (keychain) => {\n        this.keychain = keychain;\n      },\n      version: version,\n    });\n  }\n\n  private waitForKeychain({\n    timeout = 50000,\n    interval = 100,\n  }:\n    | {\n        timeout?: number;\n        interval?: number;\n      }\n    | undefined = {}) {\n    return new Promise<void>((resolve, reject) => {\n      const startTime = Date.now();\n      const id = setInterval(() => {\n        if (Date.now() - startTime > timeout) {\n          clearInterval(id);\n          reject(new Error(\"Timeout waiting for keychain\"));\n          return;\n        }\n\n        if (!this.keychain) return;\n\n        clearInterval(id);\n        resolve();\n      }, interval);\n    });\n  }\n}\n","import { LookupRequest, LookupResponse } from \"./types\";\nimport { num } from \"starknet\";\nimport { API_URL } from \"./constants\";\n\nconst cache = new Map<string, string>();\n\nasync function lookup(request: LookupRequest): Promise<LookupResponse> {\n  if (!request.addresses?.length && !request.usernames?.length) {\n    return { results: [] };\n  }\n\n  const response = await fetch(`${API_URL}/lookup`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(request),\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  return response.json();\n}\n\nexport async function lookupUsernames(\n  usernames: string[],\n): Promise<Map<string, string>> {\n  const uncachedUsernames = usernames.filter((name) => !cache.has(name));\n\n  if (uncachedUsernames.length > 0) {\n    const response = await lookup({ usernames: uncachedUsernames });\n\n    response.results.forEach((result) => {\n      cache.set(result.username, result.addresses[0]); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    usernames\n      .map((name) => [name, cache.get(name)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n\nexport async function lookupAddresses(\n  addresses: string[],\n): Promise<Map<string, string>> {\n  addresses = addresses.map(num.toHex);\n  const uncachedAddresses = addresses.filter((addr) => !cache.has(addr));\n\n  if (uncachedAddresses.length > 0) {\n    const response = await lookup({\n      addresses: uncachedAddresses,\n    });\n\n    response.results.forEach((result) => {\n      cache.set(result.addresses[0], result.username); // TODO: handle multiple controller addresses\n    });\n  }\n\n  return new Map(\n    addresses\n      .map((addr) => [addr, cache.get(addr)] as [string, string])\n      .filter((entry): entry is [string, string] => entry[1] !== undefined),\n  );\n}\n","// src/generated/erc20-metadata.ts\nvar metadata = [\n  {\n    name: \"Wrapped BTC\",\n    symbol: \"WBTC\",\n    decimals: 8,\n    l2_token_address: \"0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac\",\n    sort_order: 0,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo\"\n  },\n  {\n    name: \"USD Coin\",\n    symbol: \"USDC\",\n    decimals: 6,\n    l2_token_address: \"0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8\",\n    sort_order: 5,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo\"\n  },\n  {\n    name: \"LUSD Stablecoin\",\n    symbol: \"LUSD\",\n    decimals: 18,\n    l2_token_address: \"0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo\"\n  },\n  {\n    name: \"Tether USD\",\n    symbol: \"USDT\",\n    decimals: 6,\n    l2_token_address: \"0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8\",\n    sort_order: 4,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo\"\n  },\n  {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    l2_token_address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    sort_order: 3,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo\"\n  },\n  {\n    name: \"Dai Stablecoin\",\n    symbol: \"DAIv0\",\n    decimals: 18,\n    l2_token_address: \"0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3\",\n    sort_order: 4,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo\"\n  },\n  {\n    name: \"Dai Stablecoin\",\n    symbol: \"DAI\",\n    decimals: 18,\n    l2_token_address: \"0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad\",\n    sort_order: 4,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo\"\n  },\n  {\n    name: \"Legacy Starknet Wrapped Staked Ether\",\n    symbol: \"wstETH-legacy\",\n    decimals: 18,\n    l2_token_address: \"0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/26162dcc-29c2-4f5e-3acd-5e6be1f07a00/logo\"\n  },\n  {\n    name: \"Wrapped Staked Ether\",\n    symbol: \"wstETH\",\n    decimals: 18,\n    l2_token_address: \"0x0057912720381af14b0e5c87aa4718ed5e527eab60b3801ebf702ab09139e38b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo\"\n  },\n  {\n    name: \"Rocket Pool ETH\",\n    symbol: \"rETH\",\n    decimals: 18,\n    l2_token_address: \"0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo\"\n  },\n  {\n    name: \"LORDS\",\n    symbol: \"LORDS\",\n    decimals: 18,\n    l2_token_address: \"0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49\",\n    sort_order: 1,\n    total_supply: 509e5,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo\"\n  },\n  {\n    name: \"R Stablecoin\",\n    symbol: \"R\",\n    decimals: 18,\n    l2_token_address: \"0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo\"\n  },\n  {\n    name: \"Frax\",\n    symbol: \"FRAX\",\n    decimals: 18,\n    l2_token_address: \"0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406\",\n    sort_order: 1,\n    total_supply: 649462235,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo\"\n  },\n  {\n    name: \"Frax Share\",\n    symbol: \"FXS\",\n    decimals: 18,\n    l2_token_address: \"0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo\"\n  },\n  {\n    name: \"Staked Frax Ether\",\n    symbol: \"sfrxETH\",\n    decimals: 18,\n    l2_token_address: \"0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo\"\n  },\n  {\n    name: \"Uniswap\",\n    symbol: \"UNI\",\n    decimals: 18,\n    l2_token_address: \"0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee\",\n    sort_order: 1,\n    total_supply: 1e9,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo\"\n  },\n  {\n    name: \"Paper\",\n    symbol: \"PAPER\",\n    decimals: 18,\n    l2_token_address: \"0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo\"\n  },\n  {\n    name: \"StarkPepe\",\n    symbol: \"xSPEPE\",\n    decimals: 18,\n    l2_token_address: \"0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    disabled: true\n  },\n  {\n    name: \"StarkNet Token\",\n    symbol: \"STRK\",\n    decimals: 18,\n    l2_token_address: \"0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d\",\n    sort_order: 2,\n    total_supply: 1e10,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo\"\n  },\n  {\n    name: \"zkLend Token\",\n    symbol: \"ZEND\",\n    decimals: 18,\n    l2_token_address: \"0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo\"\n  },\n  {\n    name: \"Ekubo Protocol\",\n    symbol: \"EKUBO\",\n    decimals: 18,\n    l2_token_address: \"0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87\",\n    sort_order: 1,\n    total_supply: 1e7,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo\"\n  },\n  {\n    name: \"SOCKS\",\n    symbol: \"SOCKS\",\n    decimals: 18,\n    l2_token_address: \"0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015\",\n    sort_order: 1,\n    total_supply: 1e11,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo\"\n  },\n  {\n    name: \"Nostra\",\n    symbol: \"NSTR\",\n    decimals: 18,\n    l2_token_address: \"0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007\",\n    sort_order: 1,\n    total_supply: 1e8,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo\"\n  },\n  {\n    name: \"Carmine\",\n    symbol: \"CRM\",\n    decimals: 18,\n    l2_token_address: \"0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe\",\n    sort_order: 1,\n    total_supply: 1e8,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo\"\n  },\n  {\n    name: \"Cash\",\n    symbol: \"CASH\",\n    decimals: 18,\n    l2_token_address: \"0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada\",\n    sort_order: 3,\n    total_supply: null,\n    hidden: false,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo\"\n  },\n  {\n    name: \"Nums\",\n    symbol: \"NUMS\",\n    decimals: 18,\n    l2_token_address: \"0xe5f10eddc01699dc899a30dbc3c9858148fa4aa0a47c0ffd85f887ffc4653e\",\n    sort_order: 1,\n    total_supply: 1,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/90868d05-cb75-4c42-278c-5a540db2cf00/logo\"\n  },\n  {\n    name: \"Flip\",\n    symbol: \"FLIP\",\n    decimals: 18,\n    l2_token_address: \"0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo\"\n  },\n  {\n    name: \"Eternum Stone\",\n    symbol: \"STONE\",\n    decimals: 18,\n    l2_token_address: \"0x439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/932e7f83-a4c2-40f0-3048-35af3b194100/logo\"\n  },\n  {\n    name: \"Eternum Coal\",\n    symbol: \"COAL\",\n    decimals: 18,\n    l2_token_address: \"0xce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cf2ee180-06bf-4443-e3aa-724d7c28e800/logo\"\n  },\n  {\n    name: \"Eternum Wood\",\n    symbol: \"WOOD\",\n    decimals: 18,\n    l2_token_address: \"0x40d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1db5f954-c1ef-447e-9f8f-05bd9f3b2b00/logo\"\n  },\n  {\n    name: \"Eternum Copper\",\n    symbol: \"COPPER\",\n    decimals: 18,\n    l2_token_address: \"0x66ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bbcdcc9-6146-404d-9501-92a664cf3100/logo\"\n  },\n  {\n    name: \"Eternum Ironwood\",\n    symbol: \"IRONWOOD\",\n    decimals: 18,\n    l2_token_address: \"0x1720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5af7c03b-e4ae-4aee-eba4-a4e2160a1d00/logo\"\n  },\n  {\n    name: \"Eternum Obsidian\",\n    symbol: \"OBSIDIAN\",\n    decimals: 18,\n    l2_token_address: \"0x3b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8be9bc66-486b-4181-6804-725a1db8ad00/logo\"\n  },\n  {\n    name: \"Eternum Gold\",\n    symbol: \"GOLD\",\n    decimals: 18,\n    l2_token_address: \"0xdff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fb9e90f7-3c2f-4c64-7e43-c3f694f35e00/logo\"\n  },\n  {\n    name: \"Eternum Silver\",\n    symbol: \"SILVER\",\n    decimals: 18,\n    l2_token_address: \"0x6fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e443afeb-850b-46a0-a7ba-a473306d6b00/logo\"\n  },\n  {\n    name: \"Eternum Mithral\",\n    symbol: \"MITHRAL\",\n    decimals: 18,\n    l2_token_address: \"0x67ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33dc517f-8a66-45eb-f2c5-de5388e47500/logo\"\n  },\n  {\n    name: \"Eternum Alchemical Silver\",\n    symbol: \"ALCHEMICALSILVER\",\n    decimals: 18,\n    l2_token_address: \"0x3956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3d2e0fd8-4af8-49a0-4bdb-691a4d6ef800/logo\"\n  },\n  {\n    name: \"Eternum Cold Iron\",\n    symbol: \"COLDIRON\",\n    decimals: 18,\n    l2_token_address: \"0x555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/878c0d8a-8e2c-4281-0896-9cbbb2ef9400/logo\"\n  },\n  {\n    name: \"Eternum Deep Crystal\",\n    symbol: \"DEEPCRYSTAL\",\n    decimals: 18,\n    l2_token_address: \"0x1d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1c2c954f-448c-476b-a4a6-19b52efe3e00/logo\"\n  },\n  {\n    name: \"Eternum Ruby\",\n    symbol: \"RUBY\",\n    decimals: 18,\n    l2_token_address: \"0x3d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6a45b34d-3bfe-4994-45b0-f2bee8abac00/logo\"\n  },\n  {\n    name: \"Eternum Diamonds\",\n    symbol: \"DIAMONDS\",\n    decimals: 18,\n    l2_token_address: \"0xe03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/b1fa609d-8799-4754-cdea-ab69514ca700/logo\"\n  },\n  {\n    name: \"Eternum Hartwood\",\n    symbol: \"HARTWOOD\",\n    decimals: 18,\n    l2_token_address: \"0x5620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/27e37e85-91bd-4ee1-0552-1e0795077400/logo\"\n  },\n  {\n    name: \"Eternum Ignium\",\n    symbol: \"IGNIUM\",\n    decimals: 18,\n    l2_token_address: \"0x625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/58591e20-24fb-4353-417a-81d877a5a200/logo\"\n  },\n  {\n    name: \"Eternum Twilight Quartz\",\n    symbol: \"TWILIGHTQUARTZ\",\n    decimals: 18,\n    l2_token_address: \"0x35e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2f8cb892-e82a-4af3-bd09-316061faec00/logo\"\n  },\n  {\n    name: \"Eternum True Ice\",\n    symbol: \"TRUEICE\",\n    decimals: 18,\n    l2_token_address: \"0x4485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fe4bfc17-6553-4dc5-58d2-f452b4aa8a00/logo\"\n  },\n  {\n    name: \"Eternum Adamantine\",\n    symbol: \"ADAMANTINE\",\n    decimals: 18,\n    l2_token_address: \"0x367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/13bd026b-3612-480e-0119-04cf4c505a00/logo\"\n  },\n  {\n    name: \"Eternum Sapphire\",\n    symbol: \"SAPPHIRE\",\n    decimals: 18,\n    l2_token_address: \"0x2f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0ebf555f-e732-4054-f8e5-55b2ed49ba00/logo\"\n  },\n  {\n    name: \"Eternum Ethereal Silica\",\n    symbol: \"ETHEREALSILICA\",\n    decimals: 18,\n    l2_token_address: \"0x68b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f02a5b43-bfcf-408c-7d1b-fcfe68b02d00/logo\"\n  },\n  {\n    name: \"Eternum Dragon Hide\",\n    symbol: \"DRAGONHIDE\",\n    decimals: 18,\n    l2_token_address: \"0x3bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e74955fc-5c8a-4dff-4882-a49a46a5a800/logo\"\n  },\n  {\n    name: \"Eternum Ancient Fragment\",\n    symbol: \"ANCIENTFRAGMENT\",\n    decimals: 18,\n    l2_token_address: \"0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9af855b7-4790-4390-9466-6bed4481ab00/logo\"\n  },\n  {\n    name: \"Eternum Donkey\",\n    symbol: \"DONKEY\",\n    decimals: 18,\n    l2_token_address: \"0x264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/20817378-a45e-4521-f464-10f6dd13c500/logo\"\n  },\n  {\n    name: \"Eternum Knight\",\n    symbol: \"KNIGHT\",\n    decimals: 18,\n    l2_token_address: \"0xac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8787ed1f-af5c-4873-c01a-55f05e999a00/logo\"\n  },\n  {\n    name: \"Eternum Crossbowman\",\n    symbol: \"CROSSBOWMAN\",\n    decimals: 18,\n    l2_token_address: \"0x67e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dec7f31b-4b1d-46bb-4fca-c0253cf55a00/logo\"\n  },\n  {\n    name: \"Eternum Paladin\",\n    symbol: \"PALADIN\",\n    decimals: 18,\n    l2_token_address: \"0x3bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7d2cd5a5-f38a-49f6-11f8-ba3b59a59e00/logo\"\n  },\n  {\n    name: \"Eternum Wheat\",\n    symbol: \"WHEAT\",\n    decimals: 18,\n    l2_token_address: \"0x57a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c338b6a8-77c4-4dd6-34f5-1af0d3fb1e00/logo\"\n  },\n  {\n    name: \"Eternum Fish\",\n    symbol: \"FISH\",\n    decimals: 18,\n    l2_token_address: \"0x27719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9\",\n    sort_order: 1,\n    total_supply: null,\n    hidden: true,\n    logo_url: \"https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6deef27f-df40-4248-4e1b-ed1d79a3f000/logo\"\n  },\n  {\n    name: \"Fools\",\n    symbol: \"FOOLS\",\n    decimals: 18,\n    l2_token_address: \"0x068a7a07e08fc3e723a878223d00f669106780d5ea6665eb15d893476d47bf3b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://assets.underware.gg/pistols/fools.svg\"\n  },\n  {\n    name: \"Fame\",\n    symbol: \"FAME\",\n    decimals: 18,\n    l2_token_address: \"0x02549653a4ae1ff8d04a20b8820a49cbe97486c536ec0e4c8f68aa33d80067cf\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://assets.underware.gg/pistols/fame.svg\"\n  },\n  {\n    name: \"Survivor\",\n    symbol: \"SURVIVOR\",\n    decimals: 18,\n    l2_token_address: \"0x42dd777885ad2c116be96d4d634abc90a26a790ffb5871e037dd5ae7d2ec86b\",\n    sort_order: 1,\n    total_supply: null,\n    logo_url: \"https://lootsurvivor.io/images/survivor_token.png\"\n  }\n];\n\n// configs/cartridge/config.json\nvar config_default = {\n  origin: \"*\",\n  theme: {\n    name: \"Cartridge\",\n    icon: \"icon.svg\"\n  },\n  \"apple-app-site-association\": {\n    webcredentials: {\n      apps: [\n        \"FAKETEAMID.com.cartridge.marketplace\",\n        \"F9U4Y5YSTN.com.cartridge.marketplace\"\n      ]\n    }\n  }\n};\n\n// src/config-loader.ts\nvar CONFIG_BASE_URL = \"https://static.cartridge.gg/presets\";\nasync function getConfigsIndex() {\n  try {\n    const response = await fetch(`${CONFIG_BASE_URL}/index.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to load configs index: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(\"Error loading configs index:\", error);\n    return { configs: [], baseUrl: CONFIG_BASE_URL };\n  }\n}\nasync function getAvailableConfigs() {\n  const indexData = await getConfigsIndex();\n  return indexData.configs;\n}\nasync function loadConfig(configName) {\n  try {\n    const indexData = await getConfigsIndex();\n    const baseUrl = indexData.baseUrl || CONFIG_BASE_URL;\n    const prefix = `${baseUrl}/${configName}`;\n    const response = await fetch(`${prefix}/config.json`);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to load config ${configName}: ${response.statusText}`\n      );\n    }\n    const config = await response.json();\n    if (config && config.theme) {\n      if (config.theme.icon && !config.theme.icon.startsWith(\"http\")) {\n        config.theme.icon = `${prefix}/${config.theme.icon}`;\n      }\n      if (config.theme.cover) {\n        if (typeof config.theme.cover === \"string\") {\n          if (!config.theme.cover.startsWith(\"http\")) {\n            config.theme.cover = `${prefix}/${config.theme.cover}`;\n          }\n        } else {\n          if (config.theme.cover.light && !config.theme.cover.light.startsWith(\"http\")) {\n            config.theme.cover.light = `${prefix}/${config.theme.cover.light}`;\n          }\n          if (config.theme.cover.dark && !config.theme.cover.dark.startsWith(\"http\")) {\n            config.theme.cover.dark = `${prefix}/${config.theme.cover.dark}`;\n          }\n        }\n      }\n      const prefixOptimizedImageSet = (imageSet) => {\n        if (!imageSet) return;\n        for (const format in imageSet) {\n          if (imageSet[format]) {\n            for (const size in imageSet[format]) {\n              if (imageSet[format][size] && !imageSet[format][size].startsWith(\"http\")) {\n                imageSet[format][size] = `${prefix}/${imageSet[format][size]}`;\n              }\n            }\n          }\n        }\n      };\n      if (config.theme.optimizedIcon) {\n        prefixOptimizedImageSet(config.theme.optimizedIcon);\n      }\n      if (config.theme.optimizedCover) {\n        if (typeof config.theme.optimizedCover === \"string\") {\n          if (!config.theme.optimizedCover.startsWith(\"http\")) {\n            config.theme.optimizedCover = `${prefix}/${config.theme.optimizedCover}`;\n          }\n        } else if (config.theme.optimizedCover.light || config.theme.optimizedCover.dark) {\n          const themeVal = config.theme.optimizedCover;\n          if (themeVal.light) {\n            prefixOptimizedImageSet(themeVal.light);\n          }\n          if (themeVal.dark) {\n            prefixOptimizedImageSet(themeVal.dark);\n          }\n        } else {\n          prefixOptimizedImageSet(config.theme.optimizedCover);\n        }\n      }\n    }\n    return config;\n  } catch (error) {\n    console.error(`Error loading config ${configName}:`, error);\n    return null;\n  }\n}\nasync function loadAllConfigs() {\n  const indexData = await getConfigsIndex();\n  const availableConfigs = indexData.configs;\n  const baseUrl = indexData.baseUrl || CONFIG_BASE_URL;\n  const configsMap = {};\n  await Promise.all(\n    availableConfigs.map(async (configName) => {\n      try {\n        const response = await fetch(`${baseUrl}/${configName}/config.json`);\n        if (response.ok) {\n          const config = await response.json();\n          configsMap[configName] = config;\n        }\n      } catch (error) {\n        console.error(`Error loading config ${configName}:`, error);\n      }\n    })\n  );\n  return configsMap;\n}\n\n// src/index.ts\nconfig_default.theme.icon = \"https://static.cartridge.gg/presets/cartridge/icon.svg\";\nvar erc20Metadata = metadata;\nvar defaultTheme = config_default.theme;\nexport {\n  defaultTheme,\n  erc20Metadata,\n  getAvailableConfigs,\n  getConfigsIndex,\n  loadAllConfigs,\n  loadConfig\n};\n//# sourceMappingURL=index.js.map"],"names":["ControllerAccount","WalletAccount","provider","rpcUrl","address","keychain","options","modal","calls","toArray","resolve","reject","sessionExecute","ResponseCodes","manualExecute","typedData","sessionSign","manualSign","MessageType","Resolution","ErrorCode","NativeErrorName","NativeEventType","createDestructor","localName","log","callbacks","destroyed","error","callback","createLogger","debug","args","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","getOriginFromSrc","src","scheme","location","regexResult","protocol","hostname","port","portSuffix","serializeError","name","message","stack","deserializeError","obj","deserializedError","key","connectCallReceiver","info","serializedMethods","local","remote","originForSending","originForReceiving","handleMessageEvent","event","callMessage","methodName","id","createPromiseHandler","resolution","returnValue","err","errorReplyMessage","generateId","KEY_PATH_DELIMITER","keyPathToSegments","keyPath","segmentsToKeyPath","segments","createKeyPath","prefix","setAtKeyPath","subject","value","prevSubject","idx","serializeMethods","methods","flattenedMethods","deserializeMethods","connectCallSender","callSender","methodKeyPaths","destroyConnection","createMethodProxy","iframeRemoved","replyMessage","api","handleAckMessageFactory","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","receiverMethodName","destroyCallSender","handleSynMessageFactory","synAckMessage","CHECK_IFRAME_IN_DOC_INTERVAL","monitorIframeRemoval","iframe","checkIframeInDocIntervalId","startConnectionTimeout","timeout","timeoutId","validateIframeHasSrcOrSrcDoc","connectToChild","handleSynMessage","handleAckMessage","stopConnectionTimeout","handleMessage","IFrame","url","preset","onClose","onConnect","container","e","_origin","child","observer","existingController","version","defineProperties","target","values","types","stringify","HEX","result","i","keys","k","makeError","code","shortMessage","details","assert","check","assertArgument","accum","form","_getBytes","copy","offset","getBytes","HexCharacters","hexlify","data","bytes","v","isBytes","a","anumber","n","abytes","b","lengths","aexists","instance","checkFinished","aoutput","out","min","u32","arr","clean","arrays","isLE","byteSwap","word","byteSwap32","swap32IfBE","u","utf8ToBytes","str","toBytes","Hash","createHasher","hashCons","hashC","msg","tmp","U32_MASK64","_32n","fromBig","le","split","lst","len","Ah","Al","h","l","rotlSH","s","rotlSL","rotlBH","rotlBL","_0n","_1n","_2n","_7n","_256n","_0x71n","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","round","R","x","y","t","j","IOTAS","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","keccakP","rounds","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","Keccak","blockLen","suffix","outputLen","enableXOF","state","pos","take","bufferOut","to","gen","keccak_256","locked","_keccak256","__keccak256","keccak256","_data","func","BN_0","BN_36","getChecksumAddress","chars","expanded","hashed","ibanLookup","safeDigits","ibanChecksum","c","block","checksum","Base36","fromBase36","getAddress","ArgentWallet","available","wallet","accounts","sig","chainId","_tokenAddress","_txHash","_timeoutMs","requestProviders","listener","handler","createStore","listeners","providerDetails","request","providerDetail","unwatch","rdns","emitImmediately","PLATFORMS","constants","chainIdToPlatform","hex","num","platform","EthereumWalletBase","account","ethereum","transaction","txn","tokenAddress","balance","txHash","timeoutMs","startTime","pollInterval","receipt","BaseWallet","MetaMaskWallet","isArrayOf","isString","item","afn","input","astr","label","aArr","astrArr","anumArr","chain","wrap","encode","decode","alphabet","letters","lettersA","indexes","digits","letter","join","separator","from","padding","bits","chr","end","normalize","fn","convertRadix","res","d","dlen","carry","done","digit","fromCarry","digitBase","div","rounded","gcd","radix2carry","powers","convertRadix2","max","mask","pow","radix","_256","radix2","revPadding","hasBase64Builtin","base64","genBase58","abc","base58","utf8","hasHexBuiltin","hexBuiltin","equalBytes","createView","isPlainObject","isNum","lengthCoder","isCoder","w","byteLen","Path","r","Bitset","bs","bsLen","chunk","allowRewrite","invert","FULL_MASK","BITS","left","lastMask","m","cur","first","lastPos","last","start","objFn","field","fieldFn","path","parts","objPath","_Reader","opts","parent","parentOffset","baseHex","notRead","formatted","length","peek","slice","needle","_Writer","buffers","sum","buf","pad","ptr","p","swapEndianness","checkBounds","signed","signBit","_wrap","inner","validate","isBaseCoder","elm","dict","numberBigint","tsEnum","decimal","precision","decimalMask","sep","int","frac","neg","intS","fracS","fracLen","match","reverse","coder","coders","bigint","size","sized","bLen","U64LE","view","intView","validateSigned","maxVal","validateUnsigned","U32LE","U8","bool","createBytes","_length","_isb","tPos","string","apply","base","innerValue","optional","flag","def","constant","_w","_r","sizeof","fields","f","struct","array","startPos","map","variants","variantNames","variant","tag","TAG","dataType","ZeroPad","_","padLength","blockSize","padRight","padFn","_padFn","padBytes","PRECISION","Decimal","P.coders","shortVec","P.wrap","rustString","P.string","P.padRight","P.U32LE","b58","P.bytes","pubKey","Message","P.struct","P.U8","P.array","validateAddress","keyParams","req","unsigned","total","TransactionRaw","Transaction","signatures","add","sign","write","acc","_keys","requiredSignatures","readSigned","readUnsigned","sigs","registry","defineProgram","tagType","P.map","mainCoder","P.tag","instr","tl","program","SYS_RECENT_BLOCKHASHES","SYS_RENT","SYS_PROGRAM","sys","P.U64LE","o","assertType","_value","authorityType","tokenName","TOKEN_PROGRAM","P.optional","P.bool","ASSOCIATED_TOKEN_PROGRAM","P.constant","U32LEBOOL","createTxComplex","instructions","blockhash","ALPHABET","BASE_MAP","xc","BASE","LEADER","FACTOR","iFACTOR","source","zeroes","pbegin","pend","it1","it2","decodeUnsafe","psz","b256","charCode","it3","it4","vch","buffer","basex","decoded","sol.Transaction","tx","_options","txHex","sol.createTxComplex","PhantomWallet","response","encodedMessage","serailized_txn","_chainId","RabbyWallet","BraavosWallet","WalletBridge","metamask","phantom","argent","braavos","rabby","type","identifier","adapter","operation","responseType","errorMessage","walletType","checkSummedAddress","KeychainIFrame","policies","slot","namespace","tokens","iframeOptions","_url","KEYCHAIN_URL","walletBridge","ControllerProvider","BaseProvider","chains","defaultChainId","NotReadyToConnect","currentChain","_chain","tab","username","at","origin","_policy","availableChains","shortString","currentChainId","parseChainId","isMainnet","isSepolia","isCartridgeRpc","isLocalhost","interval","cache","lookup","API_URL","lookupUsernames","usernames","uncachedUsernames","entry","lookupAddresses","addresses","uncachedAddresses","addr","metadata","config_default","CONFIG_BASE_URL","getConfigsIndex","getAvailableConfigs","loadConfig","configName","config","prefixOptimizedImageSet","imageSet","format","themeVal","loadAllConfigs","indexData","availableConfigs","baseUrl","configsMap","erc20Metadata","defaultTheme"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,27,28,33,34,35,36,37,46]}