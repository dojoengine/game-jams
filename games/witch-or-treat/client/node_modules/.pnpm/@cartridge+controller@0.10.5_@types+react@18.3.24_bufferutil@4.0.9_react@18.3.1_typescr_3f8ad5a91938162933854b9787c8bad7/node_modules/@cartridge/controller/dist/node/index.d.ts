import { WalletAccount } from 'starknet';
import { ContractPolicy, Method, SignMessagePolicy, SessionPolicies } from '@cartridge/presets';
import { StarknetWindowObject, WalletEvents, RequestFn, WalletEventListener, AddStarknetChainParameters } from '@starknet-io/types-js';

declare abstract class BaseProvider implements StarknetWindowObject {
    id: string;
    name: string;
    version: string;
    icon: string;
    account?: WalletAccount;
    subscriptions: WalletEvents[];
    private _probePromise;
    protected safeProbe(): Promise<WalletAccount | undefined>;
    request: RequestFn;
    on: WalletEventListener;
    off: WalletEventListener;
    protected emitNetworkChanged(chainId: string): void;
    protected emitAccountsChanged(accounts: string[]): void;
    abstract probe(): Promise<WalletAccount | undefined>;
    abstract connect(): Promise<WalletAccount | undefined>;
    abstract switchStarknetChain(chainId: string): Promise<boolean>;
    abstract addStarknetChain(chain: AddStarknetChainParameters): Promise<boolean>;
}

type ParsedSessionPolicies = {
    verified: boolean;
    contracts?: SessionContracts;
    messages?: SessionMessages;
};
type SessionContracts = Record<string, Omit<ContractPolicy, "methods"> & {
    methods: (Method & {
        authorized?: boolean;
    })[];
}>;
type SessionMessages = (SignMessagePolicy & {
    authorized?: boolean;
})[];

/**
 * Implements a file system backend.
 * This is designed for Node.js environments to store session data on the filesystem.
 */
declare class NodeBackend {
    private basePath;
    private sessionFile;
    private data;
    private callbackServer?;
    constructor(basePath: string);
    private ensureDirectoryExists;
    private loadData;
    private saveData;
    get(key: string): Promise<string | null>;
    set(key: string, value: string): Promise<void>;
    delete(key: string): Promise<void>;
    getRedirectUri(): Promise<string>;
    waitForCallback(): Promise<string | null>;
    openLink(url: string): void;
}

type SessionOptions = {
    rpc: string;
    chainId: string;
    policies: SessionPolicies;
    basePath: string;
    keychainUrl?: string;
};
declare class SessionProvider extends BaseProvider {
    id: string;
    name: string;
    protected _chainId: string;
    protected _rpcUrl: string;
    protected _username?: string;
    protected _policies: ParsedSessionPolicies;
    protected _keychainUrl: string;
    protected _backend: NodeBackend;
    constructor({ rpc, chainId, policies, basePath, keychainUrl, }: SessionOptions);
    username(): Promise<any>;
    probe(): Promise<WalletAccount | undefined>;
    connect(): Promise<WalletAccount | undefined>;
    disconnect(): Promise<void>;
    switchStarknetChain(_chainId: string): Promise<boolean>;
    addStarknetChain(_chain: AddStarknetChainParameters): Promise<boolean>;
}

declare class NotReadyToConnect extends Error {
    constructor();
}

type ExternalWalletType = "argent" | "braavos" | "metamask" | "phantom" | "rabby" | "base";
type ExternalPlatform = "starknet" | "ethereum" | "solana" | "base" | "arbitrum" | "optimism";
interface ExternalWallet {
    type: ExternalWalletType;
    available: boolean;
    version?: string;
    chainId?: string;
    name?: string;
    platform?: ExternalPlatform;
    connectedAccounts?: string[];
}
interface ExternalWalletResponse<T = unknown> {
    success: boolean;
    wallet: ExternalWalletType;
    result?: T;
    error?: string;
    account?: string;
}

declare class WalletBridge {
    private readonly walletAdapters;
    constructor();
    getIFrameMethods(): {
        externalDetectWallets: (_origin: string) => () => Promise<ExternalWallet[]>;
        externalConnectWallet: (_origin: string) => (type: ExternalWalletType) => Promise<ExternalWalletResponse<unknown>>;
        externalSignMessage: (_origin: string) => (identifier: ExternalWalletType | string, message: string) => Promise<ExternalWalletResponse<unknown>>;
        externalSignTypedData: (_origin: string) => (identifier: ExternalWalletType | string, data: any) => Promise<ExternalWalletResponse<unknown>>;
        externalSendTransaction: (_origin: string) => (identifier: ExternalWalletType | string, txn: any) => Promise<ExternalWalletResponse<unknown>>;
        externalGetBalance: (_origin: string) => (identifier: ExternalWalletType | string, tokenAddress?: string) => Promise<ExternalWalletResponse<unknown>>;
        externalSwitchChain: (_origin: string) => (identifier: ExternalWalletType | string, chainId: string) => Promise<boolean>;
        externalWaitForTransaction: (_origin: string) => (identifier: ExternalWalletType | string, txHash: string, timeoutMs?: number) => Promise<ExternalWalletResponse<unknown>>;
    };
    detectWallets(): Promise<ExternalWallet[]>;
    private getWalletAdapterByType;
    private handleError;
    connectWallet(type: ExternalWalletType): Promise<ExternalWalletResponse>;
    private getConnectedWalletAdapter;
    signMessage(identifier: ExternalWalletType | string, message: string): Promise<ExternalWalletResponse>;
    signTypedData(identifier: ExternalWalletType | string, data: any): Promise<ExternalWalletResponse>;
    sendTransaction(identifier: ExternalWalletType | string, txn: any): Promise<ExternalWalletResponse>;
    getBalance(identifier: ExternalWalletType | string, tokenAddress?: string): Promise<ExternalWalletResponse>;
    switchChain(identifier: ExternalWalletType | string, chainId: string): Promise<boolean>;
    waitForTransaction(identifier: ExternalWalletType | string, txHash: string, timeoutMs?: number): Promise<ExternalWalletResponse>;
}
declare global {
    interface Window {
        ethereum?: any;
        solana?: any;
        starknet_argentX?: any;
        starknet_braavos?: any;
        wallet_bridge?: WalletBridge;
    }
}

type ControllerError = {
    code: Number;
    message: string;
    data?: any;
};

export { type ControllerError, NotReadyToConnect, type SessionOptions, SessionProvider as default };
