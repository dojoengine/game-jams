import { WalletAccount as h, stark as m, ec as p, encode as S } from "starknet";
import { signerToGuid as g, subscribeCreateSession as f } from "@cartridge/controller-wasm";
export * from "@cartridge/controller-wasm";
import { n as y, B as _, K as w, b as v } from "./provider-CznCrt4b.js";
import { F as J, N as R, R as P, S as G } from "./provider-CznCrt4b.js";
import { CartridgeSessionAccount as I } from "@cartridge/controller-wasm/session";
class O extends h {
  controller;
  constructor(t, {
    rpcUrl: r,
    privateKey: e,
    address: n,
    ownerGuid: i,
    chainId: a,
    expiresAt: s,
    policies: o,
    guardianKeyGuid: c,
    metadataHash: l,
    sessionKeyGuid: u
  }) {
    super({
      provider: { nodeUrl: r },
      walletProvider: t,
      address: n
    }), this.controller = I.newAsRegistered(
      r,
      e,
      n,
      i,
      a,
      {
        expiresAt: s,
        policies: o,
        guardianKeyGuid: c,
        metadataHash: l,
        sessionKeyGuid: u
      }
    );
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(t) {
    return this.controller.execute(y(t));
  }
}
class k extends _ {
  id = "controller_session";
  name = "Controller Session";
  _chainId;
  _rpcUrl;
  _username;
  _redirectUrl;
  _policies;
  _keychainUrl;
  _apiUrl;
  constructor({
    rpc: t,
    chainId: r,
    policies: e,
    redirectUrl: n,
    keychainUrl: i,
    apiUrl: a
  }) {
    super(), this._policies = {
      verified: !1,
      contracts: e.contracts ? Object.fromEntries(
        Object.entries(e.contracts).map(([s, o]) => [
          s,
          {
            ...o,
            methods: o.methods.map((c) => ({
              ...c,
              authorized: !0
            }))
          }
        ])
      ) : void 0,
      messages: e.messages?.map((s) => ({
        ...s,
        authorized: !0
      }))
    }, this._rpcUrl = t, this._chainId = r, this._redirectUrl = n, this._keychainUrl = i || w, this._apiUrl = a, typeof window < "u" && (window.starknet_controller_session = this);
  }
  validatePoliciesSubset(t, r) {
    if (t.contracts) {
      if (!r.contracts) return !1;
      for (const [e, n] of Object.entries(t.contracts)) {
        const i = r.contracts[e];
        if (!i) return !1;
        for (const a of n.methods) {
          const s = i.methods.find(
            (o) => o.entrypoint === a.entrypoint
          );
          if (!s || !s.authorized) return !1;
        }
      }
    }
    if (t.messages) {
      if (!r.messages) return !1;
      for (const e of t.messages) {
        const n = r.messages.find(
          (i) => JSON.stringify(i.domain) === JSON.stringify(e.domain) && JSON.stringify(i.types) === JSON.stringify(e.types)
        );
        if (!n || !n.authorized) return !1;
      }
    }
    return !0;
  }
  async username() {
    return await this.tryRetrieveFromQueryOrStorage(), this._username;
  }
  async probe() {
    return this.account ? this.account : (this.account = await this.tryRetrieveFromQueryOrStorage(), this.account);
  }
  async connect() {
    if (this.account)
      return this.account;
    if (this.account = await this.tryRetrieveFromQueryOrStorage(), this.account)
      return this.account;
    const t = m.randomAddress(), r = p.starkCurve.getStarkKey(t);
    localStorage.setItem(
      "sessionSigner",
      JSON.stringify({
        privKey: t,
        pubKey: r
      })
    ), localStorage.setItem("sessionPolicies", JSON.stringify(this._policies));
    const e = `${this._keychainUrl}/session?public_key=${r}&redirect_uri=${this._redirectUrl}&redirect_query_name=startapp&policies=${JSON.stringify(
      this._policies
    )}&rpc_url=${this._rpcUrl}`;
    localStorage.setItem("lastUsedConnector", this.id);
    const n = window.open(e, "_blank");
    try {
      const i = S.addHexPrefix(t), a = g({
        starknet: { privateKey: i }
      }), s = this._apiUrl ?? "https://api.cartridge.gg", o = await f(
        a,
        s
      ), c = o.authorization[1], l = {
        username: o.controller.accountID,
        address: o.controller.address,
        ownerGuid: c,
        expiresAt: o.expiresAt,
        guardianKeyGuid: "0x0",
        metadataHash: "0x0",
        sessionKeyGuid: a
      };
      return localStorage.setItem("session", JSON.stringify(l)), this.tryRetrieveFromQueryOrStorage(), n?.close(), this.account;
    } catch (i) {
      console.log(i);
    }
  }
  switchStarknetChain(t) {
    throw new Error("switchStarknetChain not implemented");
  }
  addStarknetChain(t) {
    throw new Error("addStarknetChain not implemented");
  }
  disconnect() {
    return localStorage.removeItem("sessionSigner"), localStorage.removeItem("session"), localStorage.removeItem("sessionPolicies"), this.account = void 0, this._username = void 0, Promise.resolve();
  }
  async tryRetrieveFromQueryOrStorage() {
    if (this.account)
      return this.account;
    const t = localStorage.getItem("sessionSigner"), r = t ? JSON.parse(t) : null;
    let e = null;
    const n = localStorage.getItem("session");
    if (n && (e = JSON.parse(n)), window.location.search.includes("startapp")) {
      const s = new URLSearchParams(window.location.search), o = s.get("startapp");
      if (o) {
        const c = JSON.parse(
          atob(o)
        );
        Number(c.expiresAt) !== Number(e?.expiresAt) && (e = c, localStorage.setItem("session", JSON.stringify(e))), s.delete("startapp");
        const l = window.location.pathname + (s.toString() ? `?${s.toString()}` : "") + window.location.hash;
        window.history.replaceState({}, document.title, l);
      }
    }
    if (!e || !r)
      return;
    const i = parseInt(e.expiresAt) * 1e3;
    if (Date.now() >= i) {
      this.clearStoredSession();
      return;
    }
    const a = localStorage.getItem("sessionPolicies");
    if (a) {
      const s = JSON.parse(
        a
      );
      if (!this.validatePoliciesSubset(
        this._policies,
        s
      )) {
        this.clearStoredSession();
        return;
      }
    }
    return this._username = e.username, this.account = new O(this, {
      rpcUrl: this._rpcUrl,
      privateKey: r.privKey,
      address: e.address,
      ownerGuid: e.ownerGuid,
      chainId: this._chainId,
      expiresAt: parseInt(e.expiresAt),
      policies: v(this._policies),
      guardianKeyGuid: e.guardianKeyGuid,
      metadataHash: e.metadataHash,
      sessionKeyGuid: e.sessionKeyGuid
    }), this.account;
  }
  clearStoredSession() {
    localStorage.removeItem("sessionSigner"), localStorage.removeItem("session"), localStorage.removeItem("sessionPolicies");
  }
}
export {
  J as FeeSource,
  R as NotReadyToConnect,
  P as ResponseCodes,
  G as StarterPackItemType,
  k as default
};
//# sourceMappingURL=session.js.map
