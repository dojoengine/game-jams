import { Patch, Draft } from 'immer';
import { StateCreator, StoreApi } from 'zustand';

/**
 * SchemaType represents the structure of your Dojo world models.
 * Each namespace contains models defined by their field types.
 *
 * @example
 * ```typescript
 * const schema = {
 *   world: {
 *     Player: {
 *       id: 'felt252',
 *       name: 'string',
 *       score: 'u32'
 *     },
 *     Item: {
 *       id: 'felt252',
 *       name: 'string',
 *       durability: 'u8'
 *     }
 *   }
 * } satisfies SchemaType;
 * ```
 */
type SchemaType = {
    /**
     * namespace: Your namespace for grouping related models.
     * This is typically used to organize models by their domain or context.
     * For example, 'world', 'game', 'inventory', etc.
     */
    [namespace: string]: {
        /**
         * model: Your model name, case sensitive.
         * This represents a specific entity or concept within your namespace.
         * For example, 'Player', 'Item', 'Quest', etc.
         */
        [model: string]: {
            /**
             * Dynamic fields of the model.
             * These can be of any type, typically representing the properties of your model.
             */
            [field: string]: any;
        };
    };
};
/**
 * Parsed entity with its ID and models.
 * Ensures that each model's data adheres to the schema's field types.
 *
 * @example
 * ```typescript
 * // Given a schema:
 * const schema = {
 *   world: {
 *     Player: {
 *       id: 'felt252',
 *       name: 'string',
 *       score: 'u32'
 *     }
 *   }
 * } satisfies SchemaType;
 *
 * // A ParsedEntity might look like:
 * const entity: ParsedEntity<typeof schema> = {
 *   entityId: '0x123',
 *   models: {
 *     world: {
 *       Player: {
 *         id: '0x123',
 *         name: 'Alice',
 *         score: 100
 *       }
 *     }
 *   }
 * };
 * ```
 */
type ParsedEntity<T extends SchemaType> = {
    entityId: string;
    models: {
        [K in keyof T]: {
            [M in keyof T[K]]?: T[K][M] extends object ? Partial<T[K][M]> : T[K][M];
        };
    };
};

type ImmerMiddleware = [["zustand/immer", never]];
type SubscribeMiddleware = [["zustand/subscribeWithSelector", never]];
type Middlewares = [...SubscribeMiddleware, ...ImmerMiddleware];
type CreateStore = <T, Mos extends [...Middlewares]>(initializer: StateCreator<T, [], Mos>) => StoreApi<T>;
/**
 * Factory function to create a Zustand store based on a given SchemaType.
 *
 * @template T - The schema type.
 * @returns A Zustand hook tailored to the provided schema.
 */
declare function createDojoStoreFactory<T extends SchemaType>(storeCreatorFn: CreateStore): StoreApi<GameState<T>>;

interface PendingTransaction {
    transactionId: string;
    patches: Patch[];
    inversePatches: Patch[];
}
interface GameState<T extends SchemaType> {
    entities: Record<string, ParsedEntity<T>>;
    historical_entities: Record<string, ParsedEntity<T>[]>;
    pendingTransactions: Record<string, PendingTransaction>;
    setEntities: (entities: ParsedEntity<T>[]) => void;
    mergeEntities: (entities: ParsedEntity<T>[]) => void;
    updateEntity: (entity: Partial<ParsedEntity<T>>) => void;
    setHistoricalEntities: (entities: ParsedEntity<T>[]) => void;
    mergeHistoricalEntities: (entities: ParsedEntity<T>[]) => void;
    updateHistoricalEntity: (entity: Partial<ParsedEntity<T>>) => void;
    applyOptimisticUpdate: (transactionId: string, updateFn: (draft: Draft<GameState<T>>) => void) => void;
    revertOptimisticUpdate: (transactionId: string) => void;
    confirmTransaction: (transactionId: string) => void;
    subscribeToEntity: (entityId: string, listener: (entity: ParsedEntity<T> | undefined) => void) => () => void;
    waitForEntityChange: (entityId: string, predicate: (entity: ParsedEntity<T> | undefined) => boolean, timeout?: number) => Promise<ParsedEntity<T> | undefined>;
    getEntity: (entityId: string) => ParsedEntity<T> | undefined;
    getEntities: (filter?: (entity: ParsedEntity<T>) => boolean) => ParsedEntity<T>[];
    getEntitiesByModel: (namespace: keyof T, model: keyof T[keyof T]) => ParsedEntity<T>[];
    getHistoricalEntities: (entityId: string) => ParsedEntity<T>[];
    getEntityAtIndex: (entityId: string, index: number) => ParsedEntity<T> | undefined;
    clearHistoricalEntities: (entityId?: string) => void;
    resetStore: () => void;
}
type DojoStore<T extends SchemaType> = StoreApi<GameState<T>>;

/**
 * Factory function to create a Vanilla Zustand store based on a given SchemaType.
 *
 * @template T - The schema type.
 * @returns A Zustand hook tailored to the provided schema.
 */
declare function createDojoStore<T extends SchemaType>(): StoreApi<GameState<T>>;

export { type DojoStore, type GameState, createDojoStore, createDojoStoreFactory };
