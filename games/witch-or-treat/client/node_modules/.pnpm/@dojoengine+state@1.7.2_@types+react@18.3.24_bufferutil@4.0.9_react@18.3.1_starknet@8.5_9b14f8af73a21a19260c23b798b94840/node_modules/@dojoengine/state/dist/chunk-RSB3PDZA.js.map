{"version":3,"sources":["../src/recs/index.ts","../src/utils/index.ts"],"sourcesContent":["import {\n    type Component,\n    type ComponentValue,\n    type Entity,\n    type Metadata,\n    type Schema,\n    getComponentValue,\n    hasComponent,\n    removeComponent,\n    setComponent,\n    updateComponent,\n} from \"@dojoengine/recs\";\nimport type {\n    Clause,\n    Entity as ToriiEntity,\n    OrderBy,\n    ToriiClient,\n} from \"@dojoengine/torii-client\";\nimport { convertValues } from \"../utils\";\n\n/**\n * Fetches and synchronizes entities with their components. This is useful for initializing the world state.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param clause - An optional clause to filter entities.\n * @param entityKeyClause - An array of entity key clauses to synchronize.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n * @param logging - Whether to log debug information (default: true).\n * @returns A promise that resolves to a subscription for entity updates.\n *\n * @example\n * // Fetch all entities and their components\n * const components = createClientComponents({ contractComponents });\n * const subscription = await getSyncEntities(client, components);\n *\n * @example\n * // Fetch filtered entities and their components\n * const components = createClientComponents({ contractComponents });\n * const clause = { ... }; // Define your filter clause\n * const entityKeyClause = [ ... ]; // Define your entity key clauses\n * const subscription = await getSyncEntities(client, components, clause, entityKeyClause);\n *\n * This function fetches entities and their components from the client, then\n * sets up a subscription for entity updates. It uses the provided clause (if any)\n * to filter entities and the specified components to determine which data to retrieve.\n * The function fetches entities in batches, controlled by the 'limit' parameter,\n * and then establishes a real-time subscription for future updates.\n */\nexport const getSyncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    clause: Clause,\n    orderBy: OrderBy[] = [],\n    entityModels: string[] = [],\n    limit: number = 100,\n    logging: boolean = false\n) => {\n    if (logging) console.log(\"Starting getSyncEntities \", clause);\n    await getEntities(\n        client,\n        clause,\n        components,\n        orderBy,\n        entityModels,\n        limit,\n        logging\n    );\n    return await syncEntities(client, components, clause, logging);\n};\n/**\n * Fetches and synchronizes events with their components. This is useful for initializing the world state with event data.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param clause - An optional clause to filter events.\n * @param entityKeyClause - An array of entity key clauses to synchronize.\n * @param limit - The maximum number of events to fetch per request (default: 100).\n * @param logging - Whether to log debug information (default: false).\n * @param historical - Whether to fetch and subscribe to historical events (default: false).\n * @param callback - An optional callback function to be called after fetching events.\n * @returns A promise that resolves to a subscription for event updates.\n *\n * @example\n * // Fetch all events and their components\n * const components = createClientComponents({ contractComponents });\n * const subscription = await getSyncEvents(client, components, undefined, entityKeyClause);\n *\n * @example\n * // Fetch filtered events and their components\n * const components = createClientComponents({ contractComponents });\n * const clause = { ... }; // Define your filter clause\n * const entityKeyClause = [ ... ]; // Define your entity key clauses\n * const subscription = await getSyncEvents(client, components, clause, entityKeyClause);\n *\n * This function fetches events and their components from the client, then\n * sets up a subscription for event updates. It uses the provided clause (if any)\n * to filter events and the specified components to determine which data to retrieve.\n * The function fetches events in batches, controlled by the 'limit' parameter,\n * and then establishes a real-time subscription for future updates.\n */\nexport const getSyncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    clause: Clause,\n    orderBy: OrderBy[] = [],\n    entityModels: string[] = [],\n    limit: number = 100,\n    logging: boolean = false,\n    historical: boolean = true,\n    callback?: () => void\n) => {\n    if (logging) console.log(\"Starting getSyncEvents\");\n    await getEvents(\n        client,\n        components,\n        orderBy,\n        entityModels,\n        limit,\n        clause,\n        logging,\n        historical,\n        callback\n    );\n    return await syncEvents(client, components, clause, logging);\n};\n\n/**\n * Fetches all entities and their components from the client.\n * @param client - The client instance for API communication.\n * @param clause - An optional clause to filter entities.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n * @param logging - Whether to log debug information (default: false).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntities(client, undefined, components, 100);\n *\n * This function performs paginated queries to fetch all entities and their components.\n */\nexport const getEntities = async <S extends Schema>(\n    client: ToriiClient,\n    clause: Clause | undefined,\n    components: Component<S, Metadata, undefined>[],\n    orderBy: OrderBy[] = [],\n    entityModels: string[] = [],\n    limit: number = 100,\n    logging: boolean = false,\n    historical: boolean = false,\n    {\n        dbConnection,\n        timestampCacheKey,\n    }: { dbConnection: IDBDatabase | undefined; timestampCacheKey: string } = {\n        dbConnection: undefined,\n        timestampCacheKey: \"\",\n    }\n) => {\n    if (logging) console.log(\"Starting getEntities\");\n    let cursor = undefined;\n    let continueFetching = true;\n\n    // const time = dbConnection ? getCache(timestampCacheKey) : 0;\n\n    while (continueFetching) {\n        const entities = await client.getEntities({\n            pagination: {\n                limit,\n                cursor,\n                direction: \"Forward\",\n                order_by: orderBy,\n            },\n            clause: clause || undefined,\n            no_hashed_keys: false,\n            models: entityModels,\n            historical,\n        });\n\n        if (dbConnection) {\n            await insertEntitiesInDB(dbConnection, entities.items);\n        }\n\n        if (logging) console.log(`Fetched entities`, entities.items);\n\n        setEntities(entities.items, components, logging);\n\n        if (Object.keys(entities.items).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor = entities.next_cursor;\n        }\n    }\n\n    if (dbConnection) {\n        const currentTime = Math.floor(Date.now() / 1000);\n        setCache(currentTime, timestampCacheKey);\n    }\n};\n\n/**\n * Fetches event messages from the client and synchronizes them with t\n * he specified components.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of event messages to fetch per request (default: 100).\n * @param clause - An optional clause to filter event messages.\n * @param logging - Whether to log debug information (default: false).\n * @param historical - Whether to fetch historical events (default: false).\n * @param callback - An optional callback function to be called after fetching events.\n */\nexport const getEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    orderBy: OrderBy[] = [],\n    entityModels: string[] = [],\n    limit: number = 100,\n    clause: Clause | undefined,\n    logging: boolean = false,\n    historical: boolean = false,\n    callback?: () => void\n) => {\n    if (logging) console.log(\"Starting getEvents\");\n    let cursor = undefined;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const entities = await client.getEventMessages({\n            pagination: {\n                limit,\n                cursor,\n                direction: \"Forward\",\n                order_by: orderBy,\n            },\n            clause: clause || undefined,\n            no_hashed_keys: false,\n            models: entityModels,\n            historical,\n        });\n\n        if (logging) console.log(\"entities\", entities.items);\n\n        setEntities(entities.items, components, logging);\n        if (entities.items.length < limit && !entities.next_cursor) {\n            continueFetching = false;\n            continue;\n        }\n\n        if (Object.keys(entities.items).length === 0) {\n            console.error(\"STOP FETCHING\");\n            continueFetching = false;\n        } else {\n            console.error(\"NEXT_CURSOR\", entities.next_cursor);\n            cursor = entities.next_cursor;\n        }\n    }\n\n    callback && callback();\n};\n\n/**\n * Fetches entities and their components from the client based on specified criteria.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions to fetch.\n * @param entityKeyClause - An Clause to filter entities by their keys.\n * @param patternMatching - The pattern matching strategy for entity keys (default: \"FixedLen\").\n * @param limit - The maximum number of entities to fetch per request (default: 1000).\n * @param logging - Whether to log debug information (default: false).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, { Keys: { keys: [\"0x1\"], models: [\"Position\"] } }, \"FixedLen\", 1000);\n *\n * This function performs paginated queries to fetch all matching entities and their\n * components. It uses the provided Clause to filter entities and\n * the specified components to determine which data to retrieve.\n *\n * Note: Make sure to synchronize the entities by calling the syncEntities method after this.\n */\nexport const getEntitiesQuery = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: Clause,\n    orderBy: OrderBy[] = [],\n    entityModels: string[] = [],\n    limit: number = 1000,\n    logging: boolean = false,\n    historical: boolean = false\n) => {\n    if (logging) console.log(\"Starting getEntitiesQuery\");\n    let cursor = undefined;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const fetchedEntities = await client.getEntities({\n            pagination: {\n                limit,\n                cursor,\n                direction: \"Forward\",\n                order_by: orderBy,\n            },\n            clause: entityKeyClause,\n            no_hashed_keys: false,\n            models: entityModels,\n            historical,\n        });\n        if (logging)\n            console.log(\n                `Fetched ${Object.keys(fetchedEntities.items).length} entities ${fetchedEntities.next_cursor}`\n            );\n\n        setEntities(fetchedEntities.items, components, logging);\n\n        if (\n            fetchedEntities.items.length < limit &&\n            !fetchedEntities.next_cursor\n        ) {\n            continueFetching = false;\n            continue;\n        }\n\n        if (Object.keys(fetchedEntities.items).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor = fetchedEntities.next_cursor;\n        }\n    }\n};\n\n/**\n * Sets up a subscription to sync entity updates.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An array of Clause to filter entities.\n * @param logging - Whether to log debug information (default: true).\n * @returns A promise that resolves with the subscription handler.\n * @example\n * const sync = await syncEntities(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: Clause,\n    logging: boolean = true\n) => {\n    if (logging) console.log(\"Starting syncEntities\");\n    return await client.onEntityUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            if (logging) console.log(\"Entity updated\", fetchedEntities);\n\n            setEntities({ [fetchedEntities]: data }, components, logging);\n        }\n    );\n};\n\n/**\n * Sets up a subscription to sync event messages.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An array of Clause to filter entities.\n * @param logging - Whether to log debug information (default: false).\n * @param historical - Whether to sync to historical events (default: false).\n * @returns A promise that resolves with the subscription handler.\n * @example\n * const sync = await syncEvents(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: Clause,\n    logging: boolean = false\n) => {\n    if (logging) console.log(\"Starting syncEvents\");\n    return await client.onEventMessageUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            if (logging) console.log(\"Event message updated\", fetchedEntities);\n\n            setEntities({ [fetchedEntities]: data }, components, logging);\n        }\n    );\n};\n\n// Helper function to process components for a single entity\nasync function processEntityComponents<S extends Schema>(\n    entityId: string,\n    componentsMap: Record<string, any>,\n    recsComponents: Component<S, Metadata, undefined>[],\n    logging: boolean\n) {\n    for (const componentName in componentsMap) {\n        if (!Object.hasOwn(componentsMap, componentName)) {\n            continue;\n        }\n        const recsComponent = Object.values(recsComponents).find(\n            (c) =>\n                `${c.metadata?.namespace}-${c.metadata?.name}` === componentName\n        );\n\n        if (!recsComponent) {\n            if (logging)\n                console.warn(\n                    `Component ${componentName} not found in provided components for entity ${entityId}.`\n                );\n            continue;\n        }\n\n        try {\n            const rawValue = componentsMap[componentName];\n            // Handle component removal if rawValue is an empty object\n            if (\n                rawValue &&\n                typeof rawValue === \"object\" &&\n                Object.keys(rawValue).length === 0\n            ) {\n                removeComponent(recsComponent, entityId as Entity, {\n                    skipUpdateStream: false,\n                });\n                if (logging)\n                    console.log(\n                        `Removed component ${recsComponent.metadata?.name} on ${entityId}`\n                    );\n                continue;\n            }\n\n            if (logging)\n                console.log(\n                    `Raw value for ${componentName} on ${entityId}:`,\n                    rawValue\n                );\n\n            const convertedValue = convertValues(\n                recsComponent.schema,\n                rawValue\n            ) as ComponentValue;\n\n            if (logging)\n                console.log(\n                    `Converted value for ${componentName} on ${entityId}:`,\n                    convertedValue\n                );\n\n            if (convertedValue === undefined || convertedValue === null) {\n                console.error(\n                    `convertValues returned null or undefined for ${componentName} on ${entityId}. Raw value:`,\n                    rawValue\n                );\n                // If this means deletion, it should have been caught by the empty object check.\n                // Otherwise, it's an invalid value, so we skip setting/updating.\n                continue;\n            }\n\n            if (hasComponent(recsComponent, entityId as Entity)) {\n                updateComponent(\n                    recsComponent,\n                    entityId as Entity,\n                    convertedValue as Partial<ComponentValue<S, undefined>>,\n                    getComponentValue(recsComponent, entityId as Entity)\n                );\n                if (logging)\n                    console.log(\n                        `Updated component ${recsComponent.metadata?.name} on ${entityId}`\n                    );\n            } else {\n                setComponent(recsComponent, entityId as Entity, convertedValue);\n                if (logging)\n                    console.log(\n                        `Set component ${recsComponent.metadata?.name} on ${entityId}`\n                    );\n            }\n        } catch (error) {\n            console.warn(\n                `Failed to set component ${recsComponent.metadata?.name} on ${entityId}`,\n                error\n            );\n        }\n    }\n}\n\n/**\n * Updates the components of entities in the local state.\n * Handles different input structures: an array of ToriiEntity models or a record of entity IDs to component maps.\n * @param entitiesInput - The entities data, can be ToriiEntity[] (e.g., from getEntities) or Record<EntityId, ComponentMap> (e.g., from syncEntities).\n * @param recsComponents - An array of RECS component definitions.\n * @param logging - Whether to log debug information (default: false).\n */\nexport const setEntities = async <S extends Schema>(\n    entitiesInput: any, // Can be ToriiEntity[] or Record<EntityId, ComponentMap>\n    recsComponents: Component<S, Metadata, undefined>[],\n    logging: boolean = false\n) => {\n    if (logging) console.log(\"Initial input to setEntities:\", entitiesInput);\n\n    if (!entitiesInput) {\n        if (logging) console.warn(\"Null or undefined input to setEntities.\");\n        return;\n    }\n\n    if (Array.isArray(entitiesInput)) {\n        // Case 1: Input is an array of ToriiEntity (EntityModel)\n        if (entitiesInput.length === 0) {\n            if (logging) console.warn(\"Empty array passed to setEntities.\");\n            return;\n        }\n        if (logging)\n            console.log(\"Processing input as an array of ToriiEntity models.\");\n        for (const entityModel of entitiesInput as ToriiEntity[]) {\n            if (\n                entityModel &&\n                typeof entityModel.hashed_keys === \"string\" &&\n                entityModel.models &&\n                typeof entityModel.models === \"object\"\n            ) {\n                await processEntityComponents(\n                    entityModel.hashed_keys,\n                    entityModel.models,\n                    recsComponents,\n                    logging\n                );\n            } else {\n                if (logging)\n                    console.warn(\n                        \"Skipping invalid entity model in array:\",\n                        entityModel\n                    );\n            }\n        }\n    } else if (typeof entitiesInput === \"object\" && entitiesInput !== null) {\n        // Case 2: Input is an object (Record<EntityId, ComponentMap>)\n        if (Object.keys(entitiesInput).length === 0) {\n            // Handles general empty objects. The specific `{\"0x0\": {}}` check from before\n            // would effectively result in no operations if it passed this, as the inner loop wouldn't run.\n            if (logging) console.warn(\"Empty object passed to setEntities.\");\n            return;\n        }\n        if (logging)\n            console.log(\"Processing input as Record<EntityId, ComponentMap>.\");\n        for (const entityId in entitiesInput) {\n            if (Object.hasOwn(entitiesInput, entityId)) {\n                const componentsMap = entitiesInput[entityId].models;\n                if (\n                    typeof componentsMap === \"object\" &&\n                    componentsMap !== null\n                ) {\n                    await processEntityComponents(\n                        entityId,\n                        componentsMap,\n                        recsComponents,\n                        logging\n                    );\n                } else {\n                    if (logging)\n                        console.warn(\n                            `Data for entity ${entityId} is not a valid components map:`,\n                            componentsMap\n                        );\n                }\n            }\n        }\n    } else {\n        if (logging)\n            console.warn(\"Invalid input type for setEntities:\", entitiesInput);\n    }\n};\n\nconst setCache = (time: number, timestampCacheKey: string) => {\n    const timeString = Math.floor(time).toString();\n    localStorage.setItem(timestampCacheKey, timeString);\n};\n\n// const getCache = (timestampCacheKey: string) => {\n//     return Number(localStorage.getItem(timestampCacheKey) || 0);\n// };\n\nasync function insertEntitiesInDB(\n    db: IDBDatabase,\n    entities: ToriiEntity[]\n): Promise<void> {\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([\"entities\"], \"readwrite\");\n        const store = transaction.objectStore(\"entities\");\n\n        let completed = 0;\n        let error: Error | null = null;\n\n        // Handle transaction completion\n        transaction.oncomplete = () => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve();\n            }\n        };\n\n        transaction.onerror = () => {\n            reject(transaction.error);\n        };\n\n        // Store each entity\n        for (const [entityId, data] of Object.entries(entities)) {\n            const entityData = {\n                id: entityId,\n                ...data,\n            };\n\n            const request = store.put(entityData);\n            completed++;\n\n            request.onerror = () => {\n                error = request.error;\n            };\n        }\n    });\n}\n","import { Type as RecsType, Schema } from \"@dojoengine/recs\";\n\nexport function convertValues(schema: Schema, values: any) {\n    return Object.keys(schema).reduce<any>((acc, key) => {\n        let schemaType = schema[key];\n        let value = values[key];\n\n        // If key in values is not present, no need to set it to null\n        // so we return the accumulator as is\n        if (undefined === value) {\n            return acc;\n        }\n\n        if (value == null) {\n            acc[key] = value;\n            return acc;\n        }\n\n        if (value.type === \"enum\") {\n            if (value.type_name && value.type_name.includes(\"Option\")) {\n                if (value.value.option === \"None\") {\n                    acc[key] = null;\n                    return acc;\n                } else {\n                    schemaType = mapOptionalToRealType(schemaType);\n                    value = value.value.value;\n                }\n            } else {\n                acc[key] = value.value.option;\n                return acc;\n            }\n        }\n\n        switch (schemaType) {\n            case RecsType.StringArray:\n                acc[key] = handleStringArray(value);\n                break;\n\n            case RecsType.String:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.BigInt:\n                acc[key] = handleBigInt(value.value);\n                break;\n\n            case RecsType.Boolean:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.Number:\n                acc[key] = Number(value.value);\n                break;\n\n            default:\n                acc[key] = handleDefault(schemaType, value);\n                break;\n        }\n\n        return acc;\n    }, {});\n}\n\nfunction mapOptionalToRealType(schemaType: any) {\n    switch (schemaType) {\n        case RecsType.OptionalNumber:\n            return RecsType.Number;\n        case RecsType.OptionalBigInt:\n            return RecsType.BigInt;\n        case RecsType.OptionalString:\n            return RecsType.String;\n        case RecsType.OptionalNumberArray:\n            return RecsType.NumberArray;\n        case RecsType.OptionalBigIntArray:\n            return RecsType.BigIntArray;\n        case RecsType.OptionalStringArray:\n            return RecsType.StringArray;\n        case RecsType.OptionalEntity:\n            return RecsType.Entity;\n        case RecsType.OptionalEntityArray:\n            return RecsType.EntityArray;\n        case RecsType.OptionalT:\n            return RecsType.T;\n        default:\n            return schemaType;\n    }\n}\n\nfunction handleStringArray(value: any) {\n    if (value.type === \"array\" && value.value.length === 0) {\n        return [];\n    }\n    if (value.type === \"array\" && value.value[0]?.type === \"enum\") {\n        return value.value.map((item: any) => item.value.option);\n    }\n    return value.value.map((a: any) => {\n        try {\n            return BigInt(a.value);\n        } catch (error) {\n            return a.value;\n        }\n    });\n}\n\nfunction handleBigInt(value: string | bigint) {\n    if (typeof value === \"bigint\") {\n        return value;\n    }\n    try {\n        return BigInt(value);\n    } catch (error) {\n        console.warn(\n            `Failed to convert ${value} to BigInt. Attempting hexadecimal conversion.`\n        );\n        try {\n            return BigInt(`0x${value}`);\n        } catch (hexError) {\n            console.warn(\n                `Failed to convert 0x${value} to BigInt. Using string value instead.`\n            );\n            return value;\n        }\n    }\n}\n\nfunction handleDefault(schemaType: any, value: any) {\n    if (typeof schemaType === \"object\" && value.type === \"struct\") {\n        if (value.value instanceof Map) {\n            const structValues = Object.fromEntries(value.value);\n            return convertValues(schemaType, structValues);\n        } else if (typeof value.value === \"object\") {\n            // Handle cases where value.value might already be a plain object\n            return convertValues(schemaType, value.value);\n        } else {\n            console.warn(\n                `Expected value.value to be a Map or object for struct type, got ${typeof value.value}.`\n            );\n            return value.value;\n        }\n    }\n    if (Array.isArray(schemaType) && value.type === \"array\") {\n        return value.value.map((item: any) =>\n            convertValues(schemaType[0], item)\n        );\n    }\n    return value.value;\n}\n"],"mappings":"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","names":["getComponentValue","hasComponent","removeComponent","setComponent","updateComponent","RecsType","convertValues","schema","values","acc","key","schemaType","value","mapOptionalToRealType","handleStringArray","handleBigInt","handleDefault","item","a","structValues","getSyncEntities","client","components","clause","orderBy","entityModels","limit","logging","getEntities","syncEntities","getSyncEvents","historical","callback","getEvents","syncEvents","dbConnection","timestampCacheKey","cursor","continueFetching","entities","insertEntitiesInDB","setEntities","currentTime","setCache","getEntitiesQuery","entityKeyClause","fetchedEntities","data","processEntityComponents","entityId","componentsMap","recsComponents","componentName","recsComponent","c","rawValue","removeComponent","convertedValue","convertValues","hasComponent","updateComponent","getComponentValue","setComponent","error","entitiesInput","entityModel","time","timeString","db","resolve","reject","transaction","store","completed","entityData","request"]}