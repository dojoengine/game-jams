import { Schema, Component, Metadata } from '@dojoengine/recs';
import { ToriiClient, Clause, OrderBy } from '@dojoengine/torii-client';

declare class Subscription {
  private constructor();
  free(): void;
  /**
   * Cancels an active subscription
   */
  cancel(): void;
  id: bigint;
}

/**
 * Fetches and synchronizes entities with their components. This is useful for initializing the world state.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions.
 * @param clause - An optional clause to filter entities.
 * @param entityKeyClause - An array of entity key clauses to synchronize.
 * @param limit - The maximum number of entities to fetch per request (default: 100).
 * @param logging - Whether to log debug information (default: true).
 * @returns A promise that resolves to a subscription for entity updates.
 *
 * @example
 * // Fetch all entities and their components
 * const components = createClientComponents({ contractComponents });
 * const subscription = await getSyncEntities(client, components);
 *
 * @example
 * // Fetch filtered entities and their components
 * const components = createClientComponents({ contractComponents });
 * const clause = { ... }; // Define your filter clause
 * const entityKeyClause = [ ... ]; // Define your entity key clauses
 * const subscription = await getSyncEntities(client, components, clause, entityKeyClause);
 *
 * This function fetches entities and their components from the client, then
 * sets up a subscription for entity updates. It uses the provided clause (if any)
 * to filter entities and the specified components to determine which data to retrieve.
 * The function fetches entities in batches, controlled by the 'limit' parameter,
 * and then establishes a real-time subscription for future updates.
 */
declare const getSyncEntities: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], clause: Clause, orderBy?: OrderBy[], entityModels?: string[], limit?: number, logging?: boolean) => Promise<Subscription>;
/**
 * Fetches and synchronizes events with their components. This is useful for initializing the world state with event data.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions.
 * @param clause - An optional clause to filter events.
 * @param entityKeyClause - An array of entity key clauses to synchronize.
 * @param limit - The maximum number of events to fetch per request (default: 100).
 * @param logging - Whether to log debug information (default: false).
 * @param historical - Whether to fetch and subscribe to historical events (default: false).
 * @param callback - An optional callback function to be called after fetching events.
 * @returns A promise that resolves to a subscription for event updates.
 *
 * @example
 * // Fetch all events and their components
 * const components = createClientComponents({ contractComponents });
 * const subscription = await getSyncEvents(client, components, undefined, entityKeyClause);
 *
 * @example
 * // Fetch filtered events and their components
 * const components = createClientComponents({ contractComponents });
 * const clause = { ... }; // Define your filter clause
 * const entityKeyClause = [ ... ]; // Define your entity key clauses
 * const subscription = await getSyncEvents(client, components, clause, entityKeyClause);
 *
 * This function fetches events and their components from the client, then
 * sets up a subscription for event updates. It uses the provided clause (if any)
 * to filter events and the specified components to determine which data to retrieve.
 * The function fetches events in batches, controlled by the 'limit' parameter,
 * and then establishes a real-time subscription for future updates.
 */
declare const getSyncEvents: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], clause: Clause, orderBy?: OrderBy[], entityModels?: string[], limit?: number, logging?: boolean, historical?: boolean, callback?: () => void) => Promise<Subscription>;
/**
 * Fetches all entities and their components from the client.
 * @param client - The client instance for API communication.
 * @param clause - An optional clause to filter entities.
 * @param components - An array of component definitions.
 * @param limit - The maximum number of entities to fetch per request (default: 100).
 * @param logging - Whether to log debug information (default: false).
 *
 * @example
 * const components = createClientComponents({ contractComponents });
 * await getEntities(client, undefined, components, 100);
 *
 * This function performs paginated queries to fetch all entities and their components.
 */
declare const getEntities: <S extends Schema>(client: ToriiClient, clause: Clause | undefined, components: Component<S, Metadata, undefined>[], orderBy?: OrderBy[], entityModels?: string[], limit?: number, logging?: boolean, historical?: boolean, { dbConnection, timestampCacheKey, }?: {
    dbConnection: IDBDatabase | undefined;
    timestampCacheKey: string;
}) => Promise<void>;
/**
 * Fetches event messages from the client and synchronizes them with t
 * he specified components.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions.
 * @param limit - The maximum number of event messages to fetch per request (default: 100).
 * @param clause - An optional clause to filter event messages.
 * @param logging - Whether to log debug information (default: false).
 * @param historical - Whether to fetch historical events (default: false).
 * @param callback - An optional callback function to be called after fetching events.
 */
declare const getEvents: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], orderBy: OrderBy[] | undefined, entityModels: string[] | undefined, limit: number | undefined, clause: Clause | undefined, logging?: boolean, historical?: boolean, callback?: () => void) => Promise<void>;
/**
 * Fetches entities and their components from the client based on specified criteria.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions to fetch.
 * @param entityKeyClause - An Clause to filter entities by their keys.
 * @param patternMatching - The pattern matching strategy for entity keys (default: "FixedLen").
 * @param limit - The maximum number of entities to fetch per request (default: 1000).
 * @param logging - Whether to log debug information (default: false).
 *
 * @example
 * const components = createClientComponents({ contractComponents });
 * await getEntitiesQuery(client, components, { Keys: { keys: ["0x1"], models: ["Position"] } }, "FixedLen", 1000);
 *
 * This function performs paginated queries to fetch all matching entities and their
 * components. It uses the provided Clause to filter entities and
 * the specified components to determine which data to retrieve.
 *
 * Note: Make sure to synchronize the entities by calling the syncEntities method after this.
 */
declare const getEntitiesQuery: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], entityKeyClause: Clause, orderBy?: OrderBy[], entityModels?: string[], limit?: number, logging?: boolean, historical?: boolean) => Promise<void>;
/**
 * Sets up a subscription to sync entity updates.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions.
 * @param entityKeyClause - An array of Clause to filter entities.
 * @param logging - Whether to log debug information (default: true).
 * @returns A promise that resolves with the subscription handler.
 * @example
 * const sync = await syncEntities(client, components, entityKeyClause);
 * // later...
 * sync.cancel(); // cancel the subscription
 */
declare const syncEntities: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], entityKeyClause: Clause, logging?: boolean) => Promise<Subscription>;
/**
 * Sets up a subscription to sync event messages.
 * @param client - The client instance for API communication.
 * @param components - An array of component definitions.
 * @param entityKeyClause - An array of Clause to filter entities.
 * @param logging - Whether to log debug information (default: false).
 * @param historical - Whether to sync to historical events (default: false).
 * @returns A promise that resolves with the subscription handler.
 * @example
 * const sync = await syncEvents(client, components, entityKeyClause);
 * // later...
 * sync.cancel(); // cancel the subscription
 */
declare const syncEvents: <S extends Schema>(client: ToriiClient, components: Component<S, Metadata, undefined>[], entityKeyClause: Clause, logging?: boolean) => Promise<Subscription>;
/**
 * Updates the components of entities in the local state.
 * Handles different input structures: an array of ToriiEntity models or a record of entity IDs to component maps.
 * @param entitiesInput - The entities data, can be ToriiEntity[] (e.g., from getEntities) or Record<EntityId, ComponentMap> (e.g., from syncEntities).
 * @param recsComponents - An array of RECS component definitions.
 * @param logging - Whether to log debug information (default: false).
 */
declare const setEntities: <S extends Schema>(entitiesInput: any, // Can be ToriiEntity[] or Record<EntityId, ComponentMap>
recsComponents: Component<S, Metadata, undefined>[], logging?: boolean) => Promise<void>;

export { getEntities, getEntitiesQuery, getEvents, getSyncEntities, getSyncEvents, setEntities, syncEntities, syncEvents };
