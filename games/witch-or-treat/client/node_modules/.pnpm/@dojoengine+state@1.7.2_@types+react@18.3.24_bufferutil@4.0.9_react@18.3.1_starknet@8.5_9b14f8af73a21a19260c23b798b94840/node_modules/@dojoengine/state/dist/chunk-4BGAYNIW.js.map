{"version":3,"sources":["../src/zustand/index.ts","../src/zustand/zustand.ts","../../internal/src/clauseBuilder.ts","../../internal/src/convertToMemberValue.ts","../../internal/src/errors.ts","../../internal/src/generateTypedData.ts","../../internal/src/merge.ts","../../internal/src/models.ts","../../internal/src/pagination.ts","../../internal/src/parseEntities.ts","../../internal/src/subscribeQueryModel.ts","../../internal/src/token.ts","../../internal/src/toriiQueryBuilder.ts","../../../node_modules/neverthrow/dist/index.es.js"],"sourcesContent":["import type { Draft, Patch } from \"immer\";\nimport type { StoreApi } from \"zustand\";\nimport { createStore } from \"zustand/vanilla\";\nimport type { ParsedEntity, SchemaType } from \"@dojoengine/internal\";\nimport { createDojoStoreFactory } from \"./zustand\";\n\ninterface PendingTransaction {\n    transactionId: string;\n    patches: Patch[];\n    inversePatches: Patch[];\n}\n\nexport interface GameState<T extends SchemaType> {\n    entities: Record<string, ParsedEntity<T>>;\n    historical_entities: Record<string, ParsedEntity<T>[]>;\n    pendingTransactions: Record<string, PendingTransaction>;\n    setEntities: (entities: ParsedEntity<T>[]) => void;\n    mergeEntities: (entities: ParsedEntity<T>[]) => void;\n    updateEntity: (entity: Partial<ParsedEntity<T>>) => void;\n    setHistoricalEntities: (entities: ParsedEntity<T>[]) => void;\n    mergeHistoricalEntities: (entities: ParsedEntity<T>[]) => void;\n    updateHistoricalEntity: (entity: Partial<ParsedEntity<T>>) => void;\n    applyOptimisticUpdate: (\n        transactionId: string,\n        updateFn: (draft: Draft<GameState<T>>) => void\n    ) => void;\n    revertOptimisticUpdate: (transactionId: string) => void;\n    confirmTransaction: (transactionId: string) => void;\n    subscribeToEntity: (\n        entityId: string,\n        listener: (entity: ParsedEntity<T> | undefined) => void\n    ) => () => void;\n    waitForEntityChange: (\n        entityId: string,\n        predicate: (entity: ParsedEntity<T> | undefined) => boolean,\n        timeout?: number\n    ) => Promise<ParsedEntity<T> | undefined>;\n    getEntity: (entityId: string) => ParsedEntity<T> | undefined;\n    getEntities: (\n        filter?: (entity: ParsedEntity<T>) => boolean\n    ) => ParsedEntity<T>[];\n    getEntitiesByModel: (\n        namespace: keyof T,\n        model: keyof T[keyof T]\n    ) => ParsedEntity<T>[];\n    getHistoricalEntities: (entityId: string) => ParsedEntity<T>[];\n    getEntityAtIndex: (\n        entityId: string,\n        index: number\n    ) => ParsedEntity<T> | undefined;\n    clearHistoricalEntities: (entityId?: string) => void;\n    resetStore: () => void;\n}\n\n// Define the store type\nexport type DojoStore<T extends SchemaType> = StoreApi<GameState<T>>;\n\n// Re-export the factory function\nexport { createDojoStoreFactory } from \"./zustand\";\n\n/**\n * Factory function to create a Vanilla Zustand store based on a given SchemaType.\n *\n * @template T - The schema type.\n * @returns A Zustand hook tailored to the provided schema.\n */\nexport function createDojoStore<T extends SchemaType>() {\n    return createDojoStoreFactory<T>(createStore);\n}\n","import {\n    applyPatches,\n    type Draft,\n    enablePatches,\n    produceWithPatches,\n    type WritableDraft,\n} from \"immer\";\nimport type { StateCreator, StoreApi } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\nimport {\n    deepMerge,\n    type MergedModels,\n    type ParsedEntity,\n    type SchemaType,\n} from \"@dojoengine/internal\";\nimport type { GameState } from \".\";\n\nenablePatches();\n\n// Helper function to compare entities for deduplication\nfunction areEntitiesEqual<T extends SchemaType>(\n    entity1: ParsedEntity<T>,\n    entity2: ParsedEntity<T>\n): boolean {\n    // Compare entityId and deep compare models\n    return (\n        entity1.entityId === entity2.entityId &&\n        JSON.stringify(entity1.models) === JSON.stringify(entity2.models)\n    );\n}\n\n// Define middleware types\ntype ImmerMiddleware = [[\"zustand/immer\", never]];\ntype SubscribeMiddleware = [[\"zustand/subscribeWithSelector\", never]];\ntype Middlewares = [...SubscribeMiddleware, ...ImmerMiddleware];\n\ntype CreateStore = <T, Mos extends [...Middlewares]>(\n    initializer: StateCreator<T, [], Mos>\n) => StoreApi<T>;\n\n/**\n * Factory function to create a Zustand store based on a given SchemaType.\n *\n * @template T - The schema type.\n * @returns A Zustand hook tailored to the provided schema.\n */\nexport function createDojoStoreFactory<T extends SchemaType>(\n    storeCreatorFn: CreateStore\n) {\n    const useStore = storeCreatorFn<GameState<T>, Middlewares>(\n        subscribeWithSelector(\n            immer((set, get) => ({\n                entities: {},\n                historical_entities: {},\n                pendingTransactions: {},\n                setEntities: (entities: ParsedEntity<T>[]) => {\n                    set((state: Draft<GameState<T>>) => {\n                        for (const entity of entities) {\n                            state.entities[entity.entityId] =\n                                entity as WritableDraft<ParsedEntity<T>>;\n                        }\n                    });\n                },\n                mergeEntities: (entities: ParsedEntity<T>[]) => {\n                    set((state: Draft<GameState<T>>) => {\n                        for (const entity of entities) {\n                            if (entity.entityId && entity.models) {\n                                const existingEntity =\n                                    state.entities[entity.entityId];\n\n                                if (!existingEntity) {\n                                    // Set new entity\n                                    state.entities[entity.entityId] =\n                                        entity as WritableDraft<\n                                            ParsedEntity<T>\n                                        >;\n                                    continue;\n                                }\n                                // Create new models object without spread\n                                const mergedModels: typeof existingEntity.models =\n                                    Object.assign({}, existingEntity.models);\n\n                                // Iterate through each namespace in the new models\n                                for (const [\n                                    namespace,\n                                    namespaceModels,\n                                ] of Object.entries(entity.models)) {\n                                    const typedNamespace =\n                                        namespace as keyof ParsedEntity<T>[\"models\"];\n                                    if (!(typedNamespace in mergedModels)) {\n                                        // @ts-expect-error TODO: change to better type\n                                        mergedModels[\n                                            typedNamespace as keyof typeof mergedModels\n                                        ] = {} as Record<string, unknown>;\n                                    }\n\n                                    // Use deep merge instead of Object.assign\n                                    // @ts-expect-error TODO: change to better type\n                                    mergedModels[\n                                        typedNamespace as keyof typeof mergedModels\n                                    ] = deepMerge(\n                                        mergedModels[\n                                            typedNamespace as keyof typeof mergedModels\n                                        ] as MergedModels<T>,\n                                        namespaceModels\n                                    ) as MergedModels<T>;\n                                }\n\n                                // Update the entity\n                                state.entities[entity.entityId] = {\n                                    ...existingEntity,\n                                    ...entity,\n                                    models: mergedModels,\n                                };\n                            }\n                        }\n                    });\n                },\n                updateEntity: (entity: Partial<ParsedEntity<T>>) => {\n                    set((state: Draft<GameState<T>>) => {\n                        if (entity.entityId && entity.models) {\n                            const existingEntity =\n                                state.entities[entity.entityId];\n\n                            if (!existingEntity) {\n                                // Set new entity\n                                state.entities[entity.entityId] =\n                                    entity as WritableDraft<ParsedEntity<T>>;\n                                return;\n                            }\n                            // Create new models object without spread\n                            const mergedModels: typeof existingEntity.models =\n                                Object.assign({}, existingEntity.models);\n                            // Iterate through each namespace in the new models\n                            for (const [\n                                namespace,\n                                namespaceModels,\n                            ] of Object.entries(entity.models)) {\n                                const typedNamespace =\n                                    namespace as keyof ParsedEntity<T>[\"models\"];\n                                if (!(typedNamespace in mergedModels)) {\n                                    // @ts-expect-error TODO: change to better type\n                                    mergedModels[\n                                        typedNamespace as keyof typeof mergedModels\n                                    ] = {} as Record<string, unknown>;\n                                }\n\n                                // @ts-expect-error TODO: change to better type\n                                mergedModels[\n                                    typedNamespace as keyof typeof mergedModels\n                                ] = deepMerge(\n                                    mergedModels[\n                                        typedNamespace as keyof typeof mergedModels\n                                    ] as MergedModels<T>,\n                                    namespaceModels\n                                ) as MergedModels<T>;\n                            }\n                            // Update the entity\n                            state.entities[entity.entityId] = {\n                                ...existingEntity,\n                                ...entity,\n                                models: mergedModels,\n                            };\n                        }\n                    });\n                },\n                setHistoricalEntities: (entities: ParsedEntity<T>[]) => {\n                    set((state: Draft<GameState<T>>) => {\n                        for (const entity of entities) {\n                            const existingHistory =\n                                state.historical_entities[entity.entityId];\n\n                            if (\n                                !existingHistory ||\n                                existingHistory.length === 0\n                            ) {\n                                // First state for this entity\n                                state.historical_entities[entity.entityId] = [\n                                    entity as WritableDraft<ParsedEntity<T>>,\n                                ];\n                                continue;\n                            }\n                            // Check against last state for deduplication\n                            const lastState =\n                                existingHistory[existingHistory.length - 1];\n                            if (\n                                !areEntitiesEqual(\n                                    entity,\n                                    lastState as ParsedEntity<T>\n                                )\n                            ) {\n                                existingHistory.push(\n                                    entity as WritableDraft<ParsedEntity<T>>\n                                );\n                            }\n                        }\n                    });\n                },\n                mergeHistoricalEntities: (entities: ParsedEntity<T>[]) => {\n                    set((state: Draft<GameState<T>>) => {\n                        for (const entity of entities) {\n                            if (entity.entityId && entity.models) {\n                                const existingHistory =\n                                    state.historical_entities[entity.entityId];\n\n                                if (\n                                    !existingHistory ||\n                                    existingHistory.length === 0\n                                ) {\n                                    // First state for this entity\n                                    state.historical_entities[entity.entityId] =\n                                        [\n                                            entity as WritableDraft<\n                                                ParsedEntity<T>\n                                            >,\n                                        ];\n                                    continue;\n                                }\n                                // Check against last state for deduplication\n                                const lastState =\n                                    existingHistory[existingHistory.length - 1];\n                                if (\n                                    !areEntitiesEqual(\n                                        entity,\n                                        lastState as ParsedEntity<T>\n                                    )\n                                ) {\n                                    existingHistory.push(\n                                        entity as WritableDraft<ParsedEntity<T>>\n                                    );\n                                }\n                            }\n                        }\n                    });\n                },\n                updateHistoricalEntity: (entity: Partial<ParsedEntity<T>>) => {\n                    set((state: Draft<GameState<T>>) => {\n                        if (entity.entityId) {\n                            const existingHistory =\n                                state.historical_entities[entity.entityId];\n\n                            if (\n                                !existingHistory ||\n                                existingHistory.length === 0\n                            ) {\n                                // First state, always add\n                                state.historical_entities[entity.entityId] = [\n                                    entity as WritableDraft<ParsedEntity<T>>,\n                                ];\n                            } else {\n                                // Check if state has changed from the last entry\n                                const lastState =\n                                    existingHistory[existingHistory.length - 1];\n                                if (\n                                    !areEntitiesEqual(\n                                        entity as ParsedEntity<T>,\n                                        lastState as ParsedEntity<T>\n                                    )\n                                ) {\n                                    // State has changed, add to history\n                                    existingHistory.push(\n                                        entity as WritableDraft<ParsedEntity<T>>\n                                    );\n                                }\n                                // If states are equal, do nothing (deduplicated)\n                            }\n                        }\n                    });\n                },\n                applyOptimisticUpdate: (transactionId, updateFn) => {\n                    const currentState = get();\n                    const [nextState, patches, inversePatches] =\n                        produceWithPatches(\n                            currentState,\n                            (draftState: Draft<GameState<T>>) => {\n                                updateFn(draftState);\n                            }\n                        );\n\n                    set(() => nextState);\n\n                    set((state: Draft<GameState<T>>) => {\n                        state.pendingTransactions[transactionId] = {\n                            transactionId,\n                            patches,\n                            inversePatches,\n                        };\n                    });\n                },\n                revertOptimisticUpdate: (transactionId) => {\n                    const transaction =\n                        get().pendingTransactions[transactionId];\n                    if (transaction) {\n                        set((state: Draft<GameState<T>>) =>\n                            applyPatches(state, transaction.inversePatches)\n                        );\n                        set((state: Draft<GameState<T>>) => {\n                            delete state.pendingTransactions[transactionId];\n                        });\n                    }\n                },\n                confirmTransaction: (transactionId) => {\n                    set((state: Draft<GameState<T>>) => {\n                        delete state.pendingTransactions[transactionId];\n                    });\n                },\n                subscribeToEntity: (entityId, listener): (() => void) => {\n                    return useStore.subscribe((state) => {\n                        const entity = state.entities[entityId];\n                        listener(entity);\n                    });\n                },\n                waitForEntityChange: (entityId, predicate, timeout = 6000) => {\n                    return new Promise<ParsedEntity<T> | undefined>(\n                        (resolve, reject) => {\n                            // Check current state immediately\n                            const currentEntity = get().entities[entityId];\n                            if (predicate(currentEntity)) {\n                                resolve(currentEntity);\n                                return;\n                            }\n\n                            const unsubscribe = useStore.subscribe((state) => {\n                                const entity = state.entities[entityId];\n                                if (predicate(entity)) {\n                                    clearTimeout(timer);\n                                    unsubscribe();\n                                    resolve(entity);\n                                }\n                            });\n\n                            const timer = setTimeout(() => {\n                                unsubscribe();\n                                reject(\n                                    new Error(\n                                        `waitForEntityChange: Timeout of ${timeout}ms exceeded`\n                                    )\n                                );\n                            }, timeout);\n                        }\n                    );\n                },\n                // Implementing query layer methods\n                getEntity: (entityId: string) => {\n                    return get().entities[entityId];\n                },\n\n                getEntities: (\n                    filter?: (entity: ParsedEntity<T>) => boolean\n                ) => {\n                    const allEntities = Object.values(get().entities);\n                    return filter ? allEntities.filter(filter) : allEntities;\n                },\n\n                getEntitiesByModel: (namespace, model) => {\n                    return get().getEntities((entity) => {\n                        return !!entity.models[namespace]?.[model];\n                    });\n                },\n\n                getHistoricalEntities: (entityId: string) => {\n                    return get().historical_entities[entityId] || [];\n                },\n\n                getEntityAtIndex: (entityId: string, index: number) => {\n                    const historicalStates =\n                        get().historical_entities[entityId];\n                    if (\n                        !historicalStates ||\n                        index < 0 ||\n                        index >= historicalStates.length\n                    ) {\n                        return undefined;\n                    }\n                    return historicalStates[index];\n                },\n\n                clearHistoricalEntities: (entityId?: string) => {\n                    set((state: Draft<GameState<T>>) => {\n                        if (entityId) {\n                            // Clear history for specific entity\n                            delete state.historical_entities[entityId];\n                        } else {\n                            // Clear all historical data\n                            state.historical_entities = {};\n                        }\n                    });\n                },\n                resetStore: () => {\n                    set((state: Draft<GameState<T>>) => {\n                        state.entities = {};\n                        state.historical_entities = {};\n                        state.pendingTransactions = {};\n                    });\n                },\n            }))\n        )\n    );\n\n    return useStore;\n}\n","import type {\n    Clause,\n    ComparisonOperator,\n    MemberValue,\n    PatternMatching,\n} from \"@dojoengine/torii-wasm/node\";\nimport { type BigNumberish, shortString } from \"starknet\";\nimport {\n    convertToPrimitive,\n    type MemberValueParam,\n} from \"./convertToMemberValue\";\nimport type { SchemaType } from \"./types\";\n\ntype ClauseBuilderInterface = {\n    build(): Clause;\n};\n\n// Helper types for nested model structure\ntype ModelPath<T, K extends keyof T> = K extends string\n    ? T[K] extends Record<string, any>\n        ? {\n              [SubK in keyof T[K]]: `${K}-${SubK & string}`;\n          }[keyof T[K]]\n        : never\n    : never;\n\ntype GetModelType<\n    T,\n    Path extends string,\n> = Path extends `${infer Namespace}-${infer Model}`\n    ? Namespace extends keyof T\n        ? Model extends keyof T[Namespace]\n            ? T[Namespace][Model]\n            : never\n        : never\n    : never;\n\n/**\n * Saves some keyboard strokes to get a KeysClause.\n *\n * @param models - the models you want to query, has to be in form of ns-Model\n * @param keys - the keys that has the model. You can use `undefined` as a wildcard to match any key\n * @param pattern - either VariableLen or FixedLen - to check exact match of key number\n * @return ClauseBuilder<T>\n */\nexport function KeysClause<T extends SchemaType>(\n    models: ModelPath<T, keyof T>[],\n    keys: (string | undefined)[],\n    pattern: PatternMatching = \"VariableLen\"\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().keys(models, keys, pattern);\n}\n\n/**\n * Saves some keyboard strokes to get a HashedKeysClause.\n *\n * @param keys - the hashed_keys (entityId) that you want to query over\n * @return ClauseBuilder<T>\n */\nexport function HashedKeysClause<T extends SchemaType>(\n    keys: BigNumberish[]\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().hashed_keys(keys);\n}\n\n/**\n * Saves some keyboard strokes to get a MemberClause.\n *\n * @template T - the schema type\n * @param model - the model you want to query, has to be in form of ns-Model\n * @param member - the member of the model on which you want to apply operator\n * @param operator - the operator to apply\n * @param value - the value to operate on.\n * @return ClauseBuilder<T>\n */\nexport function MemberClause<\n    T extends SchemaType,\n    Path extends ModelPath<T, keyof T>,\n    M extends keyof GetModelType<T, ModelPath<T, keyof T>>,\n>(\n    model: Path,\n    member: M & string,\n    operator: ComparisonOperator,\n    value:\n        | GetModelType<T, Path>[M]\n        | GetModelType<T, Path>[M][]\n        | MemberValueParam\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().where(model, member, operator, value);\n}\n\n/**\n * Saves some keyboard strokes to get a Composite \"Or\" Clause\n *\n * @template T - the schema type\n * @param clauses - the inner clauses that you want to compose\n * @return CompositeBuilder<T>\n */\nexport function AndComposeClause<T extends SchemaType>(\n    clauses: ClauseBuilderInterface[]\n): CompositeBuilder<T> {\n    return new ClauseBuilder<T>().compose().and(clauses);\n}\n\n/**\n * Saves some keyboard strokes to get a Composite \"And\" Clause\n * @template T - the schema type\n * @param clauses - the inner clauses that you want to compose\n * @return CompositeBuilder<T>\n */\nexport function OrComposeClause<T extends SchemaType>(\n    clauses: ClauseBuilderInterface[]\n): CompositeBuilder<T> {\n    return new ClauseBuilder<T>().compose().or(clauses);\n}\n\nexport class ClauseBuilder<T extends SchemaType> {\n    private clause: Clause;\n\n    constructor() {\n        // @ts-expect-error It's ok if it's not assignable here.\n        this.clause = {};\n    }\n\n    /**\n     * Create a clause based on entity keys\n     */\n    keys(\n        models: ModelPath<T, keyof T>[],\n        keys: (string | undefined)[],\n        pattern: PatternMatching = \"VariableLen\"\n    ): ClauseBuilder<T> {\n        this.clause = {\n            Keys: {\n                keys: keys.length === 0 ? [undefined] : keys,\n                pattern_matching: pattern,\n                models,\n            },\n        };\n        return this;\n    }\n\n    /**\n     * Create a hashed keys clause based on entity keys\n     * keys: an array of your keys array (no need to hash it, just pass raw keys)\n     */\n    hashed_keys(keys: BigNumberish[]): ClauseBuilder<T> {\n        const hexKeys = keys.map((k, index) => {\n            try {\n                // Convert to BigInt for robust handling of different input types\n                const num = typeof k === \"string\" ? BigInt(k) : BigInt(k);\n                // Convert to hex string with 0x prefix\n                return `0x${num.toString(16)}`;\n            } catch (error) {\n                throw new Error(\n                    `Invalid key value at index ${index}: ${k}. Expected a valid BigNumberish value.`\n                );\n            }\n        });\n\n        this.clause = {\n            HashedKeys: hexKeys,\n        };\n        return this;\n    }\n\n    /**\n     * Create a member clause for comparing values\n     */\n    where<\n        Path extends ModelPath<T, keyof T>,\n        M extends keyof GetModelType<T, Path>,\n    >(\n        model: Path,\n        member: M & string,\n        operator: ComparisonOperator,\n        value:\n            | GetModelType<T, Path>[M]\n            | GetModelType<T, Path>[M][]\n            | MemberValueParam\n    ): ClauseBuilder<T> {\n        const memberValue: MemberValue = Array.isArray(value)\n            ? {\n                  List: value.map((i) =>\n                      convertToPrimitive(i, shortString.encodeShortString)\n                  ),\n              }\n            : convertToPrimitive(value, shortString.encodeShortString);\n\n        this.clause = {\n            Member: {\n                model,\n                member,\n                operator,\n                value: memberValue,\n            },\n        };\n        return this;\n    }\n\n    /**\n     * Start a composite clause chain\n     */\n    compose(): CompositeBuilder<T> {\n        return new CompositeBuilder<T>();\n    }\n    /**\n     * Build the final clause\n     */\n    build(): Clause {\n        if (Object.keys(this.clause).length === 0) {\n            throw new Error(\"You cannot build an empty Clause\");\n        }\n\n        return this.clause;\n    }\n}\n\nclass CompositeBuilder<T extends Record<string, Record<string, any>>> {\n    private orClauses: Clause[] = [];\n    private andClauses: Clause[] = [];\n\n    or(clauses: ClauseBuilderInterface[]): CompositeBuilder<T> {\n        this.orClauses = clauses.map((c) => c.build());\n        return this;\n    }\n\n    and(clauses: ClauseBuilderInterface[]): CompositeBuilder<T> {\n        this.andClauses = clauses.map((c) => c.build());\n        return this;\n    }\n\n    build(): Clause {\n        if (this.orClauses.length === 0 && this.andClauses.length === 0) {\n            throw new Error(\n                \"ComposeClause is empty. Add .or([clause]) or .and([clause])\"\n            );\n        }\n\n        // If we only have OR clauses\n        if (this.orClauses && this.andClauses.length === 0) {\n            return {\n                Composite: {\n                    operator: \"Or\",\n                    clauses: this.orClauses,\n                },\n            };\n        }\n\n        // If we only have AND clauses\n        if (this.andClauses && this.orClauses.length === 0) {\n            return {\n                Composite: {\n                    operator: \"And\",\n                    clauses: this.andClauses,\n                },\n            };\n        }\n\n        // If we have both OR and AND clauses\n        if (this.andClauses && this.orClauses) {\n            return {\n                Composite: {\n                    operator: \"And\",\n                    clauses: [\n                        ...this.andClauses,\n                        {\n                            Composite: {\n                                operator: \"Or\",\n                                clauses: this.orClauses,\n                            },\n                        },\n                    ],\n                },\n            };\n        }\n\n        throw new Error(\"CompositeClause is not properly build\");\n    }\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\n\ntype ToUnion<T> = T extends infer U ? U : never;\ntype ExtractPrimitiveKeys<T> = T extends Record<infer K, any> ? K : never;\ntype PrimitiveTypeKeys = ToUnion<ExtractPrimitiveKeys<torii.Primitive>>;\n\nexport type MemberValueParam = { type: PrimitiveTypeKeys; value: any } | any;\n\n/**\n * Converts a value to a Torii primitive type.\n *\n * @param {MemberValue} value - The value to convert.\n * @returns {torii.MemberValue} - The converted primitive value.\n * @throws {Error} - If the value type is unsupported.\n */\nexport function convertToPrimitive(\n    value: MemberValueParam,\n    shortStringToFelt: typeof torii.cairoShortStringToFelt\n): torii.MemberValue {\n    // if you want to have more control over type passed to torii\n    if (Object.hasOwn(value, \"type\") && Object.hasOwn(value, \"value\")) {\n        return { Primitive: { [value.type]: value.value } as torii.Primitive };\n    }\n\n    if (typeof value === \"number\") {\n        return { Primitive: { U32: value } };\n    }\n\n    if (typeof value === \"boolean\") {\n        return { Primitive: { Bool: value } };\n    }\n\n    if (typeof value === \"bigint\") {\n        return {\n            Primitive: {\n                Felt252: shortStringToFelt(value.toString()),\n            },\n        };\n    }\n\n    if (typeof value === \"string\") {\n        return { String: value };\n    }\n\n    if (Array.isArray(value)) {\n        return {\n            List: value.map((item) =>\n                convertToPrimitive(item, shortStringToFelt)\n            ),\n        };\n    }\n\n    // Add more type conversions as needed\n    throw new Error(`Unsupported primitive type: ${typeof value}`);\n}\n","export const NO_SIGNER = \"No signer configured in sdk.init()\";\nexport const NO_IDENTITY = \"No identity configured in sdk.init()\";\nexport const NO_ACCOUNT = \"Account is undefined\";\n\nexport const UNDEFINED_CLAUSE =\n    \"Clause has not been defined yet. Use `.withClause()` to do so\";\n","import type { StarknetDomain, TypedData } from \"starknet\";\nimport type { SchemaType, UnionOfModelData } from \"./types\";\n\n/**\n * Generates typed data for any user-defined message.\n *\n * @template M - The message type defined by the schema models.\n * @param {string} nsModel - Model name prefixed with namespace joined by a hyphen.\n * @param {M} message - The user-defined message content, must be part of the schema models.\n * @param {StarknetDomain} [domain] - The domain object. If not provided, uses the default domain from options.\n * @returns {TypedData} - The generated typed data.\n */\nexport function generateTypedData<\n    T extends SchemaType,\n    M extends UnionOfModelData<T>,\n>(\n    nsModel: string,\n    message: M,\n    domain: StarknetDomain,\n    modelMapping?: Array<{ name: string; type: string }>,\n    additionnalTypes?: Record<string, Array<{ name: string; type: string }>>\n): TypedData {\n    return {\n        types: {\n            StarknetDomain: [\n                { name: \"name\", type: \"shortstring\" },\n                { name: \"version\", type: \"shortstring\" },\n                { name: \"chainId\", type: \"shortstring\" },\n                { name: \"revision\", type: \"shortstring\" },\n            ],\n            ...additionnalTypes,\n            [nsModel]:\n                undefined !== modelMapping\n                    ? modelMapping\n                    : Object.keys(message).map((key) => ({\n                          name: key,\n                          type:\n                              typeof message[key] === \"bigint\" ||\n                              typeof message[key] === \"number\"\n                                  ? \"felt\"\n                                  : \"string\",\n                      })),\n        },\n        primaryType: nsModel,\n        domain,\n        message,\n    };\n}\n","import { CairoCustomEnum, CairoOption, CairoOptionVariant } from \"starknet\";\nimport type { ParsedEntity, SchemaType } from \"./types\";\n\n/**\n * Check if a value is a CairoOption\n * @param value - The value to check\n * @returns True if the value is a CairoOption, false otherwise\n */\nexport function isCairoOption(value: unknown): value is CairoOption<unknown> {\n    return value instanceof CairoOption;\n}\n\n/**\n * Merge two CairoOption instances\n * @param target - The target CairoOption\n * @param source - The source CairoOption\n * @returns A new CairoOption instance with the merged value\n */\nexport function mergeCairoOption<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    // If source is Some, prefer source's value\n    if (source instanceof CairoOption && source.isSome()) {\n        return new CairoOption(\n            CairoOptionVariant.Some,\n            source.unwrap()\n        ) as unknown as MergedModels<T>;\n    }\n\n    // If source is None or undefined, keep target\n    if (target instanceof CairoOption) {\n        if (target.isSome()) {\n            return new CairoOption(\n                CairoOptionVariant.Some,\n                target.unwrap()\n            ) as unknown as MergedModels<T>;\n        }\n        return new CairoOption(\n            CairoOptionVariant.None\n        ) as unknown as MergedModels<T>;\n    }\n\n    // This should not happen if both are CairoOption instances\n    return target as unknown as MergedModels<T>;\n}\n\n/**\n * Check if a value is a CairoCustomEnum\n * @param value - The value to check\n * @returns True if the value is a CairoCustomEnum, false otherwise\n */\nexport function isCairoCustomEnum(value: unknown): value is CairoCustomEnum {\n    return value instanceof CairoCustomEnum;\n}\n\n/**\n * Merge two CairoCustomEnum instances\n * @param target - The target CairoCustomEnum\n * @param source - The source CairoCustomEnum\n * @returns A new CairoCustomEnum instance with the merged value\n */\nexport function mergeCairoCustomEnum<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    if (!isCairoCustomEnum(target) || !isCairoCustomEnum(source)) {\n        return target;\n    }\n    // If source has an active variant, prefer it\n    const sourceActiveVariant = source.activeVariant();\n    const sourceValue = source.unwrap();\n\n    if (sourceActiveVariant && sourceValue !== undefined) {\n        // Create a new enum with source's active variant\n        const newEnumContent: Record<string, any> = {};\n\n        // Initialize all variants from target with undefined\n        for (const key in target.variant) {\n            newEnumContent[key] = undefined;\n        }\n\n        // Set the active variant from source\n        newEnumContent[sourceActiveVariant] = sourceValue;\n\n        return new CairoCustomEnum(\n            newEnumContent\n        ) as unknown as MergedModels<T>;\n    }\n\n    // If source doesn't have an active variant, keep target\n    const targetActiveVariant = target.activeVariant();\n    const targetValue = target.unwrap();\n\n    if (targetActiveVariant && targetValue !== undefined) {\n        const newEnumContent: Record<string, any> = {};\n\n        // Initialize all variants with undefined\n        for (const key in target.variant) {\n            newEnumContent[key] = undefined;\n        }\n\n        // Set the active variant from target\n        newEnumContent[targetActiveVariant] = targetValue;\n\n        return new CairoCustomEnum(\n            newEnumContent\n        ) as unknown as MergedModels<T>;\n    }\n\n    // Fallback if not both CairoCustomEnum\n    return target;\n}\n\n/**\n * Merged models type\n * @template T - The schema type\n * @returns The merged models type\n */\nexport type MergedModels<T extends SchemaType> =\n    ParsedEntity<T>[\"models\"][keyof ParsedEntity<T>[\"models\"]];\n\nexport function deepMerge<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    if (isCairoOption(target) && isCairoOption(source)) {\n        return mergeCairoOption(target, source);\n    }\n    if (isCairoCustomEnum(target) && isCairoCustomEnum(source)) {\n        return mergeCairoCustomEnum(target, source);\n    }\n    const result = { ...target } as Record<string, any>;\n    for (const key in source) {\n        if (Object.hasOwn(source, key)) {\n            if (\n                source[key] !== null &&\n                typeof source[key] === \"object\" &&\n                !Array.isArray(source[key])\n            ) {\n                // If the property is an object in both source and target, recursively merge\n                if (\n                    key in target &&\n                    typeof target[key] === \"object\" &&\n                    !Array.isArray(target[key])\n                ) {\n                    result[key] = deepMerge(target[key], source[key]);\n                } else {\n                    // If the key doesn't exist in target or isn't an object, just assign\n                    result[key] = source[key];\n                }\n            } else {\n                // For non-objects (primitives, arrays, null), just assign\n                result[key] = source[key];\n            }\n        }\n    }\n\n    return result;\n}\n","import type { BigNumberish } from \"starknet\";\nimport type { SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function getModelByEntityId<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Schema extends SchemaType,\n>(\n    entityId: BigNumberish,\n    model: `${N}-${M}`,\n    value: StandardizedQueryResult<Schema>\n): SchemaType[N][M] | undefined {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    for (const v of value) {\n        if (v.entityId !== entityId) {\n            continue;\n        }\n        return v.models?.[namespace]?.[modelName] as\n            | SchemaType[N][M]\n            | undefined;\n    }\n}\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function getModel<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Schema extends SchemaType,\n>(\n    model: `${N}-${M}`,\n    value: StandardizedQueryResult<Schema>\n): SchemaType[N][M] | undefined {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    for (const v of value) {\n        return v.models?.[namespace]?.[modelName] as\n            | SchemaType[N][M]\n            | undefined;\n    }\n}\n\n// /**\n//  * Custom hook to retrieve all entities that have a specific model.\n//  *\n//  * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n//  * @returns The model structure if found, otherwise undefined.\n//  */\n// export function getModels<\n//     N extends keyof SchemaType,\n//     M extends keyof SchemaType[N] & string,\n//     Client extends (...args: any) => any,\n//     Schema extends SchemaType,\n// >(model: `${N}-${M}`): { [entityId: string]: SchemaType[N][M] | undefined } {\n//     const [namespace, modelName] = model.split(\"-\") as [N, M];\n//     const { useDojoStore } =\n//         useContext<DojoContextType<Client, Schema>>(DojoContext);\n//\n//     const modelData = useDojoStore((state) =>\n//         state.getEntitiesByModel(namespace, modelName).map((entity) => ({\n//             [entity.entityId]: entity.models?.[namespace]?.[modelName],\n//         }))\n//     ) as unknown as { [entityId: string]: SchemaType[N][M] | undefined };\n//\n//     return modelData;\n// }\n","import type {\n    PaginationDirection,\n    Pagination as ToriiPagination,\n} from \"@dojoengine/torii-wasm/types\";\nimport type { SchemaType, ToriiQueryBuilder } from \"./types\";\n\nconst DEFAULT_LIMIT = 1000;\nexport const defaultToriiPagination: ToriiPagination = {\n    limit: DEFAULT_LIMIT,\n    cursor: undefined,\n    direction: \"Forward\",\n    order_by: [],\n};\n\n/**\n * A generic pagination class that handles cursor-based pagination for query results.\n * This class manages the state of paginated items and provides methods to navigate through pages.\n *\n * @template T - The schema type that extends SchemaType\n * @template Inner - The type of items being paginated (must be an array type)\n */\nexport class Pagination<T extends SchemaType, Inner extends any[]> {\n    private items: Inner;\n\n    /**\n     * Creates a new Pagination instance\n     *\n     * @param limit - The maximum number of items to return per page\n     * @param cursor - Optional cursor string for pagination\n     * @param direction - Optional direction of pagination (defaults to \"Forward\")\n     */\n    constructor(\n        public limit: number,\n        public cursor?: string,\n        public direction?: string\n    ) {\n        this.items = [] as unknown as Inner;\n        if (!direction) {\n            this.direction = \"Forward\";\n        }\n    }\n\n    /**\n     * Creates a Pagination instance from a ToriiQueryBuilder\n     *\n     * @param query - The query builder to extract pagination parameters from\n     * @returns A new Pagination instance configured with the query's pagination settings\n     */\n    static fromQuery<T extends SchemaType, Inner extends any[]>(\n        query: ToriiQueryBuilder<T>,\n        nextCursor?: string\n    ): Pagination<T, Inner> {\n        const pagination = query.getPagination();\n        return new Pagination(\n            pagination.limit ?? DEFAULT_LIMIT,\n            nextCursor,\n            pagination.direction\n        );\n    }\n\n    /**\n     * Sets the items for the current page\n     *\n     * @param items - The items to set for the current page\n     * @returns The Pagination instance for method chaining\n     */\n    withItems(items: Inner) {\n        this.items = items;\n        return this;\n    }\n\n    /**\n     * Gets the current page's items\n     *\n     * @returns The array of items for the current page\n     */\n    getItems(): Inner {\n        return this.items;\n    }\n\n    /**\n     * Gets a query builder configured for the next page\n     *\n     * @param query - The base query builder to configure\n     * @returns A new query builder configured for the next page\n     */\n    getNextQuery(query: ToriiQueryBuilder<T>): ToriiQueryBuilder<T> {\n        const q = query.withLimit(this.limit);\n        if (this.cursor) {\n            q.withCursor(this.cursor);\n        }\n        if (q.getPagination().direction !== this.direction) {\n            q.withDirection(this.direction as PaginationDirection);\n        }\n        return q;\n    }\n\n    /**\n     * Gets a query builder configured for the previous page\n     *\n     * @param query - The base query builder to configure\n     * @returns A new query builder configured for the previous page\n     */\n    getPreviousQuery(query: ToriiQueryBuilder<T>): ToriiQueryBuilder<T> {\n        const q = query.withLimit(this.limit);\n        if (this.cursor) {\n            q.withCursor(this.cursor);\n        }\n        if (q.getPagination().direction === this.direction) {\n            q.withDirection(getReversedDirection(this.direction));\n        }\n\n        return q;\n    }\n}\n\n/**\n * Returns the opposite pagination direction.\n *\n * This utility function takes a pagination direction and returns its opposite:\n * - \"Forward\" becomes \"Backward\"\n * - \"Backward\" becomes \"Forward\"\n * - Any other value defaults to \"Forward\" (though this should not occur with proper typing)\n *\n * @param direction - The current pagination direction\n * @returns The reversed pagination direction\n */\nfunction getReversedDirection(\n    direction: PaginationDirection\n): PaginationDirection {\n    if (direction === \"Forward\") return \"Backward\";\n    if (direction === \"Backward\") return \"Forward\";\n    // we should not go down here.\n    return \"Forward\";\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\nimport {\n    CairoCustomEnum,\n    CairoOption,\n    CairoOptionVariant,\n    addAddressPadding,\n} from \"starknet\";\nimport type {\n    ParsedEntity,\n    SchemaType,\n    StandardizedQueryResult,\n} from \"./types\";\n\nexport function parseEntities<T extends SchemaType>(\n    entities: torii.Entity[],\n    options?: { logging?: boolean }\n): StandardizedQueryResult<T> {\n    // @ts-ignore\n    const result: ParsedEntity<T>[] = [];\n\n    for (const entity of entities) {\n        const entityId = addAddressPadding(entity.hashed_keys);\n        const entityData = entity.models;\n        const parsedEntity: ParsedEntity<T> = {\n            entityId,\n            models: {} as ParsedEntity<T>[\"models\"],\n        };\n\n        for (const modelName in entity.models) {\n            const [schemaKey, modelKey] = modelName.split(\"-\") as [\n                keyof T,\n                string,\n            ];\n\n            if (!schemaKey || !modelKey) {\n                if (options?.logging) {\n                    console.warn(`Invalid modelName format: ${modelName}`);\n                }\n                continue;\n            }\n\n            if (!parsedEntity.models[schemaKey]) {\n                parsedEntity.models[schemaKey] = {} as T[typeof schemaKey];\n            }\n\n            (parsedEntity.models[schemaKey] as any)[modelKey] = parseStruct(\n                entityData[modelName]\n            );\n        }\n\n        result.push(parsedEntity);\n\n        if (options?.logging) {\n            console.log(`Parsed entity:`, parsedEntity);\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"Parsed result:\", result);\n    }\n\n    return Object.values(result);\n}\n\n/**\n * Parses a value based on its type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parseValue(value: torii.Ty): any {\n    switch (value.type) {\n        case \"primitive\":\n            return parsePrimitive(value);\n        case \"struct\":\n            return parseStruct(\n                value.value as Record<string, torii.Ty> | Map<string, torii.Ty>\n            );\n        case \"enum\":\n            // Handling Options\n            if (\"Some\" === (value.value as torii.EnumValue).option) {\n                return new CairoOption(\n                    CairoOptionVariant.Some,\n                    parseValue((value.value as torii.EnumValue).value)\n                );\n            }\n            if (\"None\" === (value.value as torii.EnumValue).option) {\n                return new CairoOption(CairoOptionVariant.None);\n            }\n\n            // Handling simple enum as default case\n            // Handling CairoCustomEnum for more complex types\n            return parseCustomEnum(value);\n        case \"tuple\":\n        case \"array\":\n            return (value.value as torii.Ty[]).map(parseValue);\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a value identified as enum either returns a single string matching enum value\n * or CairoCustomEnum matching more complex cairo types\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {CairoCustomEnum | string} - The parsed value.\n */\nfunction parseCustomEnum(value: torii.Ty): CairoCustomEnum | string {\n    // enum is a simple enum\n    if ((value.value as torii.EnumValue).value.type === \"tuple\") {\n        // we keep retrocompatibility\n        return (value.value as torii.EnumValue).option;\n    }\n\n    return new CairoCustomEnum({\n        [(value.value as torii.EnumValue).option]: parseValue(\n            (value.value as torii.EnumValue).value\n        ),\n    });\n}\n\n/**\n * Parses a value based on its primitive type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parsePrimitive(value: torii.Ty): any {\n    switch (value.type_name) {\n        case \"u64\":\n        case \"i64\":\n            return Number(value.value as string);\n        case \"u128\":\n        case \"i128\":\n            return BigInt(value.value as string);\n        case \"u256\":\n            return BigInt(value.value as string);\n        case \"u8\":\n        case \"u16\":\n        case \"u32\":\n        case \"i8\":\n        case \"i16\":\n        case \"i32\":\n        case \"bool\":\n        case \"ContractAddress\":\n        case \"ClassHash\":\n        case \"felt252\":\n        case \"EthAddress\":\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a struct (record or map) into an object with parsed values.\n *\n * @param {Record<string, torii.Ty> | Map<string, torii.Ty>} struct - The struct to parse.\n * @returns {any} - The parsed struct as an object.\n */\nfunction parseStruct(\n    struct: Record<string, torii.Ty> | Map<string, torii.Ty>\n): any {\n    const entries =\n        struct instanceof Map\n            ? Array.from(struct.entries())\n            : Object.entries(struct);\n    return Object.fromEntries(\n        entries.map(([key, value]) => [key, parseValue(value)])\n    );\n}\n","import type { Entity } from \"@dojoengine/torii-wasm/types\";\nimport { parseEntities } from \"./parseEntities\";\nimport type {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionCallback,\n} from \"./types\";\n\n/**\n * Creates a callback function for entity subscription that processes entity data and invokes the provided callback.\n * This function is used to standardize entity data handling in subscription callbacks.\n *\n * @template T - The schema type that defines the structure of the entity data\n * @param {SubscriptionCallback<StandardizedQueryResult<T>>} callback - The callback function to be invoked with parsed entity data or error\n * @returns {Function} A function that accepts a hashed key and entity data, parses the entity data, and invokes the provided callback\n */\nexport function subscribeQueryModelCallback<T extends SchemaType>(\n    callback: SubscriptionCallback<StandardizedQueryResult<T>>\n) {\n    return (entityData: Entity) => {\n        try {\n            if (callback) {\n                const parsedData = parseEntities<T>([entityData]);\n\n                callback({\n                    data: parsedData,\n                    error: undefined,\n                });\n            }\n        } catch (error) {\n            if (callback) {\n                callback({\n                    data: undefined,\n                    error:\n                        error instanceof Error\n                            ? error\n                            : new Error(String(error)),\n                });\n            }\n        }\n    };\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\nimport { addAddressPadding } from \"starknet\";\nimport { defaultToriiPagination } from \"./pagination\";\nimport type {\n    AttributesFilter,\n    GetTokenBalanceRequest,\n    GetTokenContracts,\n    GetTokenRequest,\n    SubscribeTokenBalanceRequest,\n    SubscribeTokenRequest,\n    SubscriptionCallback,\n    UpdateTokenBalanceSubscriptionRequest,\n} from \"./types\";\n\ntype Strict<T> = {\n    [K in keyof T]-?: NonNullable<T[K]>;\n};\n\n/**\n * Creates a safe callback wrapper that handles errors\n * @param callback - The user-provided callback\n * @param defaultValue - Default value to check against\n * @returns Wrapped callback that handles try/catch\n */\nexport function safeCallback<T>(\n    callback: SubscriptionCallback<T>,\n    defaultValue: T\n): (res: T) => void {\n    return (res: T) => {\n        if (res === defaultValue) {\n            return;\n        }\n        try {\n            callback({\n                data: res,\n                error: undefined,\n            });\n        } catch (error) {\n            callback({\n                data: undefined,\n                error: error as Error,\n            });\n        }\n    };\n}\n\nexport const defaultTokenBalance: torii.TokenBalance = {\n    balance:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    account_address: \"0x0\",\n    contract_address: \"0x0\",\n    token_id:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n};\n\nexport function parseTokenRequest<\n    T extends GetTokenRequest & GetTokenBalanceRequest & GetTokenContracts,\n>(req: T): Strict<T> {\n    if (req.contractAddresses) {\n        req.contractAddresses = req.contractAddresses.map((r) =>\n            addAddressPadding(r)\n        );\n    }\n\n    if (req.accountAddresses) {\n        req.accountAddresses = req.accountAddresses.map((r) =>\n            addAddressPadding(r)\n        );\n    }\n\n    return {\n        contractAddresses: req.contractAddresses ?? [],\n        accountAddresses: req.accountAddresses ?? [],\n        attributesFilter: req.attributesFilter ?? [],\n        contractTypes: req.contractTypes ?? [],\n        tokenIds: req.tokenIds ?? [],\n        pagination: req.pagination ?? defaultToriiPagination,\n    } as Strict<T>;\n}\nfunction toAttributesFilter(\n    attributes: AttributesFilter[]\n): torii.AttributeFilter[] {\n    return attributes.map((a) => ({\n        trait_name: a.name,\n        trait_value: a.value,\n    }));\n}\n/**\n * @param {GetTokenRequest} request\n * @returns {Promise<torii.Tokens>}\n */\nexport async function getTokens(\n    client: torii.ToriiClient,\n    request: GetTokenRequest\n): Promise<torii.Tokens> {\n    const { contractAddresses, tokenIds, pagination, attributesFilter } =\n        parseTokenRequest(request);\n    return await client.getTokens({\n        contract_addresses: contractAddresses,\n        token_ids: tokenIds,\n        attribute_filters: toAttributesFilter(attributesFilter),\n        pagination,\n    });\n}\n/**\n * @param {GetTokenContracts} request\n * @returns {Promise<torii.Tokens>}\n */\nexport async function getTokenContracts(\n    client: torii.ToriiClient,\n    request: GetTokenContracts\n): Promise<torii.TokenContracts> {\n    const { contractAddresses, contractTypes, pagination } =\n        parseTokenRequest(request);\n    return await client.getTokenContracts({\n        contract_addresses: contractAddresses,\n        contract_types: contractTypes as torii.ContractType[],\n        pagination,\n    });\n}\n\n/**\n * @param {GetTokenBalanceRequest} request\n * @returns {Promise<torii.TokenBalances>}\n */\nexport async function getTokenBalances(\n    client: torii.ToriiClient,\n    request: GetTokenBalanceRequest\n): Promise<torii.TokenBalances> {\n    const { contractAddresses, accountAddresses, tokenIds, pagination } =\n        parseTokenRequest(request);\n    return await client.getTokenBalances({\n        contract_addresses: contractAddresses,\n        account_addresses: accountAddresses,\n        token_ids: tokenIds,\n        pagination,\n    });\n}\n\n/**\n * Subscribes to token balance updates\n *\n * # Parameters\n * @param {SubscribeTokenBalanceRequest} request\n *\n * # Returns\n * Result containing subscription handle or error\n * @returns torii.Subscription\n */\nexport async function onTokenBalanceUpdated(\n    client: torii.ToriiClient,\n    request: SubscribeTokenBalanceRequest\n): Promise<torii.Subscription> {\n    const { contractAddresses, accountAddresses, tokenIds } =\n        parseTokenRequest(request);\n    return await client.onTokenBalanceUpdated(\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(request.callback, defaultTokenBalance)\n    );\n}\n\n/**\n * Updates an existing token balance subscription\n *\n * # Parameters\n * @param {torii.Subscription} subscription - Existing subscription to update\n * @param {UpdateTokenBalanceSubscriptionRequest} request\n *\n * # Returns\n * Result containing unit or error\n * @returns {Promise<void>}\n */\nexport async function updateTokenBalanceSubscription(\n    client: torii.ToriiClient,\n    request: UpdateTokenBalanceSubscriptionRequest\n): Promise<void> {\n    const { subscription, contractAddresses, accountAddresses, tokenIds } =\n        request;\n    return await client.updateTokenBalanceSubscription(\n        subscription,\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? []\n    );\n}\n/**\n * Subscribes to token balance updates and returns initial data with subscription\n *\n * # Parameters\n * @param {SubscribeTokenBalanceRequest} request - Request parameters\n *\n * # Returns\n * Array containing initial token balances and subscription handle\n * @returns {Promise<[torii.TokenBalances, torii.Subscription]>}\n */\nexport async function subscribeTokenBalance(\n    client: torii.ToriiClient,\n    request: SubscribeTokenBalanceRequest\n): Promise<[torii.TokenBalances, torii.Subscription]> {\n    const { contractAddresses, accountAddresses, tokenIds, callback } = request;\n\n    // Get initial token balances\n    const initialBalances = await getTokenBalances(client, {\n        contractAddresses: contractAddresses ?? [],\n        accountAddresses: accountAddresses ?? [],\n        tokenIds: tokenIds ?? [],\n    });\n\n    // Create subscription for updates\n    const subscription = await client.onTokenBalanceUpdated(\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultTokenBalance)\n    );\n\n    return [initialBalances, subscription];\n}\n\nexport const defaultToken: torii.Token = {\n    contract_address: \"0x0\",\n    token_id:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    name: \"\",\n    symbol: \"\",\n    decimals: 0,\n    metadata: \"\",\n    total_supply: \"\",\n};\n\n/**\n * Subscribes to token updates\n *\n * # Parameters\n * @param {SubscribeTokenRequest} request\n *\n * # Returns\n * Result containing subscription handle or error\n * @returns torii.Subscription\n */\nexport async function onTokenUpdated(\n    client: torii.ToriiClient,\n    request: SubscribeTokenRequest\n): Promise<torii.Subscription> {\n    const { contractAddresses, tokenIds, callback } =\n        parseTokenRequest(request);\n    return await client.onTokenUpdated(\n        contractAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultToken)\n    );\n}\n\n/**\n * Subscribes to token updates and returns initial data with subscription\n *\n * # Parameters\n * @param {SubscribeTokenRequest} request - Request parameters\n *\n * # Returns\n * Array containing initial tokens and subscription handle\n * @returns {Promise<[torii.Tokens, torii.Subscription]>}\n */\nexport async function subscribeToken(\n    client: torii.ToriiClient,\n    request: SubscribeTokenRequest\n): Promise<[torii.Tokens, torii.Subscription]> {\n    const { contractAddresses, tokenIds, callback } = request;\n\n    // Get initial tokens\n    const initialTokens = await getTokens(client, {\n        contractAddresses: contractAddresses ?? [],\n        tokenIds: tokenIds ?? [],\n    });\n\n    // Create subscription for updates\n    const subscription = await client.onTokenUpdated(\n        contractAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultToken)\n    );\n\n    return [initialTokens, subscription];\n}\n","import type { Pagination } from \"@dojoengine/torii-wasm\";\nimport type {\n    Clause,\n    OrderBy,\n    PaginationDirection,\n    Query,\n} from \"@dojoengine/torii-wasm/types\";\nimport { err, ok, type Result } from \"neverthrow\";\nimport { UNDEFINED_CLAUSE } from \"./errors\";\nimport type { SchemaType } from \"./types\";\n\nconst defaultToriiOptions = () => ({\n    pagination: {\n        limit: 100,\n        cursor: undefined,\n        direction: \"Forward\",\n        order_by: [],\n    },\n    clause: undefined,\n    no_hashed_keys: true,\n    models: [],\n    historical: false,\n});\n\ntype ToriiQueryBuilderOptions = Omit<Partial<Query>, \"clause\">;\n\nexport class ToriiQueryBuilder<T extends SchemaType> {\n    private query: Query;\n\n    constructor(options?: ToriiQueryBuilderOptions) {\n        this.query = { ...(defaultToriiOptions() as Query), ...options };\n    }\n\n    /**\n     * Set the maximum number of results to return\n     */\n    withLimit(limit: number): ToriiQueryBuilder<T> {\n        this.query.pagination.limit = limit;\n        return this;\n    }\n\n    /**\n     * Set the offset for pagination\n     * @deprecated Use `withCursor` instead\n     */\n    withOffset(): ToriiQueryBuilder<T> {\n        return this;\n    }\n\n    /**\n     * Set the cursor for pagination\n     * undefined is default, fetch from starting point\n     * `next_cursor` is return from queries\n     */\n    withCursor(cursor: string): ToriiQueryBuilder<T> {\n        this.query.pagination.cursor = cursor;\n        return this;\n    }\n\n    /**\n     * Set the maximum number of results to return\n     */\n    withDirection(direction: PaginationDirection): ToriiQueryBuilder<T> {\n        this.query.pagination.direction = direction;\n        return this;\n    }\n\n    /**\n     * Add the clause to filter results\n     */\n    withClause(clause: Clause): ToriiQueryBuilder<T> {\n        this.query.clause = clause;\n        return this;\n    }\n\n    /**\n     * Set whether to include hashed keys in the response\n     * HashedKeys represent internal torii entity id.\n     */\n    includeHashedKeys(): ToriiQueryBuilder<T> {\n        this.query.no_hashed_keys = false;\n        return this;\n    }\n\n    /**\n     * Add a single order by clause\n     */\n    addOrderBy(\n        member: string,\n        direction: \"Asc\" | \"Desc\"\n    ): ToriiQueryBuilder<T> {\n        this.query.pagination.order_by.push({\n            field: member,\n            direction,\n        });\n        return this;\n    }\n\n    /**\n     * Add multiple order by clauses at once\n     */\n    withOrderBy(orderBy: OrderBy[]): ToriiQueryBuilder<T> {\n        this.query.pagination.order_by = orderBy;\n        return this;\n    }\n\n    /**\n     * Add a single entity model to filter\n     */\n    addEntityModel(model: keyof T & string): ToriiQueryBuilder<T> {\n        this.query.models.push(model);\n        return this;\n    }\n\n    /**\n     * Set multiple entity models at once\n     */\n    withEntityModels(models: (keyof T & string)[]): ToriiQueryBuilder<T> {\n        this.query.models = models;\n        return this;\n    }\n\n    /**\n     * Build the final query\n     */\n    build(): Query {\n        return this.query;\n    }\n\n    /**\n     * Create a new builder instance with pagination settings\n     *\n     */\n    static withPagination<T extends Record<string, Record<string, any>>>(\n        cursor: string,\n        limit: number,\n        direction: PaginationDirection\n    ): ToriiQueryBuilder<T> {\n        return new ToriiQueryBuilder<T>()\n            .withLimit(limit)\n            .withCursor(cursor)\n            .withDirection(direction);\n    }\n\n    /**\n     * Returns inner clause inside a Result wrapper.\n     */\n    getClause(): Result<Clause, string> {\n        if (!this.query.clause) {\n            return err(UNDEFINED_CLAUSE);\n        }\n        return ok(this.query.clause);\n    }\n\n    getPagination(): Pagination {\n        return this.query.pagination;\n    }\n\n    /**\n     * Check is query is historical\n     */\n    isHistorical(): boolean {\n        return this.query.historical;\n    }\n}\n\nexport type HistoricalToriiQueryBuilderOptions = Omit<\n    Partial<ToriiQueryBuilderOptions>,\n    \"historical\"\n>;\nexport class HistoricalToriiQueryBuilder<\n    T extends SchemaType,\n> extends ToriiQueryBuilder<T> {\n    constructor(options?: ToriiQueryBuilderOptions) {\n        super({\n            ...(defaultToriiOptions() as Query),\n            ...options,\n            historical: true,\n        });\n    }\n}\n","const defaultErrorConfig = {\r\n    withStackTrace: false,\r\n};\r\n// Custom error object\r\n// Context / discussion: https://github.com/supermacro/neverthrow/pull/215\r\nconst createNeverThrowError = (message, result, config = defaultErrorConfig) => {\r\n    const data = result.isOk()\r\n        ? { type: 'Ok', value: result.value }\r\n        : { type: 'Err', value: result.error };\r\n    const maybeStack = config.withStackTrace ? new Error().stack : undefined;\r\n    return {\r\n        data,\r\n        message,\r\n        stack: maybeStack,\r\n    };\r\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass ResultAsync {\r\n    constructor(res) {\r\n        this._promise = res;\r\n    }\r\n    static fromSafePromise(promise) {\r\n        const newPromise = promise.then((value) => new Ok(value));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    static fromPromise(promise, errorFn) {\r\n        const newPromise = promise\r\n            .then((value) => new Ok(value))\r\n            .catch((e) => new Err(errorFn(e)));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            return new ResultAsync((() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    return new Ok(yield fn(...args));\r\n                }\r\n                catch (error) {\r\n                    return new Err(errorFn ? errorFn(error) : error);\r\n                }\r\n            }))());\r\n        };\r\n    }\r\n    static combine(asyncResultList) {\r\n        return combineResultAsyncList(asyncResultList);\r\n    }\r\n    static combineWithAllErrors(asyncResultList) {\r\n        return combineResultAsyncListWithAllErrors(asyncResultList);\r\n    }\r\n    map(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            return new Ok(yield f(res.value));\r\n        })));\r\n    }\r\n    andThrough(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newRes = yield f(res.value);\r\n            if (newRes.isErr()) {\r\n                return new Err(newRes.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    andTee(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            try {\r\n                yield f(res.value);\r\n            }\r\n            catch (e) {\r\n                // Tee does not care about the error\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    orTee(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isOk()) {\r\n                return new Ok(res.value);\r\n            }\r\n            try {\r\n                yield f(res.error);\r\n            }\r\n            catch (e) {\r\n                // Tee does not care about the error\r\n            }\r\n            return new Err(res.error);\r\n        })));\r\n    }\r\n    mapErr(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isOk()) {\r\n                return new Ok(res.value);\r\n            }\r\n            return new Err(yield f(res.error));\r\n        })));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return new ResultAsync(this._promise.then((res) => {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newValue = f(res.value);\r\n            return newValue instanceof ResultAsync ? newValue._promise : newValue;\r\n        }));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return f(res.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    match(ok, _err) {\r\n        return this._promise.then((res) => res.match(ok, _err));\r\n    }\r\n    unwrapOr(t) {\r\n        return this._promise.then((res) => res.unwrapOr(t));\r\n    }\r\n    /**\r\n     * @deprecated will be removed in 9.0.0.\r\n     *\r\n     * You can use `safeTry` without this method.\r\n     * @example\r\n     * ```typescript\r\n     * safeTry(async function* () {\r\n     *   const okValue = yield* yourResult\r\n     * })\r\n     * ```\r\n     * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.\r\n     */\r\n    safeUnwrap() {\r\n        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {\r\n            return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));\r\n        });\r\n    }\r\n    // Makes ResultAsync implement PromiseLike<Result>\r\n    then(successCallback, failureCallback) {\r\n        return this._promise.then(successCallback, failureCallback);\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return __asyncGenerator(this, arguments, function* _a() {\r\n            const result = yield __await(this._promise);\r\n            if (result.isErr()) {\r\n                // @ts-expect-error -- This is structurally equivalent and safe\r\n                yield yield __await(errAsync(result.error));\r\n            }\r\n            // @ts-expect-error -- This is structurally equivalent and safe\r\n            return yield __await(result.value);\r\n        });\r\n    }\r\n}\r\nfunction okAsync(value) {\r\n    return new ResultAsync(Promise.resolve(new Ok(value)));\r\n}\r\nfunction errAsync(err) {\r\n    return new ResultAsync(Promise.resolve(new Err(err)));\r\n}\r\nconst fromPromise = ResultAsync.fromPromise;\r\nconst fromSafePromise = ResultAsync.fromSafePromise;\r\nconst fromAsyncThrowable = ResultAsync.fromThrowable;\n\n/**\r\n * Short circuits on the FIRST Err value that we find\r\n */\r\nconst combineResultList = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr()) {\r\n            acc = err(result.error);\r\n            break;\r\n        }\r\n        else {\r\n            acc.map((list) => list.push(result.value));\r\n        }\r\n    }\r\n    return acc;\r\n};\r\n/* This is the typesafe version of Promise.all\r\n *\r\n * Takes a list of ResultAsync<T, E> and success if all inner results are Ok values\r\n * or fails if one (or more) of the inner results are Err values\r\n */\r\nconst combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);\r\n/**\r\n * Give a list of all the errors we find\r\n */\r\nconst combineResultListWithAllErrors = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr() && acc.isErr()) {\r\n            acc.error.push(result.error);\r\n        }\r\n        else if (result.isErr() && acc.isOk()) {\r\n            acc = err([result.error]);\r\n        }\r\n        else if (result.isOk() && acc.isOk()) {\r\n            acc.value.push(result.value);\r\n        }\r\n        // do nothing when result.isOk() && acc.isErr()\r\n    }\r\n    return acc;\r\n};\r\nconst combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nvar Result;\r\n(function (Result) {\r\n    /**\r\n     * Wraps a function with a try catch, creating a new function with the same\r\n     * arguments but returning `Ok` if successful, `Err` if the function throws\r\n     *\r\n     * @param fn function to wrap with ok on success or err on failure\r\n     * @param errorFn when an error is thrown, this will wrap the error result if provided\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    function fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            try {\r\n                const result = fn(...args);\r\n                return ok(result);\r\n            }\r\n            catch (e) {\r\n                return err(errorFn ? errorFn(e) : e);\r\n            }\r\n        };\r\n    }\r\n    Result.fromThrowable = fromThrowable;\r\n    function combine(resultList) {\r\n        return combineResultList(resultList);\r\n    }\r\n    Result.combine = combine;\r\n    function combineWithAllErrors(resultList) {\r\n        return combineResultListWithAllErrors(resultList);\r\n    }\r\n    Result.combineWithAllErrors = combineWithAllErrors;\r\n})(Result || (Result = {}));\r\nfunction ok(value) {\r\n    return new Ok(value);\r\n}\r\nfunction err(err) {\r\n    return new Err(err);\r\n}\r\nfunction safeTry(body) {\r\n    const n = body().next();\r\n    if (n instanceof Promise) {\r\n        return new ResultAsync(n.then((r) => r.value));\r\n    }\r\n    return n.value;\r\n}\r\nclass Ok {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    isOk() {\r\n        return true;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    map(f) {\r\n        return ok(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    mapErr(_f) {\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThrough(f) {\r\n        return f(this.value).map((_value) => this.value);\r\n    }\r\n    andTee(f) {\r\n        try {\r\n            f(this.value);\r\n        }\r\n        catch (e) {\r\n            // Tee doesn't care about the error\r\n        }\r\n        return ok(this.value);\r\n    }\r\n    orTee(_f) {\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(_f) {\r\n        return ok(this.value);\r\n    }\r\n    asyncAndThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    asyncAndThrough(f) {\r\n        return f(this.value).map(() => this.value);\r\n    }\r\n    asyncMap(f) {\r\n        return ResultAsync.fromSafePromise(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    unwrapOr(_v) {\r\n        return this.value;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    match(ok, _err) {\r\n        return ok(this.value);\r\n    }\r\n    safeUnwrap() {\r\n        const value = this.value;\r\n        /* eslint-disable-next-line require-yield */\r\n        return (function* () {\r\n            return value;\r\n        })();\r\n    }\r\n    _unsafeUnwrap(_) {\r\n        return this.value;\r\n    }\r\n    _unsafeUnwrapErr(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrapErr` on an Ok', this, config);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, require-yield\r\n    *[Symbol.iterator]() {\r\n        return this.value;\r\n    }\r\n}\r\nclass Err {\r\n    constructor(error) {\r\n        this.error = error;\r\n    }\r\n    isOk() {\r\n        return false;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    map(_f) {\r\n        return err(this.error);\r\n    }\r\n    mapErr(f) {\r\n        return err(f(this.error));\r\n    }\r\n    andThrough(_f) {\r\n        return err(this.error);\r\n    }\r\n    andTee(_f) {\r\n        return err(this.error);\r\n    }\r\n    orTee(f) {\r\n        try {\r\n            f(this.error);\r\n        }\r\n        catch (e) {\r\n            // Tee doesn't care about the error\r\n        }\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(_f) {\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return f(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncAndThen(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    asyncAndThrough(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncMap(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    unwrapOr(v) {\r\n        return v;\r\n    }\r\n    match(_ok, err) {\r\n        return err(this.error);\r\n    }\r\n    safeUnwrap() {\r\n        const error = this.error;\r\n        return (function* () {\r\n            yield err(error);\r\n            throw new Error('Do not use this generator out of `safeTry`');\r\n        })();\r\n    }\r\n    _unsafeUnwrap(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrap` on an Err', this, config);\r\n    }\r\n    _unsafeUnwrapErr(_) {\r\n        return this.error;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        // @ts-expect-error -- This is structurally equivalent and safe\r\n        yield self;\r\n        // @ts-expect-error -- This is structurally equivalent and safe\r\n        return self;\r\n    }\r\n}\r\nconst fromThrowable = Result.fromThrowable;\r\n//#endregion\n\nexport { Err, Ok, Result, ResultAsync, err, errAsync, fromAsyncThrowable, fromPromise, fromSafePromise, fromThrowable, ok, okAsync, safeTry };\n"],"mappings":"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","names":["createStore","applyPatches","enablePatches","produceWithPatches","subscribeWithSelector","immer","shortString","CairoCustomEnum","CairoOption","CairoOptionVariant","addAddressPadding","defaultErrorConfig","createNeverThrowError","message","result","config","data","maybeStack","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","e","rejected","__values","o","s","m","i","__await","v","__asyncGenerator","g","q","verb","awaitReturn","f","n","a","b","resume","settle","r","fulfill","__asyncDelegator","p","__asyncValues","d","ResultAsync","_ResultAsync","res","promise","newPromise","value","Ok","errorFn","e","Err","fn","args","__awaiter","error","asyncResultList","combineResultAsyncList","combineResultAsyncListWithAllErrors","f","newRes","newValue","ok","_err","t","__asyncGenerator","__await","__asyncDelegator","__asyncValues","successCallback","failureCallback","result","errAsync","errAsync","err","ResultAsync","Err","fromPromise","fromSafePromise","fromAsyncThrowable","combineResultList","resultList","acc","ok","result","list","combineResultAsyncList","asyncResultList","combineResultListWithAllErrors","combineResultAsyncListWithAllErrors","Result","fromThrowable","fn","errorFn","args","e","combine","combineWithAllErrors","value","Ok","Ok","value","f","ok","_f","_value","ResultAsync","_v","_err","_","config","createNeverThrowError","Err","error","err","errAsync","v","_ok","self","fromThrowable","Result","isCairoOption","value","CairoOption","mergeCairoOption","target","source","CairoOptionVariant","isCairoCustomEnum","CairoCustomEnum","mergeCairoCustomEnum","sourceActiveVariant","sourceValue","newEnumContent","key","targetActiveVariant","targetValue","deepMerge","result","enablePatches","areEntitiesEqual","entity1","entity2","createDojoStoreFactory","storeCreatorFn","useStore","subscribeWithSelector","immer","set","get","entities","state","entity","existingEntity","mergedModels","namespace","namespaceModels","typedNamespace","D","existingHistory","lastState","transactionId","updateFn","currentState","nextState","patches","inversePatches","produceWithPatches","draftState","transaction","applyPatches","entityId","listener","predicate","timeout","resolve","reject","currentEntity","unsubscribe","timer","filter","allEntities","model","index","historicalStates","createDojoStore","createDojoStoreFactory","createStore"]}