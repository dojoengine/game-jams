{"version":3,"file":"index.cjs","sources":["../src/errors/TypedError.ts","../src/addEventListener.ts","../src/createCbCollector.ts","../src/errors/isErrorOfType.ts","../src/errors/createTypedErrorPredicate.ts","../src/async/errors.ts","../src/async/promises/CancelablePromise.ts","../src/async/promises/EnhancedPromise.ts","../src/async/sleep.ts","../src/storage/storage.ts","../src/casing.ts","../src/createLogger.ts","../src/css-vars.ts"],"sourcesContent":["export interface TypedErrorOptions {\n  message?: string;\n  cause?: unknown;\n}\n\nexport class TypedError<T extends string> extends Error {\n  constructor(type: T, options?: TypedErrorOptions);\n  constructor(type: T, message?: string, cause?: unknown);\n  constructor(public readonly type: T, messageOrOptions?: string | TypedErrorOptions, cause?: unknown) {\n    super(\n      typeof messageOrOptions === 'object' ? messageOrOptions.message : messageOrOptions || type,\n      {\n        cause: typeof messageOrOptions === 'object' ? messageOrOptions.cause : cause,\n      },\n    );\n    this.name = 'TypedError';\n    Object.setPrototypeOf(this, TypedError.prototype);\n  }\n}\n","export function addEventListener<E, L extends (...args: any[]) => any>(\n  obj: {\n    addEventListener(type: E, listener: L): void;\n    removeEventListener(type: E, listener: L): void;\n  },\n  type: E,\n  listener: L\n) {\n  obj.addEventListener(type, listener);\n  return () => obj.removeEventListener(type, listener);\n}","export type CallbackFn = () => void;\n\n/**\n * Returns a tuple, containing function to add cleanup, call cleanup, and flag showing whether\n * cleanup was called. Cleanup will not be performed in case, it was done before.\n */\nexport function createCbCollector(...cbs: (CallbackFn | CallbackFn[])[]): [\n  add: (...fns: CallbackFn[]) => void,\n  call: () => void,\n] {\n  const callbacks = cbs.flat(1);\n\n  return [\n    callbacks.push.bind(callbacks),\n    () => {\n      callbacks.forEach(cb => {\n        cb();\n      });\n    },\n  ];\n}","import { TypedError } from '@/errors/TypedError.js';\n\n/**\n * @returns True, if the specified value is a TypedError of the specified type.\n * @param value - value to check.\n * @param type - error type.\n */\nexport function isErrorOfType<T extends string>(value: unknown, type: T): value is TypedError<T> {\n  return value instanceof TypedError && value.type === type;\n}","import { TypedError } from './TypedError.js';\nimport { isErrorOfType } from '@/errors/isErrorOfType.js';\n\nexport function createTypedErrorPredicate<T extends string>(\n  type: T,\n): (value: unknown) => value is TypedError<T> {\n  return (value): value is TypedError<T> => isErrorOfType(value, type);\n}","import { TypedError } from '@/errors/TypedError.js';\nimport { createTypedErrorPredicate } from '@/errors/createTypedErrorPredicate.js';\n\nexport const ERR_ABORTED = 'ERR_ABORTED';\nexport const ERR_CANCELED = 'ERR_CANCELED';\nexport const ERR_TIMED_OUT = 'ERR_TIMED_OUT';\n\nexport function createAbortError(cause?: unknown): TypedError<typeof ERR_ABORTED> {\n  return new TypedError(ERR_ABORTED, { cause });\n}\n\nexport const isTimeoutError = createTypedErrorPredicate(ERR_TIMED_OUT);\n\nexport const isAbortError = createTypedErrorPredicate(ERR_ABORTED);\n\nexport const isCanceledError = createTypedErrorPredicate(ERR_CANCELED);","import { TypedError } from '@/errors/TypedError.js';\nimport { addEventListener } from '@/addEventListener.js';\nimport { createCbCollector } from '@/createCbCollector.js';\nimport { createAbortError, ERR_CANCELED, ERR_TIMED_OUT } from '@/async/errors.js';\nimport type { Maybe } from '@/types/misc.js';\nimport type { AsyncOptions } from '@/async/types.js';\n\nimport type {\n  PromiseExecutorFn,\n  PromiseOnRejectedFn,\n  PromiseRejectFn,\n  PromiseOnFulfilledFn,\n  PromiseResolveFn,\n} from './types.js';\n\nfunction assignReject<P extends CancelablePromise<any>>(\n  childPromise: P,\n  parentPromise: CancelablePromise<any>,\n): P {\n  childPromise.reject = parentPromise.reject;\n  return childPromise;\n}\n\n/**\n * Improved version of the JavaScript Promise.\n */\nexport class CancelablePromise<Result> extends Promise<Result> {\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn<T>(\n    fn: (abortSignal: AbortSignal) => (T | PromiseLike<T>),\n    options?: AsyncOptions,\n  ): CancelablePromise<T> {\n    return new CancelablePromise((res, rej, signal) => {\n      try {\n        const result = fn(signal);\n        return result instanceof Promise ? result.then(res, rej) : res(result);\n      } catch (e) {\n        rej(e);\n      }\n    }, options);\n  }\n\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve(): CancelablePromise<void>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<T>(value: T | PromiseLike<T>): CancelablePromise<Awaited<T>>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<T>(value?: T | PromiseLike<T>): CancelablePromise<Awaited<T>> {\n    return new CancelablePromise(resolve => {\n      resolve(value as Awaited<T>);\n    });\n  }\n\n  /**\n   * @see Promise.reject\n   */\n  static override reject<T = never>(reason?: any): CancelablePromise<T> {\n    return new CancelablePromise((_, reject) => {\n      reject(reason);\n    });\n  }\n\n  /**\n   * Creates a new BetterPromise instance using only options.\n   * @param options - additional options.\n   */\n  constructor(options?: AsyncOptions);\n  /**\n   * Creates a new BetterPromise instance using specified executor and additional options.\n   * @param executor - promise executor.\n   * @param options - additional options.\n   */\n  constructor(executor?: PromiseExecutorFn<Result>, options?: AsyncOptions);\n  constructor(\n    executorOrOptions?: PromiseExecutorFn<Result> | AsyncOptions,\n    maybeOptions?: AsyncOptions,\n  ) {\n    let executor: PromiseExecutorFn<Result> | undefined;\n    let options: AsyncOptions | undefined;\n\n    if (typeof executorOrOptions === 'function') {\n      executor = executorOrOptions;\n      options = maybeOptions;\n    } else {\n      options = executorOrOptions;\n    }\n\n    let resolve!: PromiseResolveFn<Result>;\n    let reject!: PromiseRejectFn;\n    super((res, rej) => {\n      // If an abort signal was passed initially in the promise, and it was in aborted state, it\n      // means that we have to prevent the executor from being called, just because there is no\n      // reason to do it.\n      //\n      // This signal will not be passed in case the promise was constructed via the \"then\" or\n      // \"finally\" methods, so we wouldn't have any related problems due to unhandled promise\n      // rejections.\n      options ||= {};\n      const { abortSignal } = options;\n      if (abortSignal && abortSignal.aborted) {\n        return rej(createAbortError(abortSignal.reason));\n      }\n\n      /* CLEANUP */\n      const [addCleanup, cleanup] = createCbCollector();\n      const withCleanup = <F extends (...args: any) => any>(fn: F): F => {\n        return ((...args) => {\n          cleanup();\n          return fn(...args);\n        }) as F;\n      };\n\n      // We are going to use our controller signal in the executor because we can control it.\n      // We can't say the same about the abort signal passed from above, we can't abort it by\n      // ourselves.\n      const controller = new AbortController();\n      const { signal: controllerSignal } = controller;\n\n      // The reject method should just abort the controller signal. In turn, it will reject\n      // the promise and notify the executor about the rejection.\n      reject = withCleanup(reason => {\n        controller.abort(reason);\n        rej(reason);\n      });\n      resolve = withCleanup(res) as PromiseResolveFn<Result>;\n\n      /* ABORT SIGNAL */\n      abortSignal && addCleanup(\n        addEventListener(abortSignal, 'abort', () => {\n          reject(createAbortError(abortSignal.reason));\n        }),\n      );\n\n      /* TIMEOUT */\n      const { timeout } = options;\n      if (timeout) {\n        const timeoutId = setTimeout(() => {\n          reject(new TypedError(ERR_TIMED_OUT, `Timeout reached: ${timeout}ms`));\n        }, timeout);\n\n        addCleanup(() => {\n          clearTimeout(timeoutId);\n        });\n      }\n\n      executor && executor(resolve, reject, controllerSignal);\n    });\n\n    this.reject = reject;\n  }\n\n  /**\n   * Cancels the promise execution.\n   */\n  cancel(): void {\n    this.reject(new TypedError(ERR_CANCELED));\n  }\n\n  /**\n   * @see Promise.catch\n   */\n  override catch<CatchResult = never>(\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\n  ): CancelablePromise<Result | CatchResult> {\n    return this.then(undefined, onRejected);\n  }\n\n  /**\n   * @see Promise.finally\n   */\n  override finally(onFinally?: Maybe<() => void>): CancelablePromise<Result> {\n    return assignReject(super.finally(onFinally) as CancelablePromise<Result>, this);\n  }\n\n  /**\n   * Rejects the promise.\n   */\n  reject!: PromiseRejectFn;\n\n  /**\n   * @see Promise.then\n   */\n  override then<A = Result, B = never>(\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\n  ): CancelablePromise<A | B> {\n    return assignReject(super.then(onFulfilled, onRejected) as CancelablePromise<A | B>, this);\n  }\n}\n","import type { AsyncOptions } from '@/async/types.js';\n\nimport { CancelablePromise } from './CancelablePromise.js';\nimport type {\n  PromiseExecutorFn,\n  PromiseOnRejectedFn,\n  PromiseOnFulfilledFn,\n  PromiseResolveFn,\n} from './types.js';\nimport type { Maybe } from '@/types/misc.js';\n\nfunction assignResolve<P extends EnhancedPromise<any>>(\n  childPromise: P,\n  parentPromise: EnhancedPromise<any>,\n): P {\n  childPromise.resolve = parentPromise.resolve;\n  return childPromise;\n}\n\nexport class EnhancedPromise<Result, Resolvable = Result> extends CancelablePromise<Result> {\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn<T>(\n    fn: (abortSignal: AbortSignal) => (T | PromiseLike<T>),\n    options?: AsyncOptions,\n  ): EnhancedPromise<T> {\n    return new EnhancedPromise<T>(\n      (res, rej, abortSignal) => {\n        return CancelablePromise.withFn(fn, { abortSignal }).then(res, rej);\n      },\n      options,\n    );\n  }\n\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Resolvable>(): EnhancedPromise<void, Resolvable>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Result, Resolvable = Result>(\n    value: Result,\n  ): EnhancedPromise<Result, Resolvable>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Result, Resolvable = Result>(\n    value?: Result,\n  ): EnhancedPromise<Result, Resolvable> {\n    return new EnhancedPromise(resolve => {\n      resolve(value as Result);\n    });\n  }\n\n  /**\n   * @see Promise.reject\n   */\n  static override reject<Result = never, Resolvable = Result>(\n    reason?: any,\n  ): EnhancedPromise<Result, Resolvable> {\n    return new EnhancedPromise((_, reject) => {\n      reject(reason);\n    });\n  }\n\n  /**\n   * Creates a new BetterPromise instance using only options.\n   * @param options - additional options.\n   */\n  constructor(options?: AsyncOptions);\n  /**\n   * Creates a new BetterPromise instance using specified executor and additional options.\n   * @param executor - promise executor.\n   * @param options - additional options.\n   */\n  constructor(executor?: PromiseExecutorFn<Result>, options?: AsyncOptions);\n  constructor(\n    executorOrOptions?: PromiseExecutorFn<Result> | AsyncOptions,\n    maybeOptions?: AsyncOptions,\n  ) {\n    let executor: PromiseExecutorFn<Result> | undefined;\n    let options: AsyncOptions | undefined;\n\n    if (typeof executorOrOptions === 'function') {\n      executor = executorOrOptions;\n      options = maybeOptions;\n    } else {\n      options = executorOrOptions;\n    }\n\n    let resolve!: PromiseResolveFn<Result>;\n    super((res, rej, signal) => {\n      resolve = res;\n      executor && executor(res, rej, signal);\n    }, options);\n\n    this.resolve = resolve as unknown as PromiseResolveFn<Resolvable>;\n  }\n\n  /**\n   * @see Promise.catch\n   */\n  override catch<CatchResult = never>(\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\n  ): EnhancedPromise<Result | CatchResult, Resolvable> {\n    return this.then(undefined, onRejected);\n  }\n\n  /**\n   * @see Promise.finally\n   */\n  override finally(onFinally?: Maybe<() => void>): EnhancedPromise<Result, Resolvable> {\n    return assignResolve(super.finally(onFinally) as EnhancedPromise<Result, Resolvable>, this);\n  }\n\n  /**\n   * Resolves the promise.\n   */\n  resolve!: PromiseResolveFn<Resolvable>;\n\n  /**\n   * @see Promise.then\n   */\n  override then<A = Result, B = never>(\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\n  ): EnhancedPromise<A | B, Resolvable> {\n    return assignResolve(super.then(onFulfilled, onRejected) as EnhancedPromise<A | B, Resolvable>, this);\n  }\n}","import { CancelablePromise } from '@/async/promises/CancelablePromise.js';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): CancelablePromise<void> {\n  return new CancelablePromise(r => {\n    setTimeout(r, duration);\n  }, { abortSignal });\n}\n","/**\n * Converts a passed storage key to the formatted state.\n * @param key - storage key.\n */\nfunction formatKey(key: string): string {\n  return `tapps/${key}`;\n}\n\n/**\n * Saves value in the storage.\n * @param key - storage key.\n * @param value - storage value.\n */\nexport function setStorageValue<T>(key: string, value: T): void {\n  sessionStorage.setItem(formatKey(key), JSON.stringify(value));\n}\n\n/**\n * Extracts value from the storage.\n * @param key - storage key.\n */\nexport function getStorageValue<R>(key: string): R | undefined {\n  const value = sessionStorage.getItem(formatKey(key));\n  try {\n    return value ? JSON.parse(value) as R : undefined;\n  } catch {\n  }\n}\n","/**\n * Converts value from camel case to kebab case.\n * @param value - value to convert.\n */\nexport function camelToKebab(value: string): string {\n  return value.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n\n/**\n * Converts value from camel case to snake case.\n * @param value - value to convert.\n */\nexport function camelToSnake(value: string): string {\n  return value.replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`);\n}\n\n/**\n * Converts value from snake case to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamel(value: string): string {\n  return value.replace(/_[a-z]/g, (m) => m[1].toUpperCase());\n}\n","/**\n * Message log level.\n */\nexport type LogLevel = 'log' | 'error';\n\nexport interface LoggerOptions {\n  bgColor?: string;\n  textColor?: string;\n  /**\n   * Should return true if log should be outputted.\n   * @default All logs will be outputted.\n   */\n  shouldLog?: boolean | (() => boolean);\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createLogger(scope: string, options?: LoggerOptions): [\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log: (...args: any[]) => void,\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error: (...args: any[]) => void,\n] {\n  options ||= {};\n  const {\n    textColor,\n    bgColor,\n    shouldLog = true,\n  } = options;\n\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  function print(level: LogLevel, ...args: any[]): void {\n    if (!shouldLog || (typeof shouldLog === 'function' && !shouldLog())) {\n      return;\n    }\n    const commonCss = 'font-weight:bold;padding:0 5px;border-radius:5px';\n    console[level](\n      `%c${\n        Intl\n          .DateTimeFormat('en-GB', {\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            fractionalSecondDigits: 3,\n            timeZone: 'UTC',\n          })\n          .format(new Date())\n      }%c / %c${scope}`,\n      `${commonCss};background-color: lightblue;color:black`,\n      '',\n      `${commonCss};${textColor ? `color:${textColor};` : ''}${bgColor ? `background-color:${bgColor}` : ''}`,\n      ...args,\n    );\n  }\n\n  return [\n    function log(...args: any[]): void {\n      print('log', ...args);\n    },\n    function error(...args: any[]): void {\n      print('error', ...args);\n    },\n  ];\n}","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n"],"names":["TypedError","type","messageOrOptions","cause","addEventListener","obj","listener","createCbCollector","cbs","callbacks","cb","isErrorOfType","value","createTypedErrorPredicate","ERR_ABORTED","ERR_CANCELED","ERR_TIMED_OUT","createAbortError","isTimeoutError","isAbortError","isCanceledError","assignReject","childPromise","parentPromise","CancelablePromise","executorOrOptions","maybeOptions","executor","options","resolve","reject","res","rej","abortSignal","addCleanup","cleanup","withCleanup","fn","args","controller","controllerSignal","reason","timeout","timeoutId","__publicField","signal","result","e","_","onRejected","onFinally","onFulfilled","assignResolve","EnhancedPromise","sleep","duration","r","formatKey","key","setStorageValue","getStorageValue","camelToKebab","match","camelToSnake","snakeToCamel","m","createLogger","scope","textColor","bgColor","shouldLog","print","level","commonCss","setCssVar","name","deleteCssVar"],"mappings":"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"}