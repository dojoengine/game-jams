'use strict';

var encoding = require('@turnkey/encoding');
var crypto$1 = require('@turnkey/crypto');
var buffer = require('buffer');
var bs58check = require('bs58check');
var hpkeJs = require('hpke-js');
var apiKeyStamper = require('@turnkey/api-key-stamper');

// createEmbeddedAPIKey creates an embedded API key encrypted to a target key (typically embedded within an iframe).
// This returns a bundle that can be decrypted by that target key, as well as the public key of the newly created API key.
const createEmbeddedAPIKey = async (targetPublicKey) => {
    const TURNKEY_HPKE_INFO = new TextEncoder().encode("turnkey_hpke");
    // 1: create new API key (to be encrypted to the targetPublicKey)
    const p256key = crypto$1.generateP256KeyPair();
    // 2: set up encryption
    const suite = new hpkeJs.CipherSuite({
        kem: hpkeJs.KemId.DhkemP256HkdfSha256,
        kdf: hpkeJs.KdfId.HkdfSha256,
        aead: hpkeJs.AeadId.Aes256Gcm,
    });
    // 3: import the targetPublicKey (i.e. passed in from the iframe)
    const targetKeyBytes = encoding.uint8ArrayFromHexString(targetPublicKey);
    let jwk;
    try {
        jwk = apiKeyStamper.pointDecode(targetKeyBytes);
    }
    catch (e) {
        // provide more context about the error that is being thrown
        throw new Error(`target public key is not a valid compressed public key: ${targetPublicKey}`);
    }
    const targetKey = await crypto.subtle.importKey("jwk", jwk, {
        name: "ECDH",
        namedCurve: "P-256",
    }, true, []);
    // 4: sender encrypts a message to the target key
    const sender = await suite.createSenderContext({
        recipientPublicKey: targetKey,
        info: TURNKEY_HPKE_INFO,
    });
    const ciphertext = await sender.seal(encoding.uint8ArrayFromHexString(p256key.privateKey), crypto$1.buildAdditionalAssociatedData(new Uint8Array(sender.enc), targetKeyBytes));
    const ciphertextUint8Array = new Uint8Array(ciphertext);
    // 5: assemble bundle
    const encappedKey = new Uint8Array(sender.enc);
    const compressedEncappedKey = crypto$1.compressRawPublicKey(encappedKey);
    const result = new Uint8Array(compressedEncappedKey.length + ciphertextUint8Array.length);
    result.set(compressedEncappedKey);
    result.set(ciphertextUint8Array, compressedEncappedKey.length);
    const base58encodedBundle = bs58check.encode(result);
    return {
        authBundle: base58encodedBundle,
        publicKey: p256key.publicKey,
    };
};
const generateRandomBuffer = () => {
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    return arr.buffer;
};
const base64UrlEncode = (challenge) => {
    return buffer.Buffer.from(challenge)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=/g, "");
};
Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));

exports.base64UrlEncode = base64UrlEncode;
exports.createEmbeddedAPIKey = createEmbeddedAPIKey;
exports.generateRandomBuffer = generateRandomBuffer;
//# sourceMappingURL=utils.js.map
