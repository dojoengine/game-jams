import * as P from 'micro-packed';
export type Bytes = Uint8Array;
export declare const PRECISION = 9;
export declare const Decimal: P.Coder<bigint, string>;
export declare const shortVec: P.CoderType<number>;
export declare const Message: P.CoderType<P.StructInput<{
    requiredSignatures: number;
    readSigned: number;
    readUnsigned: number;
    keys: string[];
    blockhash: string;
    instructions: P.StructInput<{
        programIdx: any;
        keys: any;
        data: any;
    }>[];
}>>;
export declare function validateAddress(address: string): void;
export type Account = {
    address: string;
    sign: boolean;
    write: boolean;
};
export type Instruction = {
    program: string;
    keys: Account[];
    data: Bytes;
};
export type Message = {
    feePayer: string;
    blockhash: string;
    instructions: Instruction[];
};
export declare const TransactionRaw: P.CoderType<P.StructInput<{
    signatures: Uint8Array[];
    msg: P.StructInput<{
        requiredSignatures: any;
        readSigned: any;
        readUnsigned: any;
        keys: any;
        blockhash: any;
        instructions: any;
    }>;
}>>;
export type Tx = {
    msg: Message;
    signatures: Record<string, Bytes>;
};
export declare const Transaction: P.CoderType<Tx>;
type KeyOpt = {
    sign: boolean;
    write: boolean;
    address?: string;
};
type Method<T, K extends Record<string, KeyOpt>> = {
    coder: P.BytesCoder<T>;
    keys: K;
};
export type TokenInfo = {
    symbol: string;
    decimals: number;
    price?: number;
};
export type TokenList = Record<string, TokenInfo>;
type MethodHint<T extends Method<any, any>> = T & {
    hint?: (o: MethodData<T>, t: TokenList) => string;
};
type FilterKeys<T> = Pick<T, {
    [K in keyof T]: T[K] extends never ? never : K;
}[keyof T]>;
type MethodData<T extends Method<any, any>> = P.UnwrapCoder<T['coder']> & FilterKeys<{
    [A in keyof T['keys']]: T['keys'][A]['address'] extends string ? never : string;
}>;
type Program<T extends Record<string, Method<any, any>>> = {
    [K in keyof T]: (data: MethodData<T[K]>) => Instruction;
};
export declare function defineProgram<T extends Record<string, MethodHint<any>>>(address: string, tagType: P.CoderType<number>, methods: T): Program<T>;
export declare function parseInstruction(instr: Instruction, tl: TokenList): any;
export declare const SYS_RECENT_BLOCKHASHES = "SysvarRecentB1ockHashes11111111111111111111";
export declare const SYS_RENT = "SysvarRent111111111111111111111111111111111";
export declare const SYS_PROGRAM = "11111111111111111111111111111111";
export declare const sys: Program<{
    createAccount: {
        coder: P.CoderType<P.StructInput<{
            lamports: bigint;
            space: bigint;
            owner: string;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            newAccount: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            source: string;
            newAccount: string;
            lamports: bigint;
            space: bigint;
            owner: string;
        }) => string;
    };
    assign: {
        coder: P.CoderType<P.StructInput<{
            owner: string;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            owner: string;
        }) => string;
    };
    transfer: {
        coder: P.CoderType<P.StructInput<{
            lamports: bigint;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            destination: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            lamports: bigint;
            source: string;
            destination: string;
        }) => string;
    };
    createAccountWithSeed: {
        coder: P.CoderType<P.StructInput<{
            base: string;
            seed: string;
            lamports: bigint;
            space: bigint;
            owner: string;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            newAccount: {
                sign: boolean;
                write: boolean;
            };
            base: {
                sign: boolean;
                write: boolean;
            };
        };
    };
    advanceNonce: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            nonceAccount: {
                sign: boolean;
                write: boolean;
            };
            _recent_bh: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            nonceAuthority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            nonceAccount: string;
            nonceAuthority: string;
        }) => string;
    };
    withdrawFromNonce: {
        coder: P.CoderType<P.StructInput<{
            lamports: bigint;
        }>>;
        keys: {
            nonceAccount: {
                sign: boolean;
                write: boolean;
            };
            destination: {
                sign: boolean;
                write: boolean;
            };
            _recent_bh: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            nonceAuthority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            lamports: bigint;
            destination: string;
            nonceAccount: string;
            nonceAuthority: string;
        }) => string;
    };
    initializeNonce: {
        coder: P.CoderType<P.StructInput<{
            nonceAuthority: string;
        }>>;
        keys: {
            nonceAccount: {
                sign: boolean;
                write: boolean;
            };
            _recent_bh: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
    };
    authorizeNonce: {
        coder: P.CoderType<P.StructInput<{
            newAuthorized: string;
        }>>;
        keys: {
            nonceAccount: {
                sign: boolean;
                write: boolean;
            };
            nonceAuthority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            nonceAccount: string;
            nonceAuthority: string;
            newAuthorized: string;
        }) => string;
    };
    allocate: {
        coder: P.CoderType<P.StructInput<{
            space: bigint;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
        };
    };
    allocateWithSeed: {
        coder: P.CoderType<P.StructInput<{
            base: string;
            seed: string;
            space: bigint;
            owner: string;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            base: {
                sign: boolean;
                write: boolean;
            };
        };
    };
    assignWithSeed: {
        coder: P.CoderType<P.StructInput<{
            base: string;
            seed: string;
            owner: string;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            base: {
                sign: boolean;
                write: boolean;
            };
        };
    };
    transferWithSeed: {
        coder: P.CoderType<P.StructInput<{
            lamports: bigint;
            sourceSeed: string;
            sourceOwner: string;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            sourceBase: {
                sign: boolean;
                write: boolean;
            };
            destination: {
                sign: boolean;
                write: boolean;
            };
        };
    };
}>;
export declare const TOKEN_PROGRAM = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
export declare const token: Program<{
    initializeMint: {
        coder: P.CoderType<P.StructInput<{
            decimals: number;
            mintAuthority: string;
            freezeAuthority: P.Option<string>;
        }>>;
        keys: {
            mint: {
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
    };
    initializeAccount: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            owner: string;
            account: string;
            mint: string;
        }, tl: TokenList) => string;
    };
    initializeMultisig: {
        coder: P.CoderType<P.StructInput<{
            m: number;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            m: number;
        }, _: TokenList) => string;
    };
    transfer: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            destination: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            source: string;
            destination: number;
            owner: string;
        }, _: TokenList) => string;
    };
    approve: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            delegate: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            account: string;
            delegate: number;
            owner: string;
        }, _: TokenList) => string;
    };
    revoke: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            account: string;
            owner: string;
        }, _: TokenList) => string;
    };
    setAuthority: {
        coder: P.CoderType<P.StructInput<{
            authorityType: string;
            newAuthority: P.Option<string>;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            currentAuthority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            newAuthority: string;
            account: string;
            currentAuthority: string;
            authorityType: string;
        }, _: TokenList) => string;
    };
    mintTo: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
        }>>;
        keys: {
            mint: {
                sign: boolean;
                write: boolean;
            };
            dest: {
                sign: boolean;
                write: boolean;
            };
            authority: {
                sign: boolean;
                write: boolean;
            };
        };
    };
    burn: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            account: string;
            mint: string;
            owner: string;
        }, _: TokenList) => string;
    };
    closeAccount: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            dest: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            dest: string;
            owner: string;
        }, _: TokenList) => string;
    };
    freezeAccount: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            authority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            authority: string;
            mint: string;
        }, _: TokenList) => string;
    };
    thawAccount: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            authority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            authority: string;
            mint: string;
        }, _: TokenList) => string;
    };
    transferChecked: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
            decimals: number;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            destination: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            source: string;
            destination: number;
            owner: string;
            decimals: number;
            mint: string;
        }, tl: TokenList) => string;
    };
    approveChecked: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
            decimals: number;
        }>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            delegate: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            source: string;
            delegate: number;
            owner: string;
            decimals: number;
            mint: string;
        }, tl: TokenList) => string;
    };
    mintToChecked: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
            decimals: number;
        }>>;
        keys: {
            mint: {
                sign: boolean;
                write: boolean;
            };
            dest: {
                sign: boolean;
                write: boolean;
            };
            authority: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            dest: string;
            authority: string;
            mint: string;
            decimals: number;
        }, tl: TokenList) => string;
    };
    burnChecked: {
        coder: P.CoderType<P.StructInput<{
            amount: bigint;
            decimals: number;
        }>>;
        keys: {
            mint: {
                sign: boolean;
                write: boolean;
            };
            account: {
                sign: boolean;
                write: boolean;
            };
            owner: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            amount: bigint;
            account: string;
            owner: string;
            mint: string;
            decimals: number;
        }, tl: TokenList) => string;
    };
    initializeAccount2: {
        coder: P.CoderType<P.StructInput<{
            owner: string;
        }>>;
        keys: {
            account: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            owner: string;
            account: string;
            mint: string;
        }, tl: TokenList) => string;
    };
    syncNative: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            nativeAccount: {
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            nativeAccount: string;
        }) => string;
    };
}>;
export declare const NonceAccount: P.CoderType<P.StructInput<{
    version: number;
    state: number;
    authority: string;
    nonce: string;
    lamportPerSignature: bigint;
}>>;
export declare function isOnCurve(bytes: Bytes | string): boolean;
export declare function programAddress(program: string, ...seeds: Bytes[]): string;
export declare const ASSOCIATED_TOKEN_PROGRAM = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
export declare const associatedToken: Program<{
    create: {
        coder: P.CoderType<P.StructInput<Record<string, any>>>;
        keys: {
            source: {
                sign: boolean;
                write: boolean;
            };
            account: {
                sign: boolean;
                write: boolean;
            };
            wallet: {
                sign: boolean;
                write: boolean;
            };
            mint: {
                sign: boolean;
                write: boolean;
            };
            _sys: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            _token: {
                address: string;
                sign: boolean;
                write: boolean;
            };
            _rent: {
                address: string;
                sign: boolean;
                write: boolean;
            };
        };
        hint: (o: {
            account: string;
            wallet: string;
            mint: string;
            source: string;
        }, tl: TokenList) => string;
    };
}>;
export declare function tokenAddress(mint: string, owner: string, allowOffCurveOwner?: boolean): string;
export declare const COMMON_TOKENS: TokenList;
export declare function tokenFromSymbol(symbol: string, tokens?: TokenList): {
    contract: string;
    symbol: string;
    decimals: number;
    price?: number;
} | undefined;
export declare const TokenAccount: P.CoderType<P.StructInput<{
    mint: string;
    owner: string;
    amount: bigint;
    delegate: P.Option<string>;
    state: string;
    isNative: P.Option<bigint>;
    delegateAmount: bigint;
    closeAuthority: P.Option<string>;
}>>;
export declare const swapProgram = "SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8";
type TxData = Bytes | string;
export declare function verifyTx(tx: TxData): void;
export declare function getPublicKey(privateKey: Bytes): Uint8Array;
export declare function getAddress(privateKey: Bytes): string;
export declare function getAddressFromPublicKey(publicKey: Bytes): string;
type PrivateKeyFormat = 'base58' | 'hex' | 'array';
export declare function formatPrivate(privateKey: Bytes, format?: PrivateKeyFormat): string | number[];
export declare function createTxComplex(address: string, instructions: Instruction[], blockhash: string): string;
export declare function createTx(from: string, to: string, amount: string, _fee: bigint, blockhash: string): string;
export declare function signTx(privateKey: Bytes, data: TxData): [string, string];
export {};
//# sourceMappingURL=index.d.ts.map