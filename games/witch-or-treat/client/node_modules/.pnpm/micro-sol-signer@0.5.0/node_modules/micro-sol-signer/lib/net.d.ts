import * as sol from './index.js';
export declare const URL = "https://api.mainnet-beta.solana.com";
export declare const TESTNET_URL = "https://api.devnet.solana.com";
export type JsonrpcInterface = {
    call: (method: string, ...args: any[]) => Promise<any>;
};
export type AccountInfo = {
    lamports: bigint;
    owner: string;
    rentEpoch: number;
    data: Uint8Array;
    exec: boolean;
};
export type RecentBlockhash = {
    blockhash: string;
    feeCalculator: {
        lamportsPerSignature: number;
    };
};
export type TokenBalance = Partial<sol.TokenInfo> & {
    contract: string;
    decimals: number;
    balance: bigint;
    tokenAccount: string;
};
export type Unspent = {
    symbol: 'SOL';
    decimals: number;
    balance: bigint;
    blockhash: string;
    active: boolean;
};
export type Transfer = {
    from?: string;
    to?: string;
    value: bigint;
};
export type TokenTransfer = Transfer & {
    tokenAccount?: string;
    contract: string;
    owner?: string;
    decimals: number;
};
export type TxTransfers = {
    hash: string;
    timestamp?: number;
    block?: number;
    transfers: Transfer[];
    tokenTransfers: TokenTransfer[];
    reverted: boolean;
    info: {
        raw: string;
        log: string[];
        fee: bigint;
    };
};
export declare class ArchiveNodeProvider {
    private rpc;
    constructor(rpc: JsonrpcInterface);
    private base64Call;
    private jsonCall;
    /**
     * Requests airdrop SOL for tests (testnet)
     * @param to - Solana address
     * @param amount - Lamports amount
     * @returns
     */
    airdrop(to: string, amount: bigint): Promise<any>;
    /**
     * Returns all information associated with the account of provided address
     * @param address
     */
    accountInfo(address: string): Promise<AccountInfo | undefined>;
    /**
     * Checks if account is valid token account (required to send tokens)
     * @param mint token contract
     * @param address address to check
     * @param owner check if owner of token account is specific address
     * @returns true if valid
     */
    isValidTokenAccount(mint: string, address: string, owner?: string): Promise<boolean>;
    /**
     * Returns minimum balance required to make account rent exempt.
     * @param size - Account data length (bytes)
     * @returns
     */
    minBalance(size: number): Promise<any>;
    /**
     * Recent blockhash and fee information
     */
    recentBlockHash(): Promise<RecentBlockhash>;
    height(): Promise<number>;
    /**
     * Latest fee (lamports per signature)
     */
    fee(): Promise<bigint>;
    /**
     * Returns account balance and latest blockhash (required to create new transaction)
     * @param address - Solana address
     */
    unspent(address: string): Promise<Unspent>;
    /**
     * Returns information about token accounts for address
     * @param address - Solana address
     * @param tokensInfo - Tokens information (sol.COMMON_TOKENS), Record<mintAddress, sol.TokenInfo>
     * @returns
     */
    tokenBalances(address: string, tokensInfo: Record<string, sol.TokenInfo>): Promise<TokenBalance[]>;
    private txInfo;
    private addressTransactions;
    /**
     * Returns all transaction information for address.
     * @param address - Solana address
     */
    transfers(address: string, perRequest?: number): Promise<TxTransfers[]>;
    sendTx(tx: string): Promise<any>;
}
export type Balances = {
    balances: Record<string, bigint>;
    tokenBalances: Record<string, Record<string, bigint>>;
};
/**
 * Calculates balances at specific point in time after tx.
 * Also, useful as a sanity check in case we've missed something.
 * Info from multiple addresses can be merged (sort everything first).
 */
export declare function calcTransfersDiff(transfers: TxTransfers[]): (TxTransfers & Balances)[];
//# sourceMappingURL=net.d.ts.map