{"version":3,"sources":["../src/client.ts","../src/generated/google/protobuf/empty.ts","../src/generated/world.ts","../src/generated/types.ts","../src/generated/schema.ts","../src/generated/world.client.ts","../src/mappings/query.ts","../src/mappings/types.ts","../src/mappings/effect-schema/transformers.ts","../src/mappings/effect-schema/entity-schemas.ts","../src/mappings/effect-schema/base-schemas.ts","../src/mappings/effect-schema/model-schemas.ts","../src/torii-client.ts"],"sourcesContent":["import { GrpcWebFetchTransport } from \"@protobuf-ts/grpcweb-transport\";\nimport { WorldClient } from \"./generated/world.client\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n\nexport interface DojoGrpcClientConfig {\n    url: string;\n    options?: RpcOptions;\n}\n\nexport class DojoGrpcClient {\n    private transport: GrpcWebFetchTransport;\n    public worldClient: WorldClient;\n\n    constructor(config: DojoGrpcClientConfig) {\n        this.transport = new GrpcWebFetchTransport({\n            baseUrl: config.url,\n            format: \"binary\",\n        });\n\n        this.worldClient = new WorldClient(this.transport);\n    }\n\n    destroy() {\n        // Clean up any resources if needed\n    }\n}\n\nexport function createDojoGrpcClient(\n    config: DojoGrpcClientConfig\n): DojoGrpcClient {\n    return new DojoGrpcClient(config);\n}\n","// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic\n// @generated from protobuf file \"google/protobuf/empty.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * A generic empty message that you can re-use to avoid defining duplicated\n * empty messages in your APIs. A typical example is to use it as the request\n * or the response type of an API method. For instance:\n *\n *     service Foo {\n *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n *     }\n *\n *\n * @generated from protobuf message google.protobuf.Empty\n */\nexport interface Empty {\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Empty$Type extends MessageType<Empty> {\n    constructor() {\n        super(\"google.protobuf.Empty\", []);\n    }\n    create(value?: PartialMessage<Empty>): Empty {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<Empty>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Empty\n */\nexport const Empty = new Empty$Type();\n","// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic\n// @generated from protobuf file \"world.proto\" (package \"world\", syntax proto3)\n// tslint:disable\nimport { Empty } from \"./google/protobuf/empty\";\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { KeysClause } from \"./types\";\nimport { Event } from \"./types\";\nimport { EventQuery } from \"./types\";\nimport { Query } from \"./types\";\nimport { Entity } from \"./types\";\nimport { Clause } from \"./types\";\nimport { World as World$ } from \"./types\";\nimport { TokenContract } from \"./types\";\nimport { TransactionQuery } from \"./types\";\nimport { TokenBalanceQuery } from \"./types\";\nimport { Token } from \"./types\";\nimport { TokenQuery } from \"./types\";\nimport { TokenBalance } from \"./types\";\nimport { Contract } from \"./types\";\nimport { ContractQuery } from \"./types\";\nimport { Controller } from \"./types\";\nimport { ControllerQuery } from \"./types\";\nimport { Transaction } from \"./types\";\nimport { TransactionFilter } from \"./types\";\n/**\n * @generated from protobuf message world.SubscribeTransactionsRequest\n */\nexport interface SubscribeTransactionsRequest {\n    /**\n     * @generated from protobuf field: types.TransactionFilter filter = 1\n     */\n    filter?: TransactionFilter;\n}\n/**\n * @generated from protobuf message world.SubscribeTransactionsResponse\n */\nexport interface SubscribeTransactionsResponse {\n    /**\n     * @generated from protobuf field: types.Transaction transaction = 1\n     */\n    transaction?: Transaction;\n}\n/**\n * @generated from protobuf message world.RetrieveControllersRequest\n */\nexport interface RetrieveControllersRequest {\n    /**\n     * @generated from protobuf field: types.ControllerQuery query = 1\n     */\n    query?: ControllerQuery;\n}\n/**\n * @generated from protobuf message world.RetrieveControllersResponse\n */\nexport interface RetrieveControllersResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.Controller controllers = 2\n     */\n    controllers: Controller[];\n}\n/**\n * @generated from protobuf message world.RetrieveContractsRequest\n */\nexport interface RetrieveContractsRequest {\n    /**\n     * @generated from protobuf field: types.ContractQuery query = 1\n     */\n    query?: ContractQuery;\n}\n/**\n * @generated from protobuf message world.RetrieveContractsResponse\n */\nexport interface RetrieveContractsResponse {\n    /**\n     * @generated from protobuf field: repeated types.Contract contracts = 1\n     */\n    contracts: Contract[];\n}\n/**\n * A request to update a token balance subscription\n *\n * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest\n */\nexport interface UpdateTokenBalancesSubscriptionRequest {\n    /**\n     * The subscription ID\n     *\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * The list of contract addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 2\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of account addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes account_addresses = 3\n     */\n    account_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 4\n     */\n    token_ids: Uint8Array[];\n}\n/**\n * A response containing token balances\n *\n * @generated from protobuf message world.SubscribeTokenBalancesResponse\n */\nexport interface SubscribeTokenBalancesResponse {\n    /**\n     * The subscription ID\n     *\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * The token balance\n     *\n     * @generated from protobuf field: types.TokenBalance balance = 2\n     */\n    balance?: TokenBalance;\n}\n/**\n * A request to retrieve tokens\n *\n * @generated from protobuf message world.RetrieveTokensRequest\n */\nexport interface RetrieveTokensRequest {\n    /**\n     * @generated from protobuf field: types.TokenQuery query = 1\n     */\n    query?: TokenQuery;\n}\n/**\n * A request to subscribe to token updates\n *\n * @generated from protobuf message world.SubscribeTokensRequest\n */\nexport interface SubscribeTokensRequest {\n    /**\n     * The list of contract addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 1\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 2\n     */\n    token_ids: Uint8Array[];\n}\n/**\n * A response containing tokens\n *\n * @generated from protobuf message world.RetrieveTokensResponse\n */\nexport interface RetrieveTokensResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.Token tokens = 2\n     */\n    tokens: Token[];\n}\n/**\n * A response containing token updates\n *\n * @generated from protobuf message world.SubscribeTokensResponse\n */\nexport interface SubscribeTokensResponse {\n    /**\n     * The subscription ID\n     *\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * The token\n     *\n     * @generated from protobuf field: types.Token token = 2\n     */\n    token?: Token;\n}\n/**\n * A request to update a token subscription\n *\n * @generated from protobuf message world.UpdateTokenSubscriptionRequest\n */\nexport interface UpdateTokenSubscriptionRequest {\n    /**\n     * The subscription ID\n     *\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * The list of contract addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 2\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 3\n     */\n    token_ids: Uint8Array[];\n}\n/**\n * A request to retrieve token balances\n *\n * @generated from protobuf message world.RetrieveTokenBalancesRequest\n */\nexport interface RetrieveTokenBalancesRequest {\n    /**\n     * @generated from protobuf field: types.TokenBalanceQuery query = 1\n     */\n    query?: TokenBalanceQuery;\n}\n/**\n * A request to subscribe to token balance updates\n *\n * @generated from protobuf message world.SubscribeTokenBalancesRequest\n */\nexport interface SubscribeTokenBalancesRequest {\n    /**\n     * The account addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes account_addresses = 1\n     */\n    account_addresses: Uint8Array[];\n    /**\n     * The list of token contract addresses to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 2\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to subscribe to\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 3\n     */\n    token_ids: Uint8Array[];\n}\n/**\n * A response containing token balances\n *\n * @generated from protobuf message world.RetrieveTokenBalancesResponse\n */\nexport interface RetrieveTokenBalancesResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.TokenBalance balances = 2\n     */\n    balances: TokenBalance[];\n}\n/**\n * A request to retrieve transactions\n *\n * @generated from protobuf message world.RetrieveTransactionsRequest\n */\nexport interface RetrieveTransactionsRequest {\n    /**\n     * @generated from protobuf field: types.TransactionQuery query = 1\n     */\n    query?: TransactionQuery;\n}\n/**\n * A response containing transactions\n *\n * @generated from protobuf message world.RetrieveTransactionsResponse\n */\nexport interface RetrieveTransactionsResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.Transaction transactions = 2\n     */\n    transactions: Transaction[];\n}\n/**\n * A request to retrieve token contracts\n *\n * @generated from protobuf message world.RetrieveTokenContractsRequest\n */\nexport interface RetrieveTokenContractsRequest {\n    /**\n     * @generated from protobuf field: types.TokenBalanceQuery query = 1\n     */\n    query?: TokenBalanceQuery;\n}\n/**\n * A response containing token balances\n *\n * @generated from protobuf message world.RetrieveTokenContractsResponse\n */\nexport interface RetrieveTokenContractsResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.TokenContract tokens = 2\n     */\n    tokens: TokenContract[];\n}\n/**\n * A request to subscribe to contract updates.\n *\n * @generated from protobuf message world.SubscribeContractsRequest\n */\nexport interface SubscribeContractsRequest {\n    /**\n     * @generated from protobuf field: types.ContractQuery query = 1\n     */\n    query?: ContractQuery;\n}\n/**\n * A response containing contract updates.\n *\n * @generated from protobuf message world.SubscribeContractsResponse\n */\nexport interface SubscribeContractsResponse {\n    /**\n     * @generated from protobuf field: types.Contract contract = 1\n     */\n    contract?: Contract;\n}\n/**\n * A request to retrieve metadata for a specific world ID.\n *\n * @generated from protobuf message world.WorldMetadataRequest\n */\nexport interface WorldMetadataRequest {\n}\n/**\n * The metadata response contains addresses and class hashes for the world.\n *\n * @generated from protobuf message world.WorldMetadataResponse\n */\nexport interface WorldMetadataResponse {\n    /**\n     * @generated from protobuf field: types.World world = 1\n     */\n    world?: World$;\n}\n/**\n * @generated from protobuf message world.SubscribeEntitiesRequest\n */\nexport interface SubscribeEntitiesRequest {\n    /**\n     * @generated from protobuf field: types.Clause clause = 1\n     */\n    clause?: Clause;\n}\n/**\n * @generated from protobuf message world.SubscribeEventMessagesRequest\n */\nexport interface SubscribeEventMessagesRequest {\n    /**\n     * @generated from protobuf field: types.Clause clause = 1\n     */\n    clause?: Clause;\n}\n/**\n * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest\n */\nexport interface UpdateEntitiesSubscriptionRequest {\n    /**\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * @generated from protobuf field: types.Clause clause = 2\n     */\n    clause?: Clause;\n}\n/**\n * @generated from protobuf message world.UpdateEventMessagesSubscriptionRequest\n */\nexport interface UpdateEventMessagesSubscriptionRequest {\n    /**\n     * @generated from protobuf field: uint64 subscription_id = 1\n     */\n    subscription_id: bigint;\n    /**\n     * @generated from protobuf field: types.Clause clause = 2\n     */\n    clause?: Clause;\n}\n/**\n * @generated from protobuf message world.SubscribeEntityResponse\n */\nexport interface SubscribeEntityResponse {\n    /**\n     * @generated from protobuf field: types.Entity entity = 1\n     */\n    entity?: Entity;\n    /**\n     * @generated from protobuf field: uint64 subscription_id = 2\n     */\n    subscription_id: bigint;\n}\n/**\n * @generated from protobuf message world.RetrieveEntitiesRequest\n */\nexport interface RetrieveEntitiesRequest {\n    /**\n     * The entities to retrieve\n     *\n     * @generated from protobuf field: types.Query query = 1\n     */\n    query?: Query;\n}\n/**\n * @generated from protobuf message world.RetrieveEventMessagesRequest\n */\nexport interface RetrieveEventMessagesRequest {\n    /**\n     * The event messages to retrieve\n     *\n     * @generated from protobuf field: types.Query query = 1\n     */\n    query?: Query;\n}\n/**\n * @generated from protobuf message world.RetrieveEntitiesResponse\n */\nexport interface RetrieveEntitiesResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.Entity entities = 2\n     */\n    entities: Entity[];\n}\n/**\n * @generated from protobuf message world.RetrieveEventsRequest\n */\nexport interface RetrieveEventsRequest {\n    /**\n     * The events to retrieve\n     *\n     * @generated from protobuf field: types.EventQuery query = 1\n     */\n    query?: EventQuery;\n}\n/**\n * @generated from protobuf message world.RetrieveEventsResponse\n */\nexport interface RetrieveEventsResponse {\n    /**\n     * @generated from protobuf field: string next_cursor = 1\n     */\n    next_cursor: string;\n    /**\n     * @generated from protobuf field: repeated types.Event events = 2\n     */\n    events: Event[];\n}\n/**\n * @generated from protobuf message world.SubscribeEventsRequest\n */\nexport interface SubscribeEventsRequest {\n    /**\n     * @generated from protobuf field: repeated types.KeysClause keys = 1\n     */\n    keys: KeysClause[];\n}\n/**\n * @generated from protobuf message world.SubscribeEventsResponse\n */\nexport interface SubscribeEventsResponse {\n    /**\n     * @generated from protobuf field: types.Event event = 1\n     */\n    event?: Event;\n}\n/**\n * @generated from protobuf message world.PublishMessageRequest\n */\nexport interface PublishMessageRequest {\n    /**\n     * @generated from protobuf field: repeated bytes signature = 1\n     */\n    signature: Uint8Array[];\n    /**\n     * @generated from protobuf field: string message = 2\n     */\n    message: string;\n}\n/**\n * @generated from protobuf message world.PublishMessageResponse\n */\nexport interface PublishMessageResponse {\n    /**\n     * @generated from protobuf field: bytes entity_id = 1\n     */\n    entity_id: Uint8Array;\n}\n/**\n * @generated from protobuf message world.PublishMessageBatchRequest\n */\nexport interface PublishMessageBatchRequest {\n    /**\n     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1\n     */\n    messages: PublishMessageRequest[];\n}\n/**\n * @generated from protobuf message world.PublishMessageBatchResponse\n */\nexport interface PublishMessageBatchResponse {\n    /**\n     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1\n     */\n    responses: PublishMessageResponse[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {\n    constructor() {\n        super(\"world.SubscribeTransactionsRequest\", [\n            { no: 1, name: \"filter\", kind: \"message\", T: () => TransactionFilter }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTransactionsRequest>): SubscribeTransactionsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTransactionsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsRequest): SubscribeTransactionsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TransactionFilter filter */ 1:\n                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TransactionFilter filter = 1; */\n        if (message.filter)\n            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTransactionsRequest\n */\nexport const SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {\n    constructor() {\n        super(\"world.SubscribeTransactionsResponse\", [\n            { no: 1, name: \"transaction\", kind: \"message\", T: () => Transaction }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTransactionsResponse>): SubscribeTransactionsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTransactionsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsResponse): SubscribeTransactionsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Transaction transaction */ 1:\n                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Transaction transaction = 1; */\n        if (message.transaction)\n            Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTransactionsResponse\n */\nexport const SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {\n    constructor() {\n        super(\"world.RetrieveControllersRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => ControllerQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveControllersRequest>): RetrieveControllersRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveControllersRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersRequest): RetrieveControllersRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.ControllerQuery query */ 1:\n                    message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveControllersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.ControllerQuery query = 1; */\n        if (message.query)\n            ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveControllersRequest\n */\nexport const RetrieveControllersRequest = new RetrieveControllersRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {\n    constructor() {\n        super(\"world.RetrieveControllersResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"controllers\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Controller }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveControllersResponse>): RetrieveControllersResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.controllers = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveControllersResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersResponse): RetrieveControllersResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.Controller controllers */ 2:\n                    message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveControllersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.Controller controllers = 2; */\n        for (let i = 0; i < message.controllers.length; i++)\n            Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveControllersResponse\n */\nexport const RetrieveControllersResponse = new RetrieveControllersResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveContractsRequest$Type extends MessageType<RetrieveContractsRequest> {\n    constructor() {\n        super(\"world.RetrieveContractsRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => ContractQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveContractsRequest>): RetrieveContractsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveContractsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsRequest): RetrieveContractsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.ContractQuery query */ 1:\n                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.ContractQuery query = 1; */\n        if (message.query)\n            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveContractsRequest\n */\nexport const RetrieveContractsRequest = new RetrieveContractsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveContractsResponse$Type extends MessageType<RetrieveContractsResponse> {\n    constructor() {\n        super(\"world.RetrieveContractsResponse\", [\n            { no: 1, name: \"contracts\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Contract }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveContractsResponse>): RetrieveContractsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contracts = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveContractsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsResponse): RetrieveContractsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated types.Contract contracts */ 1:\n                    message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated types.Contract contracts = 1; */\n        for (let i = 0; i < message.contracts.length; i++)\n            Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveContractsResponse\n */\nexport const RetrieveContractsResponse = new RetrieveContractsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {\n    constructor() {\n        super(\"world.UpdateTokenBalancesSubscriptionRequest\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"account_addresses\", kind: \"scalar\", localName: \"account_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>): UpdateTokenBalancesSubscriptionRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        message.contract_addresses = [];\n        message.account_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<UpdateTokenBalancesSubscriptionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenBalancesSubscriptionRequest): UpdateTokenBalancesSubscriptionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* repeated bytes contract_addresses */ 2:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes account_addresses */ 3:\n                    message.account_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 4:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpdateTokenBalancesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* repeated bytes contract_addresses = 2; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes account_addresses = 3; */\n        for (let i = 0; i < message.account_addresses.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);\n        /* repeated bytes token_ids = 4; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest\n */\nexport const UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {\n    constructor() {\n        super(\"world.SubscribeTokenBalancesResponse\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"balance\", kind: \"message\", T: () => TokenBalance }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTokenBalancesResponse>): SubscribeTokenBalancesResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTokenBalancesResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesResponse): SubscribeTokenBalancesResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* types.TokenBalance balance */ 2:\n                    message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* types.TokenBalance balance = 2; */\n        if (message.balance)\n            TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse\n */\nexport const SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {\n    constructor() {\n        super(\"world.RetrieveTokensRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => TokenQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokensRequest>): RetrieveTokensRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokensRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensRequest): RetrieveTokensRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TokenQuery query */ 1:\n                    message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TokenQuery query = 1; */\n        if (message.query)\n            TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokensRequest\n */\nexport const RetrieveTokensRequest = new RetrieveTokensRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {\n    constructor() {\n        super(\"world.SubscribeTokensRequest\", [\n            { no: 1, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTokensRequest>): SubscribeTokensRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTokensRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensRequest): SubscribeTokensRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes contract_addresses */ 1:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 2:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes contract_addresses = 1; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes token_ids = 2; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTokensRequest\n */\nexport const SubscribeTokensRequest = new SubscribeTokensRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {\n    constructor() {\n        super(\"world.RetrieveTokensResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"tokens\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Token }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokensResponse>): RetrieveTokensResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.tokens = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokensResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensResponse): RetrieveTokensResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.Token tokens */ 2:\n                    message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.Token tokens = 2; */\n        for (let i = 0; i < message.tokens.length; i++)\n            Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokensResponse\n */\nexport const RetrieveTokensResponse = new RetrieveTokensResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {\n    constructor() {\n        super(\"world.SubscribeTokensResponse\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"token\", kind: \"message\", T: () => Token }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTokensResponse>): SubscribeTokensResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTokensResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensResponse): SubscribeTokensResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* types.Token token */ 2:\n                    message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* types.Token token = 2; */\n        if (message.token)\n            Token.internalBinaryWrite(message.token, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTokensResponse\n */\nexport const SubscribeTokensResponse = new SubscribeTokensResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {\n    constructor() {\n        super(\"world.UpdateTokenSubscriptionRequest\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<UpdateTokenSubscriptionRequest>): UpdateTokenSubscriptionRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        message.contract_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<UpdateTokenSubscriptionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenSubscriptionRequest): UpdateTokenSubscriptionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* repeated bytes contract_addresses */ 2:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 3:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpdateTokenSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* repeated bytes contract_addresses = 2; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes token_ids = 3; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest\n */\nexport const UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {\n    constructor() {\n        super(\"world.RetrieveTokenBalancesRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => TokenBalanceQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokenBalancesRequest>): RetrieveTokenBalancesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokenBalancesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesRequest): RetrieveTokenBalancesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TokenBalanceQuery query */ 1:\n                    message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TokenBalanceQuery query = 1; */\n        if (message.query)\n            TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest\n */\nexport const RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {\n    constructor() {\n        super(\"world.SubscribeTokenBalancesRequest\", [\n            { no: 1, name: \"account_addresses\", kind: \"scalar\", localName: \"account_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeTokenBalancesRequest>): SubscribeTokenBalancesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.account_addresses = [];\n        message.contract_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeTokenBalancesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesRequest): SubscribeTokenBalancesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes account_addresses */ 1:\n                    message.account_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes contract_addresses */ 2:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 3:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes account_addresses = 1; */\n        for (let i = 0; i < message.account_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);\n        /* repeated bytes contract_addresses = 2; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes token_ids = 3; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest\n */\nexport const SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {\n    constructor() {\n        super(\"world.RetrieveTokenBalancesResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"balances\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenBalance }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokenBalancesResponse>): RetrieveTokenBalancesResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.balances = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokenBalancesResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesResponse): RetrieveTokenBalancesResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.TokenBalance balances */ 2:\n                    message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.TokenBalance balances = 2; */\n        for (let i = 0; i < message.balances.length; i++)\n            TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse\n */\nexport const RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {\n    constructor() {\n        super(\"world.RetrieveTransactionsRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => TransactionQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTransactionsRequest>): RetrieveTransactionsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTransactionsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsRequest): RetrieveTransactionsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TransactionQuery query */ 1:\n                    message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TransactionQuery query = 1; */\n        if (message.query)\n            TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTransactionsRequest\n */\nexport const RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {\n    constructor() {\n        super(\"world.RetrieveTransactionsResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"transactions\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Transaction }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTransactionsResponse>): RetrieveTransactionsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.transactions = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTransactionsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsResponse): RetrieveTransactionsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.Transaction transactions */ 2:\n                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.Transaction transactions = 2; */\n        for (let i = 0; i < message.transactions.length; i++)\n            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTransactionsResponse\n */\nexport const RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokenContractsRequest$Type extends MessageType<RetrieveTokenContractsRequest> {\n    constructor() {\n        super(\"world.RetrieveTokenContractsRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => TokenBalanceQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokenContractsRequest>): RetrieveTokenContractsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokenContractsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsRequest): RetrieveTokenContractsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TokenBalanceQuery query */ 1:\n                    message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokenContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TokenBalanceQuery query = 1; */\n        if (message.query)\n            TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokenContractsRequest\n */\nexport const RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveTokenContractsResponse$Type extends MessageType<RetrieveTokenContractsResponse> {\n    constructor() {\n        super(\"world.RetrieveTokenContractsResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"tokens\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenContract }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveTokenContractsResponse>): RetrieveTokenContractsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.tokens = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveTokenContractsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsResponse): RetrieveTokenContractsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.TokenContract tokens */ 2:\n                    message.tokens.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveTokenContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.TokenContract tokens = 2; */\n        for (let i = 0; i < message.tokens.length; i++)\n            TokenContract.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveTokenContractsResponse\n */\nexport const RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeContractsRequest$Type extends MessageType<SubscribeContractsRequest> {\n    constructor() {\n        super(\"world.SubscribeContractsRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => ContractQuery }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeContractsRequest>): SubscribeContractsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeContractsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsRequest): SubscribeContractsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.ContractQuery query */ 1:\n                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.ContractQuery query = 1; */\n        if (message.query)\n            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeContractsRequest\n */\nexport const SubscribeContractsRequest = new SubscribeContractsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeContractsResponse$Type extends MessageType<SubscribeContractsResponse> {\n    constructor() {\n        super(\"world.SubscribeContractsResponse\", [\n            { no: 1, name: \"contract\", kind: \"message\", T: () => Contract }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeContractsResponse>): SubscribeContractsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeContractsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsResponse): SubscribeContractsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Contract contract */ 1:\n                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Contract contract = 1; */\n        if (message.contract)\n            Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeContractsResponse\n */\nexport const SubscribeContractsResponse = new SubscribeContractsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass WorldMetadataRequest$Type extends MessageType<WorldMetadataRequest> {\n    constructor() {\n        super(\"world.WorldMetadataRequest\", []);\n    }\n    create(value?: PartialMessage<WorldMetadataRequest>): WorldMetadataRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<WorldMetadataRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataRequest): WorldMetadataRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: WorldMetadataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.WorldMetadataRequest\n */\nexport const WorldMetadataRequest = new WorldMetadataRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass WorldMetadataResponse$Type extends MessageType<WorldMetadataResponse> {\n    constructor() {\n        super(\"world.WorldMetadataResponse\", [\n            { no: 1, name: \"world\", kind: \"message\", T: () => World$ }\n        ]);\n    }\n    create(value?: PartialMessage<WorldMetadataResponse>): WorldMetadataResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<WorldMetadataResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataResponse): WorldMetadataResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.World world */ 1:\n                    message.world = World$.internalBinaryRead(reader, reader.uint32(), options, message.world);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: WorldMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.World world = 1; */\n        if (message.world)\n            World$.internalBinaryWrite(message.world, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.WorldMetadataResponse\n */\nexport const WorldMetadataResponse = new WorldMetadataResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {\n    constructor() {\n        super(\"world.SubscribeEntitiesRequest\", [\n            { no: 1, name: \"clause\", kind: \"message\", T: () => Clause }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeEntitiesRequest>): SubscribeEntitiesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeEntitiesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntitiesRequest): SubscribeEntitiesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Clause clause */ 1:\n                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Clause clause = 1; */\n        if (message.clause)\n            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeEntitiesRequest\n */\nexport const SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeEventMessagesRequest$Type extends MessageType<SubscribeEventMessagesRequest> {\n    constructor() {\n        super(\"world.SubscribeEventMessagesRequest\", [\n            { no: 1, name: \"clause\", kind: \"message\", T: () => Clause }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeEventMessagesRequest>): SubscribeEventMessagesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeEventMessagesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventMessagesRequest): SubscribeEventMessagesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Clause clause */ 1:\n                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Clause clause = 1; */\n        if (message.clause)\n            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeEventMessagesRequest\n */\nexport const SubscribeEventMessagesRequest = new SubscribeEventMessagesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {\n    constructor() {\n        super(\"world.UpdateEntitiesSubscriptionRequest\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"clause\", kind: \"message\", T: () => Clause }\n        ]);\n    }\n    create(value?: PartialMessage<UpdateEntitiesSubscriptionRequest>): UpdateEntitiesSubscriptionRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<UpdateEntitiesSubscriptionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEntitiesSubscriptionRequest): UpdateEntitiesSubscriptionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* types.Clause clause */ 2:\n                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpdateEntitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* types.Clause clause = 2; */\n        if (message.clause)\n            Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest\n */\nexport const UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateEventMessagesSubscriptionRequest$Type extends MessageType<UpdateEventMessagesSubscriptionRequest> {\n    constructor() {\n        super(\"world.UpdateEventMessagesSubscriptionRequest\", [\n            { no: 1, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"clause\", kind: \"message\", T: () => Clause }\n        ]);\n    }\n    create(value?: PartialMessage<UpdateEventMessagesSubscriptionRequest>): UpdateEventMessagesSubscriptionRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<UpdateEventMessagesSubscriptionRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEventMessagesSubscriptionRequest): UpdateEventMessagesSubscriptionRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 subscription_id */ 1:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                case /* types.Clause clause */ 2:\n                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: UpdateEventMessagesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 subscription_id = 1; */\n        if (message.subscription_id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.subscription_id);\n        /* types.Clause clause = 2; */\n        if (message.clause)\n            Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.UpdateEventMessagesSubscriptionRequest\n */\nexport const UpdateEventMessagesSubscriptionRequest = new UpdateEventMessagesSubscriptionRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {\n    constructor() {\n        super(\"world.SubscribeEntityResponse\", [\n            { no: 1, name: \"entity\", kind: \"message\", T: () => Entity },\n            { no: 2, name: \"subscription_id\", kind: \"scalar\", localName: \"subscription_id\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeEntityResponse>): SubscribeEntityResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.subscription_id = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeEntityResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntityResponse): SubscribeEntityResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Entity entity */ 1:\n                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);\n                    break;\n                case /* uint64 subscription_id */ 2:\n                    message.subscription_id = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Entity entity = 1; */\n        if (message.entity)\n            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* uint64 subscription_id = 2; */\n        if (message.subscription_id !== 0n)\n            writer.tag(2, WireType.Varint).uint64(message.subscription_id);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeEntityResponse\n */\nexport const SubscribeEntityResponse = new SubscribeEntityResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {\n    constructor() {\n        super(\"world.RetrieveEntitiesRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => Query }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveEntitiesRequest>): RetrieveEntitiesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveEntitiesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesRequest): RetrieveEntitiesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Query query */ 1:\n                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Query query = 1; */\n        if (message.query)\n            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveEntitiesRequest\n */\nexport const RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveEventMessagesRequest$Type extends MessageType<RetrieveEventMessagesRequest> {\n    constructor() {\n        super(\"world.RetrieveEventMessagesRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => Query }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveEventMessagesRequest>): RetrieveEventMessagesRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveEventMessagesRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventMessagesRequest): RetrieveEventMessagesRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Query query */ 1:\n                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Query query = 1; */\n        if (message.query)\n            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveEventMessagesRequest\n */\nexport const RetrieveEventMessagesRequest = new RetrieveEventMessagesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {\n    constructor() {\n        super(\"world.RetrieveEntitiesResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"entities\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Entity }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveEntitiesResponse>): RetrieveEntitiesResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.entities = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveEntitiesResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesResponse): RetrieveEntitiesResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.Entity entities */ 2:\n                    message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.Entity entities = 2; */\n        for (let i = 0; i < message.entities.length; i++)\n            Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveEntitiesResponse\n */\nexport const RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {\n    constructor() {\n        super(\"world.RetrieveEventsRequest\", [\n            { no: 1, name: \"query\", kind: \"message\", T: () => EventQuery }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveEventsRequest>): RetrieveEventsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveEventsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsRequest): RetrieveEventsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.EventQuery query */ 1:\n                    message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.EventQuery query = 1; */\n        if (message.query)\n            EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveEventsRequest\n */\nexport const RetrieveEventsRequest = new RetrieveEventsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {\n    constructor() {\n        super(\"world.RetrieveEventsResponse\", [\n            { no: 1, name: \"next_cursor\", kind: \"scalar\", localName: \"next_cursor\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"events\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event }\n        ]);\n    }\n    create(value?: PartialMessage<RetrieveEventsResponse>): RetrieveEventsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.next_cursor = \"\";\n        message.events = [];\n        if (value !== undefined)\n            reflectionMergePartial<RetrieveEventsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsResponse): RetrieveEventsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string next_cursor */ 1:\n                    message.next_cursor = reader.string();\n                    break;\n                case /* repeated types.Event events */ 2:\n                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: RetrieveEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string next_cursor = 1; */\n        if (message.next_cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);\n        /* repeated types.Event events = 2; */\n        for (let i = 0; i < message.events.length; i++)\n            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.RetrieveEventsResponse\n */\nexport const RetrieveEventsResponse = new RetrieveEventsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {\n    constructor() {\n        super(\"world.SubscribeEventsRequest\", [\n            { no: 1, name: \"keys\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KeysClause }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.keys = [];\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeEventsRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated types.KeysClause keys */ 1:\n                    message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated types.KeysClause keys = 1; */\n        for (let i = 0; i < message.keys.length; i++)\n            KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeEventsRequest\n */\nexport const SubscribeEventsRequest = new SubscribeEventsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {\n    constructor() {\n        super(\"world.SubscribeEventsResponse\", [\n            { no: 1, name: \"event\", kind: \"message\", T: () => Event }\n        ]);\n    }\n    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<SubscribeEventsResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Event event */ 1:\n                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Event event = 1; */\n        if (message.event)\n            Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.SubscribeEventsResponse\n */\nexport const SubscribeEventsResponse = new SubscribeEventsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {\n    constructor() {\n        super(\"world.PublishMessageRequest\", [\n            { no: 1, name: \"signature\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"message\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PublishMessageRequest>): PublishMessageRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.signature = [];\n        message.message = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<PublishMessageRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageRequest): PublishMessageRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes signature */ 1:\n                    message.signature.push(reader.bytes());\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PublishMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes signature = 1; */\n        for (let i = 0; i < message.signature.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.signature[i]);\n        /* string message = 2; */\n        if (message.message !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.PublishMessageRequest\n */\nexport const PublishMessageRequest = new PublishMessageRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {\n    constructor() {\n        super(\"world.PublishMessageResponse\", [\n            { no: 1, name: \"entity_id\", kind: \"scalar\", localName: \"entity_id\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PublishMessageResponse>): PublishMessageResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.entity_id = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<PublishMessageResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageResponse): PublishMessageResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes entity_id */ 1:\n                    message.entity_id = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PublishMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes entity_id = 1; */\n        if (message.entity_id.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.entity_id);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.PublishMessageResponse\n */\nexport const PublishMessageResponse = new PublishMessageResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {\n    constructor() {\n        super(\"world.PublishMessageBatchRequest\", [\n            { no: 1, name: \"messages\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageRequest }\n        ]);\n    }\n    create(value?: PartialMessage<PublishMessageBatchRequest>): PublishMessageBatchRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.messages = [];\n        if (value !== undefined)\n            reflectionMergePartial<PublishMessageBatchRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchRequest): PublishMessageBatchRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated world.PublishMessageRequest messages */ 1:\n                    message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PublishMessageBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated world.PublishMessageRequest messages = 1; */\n        for (let i = 0; i < message.messages.length; i++)\n            PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.PublishMessageBatchRequest\n */\nexport const PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {\n    constructor() {\n        super(\"world.PublishMessageBatchResponse\", [\n            { no: 1, name: \"responses\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageResponse }\n        ]);\n    }\n    create(value?: PartialMessage<PublishMessageBatchResponse>): PublishMessageBatchResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.responses = [];\n        if (value !== undefined)\n            reflectionMergePartial<PublishMessageBatchResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchResponse): PublishMessageBatchResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated world.PublishMessageResponse responses */ 1:\n                    message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PublishMessageBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated world.PublishMessageResponse responses = 1; */\n        for (let i = 0; i < message.responses.length; i++)\n            PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message world.PublishMessageBatchResponse\n */\nexport const PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();\n/**\n * @generated ServiceType for protobuf service world.World\n */\nexport const World = new ServiceType(\"world.World\", [\n    { name: \"SubscribeContracts\", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },\n    { name: \"WorldMetadata\", options: {}, I: WorldMetadataRequest, O: WorldMetadataResponse },\n    { name: \"SubscribeEntities\", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },\n    { name: \"UpdateEntitiesSubscription\", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },\n    { name: \"RetrieveEntities\", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },\n    { name: \"SubscribeEventMessages\", serverStreaming: true, options: {}, I: SubscribeEventMessagesRequest, O: SubscribeEntityResponse },\n    { name: \"UpdateEventMessagesSubscription\", options: {}, I: UpdateEventMessagesSubscriptionRequest, O: Empty },\n    { name: \"SubscribeTokenBalances\", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },\n    { name: \"UpdateTokenBalancesSubscription\", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },\n    { name: \"SubscribeTokens\", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },\n    { name: \"UpdateTokensSubscription\", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },\n    { name: \"RetrieveEventMessages\", options: {}, I: RetrieveEventMessagesRequest, O: RetrieveEntitiesResponse },\n    { name: \"RetrieveEvents\", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },\n    { name: \"SubscribeEvents\", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },\n    { name: \"RetrieveTokens\", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },\n    { name: \"RetrieveTokenBalances\", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },\n    { name: \"RetrieveTransactions\", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },\n    { name: \"SubscribeTransactions\", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },\n    { name: \"RetrieveControllers\", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },\n    { name: \"RetrieveContracts\", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },\n    { name: \"RetrieveTokenContracts\", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },\n    { name: \"PublishMessage\", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },\n    { name: \"PublishMessageBatch\", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse }\n]);\n","// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic\n// @generated from protobuf file \"types.proto\" (package \"types\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Primitive } from \"./schema\";\nimport { Struct } from \"./schema\";\n/**\n * @generated from protobuf message types.World\n */\nexport interface World {\n    /**\n     * The hex-encoded address of the world.\n     *\n     * @generated from protobuf field: string world_address = 1\n     */\n    world_address: string;\n    /**\n     * A list of metadata for all registered components in the world.\n     *\n     * @generated from protobuf field: repeated types.Model models = 2\n     */\n    models: Model[];\n}\n/**\n * @generated from protobuf message types.Model\n */\nexport interface Model {\n    /**\n     * Model selector\n     *\n     * @generated from protobuf field: bytes selector = 1\n     */\n    selector: Uint8Array;\n    /**\n     * Model namespace\n     *\n     * @generated from protobuf field: string namespace = 2\n     */\n    namespace: string;\n    /**\n     * Model name\n     *\n     * @generated from protobuf field: string name = 3\n     */\n    name: string;\n    /**\n     * Model size when it is packed for storage\n     *\n     * @generated from protobuf field: uint32 packed_size = 4\n     */\n    packed_size: number;\n    /**\n     * Model size when it is unpacked\n     *\n     * @generated from protobuf field: uint32 unpacked_size = 5\n     */\n    unpacked_size: number;\n    /**\n     * felt bytes of the class hash of the component\n     *\n     * @generated from protobuf field: bytes class_hash = 6\n     */\n    class_hash: Uint8Array;\n    /**\n     * The layout of the component in bytes\n     *\n     * @generated from protobuf field: bytes layout = 7\n     */\n    layout: Uint8Array;\n    /**\n     * The schema of the component serialized in bytes (for simplicity sake)\n     *\n     * @generated from protobuf field: bytes schema = 8\n     */\n    schema: Uint8Array;\n    /**\n     * felt bytes of the contract address of the component\n     *\n     * @generated from protobuf field: bytes contract_address = 9\n     */\n    contract_address: Uint8Array;\n    /**\n     * @generated from protobuf field: bool use_legacy_store = 10\n     */\n    use_legacy_store: boolean;\n}\n/**\n * @generated from protobuf message types.Entity\n */\nexport interface Entity {\n    /**\n     * The entity's hashed keys\n     *\n     * @generated from protobuf field: bytes hashed_keys = 1\n     */\n    hashed_keys: Uint8Array;\n    /**\n     * Models of the entity\n     *\n     * @generated from protobuf field: repeated types.Struct models = 2\n     */\n    models: Struct[];\n    /**\n     * Created at timestamp\n     *\n     * @generated from protobuf field: uint64 created_at = 3\n     */\n    created_at: bigint;\n    /**\n     * Updated at timestamp\n     *\n     * @generated from protobuf field: uint64 updated_at = 4\n     */\n    updated_at: bigint;\n    /**\n     * Block timestamp when the entity was updated\n     *\n     * @generated from protobuf field: uint64 executed_at = 5\n     */\n    executed_at: bigint;\n}\n/**\n * @generated from protobuf message types.Event\n */\nexport interface Event {\n    /**\n     * The event's keys\n     *\n     * @generated from protobuf field: repeated bytes keys = 1\n     */\n    keys: Uint8Array[];\n    /**\n     * Data of the event\n     *\n     * @generated from protobuf field: repeated bytes data = 2\n     */\n    data: Uint8Array[];\n    /**\n     * event's transaction hash\n     *\n     * @generated from protobuf field: bytes transaction_hash = 3\n     */\n    transaction_hash: Uint8Array;\n}\n/**\n * @generated from protobuf message types.Query\n */\nexport interface Query {\n    /**\n     * @generated from protobuf field: types.Clause clause = 1\n     */\n    clause?: Clause;\n    /**\n     * @generated from protobuf field: bool no_hashed_keys = 2\n     */\n    no_hashed_keys: boolean;\n    /**\n     * @generated from protobuf field: repeated string models = 3\n     */\n    models: string[];\n    /**\n     * @generated from protobuf field: types.Pagination pagination = 4\n     */\n    pagination?: Pagination;\n    /**\n     * @generated from protobuf field: bool historical = 5\n     */\n    historical: boolean;\n}\n/**\n * @generated from protobuf message types.EventQuery\n */\nexport interface EventQuery {\n    /**\n     * @generated from protobuf field: types.KeysClause keys = 1\n     */\n    keys?: KeysClause;\n    /**\n     * @generated from protobuf field: types.Pagination pagination = 2\n     */\n    pagination?: Pagination;\n}\n/**\n * @generated from protobuf message types.Clause\n */\nexport interface Clause {\n    /**\n     * @generated from protobuf oneof: clause_type\n     */\n    clause_type: {\n        oneofKind: \"hashed_keys\";\n        /**\n         * @generated from protobuf field: types.HashedKeysClause hashed_keys = 1\n         */\n        hashed_keys: HashedKeysClause;\n    } | {\n        oneofKind: \"keys\";\n        /**\n         * @generated from protobuf field: types.KeysClause keys = 2\n         */\n        keys: KeysClause;\n    } | {\n        oneofKind: \"member\";\n        /**\n         * @generated from protobuf field: types.MemberClause member = 3\n         */\n        member: MemberClause;\n    } | {\n        oneofKind: \"composite\";\n        /**\n         * @generated from protobuf field: types.CompositeClause composite = 4\n         */\n        composite: CompositeClause;\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message types.KeysClause\n */\nexport interface KeysClause {\n    /**\n     * @generated from protobuf field: repeated bytes keys = 2\n     */\n    keys: Uint8Array[];\n    /**\n     * @generated from protobuf field: types.PatternMatching pattern_matching = 3\n     */\n    pattern_matching: PatternMatching;\n    /**\n     * @generated from protobuf field: repeated string models = 4\n     */\n    models: string[];\n}\n/**\n * @generated from protobuf message types.HashedKeysClause\n */\nexport interface HashedKeysClause {\n    /**\n     * @generated from protobuf field: repeated bytes hashed_keys = 1\n     */\n    hashed_keys: Uint8Array[];\n}\n/**\n * @generated from protobuf message types.MemberValue\n */\nexport interface MemberValue {\n    /**\n     * @generated from protobuf oneof: value_type\n     */\n    value_type: {\n        oneofKind: \"primitive\";\n        /**\n         * @generated from protobuf field: types.Primitive primitive = 1\n         */\n        primitive: Primitive;\n    } | {\n        oneofKind: \"string\";\n        /**\n         * @generated from protobuf field: string string = 2\n         */\n        string: string;\n    } | {\n        oneofKind: \"list\";\n        /**\n         * @generated from protobuf field: types.MemberValueList list = 3\n         */\n        list: MemberValueList;\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message types.MemberValueList\n */\nexport interface MemberValueList {\n    /**\n     * @generated from protobuf field: repeated types.MemberValue values = 1\n     */\n    values: MemberValue[];\n}\n/**\n * @generated from protobuf message types.MemberClause\n */\nexport interface MemberClause {\n    /**\n     * @generated from protobuf field: string model = 2\n     */\n    model: string;\n    /**\n     * @generated from protobuf field: string member = 3\n     */\n    member: string;\n    /**\n     * @generated from protobuf field: types.ComparisonOperator operator = 4\n     */\n    operator: ComparisonOperator;\n    /**\n     * @generated from protobuf field: types.MemberValue value = 5\n     */\n    value?: MemberValue;\n}\n/**\n * @generated from protobuf message types.CompositeClause\n */\nexport interface CompositeClause {\n    /**\n     * @generated from protobuf field: types.LogicalOperator operator = 3\n     */\n    operator: LogicalOperator;\n    /**\n     * @generated from protobuf field: repeated types.Clause clauses = 4\n     */\n    clauses: Clause[];\n}\n/**\n * @generated from protobuf message types.Token\n */\nexport interface Token {\n    /**\n     * @generated from protobuf field: optional bytes token_id = 1\n     */\n    token_id?: Uint8Array;\n    /**\n     * @generated from protobuf field: bytes contract_address = 2\n     */\n    contract_address: Uint8Array;\n    /**\n     * @generated from protobuf field: string name = 3\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: string symbol = 4\n     */\n    symbol: string;\n    /**\n     * @generated from protobuf field: uint32 decimals = 5\n     */\n    decimals: number;\n    /**\n     * @generated from protobuf field: bytes metadata = 6\n     */\n    metadata: Uint8Array;\n    /**\n     * @generated from protobuf field: optional bytes total_supply = 7\n     */\n    total_supply?: Uint8Array;\n}\n/**\n * @generated from protobuf message types.TokenContract\n */\nexport interface TokenContract {\n    /**\n     * @generated from protobuf field: bytes contract_address = 2\n     */\n    contract_address: Uint8Array;\n    /**\n     * @generated from protobuf field: string name = 3\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: string symbol = 4\n     */\n    symbol: string;\n    /**\n     * @generated from protobuf field: uint32 decimals = 5\n     */\n    decimals: number;\n    /**\n     * @generated from protobuf field: uint32 count = 6\n     */\n    count: number;\n    /**\n     * @generated from protobuf field: bytes metadata = 7\n     */\n    metadata: Uint8Array;\n}\n/**\n * @generated from protobuf message types.TokenBalance\n */\nexport interface TokenBalance {\n    /**\n     * @generated from protobuf field: bytes balance = 1\n     */\n    balance: Uint8Array;\n    /**\n     * @generated from protobuf field: bytes account_address = 2\n     */\n    account_address: Uint8Array;\n    /**\n     * @generated from protobuf field: bytes contract_address = 3\n     */\n    contract_address: Uint8Array;\n    /**\n     * @generated from protobuf field: optional bytes token_id = 4\n     */\n    token_id?: Uint8Array;\n}\n/**\n * @generated from protobuf message types.OrderBy\n */\nexport interface OrderBy {\n    /**\n     * @generated from protobuf field: string field = 1\n     */\n    field: string;\n    /**\n     * @generated from protobuf field: types.OrderDirection direction = 2\n     */\n    direction: OrderDirection;\n}\n/**\n * @generated from protobuf message types.Controller\n */\nexport interface Controller {\n    /**\n     * @generated from protobuf field: bytes address = 1\n     */\n    address: Uint8Array;\n    /**\n     * @generated from protobuf field: string username = 2\n     */\n    username: string;\n    /**\n     * @generated from protobuf field: uint64 deployed_at_timestamp = 3\n     */\n    deployed_at_timestamp: bigint;\n}\n/**\n * @generated from protobuf message types.Pagination\n */\nexport interface Pagination {\n    /**\n     * @generated from protobuf field: string cursor = 1\n     */\n    cursor: string;\n    /**\n     * @generated from protobuf field: uint32 limit = 2\n     */\n    limit: number;\n    /**\n     * @generated from protobuf field: types.PaginationDirection direction = 3\n     */\n    direction: PaginationDirection;\n    /**\n     * @generated from protobuf field: repeated types.OrderBy order_by = 4\n     */\n    order_by: OrderBy[];\n}\n/**\n * @generated from protobuf message types.ControllerQuery\n */\nexport interface ControllerQuery {\n    /**\n     * The list of contract addresses to retrieve controllers for\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 1\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of usernames to retrieve controllers for\n     *\n     * @generated from protobuf field: repeated string usernames = 2\n     */\n    usernames: string[];\n    /**\n     * Pagination\n     *\n     * @generated from protobuf field: types.Pagination pagination = 3\n     */\n    pagination?: Pagination;\n}\n/**\n * A request to retrieve tokens\n *\n * @generated from protobuf message types.TokenQuery\n */\nexport interface TokenQuery {\n    /**\n     * The list of contract addresses to retrieve tokens for\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 1\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to retrieve tokens for\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 2\n     */\n    token_ids: Uint8Array[];\n    /**\n     * Pagination\n     *\n     * @generated from protobuf field: types.Pagination pagination = 3\n     */\n    pagination?: Pagination;\n}\n/**\n * A request to retrieve token balances\n *\n * @generated from protobuf message types.TokenBalanceQuery\n */\nexport interface TokenBalanceQuery {\n    /**\n     * The account addresses to retrieve balances for\n     *\n     * @generated from protobuf field: repeated bytes account_addresses = 1\n     */\n    account_addresses: Uint8Array[];\n    /**\n     * The list of token contract addresses to retrieve balances for\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 2\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of token IDs to retrieve balances for\n     *\n     * @generated from protobuf field: repeated bytes token_ids = 3\n     */\n    token_ids: Uint8Array[];\n    /**\n     * Pagination\n     *\n     * @generated from protobuf field: types.Pagination pagination = 4\n     */\n    pagination?: Pagination;\n}\n/**\n * @generated from protobuf message types.TransactionCall\n */\nexport interface TransactionCall {\n    /**\n     * The contract address being called\n     *\n     * @generated from protobuf field: bytes contract_address = 1\n     */\n    contract_address: Uint8Array;\n    /**\n     * The function name being called\n     *\n     * @generated from protobuf field: string entrypoint = 2\n     */\n    entrypoint: string;\n    /**\n     * The calldata for the function call\n     *\n     * @generated from protobuf field: repeated bytes calldata = 3\n     */\n    calldata: Uint8Array[];\n    /**\n     * The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)\n     *\n     * @generated from protobuf field: types.CallType call_type = 4\n     */\n    call_type: CallType;\n    /**\n     * The address making the call\n     *\n     * @generated from protobuf field: bytes caller_address = 5\n     */\n    caller_address: Uint8Array;\n}\n/**\n * @generated from protobuf message types.Transaction\n */\nexport interface Transaction {\n    /**\n     * The transaction hash\n     *\n     * @generated from protobuf field: bytes transaction_hash = 1\n     */\n    transaction_hash: Uint8Array;\n    /**\n     * The sender address\n     *\n     * @generated from protobuf field: bytes sender_address = 2\n     */\n    sender_address: Uint8Array;\n    /**\n     * The transaction calldata\n     *\n     * @generated from protobuf field: repeated bytes calldata = 3\n     */\n    calldata: Uint8Array[];\n    /**\n     * The maximum fee for the transaction\n     *\n     * @generated from protobuf field: bytes max_fee = 4\n     */\n    max_fee: Uint8Array;\n    /**\n     * The transaction signature\n     *\n     * @generated from protobuf field: repeated bytes signature = 5\n     */\n    signature: Uint8Array[];\n    /**\n     * The transaction nonce\n     *\n     * @generated from protobuf field: bytes nonce = 6\n     */\n    nonce: Uint8Array;\n    /**\n     * The block number the transaction was included in\n     *\n     * @generated from protobuf field: uint64 block_number = 7\n     */\n    block_number: bigint;\n    /**\n     * The transaction type (INVOKE, L1_HANDLER, etc.)\n     *\n     * @generated from protobuf field: string transaction_type = 8\n     */\n    transaction_type: string;\n    /**\n     * The timestamp when the transaction was executed\n     *\n     * @generated from protobuf field: uint64 block_timestamp = 9\n     */\n    block_timestamp: bigint;\n    /**\n     * The parsed calls within the transaction\n     *\n     * @generated from protobuf field: repeated types.TransactionCall calls = 10\n     */\n    calls: TransactionCall[];\n    /**\n     * The unique models associated with this transaction\n     *\n     * @generated from protobuf field: repeated bytes unique_models = 11\n     */\n    unique_models: Uint8Array[];\n}\n/**\n * @generated from protobuf message types.TransactionFilter\n */\nexport interface TransactionFilter {\n    /**\n     * The list of transaction hashes to retrieve\n     *\n     * @generated from protobuf field: repeated bytes transaction_hashes = 1\n     */\n    transaction_hashes: Uint8Array[];\n    /**\n     * The list of caller addresses to filter by\n     *\n     * @generated from protobuf field: repeated bytes caller_addresses = 2\n     */\n    caller_addresses: Uint8Array[];\n    /**\n     * The list of contract addresses to filter by (calls made to these contracts)\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 3\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of entrypoints to filter by\n     *\n     * @generated from protobuf field: repeated string entrypoints = 4\n     */\n    entrypoints: string[];\n    /**\n     * The list of model selectors to filter by\n     *\n     * @generated from protobuf field: repeated bytes model_selectors = 5\n     */\n    model_selectors: Uint8Array[];\n    /**\n     * The block number range to filter by\n     *\n     * @generated from protobuf field: optional uint64 from_block = 6\n     */\n    from_block?: bigint;\n    /**\n     * @generated from protobuf field: optional uint64 to_block = 7\n     */\n    to_block?: bigint;\n}\n/**\n * @generated from protobuf message types.TransactionQuery\n */\nexport interface TransactionQuery {\n    /**\n     * The filter to apply to the query\n     *\n     * @generated from protobuf field: types.TransactionFilter filter = 1\n     */\n    filter?: TransactionFilter;\n    /**\n     * Pagination\n     *\n     * @generated from protobuf field: types.Pagination pagination = 2\n     */\n    pagination?: Pagination;\n}\n/**\n * @generated from protobuf message types.Contract\n */\nexport interface Contract {\n    /**\n     * The contract address\n     *\n     * @generated from protobuf field: bytes contract_address = 1\n     */\n    contract_address: Uint8Array;\n    /**\n     * The type of contract\n     *\n     * @generated from protobuf field: types.ContractType contract_type = 2\n     */\n    contract_type: ContractType;\n    /**\n     * Current block height\n     *\n     * @generated from protobuf field: optional uint64 head = 3\n     */\n    head?: bigint;\n    /**\n     * Transactions per second\n     *\n     * @generated from protobuf field: optional uint64 tps = 4\n     */\n    tps?: bigint;\n    /**\n     * Last block timestamp\n     *\n     * @generated from protobuf field: optional uint64 last_block_timestamp = 5\n     */\n    last_block_timestamp?: bigint;\n    /**\n     * Last pending block transaction\n     *\n     * @generated from protobuf field: optional bytes last_pending_block_tx = 6\n     */\n    last_pending_block_tx?: Uint8Array;\n    /**\n     * When the contract was last updated\n     *\n     * @generated from protobuf field: uint64 updated_at = 7\n     */\n    updated_at: bigint;\n    /**\n     * When the contract was first tracked\n     *\n     * @generated from protobuf field: uint64 created_at = 8\n     */\n    created_at: bigint;\n}\n/**\n * A request to retrieve contracts\n *\n * @generated from protobuf message types.ContractQuery\n */\nexport interface ContractQuery {\n    /**\n     * The list of contract addresses to retrieve\n     *\n     * @generated from protobuf field: repeated bytes contract_addresses = 1\n     */\n    contract_addresses: Uint8Array[];\n    /**\n     * The list of contract types to filter by\n     *\n     * @generated from protobuf field: repeated types.ContractType contract_types = 2\n     */\n    contract_types: ContractType[];\n}\n/**\n * @generated from protobuf enum types.PatternMatching\n */\nexport enum PatternMatching {\n    /**\n     * @generated from protobuf enum value: FixedLen = 0;\n     */\n    FixedLen = 0,\n    /**\n     * @generated from protobuf enum value: VariableLen = 1;\n     */\n    VariableLen = 1\n}\n/**\n * @generated from protobuf enum types.LogicalOperator\n */\nexport enum LogicalOperator {\n    /**\n     * @generated from protobuf enum value: AND = 0;\n     */\n    AND = 0,\n    /**\n     * @generated from protobuf enum value: OR = 1;\n     */\n    OR = 1\n}\n/**\n * @generated from protobuf enum types.ComparisonOperator\n */\nexport enum ComparisonOperator {\n    /**\n     * @generated from protobuf enum value: EQ = 0;\n     */\n    EQ = 0,\n    /**\n     * @generated from protobuf enum value: NEQ = 1;\n     */\n    NEQ = 1,\n    /**\n     * @generated from protobuf enum value: GT = 2;\n     */\n    GT = 2,\n    /**\n     * @generated from protobuf enum value: GTE = 3;\n     */\n    GTE = 3,\n    /**\n     * @generated from protobuf enum value: LT = 4;\n     */\n    LT = 4,\n    /**\n     * @generated from protobuf enum value: LTE = 5;\n     */\n    LTE = 5,\n    /**\n     * @generated from protobuf enum value: IN = 6;\n     */\n    IN = 6,\n    /**\n     * @generated from protobuf enum value: NOT_IN = 7;\n     */\n    NOT_IN = 7,\n    /**\n     * Array-specific operators\n     *\n     * Array contains value\n     *\n     * @generated from protobuf enum value: CONTAINS = 8;\n     */\n    CONTAINS = 8,\n    /**\n     * Array contains all values\n     *\n     * @generated from protobuf enum value: CONTAINS_ALL = 9;\n     */\n    CONTAINS_ALL = 9,\n    /**\n     * Array contains any of the values\n     *\n     * @generated from protobuf enum value: CONTAINS_ANY = 10;\n     */\n    CONTAINS_ANY = 10,\n    /**\n     * Array length equals\n     *\n     * @generated from protobuf enum value: ARRAY_LENGTH_EQ = 11;\n     */\n    ARRAY_LENGTH_EQ = 11,\n    /**\n     * Array length greater than\n     *\n     * @generated from protobuf enum value: ARRAY_LENGTH_GT = 12;\n     */\n    ARRAY_LENGTH_GT = 12,\n    /**\n     * Array length less than\n     *\n     * @generated from protobuf enum value: ARRAY_LENGTH_LT = 13;\n     */\n    ARRAY_LENGTH_LT = 13\n}\n/**\n * @generated from protobuf enum types.OrderDirection\n */\nexport enum OrderDirection {\n    /**\n     * @generated from protobuf enum value: ASC = 0;\n     */\n    ASC = 0,\n    /**\n     * @generated from protobuf enum value: DESC = 1;\n     */\n    DESC = 1\n}\n/**\n * @generated from protobuf enum types.PaginationDirection\n */\nexport enum PaginationDirection {\n    /**\n     * @generated from protobuf enum value: FORWARD = 0;\n     */\n    FORWARD = 0,\n    /**\n     * @generated from protobuf enum value: BACKWARD = 1;\n     */\n    BACKWARD = 1\n}\n/**\n * @generated from protobuf enum types.CallType\n */\nexport enum CallType {\n    /**\n     * @generated from protobuf enum value: EXECUTE = 0;\n     */\n    EXECUTE = 0,\n    /**\n     * @generated from protobuf enum value: EXECUTE_FROM_OUTSIDE = 1;\n     */\n    EXECUTE_FROM_OUTSIDE = 1\n}\n/**\n * @generated from protobuf enum types.ContractType\n */\nexport enum ContractType {\n    /**\n     * @generated from protobuf enum value: WORLD = 0;\n     */\n    WORLD = 0,\n    /**\n     * @generated from protobuf enum value: ERC20 = 1;\n     */\n    ERC20 = 1,\n    /**\n     * @generated from protobuf enum value: ERC721 = 2;\n     */\n    ERC721 = 2,\n    /**\n     * @generated from protobuf enum value: ERC1155 = 3;\n     */\n    ERC1155 = 3,\n    /**\n     * @generated from protobuf enum value: UDC = 4;\n     */\n    UDC = 4,\n    /**\n     * @generated from protobuf enum value: OTHER = 5;\n     */\n    OTHER = 5\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass World$Type extends MessageType<World> {\n    constructor() {\n        super(\"types.World\", [\n            { no: 1, name: \"world_address\", kind: \"scalar\", localName: \"world_address\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"models\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Model }\n        ]);\n    }\n    create(value?: PartialMessage<World>): World {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.world_address = \"\";\n        message.models = [];\n        if (value !== undefined)\n            reflectionMergePartial<World>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: World): World {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string world_address */ 1:\n                    message.world_address = reader.string();\n                    break;\n                case /* repeated types.Model models */ 2:\n                    message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: World, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string world_address = 1; */\n        if (message.world_address !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.world_address);\n        /* repeated types.Model models = 2; */\n        for (let i = 0; i < message.models.length; i++)\n            Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.World\n */\nexport const World = new World$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Model$Type extends MessageType<Model> {\n    constructor() {\n        super(\"types.Model\", [\n            { no: 1, name: \"selector\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"namespace\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"packed_size\", kind: \"scalar\", localName: \"packed_size\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 5, name: \"unpacked_size\", kind: \"scalar\", localName: \"unpacked_size\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 6, name: \"class_hash\", kind: \"scalar\", localName: \"class_hash\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 7, name: \"layout\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 8, name: \"schema\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 9, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 10, name: \"use_legacy_store\", kind: \"scalar\", localName: \"use_legacy_store\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Model>): Model {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.selector = new Uint8Array(0);\n        message.namespace = \"\";\n        message.name = \"\";\n        message.packed_size = 0;\n        message.unpacked_size = 0;\n        message.class_hash = new Uint8Array(0);\n        message.layout = new Uint8Array(0);\n        message.schema = new Uint8Array(0);\n        message.contract_address = new Uint8Array(0);\n        message.use_legacy_store = false;\n        if (value !== undefined)\n            reflectionMergePartial<Model>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model): Model {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes selector */ 1:\n                    message.selector = reader.bytes();\n                    break;\n                case /* string namespace */ 2:\n                    message.namespace = reader.string();\n                    break;\n                case /* string name */ 3:\n                    message.name = reader.string();\n                    break;\n                case /* uint32 packed_size */ 4:\n                    message.packed_size = reader.uint32();\n                    break;\n                case /* uint32 unpacked_size */ 5:\n                    message.unpacked_size = reader.uint32();\n                    break;\n                case /* bytes class_hash */ 6:\n                    message.class_hash = reader.bytes();\n                    break;\n                case /* bytes layout */ 7:\n                    message.layout = reader.bytes();\n                    break;\n                case /* bytes schema */ 8:\n                    message.schema = reader.bytes();\n                    break;\n                case /* bytes contract_address */ 9:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* bool use_legacy_store */ 10:\n                    message.use_legacy_store = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Model, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes selector = 1; */\n        if (message.selector.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.selector);\n        /* string namespace = 2; */\n        if (message.namespace !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.namespace);\n        /* string name = 3; */\n        if (message.name !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.name);\n        /* uint32 packed_size = 4; */\n        if (message.packed_size !== 0)\n            writer.tag(4, WireType.Varint).uint32(message.packed_size);\n        /* uint32 unpacked_size = 5; */\n        if (message.unpacked_size !== 0)\n            writer.tag(5, WireType.Varint).uint32(message.unpacked_size);\n        /* bytes class_hash = 6; */\n        if (message.class_hash.length)\n            writer.tag(6, WireType.LengthDelimited).bytes(message.class_hash);\n        /* bytes layout = 7; */\n        if (message.layout.length)\n            writer.tag(7, WireType.LengthDelimited).bytes(message.layout);\n        /* bytes schema = 8; */\n        if (message.schema.length)\n            writer.tag(8, WireType.LengthDelimited).bytes(message.schema);\n        /* bytes contract_address = 9; */\n        if (message.contract_address.length)\n            writer.tag(9, WireType.LengthDelimited).bytes(message.contract_address);\n        /* bool use_legacy_store = 10; */\n        if (message.use_legacy_store !== false)\n            writer.tag(10, WireType.Varint).bool(message.use_legacy_store);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Model\n */\nexport const Model = new Model$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Entity$Type extends MessageType<Entity> {\n    constructor() {\n        super(\"types.Entity\", [\n            { no: 1, name: \"hashed_keys\", kind: \"scalar\", localName: \"hashed_keys\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"models\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Struct },\n            { no: 3, name: \"created_at\", kind: \"scalar\", localName: \"created_at\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 4, name: \"updated_at\", kind: \"scalar\", localName: \"updated_at\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 5, name: \"executed_at\", kind: \"scalar\", localName: \"executed_at\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Entity>): Entity {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.hashed_keys = new Uint8Array(0);\n        message.models = [];\n        message.created_at = 0n;\n        message.updated_at = 0n;\n        message.executed_at = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<Entity>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes hashed_keys */ 1:\n                    message.hashed_keys = reader.bytes();\n                    break;\n                case /* repeated types.Struct models */ 2:\n                    message.models.push(Struct.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* uint64 created_at */ 3:\n                    message.created_at = reader.uint64().toBigInt();\n                    break;\n                case /* uint64 updated_at */ 4:\n                    message.updated_at = reader.uint64().toBigInt();\n                    break;\n                case /* uint64 executed_at */ 5:\n                    message.executed_at = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes hashed_keys = 1; */\n        if (message.hashed_keys.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys);\n        /* repeated types.Struct models = 2; */\n        for (let i = 0; i < message.models.length; i++)\n            Struct.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* uint64 created_at = 3; */\n        if (message.created_at !== 0n)\n            writer.tag(3, WireType.Varint).uint64(message.created_at);\n        /* uint64 updated_at = 4; */\n        if (message.updated_at !== 0n)\n            writer.tag(4, WireType.Varint).uint64(message.updated_at);\n        /* uint64 executed_at = 5; */\n        if (message.executed_at !== 0n)\n            writer.tag(5, WireType.Varint).uint64(message.executed_at);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Entity\n */\nexport const Entity = new Entity$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Event$Type extends MessageType<Event> {\n    constructor() {\n        super(\"types.Event\", [\n            { no: 1, name: \"keys\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"data\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"transaction_hash\", kind: \"scalar\", localName: \"transaction_hash\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Event>): Event {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.keys = [];\n        message.data = [];\n        message.transaction_hash = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<Event>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes keys */ 1:\n                    message.keys.push(reader.bytes());\n                    break;\n                case /* repeated bytes data */ 2:\n                    message.data.push(reader.bytes());\n                    break;\n                case /* bytes transaction_hash */ 3:\n                    message.transaction_hash = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes keys = 1; */\n        for (let i = 0; i < message.keys.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.keys[i]);\n        /* repeated bytes data = 2; */\n        for (let i = 0; i < message.data.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.data[i]);\n        /* bytes transaction_hash = 3; */\n        if (message.transaction_hash.length)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.transaction_hash);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Event\n */\nexport const Event = new Event$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Query$Type extends MessageType<Query> {\n    constructor() {\n        super(\"types.Query\", [\n            { no: 1, name: \"clause\", kind: \"message\", T: () => Clause },\n            { no: 2, name: \"no_hashed_keys\", kind: \"scalar\", localName: \"no_hashed_keys\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 3, name: \"models\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"pagination\", kind: \"message\", T: () => Pagination },\n            { no: 5, name: \"historical\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Query>): Query {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.no_hashed_keys = false;\n        message.models = [];\n        message.historical = false;\n        if (value !== undefined)\n            reflectionMergePartial<Query>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query): Query {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Clause clause */ 1:\n                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);\n                    break;\n                case /* bool no_hashed_keys */ 2:\n                    message.no_hashed_keys = reader.bool();\n                    break;\n                case /* repeated string models */ 3:\n                    message.models.push(reader.string());\n                    break;\n                case /* types.Pagination pagination */ 4:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                case /* bool historical */ 5:\n                    message.historical = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Query, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Clause clause = 1; */\n        if (message.clause)\n            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* bool no_hashed_keys = 2; */\n        if (message.no_hashed_keys !== false)\n            writer.tag(2, WireType.Varint).bool(message.no_hashed_keys);\n        /* repeated string models = 3; */\n        for (let i = 0; i < message.models.length; i++)\n            writer.tag(3, WireType.LengthDelimited).string(message.models[i]);\n        /* types.Pagination pagination = 4; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        /* bool historical = 5; */\n        if (message.historical !== false)\n            writer.tag(5, WireType.Varint).bool(message.historical);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Query\n */\nexport const Query = new Query$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass EventQuery$Type extends MessageType<EventQuery> {\n    constructor() {\n        super(\"types.EventQuery\", [\n            { no: 1, name: \"keys\", kind: \"message\", T: () => KeysClause },\n            { no: 2, name: \"pagination\", kind: \"message\", T: () => Pagination }\n        ]);\n    }\n    create(value?: PartialMessage<EventQuery>): EventQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<EventQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQuery): EventQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.KeysClause keys */ 1:\n                    message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);\n                    break;\n                case /* types.Pagination pagination */ 2:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: EventQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.KeysClause keys = 1; */\n        if (message.keys)\n            KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* types.Pagination pagination = 2; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.EventQuery\n */\nexport const EventQuery = new EventQuery$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Clause$Type extends MessageType<Clause> {\n    constructor() {\n        super(\"types.Clause\", [\n            { no: 1, name: \"hashed_keys\", kind: \"message\", localName: \"hashed_keys\", oneof: \"clause_type\", T: () => HashedKeysClause },\n            { no: 2, name: \"keys\", kind: \"message\", oneof: \"clause_type\", T: () => KeysClause },\n            { no: 3, name: \"member\", kind: \"message\", oneof: \"clause_type\", T: () => MemberClause },\n            { no: 4, name: \"composite\", kind: \"message\", oneof: \"clause_type\", T: () => CompositeClause }\n        ]);\n    }\n    create(value?: PartialMessage<Clause>): Clause {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.clause_type = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<Clause>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clause): Clause {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.HashedKeysClause hashed_keys */ 1:\n                    message.clause_type = {\n                        oneofKind: \"hashed_keys\",\n                        hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).hashed_keys)\n                    };\n                    break;\n                case /* types.KeysClause keys */ 2:\n                    message.clause_type = {\n                        oneofKind: \"keys\",\n                        keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).keys)\n                    };\n                    break;\n                case /* types.MemberClause member */ 3:\n                    message.clause_type = {\n                        oneofKind: \"member\",\n                        member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).member)\n                    };\n                    break;\n                case /* types.CompositeClause composite */ 4:\n                    message.clause_type = {\n                        oneofKind: \"composite\",\n                        composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).composite)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Clause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.HashedKeysClause hashed_keys = 1; */\n        if (message.clause_type.oneofKind === \"hashed_keys\")\n            HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* types.KeysClause keys = 2; */\n        if (message.clause_type.oneofKind === \"keys\")\n            KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* types.MemberClause member = 3; */\n        if (message.clause_type.oneofKind === \"member\")\n            MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        /* types.CompositeClause composite = 4; */\n        if (message.clause_type.oneofKind === \"composite\")\n            CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Clause\n */\nexport const Clause = new Clause$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass KeysClause$Type extends MessageType<KeysClause> {\n    constructor() {\n        super(\"types.KeysClause\", [\n            { no: 2, name: \"keys\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"pattern_matching\", kind: \"enum\", localName: \"pattern_matching\", T: () => [\"types.PatternMatching\", PatternMatching] },\n            { no: 4, name: \"models\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<KeysClause>): KeysClause {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.keys = [];\n        message.pattern_matching = 0;\n        message.models = [];\n        if (value !== undefined)\n            reflectionMergePartial<KeysClause>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeysClause): KeysClause {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes keys */ 2:\n                    message.keys.push(reader.bytes());\n                    break;\n                case /* types.PatternMatching pattern_matching */ 3:\n                    message.pattern_matching = reader.int32();\n                    break;\n                case /* repeated string models */ 4:\n                    message.models.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: KeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes keys = 2; */\n        for (let i = 0; i < message.keys.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.keys[i]);\n        /* types.PatternMatching pattern_matching = 3; */\n        if (message.pattern_matching !== 0)\n            writer.tag(3, WireType.Varint).int32(message.pattern_matching);\n        /* repeated string models = 4; */\n        for (let i = 0; i < message.models.length; i++)\n            writer.tag(4, WireType.LengthDelimited).string(message.models[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.KeysClause\n */\nexport const KeysClause = new KeysClause$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HashedKeysClause$Type extends MessageType<HashedKeysClause> {\n    constructor() {\n        super(\"types.HashedKeysClause\", [\n            { no: 1, name: \"hashed_keys\", kind: \"scalar\", localName: \"hashed_keys\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<HashedKeysClause>): HashedKeysClause {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.hashed_keys = [];\n        if (value !== undefined)\n            reflectionMergePartial<HashedKeysClause>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HashedKeysClause): HashedKeysClause {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes hashed_keys */ 1:\n                    message.hashed_keys.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: HashedKeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes hashed_keys = 1; */\n        for (let i = 0; i < message.hashed_keys.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.HashedKeysClause\n */\nexport const HashedKeysClause = new HashedKeysClause$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MemberValue$Type extends MessageType<MemberValue> {\n    constructor() {\n        super(\"types.MemberValue\", [\n            { no: 1, name: \"primitive\", kind: \"message\", oneof: \"value_type\", T: () => Primitive },\n            { no: 2, name: \"string\", kind: \"scalar\", oneof: \"value_type\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"list\", kind: \"message\", oneof: \"value_type\", T: () => MemberValueList }\n        ]);\n    }\n    create(value?: PartialMessage<MemberValue>): MemberValue {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.value_type = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<MemberValue>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValue): MemberValue {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Primitive primitive */ 1:\n                    message.value_type = {\n                        oneofKind: \"primitive\",\n                        primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).primitive)\n                    };\n                    break;\n                case /* string string */ 2:\n                    message.value_type = {\n                        oneofKind: \"string\",\n                        string: reader.string()\n                    };\n                    break;\n                case /* types.MemberValueList list */ 3:\n                    message.value_type = {\n                        oneofKind: \"list\",\n                        list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).list)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MemberValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Primitive primitive = 1; */\n        if (message.value_type.oneofKind === \"primitive\")\n            Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* string string = 2; */\n        if (message.value_type.oneofKind === \"string\")\n            writer.tag(2, WireType.LengthDelimited).string(message.value_type.string);\n        /* types.MemberValueList list = 3; */\n        if (message.value_type.oneofKind === \"list\")\n            MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.MemberValue\n */\nexport const MemberValue = new MemberValue$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MemberValueList$Type extends MessageType<MemberValueList> {\n    constructor() {\n        super(\"types.MemberValueList\", [\n            { no: 1, name: \"values\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MemberValue }\n        ]);\n    }\n    create(value?: PartialMessage<MemberValueList>): MemberValueList {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.values = [];\n        if (value !== undefined)\n            reflectionMergePartial<MemberValueList>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValueList): MemberValueList {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated types.MemberValue values */ 1:\n                    message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MemberValueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated types.MemberValue values = 1; */\n        for (let i = 0; i < message.values.length; i++)\n            MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.MemberValueList\n */\nexport const MemberValueList = new MemberValueList$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MemberClause$Type extends MessageType<MemberClause> {\n    constructor() {\n        super(\"types.MemberClause\", [\n            { no: 2, name: \"model\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"member\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"operator\", kind: \"enum\", T: () => [\"types.ComparisonOperator\", ComparisonOperator] },\n            { no: 5, name: \"value\", kind: \"message\", T: () => MemberValue }\n        ]);\n    }\n    create(value?: PartialMessage<MemberClause>): MemberClause {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.model = \"\";\n        message.member = \"\";\n        message.operator = 0;\n        if (value !== undefined)\n            reflectionMergePartial<MemberClause>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberClause): MemberClause {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string model */ 2:\n                    message.model = reader.string();\n                    break;\n                case /* string member */ 3:\n                    message.member = reader.string();\n                    break;\n                case /* types.ComparisonOperator operator */ 4:\n                    message.operator = reader.int32();\n                    break;\n                case /* types.MemberValue value */ 5:\n                    message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MemberClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string model = 2; */\n        if (message.model !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.model);\n        /* string member = 3; */\n        if (message.member !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.member);\n        /* types.ComparisonOperator operator = 4; */\n        if (message.operator !== 0)\n            writer.tag(4, WireType.Varint).int32(message.operator);\n        /* types.MemberValue value = 5; */\n        if (message.value)\n            MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.MemberClause\n */\nexport const MemberClause = new MemberClause$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CompositeClause$Type extends MessageType<CompositeClause> {\n    constructor() {\n        super(\"types.CompositeClause\", [\n            { no: 3, name: \"operator\", kind: \"enum\", T: () => [\"types.LogicalOperator\", LogicalOperator] },\n            { no: 4, name: \"clauses\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Clause }\n        ]);\n    }\n    create(value?: PartialMessage<CompositeClause>): CompositeClause {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.operator = 0;\n        message.clauses = [];\n        if (value !== undefined)\n            reflectionMergePartial<CompositeClause>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompositeClause): CompositeClause {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.LogicalOperator operator */ 3:\n                    message.operator = reader.int32();\n                    break;\n                case /* repeated types.Clause clauses */ 4:\n                    message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: CompositeClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.LogicalOperator operator = 3; */\n        if (message.operator !== 0)\n            writer.tag(3, WireType.Varint).int32(message.operator);\n        /* repeated types.Clause clauses = 4; */\n        for (let i = 0; i < message.clauses.length; i++)\n            Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.CompositeClause\n */\nexport const CompositeClause = new CompositeClause$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Token$Type extends MessageType<Token> {\n    constructor() {\n        super(\"types.Token\", [\n            { no: 1, name: \"token_id\", kind: \"scalar\", localName: \"token_id\", opt: true, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"symbol\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 5, name: \"decimals\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 6, name: \"metadata\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 7, name: \"total_supply\", kind: \"scalar\", localName: \"total_supply\", opt: true, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Token>): Token {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_address = new Uint8Array(0);\n        message.name = \"\";\n        message.symbol = \"\";\n        message.decimals = 0;\n        message.metadata = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<Token>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* optional bytes token_id */ 1:\n                    message.token_id = reader.bytes();\n                    break;\n                case /* bytes contract_address */ 2:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* string name */ 3:\n                    message.name = reader.string();\n                    break;\n                case /* string symbol */ 4:\n                    message.symbol = reader.string();\n                    break;\n                case /* uint32 decimals */ 5:\n                    message.decimals = reader.uint32();\n                    break;\n                case /* bytes metadata */ 6:\n                    message.metadata = reader.bytes();\n                    break;\n                case /* optional bytes total_supply */ 7:\n                    message.total_supply = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* optional bytes token_id = 1; */\n        if (message.token_id !== undefined)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.token_id);\n        /* bytes contract_address = 2; */\n        if (message.contract_address.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);\n        /* string name = 3; */\n        if (message.name !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.name);\n        /* string symbol = 4; */\n        if (message.symbol !== \"\")\n            writer.tag(4, WireType.LengthDelimited).string(message.symbol);\n        /* uint32 decimals = 5; */\n        if (message.decimals !== 0)\n            writer.tag(5, WireType.Varint).uint32(message.decimals);\n        /* bytes metadata = 6; */\n        if (message.metadata.length)\n            writer.tag(6, WireType.LengthDelimited).bytes(message.metadata);\n        /* optional bytes total_supply = 7; */\n        if (message.total_supply !== undefined)\n            writer.tag(7, WireType.LengthDelimited).bytes(message.total_supply);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Token\n */\nexport const Token = new Token$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TokenContract$Type extends MessageType<TokenContract> {\n    constructor() {\n        super(\"types.TokenContract\", [\n            { no: 2, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"symbol\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 5, name: \"decimals\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 6, name: \"count\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 7, name: \"metadata\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TokenContract>): TokenContract {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_address = new Uint8Array(0);\n        message.name = \"\";\n        message.symbol = \"\";\n        message.decimals = 0;\n        message.count = 0;\n        message.metadata = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<TokenContract>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContract): TokenContract {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes contract_address */ 2:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* string name */ 3:\n                    message.name = reader.string();\n                    break;\n                case /* string symbol */ 4:\n                    message.symbol = reader.string();\n                    break;\n                case /* uint32 decimals */ 5:\n                    message.decimals = reader.uint32();\n                    break;\n                case /* uint32 count */ 6:\n                    message.count = reader.uint32();\n                    break;\n                case /* bytes metadata */ 7:\n                    message.metadata = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TokenContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes contract_address = 2; */\n        if (message.contract_address.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);\n        /* string name = 3; */\n        if (message.name !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.name);\n        /* string symbol = 4; */\n        if (message.symbol !== \"\")\n            writer.tag(4, WireType.LengthDelimited).string(message.symbol);\n        /* uint32 decimals = 5; */\n        if (message.decimals !== 0)\n            writer.tag(5, WireType.Varint).uint32(message.decimals);\n        /* uint32 count = 6; */\n        if (message.count !== 0)\n            writer.tag(6, WireType.Varint).uint32(message.count);\n        /* bytes metadata = 7; */\n        if (message.metadata.length)\n            writer.tag(7, WireType.LengthDelimited).bytes(message.metadata);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TokenContract\n */\nexport const TokenContract = new TokenContract$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TokenBalance$Type extends MessageType<TokenBalance> {\n    constructor() {\n        super(\"types.TokenBalance\", [\n            { no: 1, name: \"balance\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"account_address\", kind: \"scalar\", localName: \"account_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"token_id\", kind: \"scalar\", localName: \"token_id\", opt: true, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TokenBalance>): TokenBalance {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.balance = new Uint8Array(0);\n        message.account_address = new Uint8Array(0);\n        message.contract_address = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<TokenBalance>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalance): TokenBalance {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes balance */ 1:\n                    message.balance = reader.bytes();\n                    break;\n                case /* bytes account_address */ 2:\n                    message.account_address = reader.bytes();\n                    break;\n                case /* bytes contract_address */ 3:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* optional bytes token_id */ 4:\n                    message.token_id = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TokenBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes balance = 1; */\n        if (message.balance.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.balance);\n        /* bytes account_address = 2; */\n        if (message.account_address.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.account_address);\n        /* bytes contract_address = 3; */\n        if (message.contract_address.length)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_address);\n        /* optional bytes token_id = 4; */\n        if (message.token_id !== undefined)\n            writer.tag(4, WireType.LengthDelimited).bytes(message.token_id);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TokenBalance\n */\nexport const TokenBalance = new TokenBalance$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass OrderBy$Type extends MessageType<OrderBy> {\n    constructor() {\n        super(\"types.OrderBy\", [\n            { no: 1, name: \"field\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"direction\", kind: \"enum\", T: () => [\"types.OrderDirection\", OrderDirection] }\n        ]);\n    }\n    create(value?: PartialMessage<OrderBy>): OrderBy {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.field = \"\";\n        message.direction = 0;\n        if (value !== undefined)\n            reflectionMergePartial<OrderBy>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBy): OrderBy {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string field */ 1:\n                    message.field = reader.string();\n                    break;\n                case /* types.OrderDirection direction */ 2:\n                    message.direction = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: OrderBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string field = 1; */\n        if (message.field !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.field);\n        /* types.OrderDirection direction = 2; */\n        if (message.direction !== 0)\n            writer.tag(2, WireType.Varint).int32(message.direction);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.OrderBy\n */\nexport const OrderBy = new OrderBy$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Controller$Type extends MessageType<Controller> {\n    constructor() {\n        super(\"types.Controller\", [\n            { no: 1, name: \"address\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"username\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"deployed_at_timestamp\", kind: \"scalar\", localName: \"deployed_at_timestamp\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Controller>): Controller {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.address = new Uint8Array(0);\n        message.username = \"\";\n        message.deployed_at_timestamp = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<Controller>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Controller): Controller {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes address */ 1:\n                    message.address = reader.bytes();\n                    break;\n                case /* string username */ 2:\n                    message.username = reader.string();\n                    break;\n                case /* uint64 deployed_at_timestamp */ 3:\n                    message.deployed_at_timestamp = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Controller, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes address = 1; */\n        if (message.address.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.address);\n        /* string username = 2; */\n        if (message.username !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.username);\n        /* uint64 deployed_at_timestamp = 3; */\n        if (message.deployed_at_timestamp !== 0n)\n            writer.tag(3, WireType.Varint).uint64(message.deployed_at_timestamp);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Controller\n */\nexport const Controller = new Controller$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pagination$Type extends MessageType<Pagination> {\n    constructor() {\n        super(\"types.Pagination\", [\n            { no: 1, name: \"cursor\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"limit\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 3, name: \"direction\", kind: \"enum\", T: () => [\"types.PaginationDirection\", PaginationDirection] },\n            { no: 4, name: \"order_by\", kind: \"message\", localName: \"order_by\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderBy }\n        ]);\n    }\n    create(value?: PartialMessage<Pagination>): Pagination {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cursor = \"\";\n        message.limit = 0;\n        message.direction = 0;\n        message.order_by = [];\n        if (value !== undefined)\n            reflectionMergePartial<Pagination>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination): Pagination {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string cursor */ 1:\n                    message.cursor = reader.string();\n                    break;\n                case /* uint32 limit */ 2:\n                    message.limit = reader.uint32();\n                    break;\n                case /* types.PaginationDirection direction */ 3:\n                    message.direction = reader.int32();\n                    break;\n                case /* repeated types.OrderBy order_by */ 4:\n                    message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Pagination, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string cursor = 1; */\n        if (message.cursor !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.cursor);\n        /* uint32 limit = 2; */\n        if (message.limit !== 0)\n            writer.tag(2, WireType.Varint).uint32(message.limit);\n        /* types.PaginationDirection direction = 3; */\n        if (message.direction !== 0)\n            writer.tag(3, WireType.Varint).int32(message.direction);\n        /* repeated types.OrderBy order_by = 4; */\n        for (let i = 0; i < message.order_by.length; i++)\n            OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Pagination\n */\nexport const Pagination = new Pagination$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ControllerQuery$Type extends MessageType<ControllerQuery> {\n    constructor() {\n        super(\"types.ControllerQuery\", [\n            { no: 1, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"usernames\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"pagination\", kind: \"message\", T: () => Pagination }\n        ]);\n    }\n    create(value?: PartialMessage<ControllerQuery>): ControllerQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_addresses = [];\n        message.usernames = [];\n        if (value !== undefined)\n            reflectionMergePartial<ControllerQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerQuery): ControllerQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes contract_addresses */ 1:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated string usernames */ 2:\n                    message.usernames.push(reader.string());\n                    break;\n                case /* types.Pagination pagination */ 3:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ControllerQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes contract_addresses = 1; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated string usernames = 2; */\n        for (let i = 0; i < message.usernames.length; i++)\n            writer.tag(2, WireType.LengthDelimited).string(message.usernames[i]);\n        /* types.Pagination pagination = 3; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.ControllerQuery\n */\nexport const ControllerQuery = new ControllerQuery$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TokenQuery$Type extends MessageType<TokenQuery> {\n    constructor() {\n        super(\"types.TokenQuery\", [\n            { no: 1, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"pagination\", kind: \"message\", T: () => Pagination }\n        ]);\n    }\n    create(value?: PartialMessage<TokenQuery>): TokenQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<TokenQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenQuery): TokenQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes contract_addresses */ 1:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 2:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                case /* types.Pagination pagination */ 3:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TokenQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes contract_addresses = 1; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes token_ids = 2; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        /* types.Pagination pagination = 3; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TokenQuery\n */\nexport const TokenQuery = new TokenQuery$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TokenBalanceQuery$Type extends MessageType<TokenBalanceQuery> {\n    constructor() {\n        super(\"types.TokenBalanceQuery\", [\n            { no: 1, name: \"account_addresses\", kind: \"scalar\", localName: \"account_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"token_ids\", kind: \"scalar\", localName: \"token_ids\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"pagination\", kind: \"message\", T: () => Pagination }\n        ]);\n    }\n    create(value?: PartialMessage<TokenBalanceQuery>): TokenBalanceQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.account_addresses = [];\n        message.contract_addresses = [];\n        message.token_ids = [];\n        if (value !== undefined)\n            reflectionMergePartial<TokenBalanceQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalanceQuery): TokenBalanceQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes account_addresses */ 1:\n                    message.account_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes contract_addresses */ 2:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes token_ids */ 3:\n                    message.token_ids.push(reader.bytes());\n                    break;\n                case /* types.Pagination pagination */ 4:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TokenBalanceQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes account_addresses = 1; */\n        for (let i = 0; i < message.account_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);\n        /* repeated bytes contract_addresses = 2; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated bytes token_ids = 3; */\n        for (let i = 0; i < message.token_ids.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);\n        /* types.Pagination pagination = 4; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TokenBalanceQuery\n */\nexport const TokenBalanceQuery = new TokenBalanceQuery$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TransactionCall$Type extends MessageType<TransactionCall> {\n    constructor() {\n        super(\"types.TransactionCall\", [\n            { no: 1, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"entrypoint\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"calldata\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"call_type\", kind: \"enum\", localName: \"call_type\", T: () => [\"types.CallType\", CallType] },\n            { no: 5, name: \"caller_address\", kind: \"scalar\", localName: \"caller_address\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TransactionCall>): TransactionCall {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_address = new Uint8Array(0);\n        message.entrypoint = \"\";\n        message.calldata = [];\n        message.call_type = 0;\n        message.caller_address = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<TransactionCall>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionCall): TransactionCall {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes contract_address */ 1:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* string entrypoint */ 2:\n                    message.entrypoint = reader.string();\n                    break;\n                case /* repeated bytes calldata */ 3:\n                    message.calldata.push(reader.bytes());\n                    break;\n                case /* types.CallType call_type */ 4:\n                    message.call_type = reader.int32();\n                    break;\n                case /* bytes caller_address */ 5:\n                    message.caller_address = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TransactionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes contract_address = 1; */\n        if (message.contract_address.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);\n        /* string entrypoint = 2; */\n        if (message.entrypoint !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.entrypoint);\n        /* repeated bytes calldata = 3; */\n        for (let i = 0; i < message.calldata.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);\n        /* types.CallType call_type = 4; */\n        if (message.call_type !== 0)\n            writer.tag(4, WireType.Varint).int32(message.call_type);\n        /* bytes caller_address = 5; */\n        if (message.caller_address.length)\n            writer.tag(5, WireType.LengthDelimited).bytes(message.caller_address);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TransactionCall\n */\nexport const TransactionCall = new TransactionCall$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Transaction$Type extends MessageType<Transaction> {\n    constructor() {\n        super(\"types.Transaction\", [\n            { no: 1, name: \"transaction_hash\", kind: \"scalar\", localName: \"transaction_hash\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"sender_address\", kind: \"scalar\", localName: \"sender_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"calldata\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"max_fee\", kind: \"scalar\", localName: \"max_fee\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 5, name: \"signature\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 6, name: \"nonce\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 7, name: \"block_number\", kind: \"scalar\", localName: \"block_number\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 8, name: \"transaction_type\", kind: \"scalar\", localName: \"transaction_type\", T: 9 /*ScalarType.STRING*/ },\n            { no: 9, name: \"block_timestamp\", kind: \"scalar\", localName: \"block_timestamp\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 10, name: \"calls\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TransactionCall },\n            { no: 11, name: \"unique_models\", kind: \"scalar\", localName: \"unique_models\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Transaction>): Transaction {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.transaction_hash = new Uint8Array(0);\n        message.sender_address = new Uint8Array(0);\n        message.calldata = [];\n        message.max_fee = new Uint8Array(0);\n        message.signature = [];\n        message.nonce = new Uint8Array(0);\n        message.block_number = 0n;\n        message.transaction_type = \"\";\n        message.block_timestamp = 0n;\n        message.calls = [];\n        message.unique_models = [];\n        if (value !== undefined)\n            reflectionMergePartial<Transaction>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes transaction_hash */ 1:\n                    message.transaction_hash = reader.bytes();\n                    break;\n                case /* bytes sender_address */ 2:\n                    message.sender_address = reader.bytes();\n                    break;\n                case /* repeated bytes calldata */ 3:\n                    message.calldata.push(reader.bytes());\n                    break;\n                case /* bytes max_fee */ 4:\n                    message.max_fee = reader.bytes();\n                    break;\n                case /* repeated bytes signature */ 5:\n                    message.signature.push(reader.bytes());\n                    break;\n                case /* bytes nonce */ 6:\n                    message.nonce = reader.bytes();\n                    break;\n                case /* uint64 block_number */ 7:\n                    message.block_number = reader.uint64().toBigInt();\n                    break;\n                case /* string transaction_type */ 8:\n                    message.transaction_type = reader.string();\n                    break;\n                case /* uint64 block_timestamp */ 9:\n                    message.block_timestamp = reader.uint64().toBigInt();\n                    break;\n                case /* repeated types.TransactionCall calls */ 10:\n                    message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated bytes unique_models */ 11:\n                    message.unique_models.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes transaction_hash = 1; */\n        if (message.transaction_hash.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hash);\n        /* bytes sender_address = 2; */\n        if (message.sender_address.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.sender_address);\n        /* repeated bytes calldata = 3; */\n        for (let i = 0; i < message.calldata.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);\n        /* bytes max_fee = 4; */\n        if (message.max_fee.length)\n            writer.tag(4, WireType.LengthDelimited).bytes(message.max_fee);\n        /* repeated bytes signature = 5; */\n        for (let i = 0; i < message.signature.length; i++)\n            writer.tag(5, WireType.LengthDelimited).bytes(message.signature[i]);\n        /* bytes nonce = 6; */\n        if (message.nonce.length)\n            writer.tag(6, WireType.LengthDelimited).bytes(message.nonce);\n        /* uint64 block_number = 7; */\n        if (message.block_number !== 0n)\n            writer.tag(7, WireType.Varint).uint64(message.block_number);\n        /* string transaction_type = 8; */\n        if (message.transaction_type !== \"\")\n            writer.tag(8, WireType.LengthDelimited).string(message.transaction_type);\n        /* uint64 block_timestamp = 9; */\n        if (message.block_timestamp !== 0n)\n            writer.tag(9, WireType.Varint).uint64(message.block_timestamp);\n        /* repeated types.TransactionCall calls = 10; */\n        for (let i = 0; i < message.calls.length; i++)\n            TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();\n        /* repeated bytes unique_models = 11; */\n        for (let i = 0; i < message.unique_models.length; i++)\n            writer.tag(11, WireType.LengthDelimited).bytes(message.unique_models[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Transaction\n */\nexport const Transaction = new Transaction$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TransactionFilter$Type extends MessageType<TransactionFilter> {\n    constructor() {\n        super(\"types.TransactionFilter\", [\n            { no: 1, name: \"transaction_hashes\", kind: \"scalar\", localName: \"transaction_hashes\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"caller_addresses\", kind: \"scalar\", localName: \"caller_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"entrypoints\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },\n            { no: 5, name: \"model_selectors\", kind: \"scalar\", localName: \"model_selectors\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 6, name: \"from_block\", kind: \"scalar\", localName: \"from_block\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 7, name: \"to_block\", kind: \"scalar\", localName: \"to_block\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TransactionFilter>): TransactionFilter {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.transaction_hashes = [];\n        message.caller_addresses = [];\n        message.contract_addresses = [];\n        message.entrypoints = [];\n        message.model_selectors = [];\n        if (value !== undefined)\n            reflectionMergePartial<TransactionFilter>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionFilter): TransactionFilter {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes transaction_hashes */ 1:\n                    message.transaction_hashes.push(reader.bytes());\n                    break;\n                case /* repeated bytes caller_addresses */ 2:\n                    message.caller_addresses.push(reader.bytes());\n                    break;\n                case /* repeated bytes contract_addresses */ 3:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated string entrypoints */ 4:\n                    message.entrypoints.push(reader.string());\n                    break;\n                case /* repeated bytes model_selectors */ 5:\n                    message.model_selectors.push(reader.bytes());\n                    break;\n                case /* optional uint64 from_block */ 6:\n                    message.from_block = reader.uint64().toBigInt();\n                    break;\n                case /* optional uint64 to_block */ 7:\n                    message.to_block = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TransactionFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes transaction_hashes = 1; */\n        for (let i = 0; i < message.transaction_hashes.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hashes[i]);\n        /* repeated bytes caller_addresses = 2; */\n        for (let i = 0; i < message.caller_addresses.length; i++)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.caller_addresses[i]);\n        /* repeated bytes contract_addresses = 3; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated string entrypoints = 4; */\n        for (let i = 0; i < message.entrypoints.length; i++)\n            writer.tag(4, WireType.LengthDelimited).string(message.entrypoints[i]);\n        /* repeated bytes model_selectors = 5; */\n        for (let i = 0; i < message.model_selectors.length; i++)\n            writer.tag(5, WireType.LengthDelimited).bytes(message.model_selectors[i]);\n        /* optional uint64 from_block = 6; */\n        if (message.from_block !== undefined)\n            writer.tag(6, WireType.Varint).uint64(message.from_block);\n        /* optional uint64 to_block = 7; */\n        if (message.to_block !== undefined)\n            writer.tag(7, WireType.Varint).uint64(message.to_block);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TransactionFilter\n */\nexport const TransactionFilter = new TransactionFilter$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TransactionQuery$Type extends MessageType<TransactionQuery> {\n    constructor() {\n        super(\"types.TransactionQuery\", [\n            { no: 1, name: \"filter\", kind: \"message\", T: () => TransactionFilter },\n            { no: 2, name: \"pagination\", kind: \"message\", T: () => Pagination }\n        ]);\n    }\n    create(value?: PartialMessage<TransactionQuery>): TransactionQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<TransactionQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionQuery): TransactionQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.TransactionFilter filter */ 1:\n                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);\n                    break;\n                case /* types.Pagination pagination */ 2:\n                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TransactionQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.TransactionFilter filter = 1; */\n        if (message.filter)\n            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* types.Pagination pagination = 2; */\n        if (message.pagination)\n            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.TransactionQuery\n */\nexport const TransactionQuery = new TransactionQuery$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Contract$Type extends MessageType<Contract> {\n    constructor() {\n        super(\"types.Contract\", [\n            { no: 1, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"contract_type\", kind: \"enum\", localName: \"contract_type\", T: () => [\"types.ContractType\", ContractType] },\n            { no: 3, name: \"head\", kind: \"scalar\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 4, name: \"tps\", kind: \"scalar\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 5, name: \"last_block_timestamp\", kind: \"scalar\", localName: \"last_block_timestamp\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 6, name: \"last_pending_block_tx\", kind: \"scalar\", localName: \"last_pending_block_tx\", opt: true, T: 12 /*ScalarType.BYTES*/ },\n            { no: 7, name: \"updated_at\", kind: \"scalar\", localName: \"updated_at\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 8, name: \"created_at\", kind: \"scalar\", localName: \"created_at\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Contract>): Contract {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_address = new Uint8Array(0);\n        message.contract_type = 0;\n        message.updated_at = 0n;\n        message.created_at = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<Contract>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes contract_address */ 1:\n                    message.contract_address = reader.bytes();\n                    break;\n                case /* types.ContractType contract_type */ 2:\n                    message.contract_type = reader.int32();\n                    break;\n                case /* optional uint64 head */ 3:\n                    message.head = reader.uint64().toBigInt();\n                    break;\n                case /* optional uint64 tps */ 4:\n                    message.tps = reader.uint64().toBigInt();\n                    break;\n                case /* optional uint64 last_block_timestamp */ 5:\n                    message.last_block_timestamp = reader.uint64().toBigInt();\n                    break;\n                case /* optional bytes last_pending_block_tx */ 6:\n                    message.last_pending_block_tx = reader.bytes();\n                    break;\n                case /* uint64 updated_at */ 7:\n                    message.updated_at = reader.uint64().toBigInt();\n                    break;\n                case /* uint64 created_at */ 8:\n                    message.created_at = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes contract_address = 1; */\n        if (message.contract_address.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);\n        /* types.ContractType contract_type = 2; */\n        if (message.contract_type !== 0)\n            writer.tag(2, WireType.Varint).int32(message.contract_type);\n        /* optional uint64 head = 3; */\n        if (message.head !== undefined)\n            writer.tag(3, WireType.Varint).uint64(message.head);\n        /* optional uint64 tps = 4; */\n        if (message.tps !== undefined)\n            writer.tag(4, WireType.Varint).uint64(message.tps);\n        /* optional uint64 last_block_timestamp = 5; */\n        if (message.last_block_timestamp !== undefined)\n            writer.tag(5, WireType.Varint).uint64(message.last_block_timestamp);\n        /* optional bytes last_pending_block_tx = 6; */\n        if (message.last_pending_block_tx !== undefined)\n            writer.tag(6, WireType.LengthDelimited).bytes(message.last_pending_block_tx);\n        /* uint64 updated_at = 7; */\n        if (message.updated_at !== 0n)\n            writer.tag(7, WireType.Varint).uint64(message.updated_at);\n        /* uint64 created_at = 8; */\n        if (message.created_at !== 0n)\n            writer.tag(8, WireType.Varint).uint64(message.created_at);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Contract\n */\nexport const Contract = new Contract$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ContractQuery$Type extends MessageType<ContractQuery> {\n    constructor() {\n        super(\"types.ContractQuery\", [\n            { no: 1, name: \"contract_addresses\", kind: \"scalar\", localName: \"contract_addresses\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"contract_types\", kind: \"enum\", localName: \"contract_types\", repeat: 1 /*RepeatType.PACKED*/, T: () => [\"types.ContractType\", ContractType] }\n        ]);\n    }\n    create(value?: PartialMessage<ContractQuery>): ContractQuery {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.contract_addresses = [];\n        message.contract_types = [];\n        if (value !== undefined)\n            reflectionMergePartial<ContractQuery>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractQuery): ContractQuery {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes contract_addresses */ 1:\n                    message.contract_addresses.push(reader.bytes());\n                    break;\n                case /* repeated types.ContractType contract_types */ 2:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.contract_types.push(reader.int32());\n                    else\n                        message.contract_types.push(reader.int32());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes contract_addresses = 1; */\n        for (let i = 0; i < message.contract_addresses.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);\n        /* repeated types.ContractType contract_types = 2; */\n        if (message.contract_types.length) {\n            writer.tag(2, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.contract_types.length; i++)\n                writer.int32(message.contract_types[i]);\n            writer.join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.ContractQuery\n */\nexport const ContractQuery = new ContractQuery$Type();\n","// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic\n// @generated from protobuf file \"schema.proto\" (package \"types\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message types.EnumOption\n */\nexport interface EnumOption {\n    /**\n     * @generated from protobuf field: string name = 1\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: types.Ty ty = 2\n     */\n    ty?: Ty;\n}\n/**\n * @generated from protobuf message types.Enum\n */\nexport interface Enum {\n    /**\n     * @generated from protobuf field: string name = 1\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: uint32 option = 2\n     */\n    option: number;\n    /**\n     * @generated from protobuf field: repeated types.EnumOption options = 3\n     */\n    options: EnumOption[];\n}\n/**\n * @generated from protobuf message types.Primitive\n */\nexport interface Primitive {\n    /**\n     * @generated from protobuf oneof: primitive_type\n     */\n    primitive_type: {\n        oneofKind: \"i8\";\n        /**\n         * @generated from protobuf field: int32 i8 = 1\n         */\n        i8: number;\n    } | {\n        oneofKind: \"i16\";\n        /**\n         * @generated from protobuf field: int32 i16 = 2\n         */\n        i16: number;\n    } | {\n        oneofKind: \"i32\";\n        /**\n         * @generated from protobuf field: int32 i32 = 3\n         */\n        i32: number;\n    } | {\n        oneofKind: \"i64\";\n        /**\n         * @generated from protobuf field: int64 i64 = 4\n         */\n        i64: bigint;\n    } | {\n        oneofKind: \"i128\";\n        /**\n         * @generated from protobuf field: bytes i128 = 5\n         */\n        i128: Uint8Array;\n    } | {\n        oneofKind: \"u8\";\n        /**\n         * @generated from protobuf field: uint32 u8 = 6\n         */\n        u8: number;\n    } | {\n        oneofKind: \"u16\";\n        /**\n         * @generated from protobuf field: uint32 u16 = 7\n         */\n        u16: number;\n    } | {\n        oneofKind: \"u32\";\n        /**\n         * @generated from protobuf field: uint32 u32 = 8\n         */\n        u32: number;\n    } | {\n        oneofKind: \"u64\";\n        /**\n         * @generated from protobuf field: uint64 u64 = 9\n         */\n        u64: bigint;\n    } | {\n        oneofKind: \"u128\";\n        /**\n         * @generated from protobuf field: bytes u128 = 10\n         */\n        u128: Uint8Array;\n    } | {\n        oneofKind: \"u256\";\n        /**\n         * @generated from protobuf field: bytes u256 = 11\n         */\n        u256: Uint8Array;\n    } | {\n        oneofKind: \"bool\";\n        /**\n         * @generated from protobuf field: bool bool = 12\n         */\n        bool: boolean;\n    } | {\n        oneofKind: \"felt252\";\n        /**\n         * @generated from protobuf field: bytes felt252 = 13\n         */\n        felt252: Uint8Array;\n    } | {\n        oneofKind: \"class_hash\";\n        /**\n         * @generated from protobuf field: bytes class_hash = 14\n         */\n        class_hash: Uint8Array;\n    } | {\n        oneofKind: \"contract_address\";\n        /**\n         * @generated from protobuf field: bytes contract_address = 15\n         */\n        contract_address: Uint8Array;\n    } | {\n        oneofKind: \"eth_address\";\n        /**\n         * @generated from protobuf field: bytes eth_address = 16\n         */\n        eth_address: Uint8Array;\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message types.Struct\n */\nexport interface Struct {\n    /**\n     * @generated from protobuf field: string name = 1\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: repeated types.Member children = 2\n     */\n    children: Member[];\n}\n/**\n * @generated from protobuf message types.Array\n */\nexport interface Array$ {\n    /**\n     * @generated from protobuf field: repeated types.Ty children = 1\n     */\n    children: Ty[];\n}\n/**\n * @generated from protobuf message types.FixedSizeArray\n */\nexport interface FixedSizeArray {\n    /**\n     * @generated from protobuf field: repeated types.Ty children = 1\n     */\n    children: Ty[];\n    /**\n     * @generated from protobuf field: uint32 size = 2\n     */\n    size: number;\n}\n/**\n * @generated from protobuf message types.Ty\n */\nexport interface Ty {\n    /**\n     * @generated from protobuf oneof: ty_type\n     */\n    ty_type: {\n        oneofKind: \"primitive\";\n        /**\n         * @generated from protobuf field: types.Primitive primitive = 2\n         */\n        primitive: Primitive;\n    } | {\n        oneofKind: \"enum\";\n        /**\n         * @generated from protobuf field: types.Enum enum = 3\n         */\n        enum: Enum;\n    } | {\n        oneofKind: \"struct\";\n        /**\n         * @generated from protobuf field: types.Struct struct = 4\n         */\n        struct: Struct;\n    } | {\n        oneofKind: \"tuple\";\n        /**\n         * @generated from protobuf field: types.Array tuple = 5\n         */\n        tuple: Array$;\n    } | {\n        oneofKind: \"array\";\n        /**\n         * @generated from protobuf field: types.Array array = 6\n         */\n        array: Array$;\n    } | {\n        oneofKind: \"bytearray\";\n        /**\n         * @generated from protobuf field: string bytearray = 7\n         */\n        bytearray: string;\n    } | {\n        oneofKind: \"fixed_size_array\";\n        /**\n         * @generated from protobuf field: types.FixedSizeArray fixed_size_array = 8\n         */\n        fixed_size_array: FixedSizeArray;\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message types.Member\n */\nexport interface Member {\n    /**\n     * @generated from protobuf field: string name = 1\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: types.Ty ty = 2\n     */\n    ty?: Ty;\n    /**\n     * @generated from protobuf field: bool key = 3\n     */\n    key: boolean;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass EnumOption$Type extends MessageType<EnumOption> {\n    constructor() {\n        super(\"types.EnumOption\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"ty\", kind: \"message\", T: () => Ty }\n        ]);\n    }\n    create(value?: PartialMessage<EnumOption>): EnumOption {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.name = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<EnumOption>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumOption): EnumOption {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* types.Ty ty */ 2:\n                    message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: EnumOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        /* types.Ty ty = 2; */\n        if (message.ty)\n            Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.EnumOption\n */\nexport const EnumOption = new EnumOption$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Enum$Type extends MessageType<Enum> {\n    constructor() {\n        super(\"types.Enum\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"option\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 3, name: \"options\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EnumOption }\n        ]);\n    }\n    create(value?: PartialMessage<Enum>): Enum {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.name = \"\";\n        message.option = 0;\n        message.options = [];\n        if (value !== undefined)\n            reflectionMergePartial<Enum>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enum): Enum {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* uint32 option */ 2:\n                    message.option = reader.uint32();\n                    break;\n                case /* repeated types.EnumOption options */ 3:\n                    message.options.push(EnumOption.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Enum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        /* uint32 option = 2; */\n        if (message.option !== 0)\n            writer.tag(2, WireType.Varint).uint32(message.option);\n        /* repeated types.EnumOption options = 3; */\n        for (let i = 0; i < message.options.length; i++)\n            EnumOption.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Enum\n */\nexport const Enum = new Enum$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Primitive$Type extends MessageType<Primitive> {\n    constructor() {\n        super(\"types.Primitive\", [\n            { no: 1, name: \"i8\", kind: \"scalar\", oneof: \"primitive_type\", T: 5 /*ScalarType.INT32*/ },\n            { no: 2, name: \"i16\", kind: \"scalar\", oneof: \"primitive_type\", T: 5 /*ScalarType.INT32*/ },\n            { no: 3, name: \"i32\", kind: \"scalar\", oneof: \"primitive_type\", T: 5 /*ScalarType.INT32*/ },\n            { no: 4, name: \"i64\", kind: \"scalar\", oneof: \"primitive_type\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 5, name: \"i128\", kind: \"scalar\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 6, name: \"u8\", kind: \"scalar\", oneof: \"primitive_type\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 7, name: \"u16\", kind: \"scalar\", oneof: \"primitive_type\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 8, name: \"u32\", kind: \"scalar\", oneof: \"primitive_type\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 9, name: \"u64\", kind: \"scalar\", oneof: \"primitive_type\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 10, name: \"u128\", kind: \"scalar\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 11, name: \"u256\", kind: \"scalar\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 12, name: \"bool\", kind: \"scalar\", oneof: \"primitive_type\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 13, name: \"felt252\", kind: \"scalar\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 14, name: \"class_hash\", kind: \"scalar\", localName: \"class_hash\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 15, name: \"contract_address\", kind: \"scalar\", localName: \"contract_address\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 16, name: \"eth_address\", kind: \"scalar\", localName: \"eth_address\", oneof: \"primitive_type\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Primitive>): Primitive {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.primitive_type = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<Primitive>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Primitive): Primitive {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int32 i8 */ 1:\n                    message.primitive_type = {\n                        oneofKind: \"i8\",\n                        i8: reader.int32()\n                    };\n                    break;\n                case /* int32 i16 */ 2:\n                    message.primitive_type = {\n                        oneofKind: \"i16\",\n                        i16: reader.int32()\n                    };\n                    break;\n                case /* int32 i32 */ 3:\n                    message.primitive_type = {\n                        oneofKind: \"i32\",\n                        i32: reader.int32()\n                    };\n                    break;\n                case /* int64 i64 */ 4:\n                    message.primitive_type = {\n                        oneofKind: \"i64\",\n                        i64: reader.int64().toBigInt()\n                    };\n                    break;\n                case /* bytes i128 */ 5:\n                    message.primitive_type = {\n                        oneofKind: \"i128\",\n                        i128: reader.bytes()\n                    };\n                    break;\n                case /* uint32 u8 */ 6:\n                    message.primitive_type = {\n                        oneofKind: \"u8\",\n                        u8: reader.uint32()\n                    };\n                    break;\n                case /* uint32 u16 */ 7:\n                    message.primitive_type = {\n                        oneofKind: \"u16\",\n                        u16: reader.uint32()\n                    };\n                    break;\n                case /* uint32 u32 */ 8:\n                    message.primitive_type = {\n                        oneofKind: \"u32\",\n                        u32: reader.uint32()\n                    };\n                    break;\n                case /* uint64 u64 */ 9:\n                    message.primitive_type = {\n                        oneofKind: \"u64\",\n                        u64: reader.uint64().toBigInt()\n                    };\n                    break;\n                case /* bytes u128 */ 10:\n                    message.primitive_type = {\n                        oneofKind: \"u128\",\n                        u128: reader.bytes()\n                    };\n                    break;\n                case /* bytes u256 */ 11:\n                    message.primitive_type = {\n                        oneofKind: \"u256\",\n                        u256: reader.bytes()\n                    };\n                    break;\n                case /* bool bool */ 12:\n                    message.primitive_type = {\n                        oneofKind: \"bool\",\n                        bool: reader.bool()\n                    };\n                    break;\n                case /* bytes felt252 */ 13:\n                    message.primitive_type = {\n                        oneofKind: \"felt252\",\n                        felt252: reader.bytes()\n                    };\n                    break;\n                case /* bytes class_hash */ 14:\n                    message.primitive_type = {\n                        oneofKind: \"class_hash\",\n                        class_hash: reader.bytes()\n                    };\n                    break;\n                case /* bytes contract_address */ 15:\n                    message.primitive_type = {\n                        oneofKind: \"contract_address\",\n                        contract_address: reader.bytes()\n                    };\n                    break;\n                case /* bytes eth_address */ 16:\n                    message.primitive_type = {\n                        oneofKind: \"eth_address\",\n                        eth_address: reader.bytes()\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Primitive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int32 i8 = 1; */\n        if (message.primitive_type.oneofKind === \"i8\")\n            writer.tag(1, WireType.Varint).int32(message.primitive_type.i8);\n        /* int32 i16 = 2; */\n        if (message.primitive_type.oneofKind === \"i16\")\n            writer.tag(2, WireType.Varint).int32(message.primitive_type.i16);\n        /* int32 i32 = 3; */\n        if (message.primitive_type.oneofKind === \"i32\")\n            writer.tag(3, WireType.Varint).int32(message.primitive_type.i32);\n        /* int64 i64 = 4; */\n        if (message.primitive_type.oneofKind === \"i64\")\n            writer.tag(4, WireType.Varint).int64(message.primitive_type.i64);\n        /* bytes i128 = 5; */\n        if (message.primitive_type.oneofKind === \"i128\")\n            writer.tag(5, WireType.LengthDelimited).bytes(message.primitive_type.i128);\n        /* uint32 u8 = 6; */\n        if (message.primitive_type.oneofKind === \"u8\")\n            writer.tag(6, WireType.Varint).uint32(message.primitive_type.u8);\n        /* uint32 u16 = 7; */\n        if (message.primitive_type.oneofKind === \"u16\")\n            writer.tag(7, WireType.Varint).uint32(message.primitive_type.u16);\n        /* uint32 u32 = 8; */\n        if (message.primitive_type.oneofKind === \"u32\")\n            writer.tag(8, WireType.Varint).uint32(message.primitive_type.u32);\n        /* uint64 u64 = 9; */\n        if (message.primitive_type.oneofKind === \"u64\")\n            writer.tag(9, WireType.Varint).uint64(message.primitive_type.u64);\n        /* bytes u128 = 10; */\n        if (message.primitive_type.oneofKind === \"u128\")\n            writer.tag(10, WireType.LengthDelimited).bytes(message.primitive_type.u128);\n        /* bytes u256 = 11; */\n        if (message.primitive_type.oneofKind === \"u256\")\n            writer.tag(11, WireType.LengthDelimited).bytes(message.primitive_type.u256);\n        /* bool bool = 12; */\n        if (message.primitive_type.oneofKind === \"bool\")\n            writer.tag(12, WireType.Varint).bool(message.primitive_type.bool);\n        /* bytes felt252 = 13; */\n        if (message.primitive_type.oneofKind === \"felt252\")\n            writer.tag(13, WireType.LengthDelimited).bytes(message.primitive_type.felt252);\n        /* bytes class_hash = 14; */\n        if (message.primitive_type.oneofKind === \"class_hash\")\n            writer.tag(14, WireType.LengthDelimited).bytes(message.primitive_type.class_hash);\n        /* bytes contract_address = 15; */\n        if (message.primitive_type.oneofKind === \"contract_address\")\n            writer.tag(15, WireType.LengthDelimited).bytes(message.primitive_type.contract_address);\n        /* bytes eth_address = 16; */\n        if (message.primitive_type.oneofKind === \"eth_address\")\n            writer.tag(16, WireType.LengthDelimited).bytes(message.primitive_type.eth_address);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Primitive\n */\nexport const Primitive = new Primitive$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Struct$Type extends MessageType<Struct> {\n    constructor() {\n        super(\"types.Struct\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"children\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Member }\n        ]);\n    }\n    create(value?: PartialMessage<Struct>): Struct {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.name = \"\";\n        message.children = [];\n        if (value !== undefined)\n            reflectionMergePartial<Struct>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Struct): Struct {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* repeated types.Member children */ 2:\n                    message.children.push(Member.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Struct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        /* repeated types.Member children = 2; */\n        for (let i = 0; i < message.children.length; i++)\n            Member.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Struct\n */\nexport const Struct = new Struct$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Array$$Type extends MessageType<Array$> {\n    constructor() {\n        super(\"types.Array\", [\n            { no: 1, name: \"children\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Ty }\n        ]);\n    }\n    create(value?: PartialMessage<Array$>): Array$ {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.children = [];\n        if (value !== undefined)\n            reflectionMergePartial<Array$>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Array$): Array$ {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated types.Ty children */ 1:\n                    message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated types.Ty children = 1; */\n        for (let i = 0; i < message.children.length; i++)\n            Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Array\n */\nexport const Array$ = new Array$$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FixedSizeArray$Type extends MessageType<FixedSizeArray> {\n    constructor() {\n        super(\"types.FixedSizeArray\", [\n            { no: 1, name: \"children\", kind: \"message\", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Ty },\n            { no: 2, name: \"size\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ }\n        ]);\n    }\n    create(value?: PartialMessage<FixedSizeArray>): FixedSizeArray {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.children = [];\n        message.size = 0;\n        if (value !== undefined)\n            reflectionMergePartial<FixedSizeArray>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedSizeArray): FixedSizeArray {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated types.Ty children */ 1:\n                    message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* uint32 size */ 2:\n                    message.size = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: FixedSizeArray, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated types.Ty children = 1; */\n        for (let i = 0; i < message.children.length; i++)\n            Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* uint32 size = 2; */\n        if (message.size !== 0)\n            writer.tag(2, WireType.Varint).uint32(message.size);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.FixedSizeArray\n */\nexport const FixedSizeArray = new FixedSizeArray$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Ty$Type extends MessageType<Ty> {\n    constructor() {\n        super(\"types.Ty\", [\n            { no: 2, name: \"primitive\", kind: \"message\", oneof: \"ty_type\", T: () => Primitive },\n            { no: 3, name: \"enum\", kind: \"message\", oneof: \"ty_type\", T: () => Enum },\n            { no: 4, name: \"struct\", kind: \"message\", oneof: \"ty_type\", T: () => Struct },\n            { no: 5, name: \"tuple\", kind: \"message\", oneof: \"ty_type\", T: () => Array$ },\n            { no: 6, name: \"array\", kind: \"message\", oneof: \"ty_type\", T: () => Array$ },\n            { no: 7, name: \"bytearray\", kind: \"scalar\", oneof: \"ty_type\", T: 9 /*ScalarType.STRING*/ },\n            { no: 8, name: \"fixed_size_array\", kind: \"message\", localName: \"fixed_size_array\", oneof: \"ty_type\", T: () => FixedSizeArray }\n        ]);\n    }\n    create(value?: PartialMessage<Ty>): Ty {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.ty_type = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<Ty>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ty): Ty {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* types.Primitive primitive */ 2:\n                    message.ty_type = {\n                        oneofKind: \"primitive\",\n                        primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).primitive)\n                    };\n                    break;\n                case /* types.Enum enum */ 3:\n                    message.ty_type = {\n                        oneofKind: \"enum\",\n                        enum: Enum.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).enum)\n                    };\n                    break;\n                case /* types.Struct struct */ 4:\n                    message.ty_type = {\n                        oneofKind: \"struct\",\n                        struct: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).struct)\n                    };\n                    break;\n                case /* types.Array tuple */ 5:\n                    message.ty_type = {\n                        oneofKind: \"tuple\",\n                        tuple: Array$.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).tuple)\n                    };\n                    break;\n                case /* types.Array array */ 6:\n                    message.ty_type = {\n                        oneofKind: \"array\",\n                        array: Array$.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).array)\n                    };\n                    break;\n                case /* string bytearray */ 7:\n                    message.ty_type = {\n                        oneofKind: \"bytearray\",\n                        bytearray: reader.string()\n                    };\n                    break;\n                case /* types.FixedSizeArray fixed_size_array */ 8:\n                    message.ty_type = {\n                        oneofKind: \"fixed_size_array\",\n                        fixed_size_array: FixedSizeArray.internalBinaryRead(reader, reader.uint32(), options, (message.ty_type as any).fixed_size_array)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Ty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* types.Primitive primitive = 2; */\n        if (message.ty_type.oneofKind === \"primitive\")\n            Primitive.internalBinaryWrite(message.ty_type.primitive, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* types.Enum enum = 3; */\n        if (message.ty_type.oneofKind === \"enum\")\n            Enum.internalBinaryWrite(message.ty_type.enum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        /* types.Struct struct = 4; */\n        if (message.ty_type.oneofKind === \"struct\")\n            Struct.internalBinaryWrite(message.ty_type.struct, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        /* types.Array tuple = 5; */\n        if (message.ty_type.oneofKind === \"tuple\")\n            Array$.internalBinaryWrite(message.ty_type.tuple, writer.tag(5, WireType.LengthDelimited).fork(), options).join();\n        /* types.Array array = 6; */\n        if (message.ty_type.oneofKind === \"array\")\n            Array$.internalBinaryWrite(message.ty_type.array, writer.tag(6, WireType.LengthDelimited).fork(), options).join();\n        /* string bytearray = 7; */\n        if (message.ty_type.oneofKind === \"bytearray\")\n            writer.tag(7, WireType.LengthDelimited).string(message.ty_type.bytearray);\n        /* types.FixedSizeArray fixed_size_array = 8; */\n        if (message.ty_type.oneofKind === \"fixed_size_array\")\n            FixedSizeArray.internalBinaryWrite(message.ty_type.fixed_size_array, writer.tag(8, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Ty\n */\nexport const Ty = new Ty$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Member$Type extends MessageType<Member> {\n    constructor() {\n        super(\"types.Member\", [\n            { no: 1, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"ty\", kind: \"message\", T: () => Ty },\n            { no: 3, name: \"key\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Member>): Member {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.name = \"\";\n        message.key = false;\n        if (value !== undefined)\n            reflectionMergePartial<Member>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Member): Member {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* types.Ty ty */ 2:\n                    message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);\n                    break;\n                case /* bool key */ 3:\n                    message.key = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string name = 1; */\n        if (message.name !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.name);\n        /* types.Ty ty = 2; */\n        if (message.ty)\n            Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* bool key = 3; */\n        if (message.key !== false)\n            writer.tag(3, WireType.Varint).bool(message.key);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message types.Member\n */\nexport const Member = new Member$Type();\n","// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic\n// @generated from protobuf file \"world.proto\" (package \"world\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { World } from \"./world\";\nimport type { PublishMessageBatchResponse } from \"./world\";\nimport type { PublishMessageBatchRequest } from \"./world\";\nimport type { PublishMessageResponse } from \"./world\";\nimport type { PublishMessageRequest } from \"./world\";\nimport type { RetrieveTokenContractsResponse } from \"./world\";\nimport type { RetrieveTokenContractsRequest } from \"./world\";\nimport type { RetrieveContractsResponse } from \"./world\";\nimport type { RetrieveContractsRequest } from \"./world\";\nimport type { RetrieveControllersResponse } from \"./world\";\nimport type { RetrieveControllersRequest } from \"./world\";\nimport type { SubscribeTransactionsResponse } from \"./world\";\nimport type { SubscribeTransactionsRequest } from \"./world\";\nimport type { RetrieveTransactionsResponse } from \"./world\";\nimport type { RetrieveTransactionsRequest } from \"./world\";\nimport type { RetrieveTokenBalancesResponse } from \"./world\";\nimport type { RetrieveTokenBalancesRequest } from \"./world\";\nimport type { RetrieveTokensResponse } from \"./world\";\nimport type { RetrieveTokensRequest } from \"./world\";\nimport type { SubscribeEventsResponse } from \"./world\";\nimport type { SubscribeEventsRequest } from \"./world\";\nimport type { RetrieveEventsResponse } from \"./world\";\nimport type { RetrieveEventsRequest } from \"./world\";\nimport type { RetrieveEventMessagesRequest } from \"./world\";\nimport type { UpdateTokenSubscriptionRequest } from \"./world\";\nimport type { SubscribeTokensResponse } from \"./world\";\nimport type { SubscribeTokensRequest } from \"./world\";\nimport type { UpdateTokenBalancesSubscriptionRequest } from \"./world\";\nimport type { SubscribeTokenBalancesResponse } from \"./world\";\nimport type { SubscribeTokenBalancesRequest } from \"./world\";\nimport type { UpdateEventMessagesSubscriptionRequest } from \"./world\";\nimport type { SubscribeEventMessagesRequest } from \"./world\";\nimport type { RetrieveEntitiesResponse } from \"./world\";\nimport type { RetrieveEntitiesRequest } from \"./world\";\nimport type { Empty } from \"./google/protobuf/empty\";\nimport type { UpdateEntitiesSubscriptionRequest } from \"./world\";\nimport type { SubscribeEntityResponse } from \"./world\";\nimport type { SubscribeEntitiesRequest } from \"./world\";\nimport type { WorldMetadataResponse } from \"./world\";\nimport type { WorldMetadataRequest } from \"./world\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { SubscribeContractsResponse } from \"./world\";\nimport type { SubscribeContractsRequest } from \"./world\";\nimport type { ServerStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * The World service provides information about the world.\n *\n * @generated from protobuf service world.World\n */\nexport interface IWorldClient {\n    /**\n     * Subscribes to updates about contracts. Like the head block number, tps, etc.\n     *\n     * @generated from protobuf rpc: SubscribeContracts\n     */\n    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse>;\n    /**\n     * Retrieves metadata about the World including all the registered components and systems.\n     *\n     * @generated from protobuf rpc: WorldMetadata\n     */\n    worldMetadata(input: WorldMetadataRequest, options?: RpcOptions): UnaryCall<WorldMetadataRequest, WorldMetadataResponse>;\n    /**\n     * Subscribe to entity updates.\n     *\n     * @generated from protobuf rpc: SubscribeEntities\n     */\n    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;\n    /**\n     * Update entity subscription\n     *\n     * @generated from protobuf rpc: UpdateEntitiesSubscription\n     */\n    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;\n    /**\n     * Retrieve entities\n     *\n     * @generated from protobuf rpc: RetrieveEntities\n     */\n    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;\n    /**\n     * Subscribe to entity updates.\n     *\n     * @generated from protobuf rpc: SubscribeEventMessages\n     */\n    subscribeEventMessages(input: SubscribeEventMessagesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventMessagesRequest, SubscribeEntityResponse>;\n    /**\n     * Update entity subscription\n     *\n     * @generated from protobuf rpc: UpdateEventMessagesSubscription\n     */\n    updateEventMessagesSubscription(input: UpdateEventMessagesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEventMessagesSubscriptionRequest, Empty>;\n    /**\n     * Subscribe to token balance updates.\n     *\n     * @generated from protobuf rpc: SubscribeTokenBalances\n     */\n    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>;\n    /**\n     * Update token balance subscription\n     *\n     * @generated from protobuf rpc: UpdateTokenBalancesSubscription\n     */\n    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty>;\n    /**\n     * Subscribe to token updates.\n     *\n     * @generated from protobuf rpc: SubscribeTokens\n     */\n    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse>;\n    /**\n     * Update token subscription\n     *\n     * @generated from protobuf rpc: UpdateTokensSubscription\n     */\n    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty>;\n    /**\n     * Retrieve entities\n     *\n     * @generated from protobuf rpc: RetrieveEventMessages\n     */\n    retrieveEventMessages(input: RetrieveEventMessagesRequest, options?: RpcOptions): UnaryCall<RetrieveEventMessagesRequest, RetrieveEntitiesResponse>;\n    /**\n     * Retrieve events\n     *\n     * @generated from protobuf rpc: RetrieveEvents\n     */\n    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse>;\n    /**\n     * Subscribe to events\n     *\n     * @generated from protobuf rpc: SubscribeEvents\n     */\n    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse>;\n    /**\n     * Retrieve tokens\n     *\n     * @generated from protobuf rpc: RetrieveTokens\n     */\n    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse>;\n    /**\n     * Retrieve token balances\n     *\n     * @generated from protobuf rpc: RetrieveTokenBalances\n     */\n    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>;\n    /**\n     * Retrieve transactions\n     *\n     * @generated from protobuf rpc: RetrieveTransactions\n     */\n    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse>;\n    /**\n     * Subscribe to transactions\n     *\n     * @generated from protobuf rpc: SubscribeTransactions\n     */\n    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse>;\n    /**\n     * Retrieve controllers\n     *\n     * @generated from protobuf rpc: RetrieveControllers\n     */\n    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse>;\n    /**\n     * Retrieve contracts\n     *\n     * @generated from protobuf rpc: RetrieveContracts\n     */\n    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse>;\n    /**\n     * Retrieve tokens contracts\n     *\n     * @generated from protobuf rpc: RetrieveTokenContracts\n     */\n    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>;\n    /**\n     * Publish a torii offchain message\n     *\n     * @generated from protobuf rpc: PublishMessage\n     */\n    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse>;\n    /**\n     * Publish a set of torii offchain messages\n     *\n     * @generated from protobuf rpc: PublishMessageBatch\n     */\n    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse>;\n}\n/**\n * The World service provides information about the world.\n *\n * @generated from protobuf service world.World\n */\nexport class WorldClient implements IWorldClient, ServiceInfo {\n    typeName = World.typeName;\n    methods = World.methods;\n    options = World.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * Subscribes to updates about contracts. Like the head block number, tps, etc.\n     *\n     * @generated from protobuf rpc: SubscribeContracts\n     */\n    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeContractsRequest, SubscribeContractsResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieves metadata about the World including all the registered components and systems.\n     *\n     * @generated from protobuf rpc: WorldMetadata\n     */\n    worldMetadata(input: WorldMetadataRequest, options?: RpcOptions): UnaryCall<WorldMetadataRequest, WorldMetadataResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<WorldMetadataRequest, WorldMetadataResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to entity updates.\n     *\n     * @generated from protobuf rpc: SubscribeEntities\n     */\n    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeEntitiesRequest, SubscribeEntityResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Update entity subscription\n     *\n     * @generated from protobuf rpc: UpdateEntitiesSubscription\n     */\n    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpdateEntitiesSubscriptionRequest, Empty>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve entities\n     *\n     * @generated from protobuf rpc: RetrieveEntities\n     */\n    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveEntitiesRequest, RetrieveEntitiesResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to entity updates.\n     *\n     * @generated from protobuf rpc: SubscribeEventMessages\n     */\n    subscribeEventMessages(input: SubscribeEventMessagesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventMessagesRequest, SubscribeEntityResponse> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeEventMessagesRequest, SubscribeEntityResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Update entity subscription\n     *\n     * @generated from protobuf rpc: UpdateEventMessagesSubscription\n     */\n    updateEventMessagesSubscription(input: UpdateEventMessagesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEventMessagesSubscriptionRequest, Empty> {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpdateEventMessagesSubscriptionRequest, Empty>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to token balance updates.\n     *\n     * @generated from protobuf rpc: SubscribeTokenBalances\n     */\n    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse> {\n        const method = this.methods[7], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Update token balance subscription\n     *\n     * @generated from protobuf rpc: UpdateTokenBalancesSubscription\n     */\n    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty> {\n        const method = this.methods[8], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpdateTokenBalancesSubscriptionRequest, Empty>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to token updates.\n     *\n     * @generated from protobuf rpc: SubscribeTokens\n     */\n    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse> {\n        const method = this.methods[9], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeTokensRequest, SubscribeTokensResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Update token subscription\n     *\n     * @generated from protobuf rpc: UpdateTokensSubscription\n     */\n    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty> {\n        const method = this.methods[10], opt = this._transport.mergeOptions(options);\n        return stackIntercept<UpdateTokenSubscriptionRequest, Empty>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve entities\n     *\n     * @generated from protobuf rpc: RetrieveEventMessages\n     */\n    retrieveEventMessages(input: RetrieveEventMessagesRequest, options?: RpcOptions): UnaryCall<RetrieveEventMessagesRequest, RetrieveEntitiesResponse> {\n        const method = this.methods[11], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveEventMessagesRequest, RetrieveEntitiesResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve events\n     *\n     * @generated from protobuf rpc: RetrieveEvents\n     */\n    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse> {\n        const method = this.methods[12], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveEventsRequest, RetrieveEventsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to events\n     *\n     * @generated from protobuf rpc: SubscribeEvents\n     */\n    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse> {\n        const method = this.methods[13], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeEventsRequest, SubscribeEventsResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve tokens\n     *\n     * @generated from protobuf rpc: RetrieveTokens\n     */\n    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse> {\n        const method = this.methods[14], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveTokensRequest, RetrieveTokensResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve token balances\n     *\n     * @generated from protobuf rpc: RetrieveTokenBalances\n     */\n    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse> {\n        const method = this.methods[15], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve transactions\n     *\n     * @generated from protobuf rpc: RetrieveTransactions\n     */\n    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse> {\n        const method = this.methods[16], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveTransactionsRequest, RetrieveTransactionsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Subscribe to transactions\n     *\n     * @generated from protobuf rpc: SubscribeTransactions\n     */\n    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse> {\n        const method = this.methods[17], opt = this._transport.mergeOptions(options);\n        return stackIntercept<SubscribeTransactionsRequest, SubscribeTransactionsResponse>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve controllers\n     *\n     * @generated from protobuf rpc: RetrieveControllers\n     */\n    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse> {\n        const method = this.methods[18], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveControllersRequest, RetrieveControllersResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve contracts\n     *\n     * @generated from protobuf rpc: RetrieveContracts\n     */\n    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse> {\n        const method = this.methods[19], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveContractsRequest, RetrieveContractsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Retrieve tokens contracts\n     *\n     * @generated from protobuf rpc: RetrieveTokenContracts\n     */\n    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse> {\n        const method = this.methods[20], opt = this._transport.mergeOptions(options);\n        return stackIntercept<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Publish a torii offchain message\n     *\n     * @generated from protobuf rpc: PublishMessage\n     */\n    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse> {\n        const method = this.methods[21], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PublishMessageRequest, PublishMessageResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * Publish a set of torii offchain messages\n     *\n     * @generated from protobuf rpc: PublishMessageBatch\n     */\n    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse> {\n        const method = this.methods[22], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PublishMessageBatchRequest, PublishMessageBatchResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n","import type {\n    Query as ToriiQuery,\n    Clause as ToriiClause,\n    Pagination as ToriiPagination,\n    OrderBy as ToriiOrderBy,\n    OrderDirection as ToriiOrderDirection,\n    PaginationDirection as ToriiPaginationDirection,\n    PatternMatching as ToriiPatternMatching,\n    ComparisonOperator as ToriiComparisonOperator,\n    LogicalOperator as ToriiLogicalOperator,\n    ControllerQuery as ToriiControllerQuery,\n    TokenQuery as ToriiTokenQuery,\n    TokenBalanceQuery as ToriiTokenBalanceQuery,\n    TransactionQuery as ToriiTransactionQuery,\n    TransactionFilter as ToriiTransactionFilter,\n    KeysClause as ToriiKeysClause,\n} from \"@dojoengine/torii-wasm\";\n\nimport type {\n    Query as GrpcQuery,\n    Clause as GrpcClause,\n    Pagination as GrpcPagination,\n    OrderBy as GrpcOrderBy,\n    KeysClause as GrpcKeysClause,\n    HashedKeysClause as GrpcHashedKeysClause,\n    MemberClause as GrpcMemberClause,\n    CompositeClause as GrpcCompositeClause,\n    MemberValue as GrpcMemberValue,\n    ControllerQuery as GrpcControllerQuery,\n    TokenQuery as GrpcTokenQuery,\n    TokenBalanceQuery as GrpcTokenBalanceQuery,\n    TransactionQuery as GrpcTransactionQuery,\n    TransactionFilter as GrpcTransactionFilter,\n    EventQuery as GrpcEventQuery,\n    ContractQuery as GrpcContractQuery,\n} from \"../generated/types\";\n\nimport {\n    OrderDirection as GrpcOrderDirection,\n    PaginationDirection as GrpcPaginationDirection,\n    PatternMatching as GrpcPatternMatching,\n    ComparisonOperator as GrpcComparisonOperator,\n    LogicalOperator as GrpcLogicalOperator,\n} from \"../generated/types\";\n\nimport type {\n    RetrieveEntitiesRequest,\n    RetrieveEventMessagesRequest,\n    RetrieveTokensRequest,\n    RetrieveTokenBalancesRequest,\n    RetrieveTokenContractsRequest,\n    RetrieveControllersRequest,\n    RetrieveTransactionsRequest,\n    RetrieveEventsRequest,\n    RetrieveContractsRequest,\n} from \"../generated/world\";\n\nfunction hexToBuffer(hex: string): Uint8Array {\n    const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n    const bytes = new Uint8Array(cleanHex.length / 2);\n    for (let i = 0; i < cleanHex.length; i += 2) {\n        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);\n    }\n    return bytes;\n}\n\nfunction mapOrderDirection(direction: ToriiOrderDirection): GrpcOrderDirection {\n    switch (direction) {\n        case \"Asc\":\n            return GrpcOrderDirection.ASC;\n        case \"Desc\":\n            return GrpcOrderDirection.DESC;\n        default:\n            return GrpcOrderDirection.ASC;\n    }\n}\n\nfunction mapPaginationDirection(\n    direction: ToriiPaginationDirection\n): GrpcPaginationDirection {\n    switch (direction) {\n        case \"Forward\":\n            return GrpcPaginationDirection.FORWARD;\n        case \"Backward\":\n            return GrpcPaginationDirection.BACKWARD;\n        default:\n            return GrpcPaginationDirection.FORWARD;\n    }\n}\n\nfunction mapOrderBy(orderBy: ToriiOrderBy): GrpcOrderBy {\n    return {\n        field: orderBy.field,\n        direction: mapOrderDirection(orderBy.direction),\n    };\n}\n\nfunction mapPagination(pagination: ToriiPagination): GrpcPagination {\n    return {\n        limit: pagination.limit || 0,\n        cursor: pagination.cursor || \"\",\n        direction: mapPaginationDirection(pagination.direction),\n        order_by: pagination.order_by.map(mapOrderBy),\n    };\n}\n\nfunction mapPatternMatching(\n    pattern: ToriiPatternMatching\n): GrpcPatternMatching {\n    switch (pattern) {\n        case \"FixedLen\":\n            return GrpcPatternMatching.FixedLen;\n        case \"VariableLen\":\n            return GrpcPatternMatching.VariableLen;\n        default:\n            return GrpcPatternMatching.FixedLen;\n    }\n}\n\nfunction mapComparisonOperator(\n    op: ToriiComparisonOperator\n): GrpcComparisonOperator {\n    switch (op) {\n        case \"Eq\":\n            return GrpcComparisonOperator.EQ;\n        case \"Neq\":\n            return GrpcComparisonOperator.NEQ;\n        case \"Gt\":\n            return GrpcComparisonOperator.GT;\n        case \"Gte\":\n            return GrpcComparisonOperator.GTE;\n        case \"Lt\":\n            return GrpcComparisonOperator.LT;\n        case \"Lte\":\n            return GrpcComparisonOperator.LTE;\n        case \"In\":\n            return GrpcComparisonOperator.IN;\n        case \"NotIn\":\n            return GrpcComparisonOperator.NOT_IN;\n        default:\n            return GrpcComparisonOperator.EQ;\n    }\n}\n\nfunction mapLogicalOperator(op: ToriiLogicalOperator): GrpcLogicalOperator {\n    switch (op) {\n        case \"And\":\n            return GrpcLogicalOperator.AND;\n        case \"Or\":\n            return GrpcLogicalOperator.OR;\n        default:\n            return GrpcLogicalOperator.AND;\n    }\n}\n\nfunction mapMemberValue(value: any): GrpcMemberValue {\n    if (typeof value === \"string\") {\n        return { value_type: { oneofKind: \"string\" as const, string: value } };\n    } else if (Array.isArray(value)) {\n        return {\n            value_type: {\n                oneofKind: \"list\" as const,\n                list: { values: value.map(mapMemberValue) },\n            },\n        };\n    } else if (value && typeof value === \"object\" && \"Primitive\" in value) {\n        return {\n            value_type: {\n                oneofKind: \"primitive\" as const,\n                primitive: value.Primitive,\n            },\n        };\n    }\n    // Fallback for primitive values\n    return {\n        value_type: { oneofKind: \"string\" as const, string: String(value) },\n    };\n}\n\nexport function mapClause(clause: ToriiClause): GrpcClause {\n    if (\"HashedKeys\" in clause) {\n        const hashedKeysClause: GrpcHashedKeysClause = {\n            hashed_keys: clause.HashedKeys.map(hexToBuffer),\n        };\n        return {\n            clause_type: {\n                oneofKind: \"hashed_keys\" as const,\n                hashed_keys: hashedKeysClause,\n            },\n        };\n    } else if (\"Keys\" in clause) {\n        const keysClause: GrpcKeysClause = {\n            keys: clause.Keys.keys.map((k) =>\n                k ? hexToBuffer(k) : new Uint8Array()\n            ),\n            pattern_matching: mapPatternMatching(clause.Keys.pattern_matching),\n            models: clause.Keys.models,\n        };\n        return {\n            clause_type: { oneofKind: \"keys\" as const, keys: keysClause },\n        };\n    } else if (\"Member\" in clause) {\n        const memberClause: GrpcMemberClause = {\n            model: clause.Member.model,\n            member: clause.Member.member,\n            operator: mapComparisonOperator(clause.Member.operator),\n            value: mapMemberValue(clause.Member.value),\n        };\n        return {\n            clause_type: { oneofKind: \"member\" as const, member: memberClause },\n        };\n    } else if (\"Composite\" in clause) {\n        const compositeClause: GrpcCompositeClause = {\n            operator: mapLogicalOperator(clause.Composite.operator),\n            clauses: clause.Composite.clauses.map(mapClause),\n        };\n        return {\n            clause_type: {\n                oneofKind: \"composite\" as const,\n                composite: compositeClause,\n            },\n        };\n    }\n\n    throw new Error(\"Unknown clause type\");\n}\n\nexport function mapQuery(query: ToriiQuery): GrpcQuery {\n    return {\n        pagination: mapPagination(query.pagination),\n        clause: query.clause ? mapClause(query.clause) : undefined,\n        no_hashed_keys: query.no_hashed_keys,\n        models: query.models,\n        historical: query.historical,\n    };\n}\n\nexport function mapControllerQuery(\n    query: ToriiControllerQuery\n): GrpcControllerQuery {\n    return {\n        contract_addresses: query.contract_addresses.map(hexToBuffer),\n        usernames: query.usernames,\n        pagination: mapPagination(query.pagination),\n    };\n}\n\nexport function mapTokenQuery(query: ToriiTokenQuery): GrpcTokenQuery {\n    return {\n        contract_addresses: query.contract_addresses.map(hexToBuffer),\n        token_ids: query.token_ids.map(hexToBuffer),\n        pagination: mapPagination(query.pagination),\n    };\n}\n\nexport function mapTokenBalanceQuery(\n    query: ToriiTokenBalanceQuery\n): GrpcTokenBalanceQuery {\n    return {\n        contract_addresses: query.contract_addresses.map(hexToBuffer),\n        account_addresses: query.account_addresses.map(hexToBuffer),\n        token_ids: query.token_ids.map(hexToBuffer),\n        pagination: mapPagination(query.pagination),\n    };\n}\n\nexport function mapTransactionFilter(\n    filter: ToriiTransactionFilter\n): GrpcTransactionFilter {\n    return {\n        transaction_hashes: filter.transaction_hashes.map(hexToBuffer),\n        caller_addresses: filter.caller_addresses.map(hexToBuffer),\n        contract_addresses: filter.contract_addresses.map(hexToBuffer),\n        entrypoints: filter.entrypoints,\n        model_selectors: filter.model_selectors.map(hexToBuffer),\n        from_block: filter.from_block ? BigInt(filter.from_block) : undefined,\n        to_block: filter.to_block ? BigInt(filter.to_block) : undefined,\n    };\n}\n\nexport function mapTransactionQuery(\n    query: ToriiTransactionQuery\n): GrpcTransactionQuery {\n    return {\n        filter: query.filter ? mapTransactionFilter(query.filter) : undefined,\n        pagination: mapPagination(query.pagination),\n    };\n}\n\nexport function createRetrieveEntitiesRequest(\n    query: ToriiQuery\n): RetrieveEntitiesRequest {\n    return {\n        query: mapQuery(query),\n    };\n}\n\nexport function createRetrieveEventMessagesRequest(\n    query: ToriiQuery\n): RetrieveEventMessagesRequest {\n    return {\n        query: mapQuery(query),\n    };\n}\n\nexport function createRetrieveTokensRequest(\n    query: ToriiTokenQuery\n): RetrieveTokensRequest {\n    return {\n        query: mapTokenQuery(query),\n    };\n}\n\nexport function createRetrieveTokenBalancesRequest(\n    query: ToriiTokenBalanceQuery\n): RetrieveTokenBalancesRequest {\n    return {\n        query: mapTokenBalanceQuery(query),\n    };\n}\n\nexport function createRetrieveTokenContractsRequest(\n    query: ToriiTokenBalanceQuery\n): RetrieveTokenContractsRequest {\n    return {\n        query: mapTokenBalanceQuery(query),\n    };\n}\n\nexport function createRetrieveControllersRequest(\n    query: ToriiControllerQuery\n): RetrieveControllersRequest {\n    return {\n        query: mapControllerQuery(query),\n    };\n}\n\nexport function createRetrieveTransactionsRequest(\n    query: ToriiTransactionQuery\n): RetrieveTransactionsRequest {\n    return {\n        query: mapTransactionQuery(query),\n    };\n}\n\nexport function createRetrieveEventsRequest(query: {\n    keys?: ToriiKeysClause;\n    pagination?: ToriiPagination;\n}): RetrieveEventsRequest {\n    return {\n        query: {\n            keys: query.keys\n                ? {\n                      keys: query.keys.keys.map((k) =>\n                          k ? hexToBuffer(k) : new Uint8Array()\n                      ),\n                      pattern_matching:\n                          query.keys.pattern_matching === \"FixedLen\"\n                              ? GrpcPatternMatching.FixedLen\n                              : GrpcPatternMatching.VariableLen,\n                      models: query.keys.models || [],\n                  }\n                : undefined,\n            pagination: query.pagination\n                ? mapPagination(query.pagination)\n                : undefined,\n        },\n    };\n}\n\nexport function createRetrieveContractsRequest(query: {\n    contract_addresses?: string[];\n    contract_types?: any[];\n}): RetrieveContractsRequest {\n    return {\n        query: {\n            contract_addresses:\n                query.contract_addresses?.map(hexToBuffer) || [],\n            contract_types: query.contract_types || [],\n        },\n    };\n}\n","import type {\n    Entity as ToriiEntity,\n    Entities as ToriiEntities,\n    Token as ToriiToken,\n    Tokens as ToriiTokens,\n    TokenBalance as ToriiTokenBalance,\n    TokenBalances as ToriiTokenBalances,\n    TokenContract as ToriiTokenContract,\n    TokenContracts as ToriiTokenContracts,\n    Controller as ToriiController,\n    Controllers as ToriiControllers,\n    Transaction as ToriiTransaction,\n    Transactions as ToriiTransactions,\n    TransactionCall as ToriiTransactionCall,\n    CallType as ToriiCallType,\n    Model as ToriiModel,\n    Ty,\n    IndexerUpdate as ToriiIndexerUpdate,\n    Message as ToriiMessage,\n} from \"@dojoengine/torii-wasm\";\n\nimport type {\n    Entity as GrpcEntity,\n    Token as GrpcToken,\n    TokenBalance as GrpcTokenBalance,\n    TokenContract as GrpcTokenContract,\n    Controller as GrpcController,\n    Transaction as GrpcTransaction,\n    TransactionCall as GrpcTransactionCall,\n    Event as GrpcEvent,\n    Contract as GrpcContract,\n    World as GrpcWorld,\n    ContractType as GrpcContractType,\n} from \"../generated/types\";\n\nimport { CallType as GrpcCallType } from \"../generated/types\";\nimport type {\n    Ty as GrpcTy,\n    Primitive as GrpcPrimitive,\n    Struct as GrpcStruct,\n    Enum as GrpcEnum,\n    Array$ as GrpcArray,\n    Member as GrpcMember,\n} from \"../generated/schema\";\n\nimport type {\n    RetrieveEntitiesResponse,\n    RetrieveTokensResponse,\n    RetrieveTokenBalancesResponse,\n    RetrieveTokenContractsResponse,\n    RetrieveControllersResponse,\n    RetrieveTransactionsResponse,\n    SubscribeIndexerResponse,\n    PublishMessageRequest,\n    RetrieveEventsResponse,\n    RetrieveContractsResponse,\n    WorldMetadataResponse,\n} from \"../generated/world\";\n\nlet textDecoder: TextDecoder | undefined = undefined;\n\nfunction bufferToHex(buffer: Uint8Array): string {\n    return (\n        \"0x\" +\n        Array.from(buffer)\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\")\n    );\n}\n\nfunction hexToBuffer(hex: string): Uint8Array {\n    const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n    const bytes = new Uint8Array(cleanHex.length / 2);\n    for (let i = 0; i < cleanHex.length; i += 2) {\n        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);\n    }\n    return bytes;\n}\n\nexport function mapCallType(callType: GrpcCallType): ToriiCallType {\n    switch (callType) {\n        case GrpcCallType.EXECUTE:\n            return \"Execute\";\n        case GrpcCallType.EXECUTE_FROM_OUTSIDE:\n            return \"ExecuteFromOutside\";\n        default:\n            return \"Execute\";\n    }\n}\n\nexport function mapTransactionCall(\n    call: GrpcTransactionCall\n): ToriiTransactionCall {\n    return {\n        contract_address: bufferToHex(call.contract_address),\n        entrypoint: call.entrypoint,\n        calldata: call.calldata.map(bufferToHex),\n        call_type: mapCallType(call.call_type),\n        caller_address: bufferToHex(call.caller_address),\n    };\n}\n\nexport function mapTransaction(tx: GrpcTransaction): ToriiTransaction {\n    return {\n        transaction_hash: bufferToHex(tx.transaction_hash),\n        sender_address: bufferToHex(tx.sender_address),\n        calldata: tx.calldata.map(bufferToHex),\n        max_fee: bufferToHex(tx.max_fee),\n        signature: tx.signature.map(bufferToHex),\n        nonce: bufferToHex(tx.nonce),\n        block_number: Number(tx.block_number),\n        transaction_type: tx.transaction_type,\n        block_timestamp: Number(tx.block_timestamp),\n        calls: tx.calls.map(mapTransactionCall),\n        unique_models: tx.unique_models.map(bufferToHex),\n    };\n}\n\nexport function mapTransactionsResponse(\n    response: RetrieveTransactionsResponse\n): ToriiTransactions {\n    return {\n        items: response.transactions.map(mapTransaction),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function mapController(controller: GrpcController): ToriiController {\n    return {\n        address: bufferToHex(controller.address),\n        username: controller.username,\n        deployed_at_timestamp: Number(controller.deployed_at_timestamp),\n    };\n}\n\nexport function mapControllersResponse(\n    response: RetrieveControllersResponse\n): ToriiControllers {\n    return {\n        items: response.controllers.map(mapController),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function uint8ArrayToString(input: Uint8Array): string {\n    if (textDecoder) {\n        return textDecoder.decode(input);\n    }\n    textDecoder = new TextDecoder();\n    return textDecoder.decode(input);\n}\n\nexport function parseJsonMetadata(input: Uint8Array): any {\n    try {\n        return JSON.parse(uint8ArrayToString(input));\n    } catch (_err) {\n        return uint8ArrayToString(input);\n    }\n}\n\nexport function mapToken(token: GrpcToken): ToriiToken {\n    return {\n        contract_address: bufferToHex(token.contract_address),\n        token_id: token.token_id ? bufferToHex(token.token_id) : undefined,\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        metadata: parseJsonMetadata(token.metadata),\n    };\n}\n\nexport function mapTokensResponse(\n    response: RetrieveTokensResponse\n): ToriiTokens {\n    return {\n        items: response.tokens.map(mapToken),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function mapTokenBalance(balance: GrpcTokenBalance): ToriiTokenBalance {\n    return {\n        balance: bufferToHex(balance.balance),\n        account_address: bufferToHex(balance.account_address),\n        contract_address: bufferToHex(balance.contract_address),\n        token_id: balance.token_id ? bufferToHex(balance.token_id) : undefined,\n    };\n}\n\nexport function mapTokenBalancesResponse(\n    response: RetrieveTokenBalancesResponse\n): ToriiTokenBalances {\n    return {\n        items: response.balances.map(mapTokenBalance),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function mapTokenContract(\n    collection: GrpcTokenContract\n): ToriiTokenContract {\n    return {\n        contract_address: bufferToHex(collection.contract_address),\n        name: collection.name,\n        symbol: collection.symbol,\n        decimals: collection.decimals,\n        count: collection.count,\n        metadata: parseJsonMetadata(collection.metadata),\n    };\n}\n\nexport function mapTokenContractsResponse(\n    response: RetrieveTokenContractsResponse\n): ToriiTokenContracts {\n    return {\n        items: response.tokens.map(mapTokenContract),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nfunction mapPrimitive(primitive: GrpcPrimitive): any {\n    if (!primitive.primitive_type) return null;\n\n    switch (primitive.primitive_type.oneofKind) {\n        case \"i8\":\n            return primitive.primitive_type.i8;\n        case \"i16\":\n            return primitive.primitive_type.i16;\n        case \"i32\":\n            return primitive.primitive_type.i32;\n        case \"i64\":\n            return Number(primitive.primitive_type.i64);\n        case \"i128\":\n            return bufferToHex(primitive.primitive_type.i128);\n        case \"u8\":\n            return primitive.primitive_type.u8;\n        case \"u16\":\n            return primitive.primitive_type.u16;\n        case \"u32\":\n            return primitive.primitive_type.u32;\n        case \"u64\":\n            return Number(primitive.primitive_type.u64);\n        case \"u128\":\n            return bufferToHex(primitive.primitive_type.u128);\n        case \"u256\":\n            return bufferToHex(primitive.primitive_type.u256);\n        case \"bool\":\n            return primitive.primitive_type.bool;\n        case \"felt252\":\n            return bufferToHex(primitive.primitive_type.felt252);\n        case \"class_hash\":\n            return bufferToHex(primitive.primitive_type.class_hash);\n        case \"contract_address\":\n            return bufferToHex(primitive.primitive_type.contract_address);\n        case \"eth_address\":\n            return bufferToHex(primitive.primitive_type.eth_address);\n        default:\n            return null;\n    }\n}\n\nfunction getPrimitiveTypeName(primitive: GrpcPrimitive): string {\n    if (!primitive.primitive_type) return \"\";\n    return primitive.primitive_type.oneofKind || \"\";\n}\n\nfunction mapTy(ty: GrpcTy, isKey: boolean = false): Ty {\n    if (!ty.ty_type) {\n        return {\n            type: \"primitive\",\n            type_name: \"\",\n            value: null,\n            key: isKey,\n        };\n    }\n\n    switch (ty.ty_type.oneofKind) {\n        case \"primitive\": {\n            return {\n                type: \"primitive\",\n                type_name: getPrimitiveTypeName(ty.ty_type.primitive),\n                value: mapPrimitive(ty.ty_type.primitive),\n                key: isKey,\n            };\n        }\n        case \"struct\": {\n            const struct = ty.ty_type.struct;\n            const structValue: Record<string, Ty> = {};\n\n            for (const member of struct.children) {\n                if (member.ty) {\n                    structValue[member.name] = mapTy(member.ty, member.key);\n                }\n            }\n\n            return {\n                type: \"struct\",\n                type_name: struct.name,\n                value: structValue,\n                key: isKey,\n            };\n        }\n        case \"enum\": {\n            const enumType = ty.ty_type.enum;\n            const selectedOption = enumType.options[enumType.option];\n\n            return {\n                type: \"enum\",\n                type_name: enumType.name,\n                value:\n                    selectedOption && selectedOption.ty\n                        ? {\n                              option: selectedOption.name,\n                              value: mapTy(selectedOption.ty),\n                          }\n                        : null,\n                key: isKey,\n            };\n        }\n        case \"array\": {\n            const array = ty.ty_type.array;\n            return {\n                type: \"array\",\n                type_name: \"array\",\n                value: array.children.map((child) => mapTy(child)),\n                key: isKey,\n            };\n        }\n        case \"tuple\": {\n            const tuple = ty.ty_type.tuple;\n            return {\n                type: \"tuple\",\n                type_name: \"tuple\",\n                value: tuple.children.map((child) => mapTy(child)),\n                key: isKey,\n            };\n        }\n        case \"bytearray\": {\n            return {\n                type: \"bytearray\",\n                type_name: \"bytearray\",\n                value: ty.ty_type.bytearray,\n                key: isKey,\n            };\n        }\n        default:\n            return {\n                type: \"primitive\",\n                type_name: \"\",\n                value: null,\n                key: isKey,\n            };\n    }\n}\n\nfunction mapModel(model: GrpcMember[]): ToriiModel {\n    const mappedModel: ToriiModel = {};\n    if (model && Array.isArray(model)) {\n        for (const member of model) {\n            if (member.ty) {\n                mappedModel[member.name] = mapTy(member.ty, member.key);\n            }\n        }\n    }\n    return mappedModel;\n}\n\nexport function mapEntity(entity: GrpcEntity): ToriiEntity {\n    const models: Record<string, ToriiModel> = {};\n    for (const model of entity.models) {\n        models[model.name] = mapModel(model.children);\n    }\n\n    return {\n        hashed_keys: bufferToHex(entity.hashed_keys),\n        models,\n    };\n}\n\nexport function mapEntitiesResponse(\n    response: RetrieveEntitiesResponse\n): ToriiEntities {\n    return {\n        items: response.entities.map(mapEntity),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function mapIndexerUpdate(\n    update: SubscribeIndexerResponse\n): ToriiIndexerUpdate {\n    return {\n        head: Number(update.head),\n        tps: Number(update.tps),\n        last_block_timestamp: Number(update.last_block_timestamp),\n        contract_address: bufferToHex(update.contract_address),\n    };\n}\n\nexport function mapMessage(message: ToriiMessage): PublishMessageRequest {\n    return {\n        message: message.message,\n        signature: message.signature.map(hexToBuffer),\n    };\n}\n\nexport function mapCallTypeToGrpc(callType: ToriiCallType): GrpcCallType {\n    switch (callType) {\n        case \"Execute\":\n            return GrpcCallType.EXECUTE;\n        case \"ExecuteFromOutside\":\n            return GrpcCallType.EXECUTE_FROM_OUTSIDE;\n        default:\n            return GrpcCallType.EXECUTE;\n    }\n}\n\nexport function mapEvent(event: GrpcEvent): any {\n    return {\n        keys: event.keys.map(bufferToHex),\n        data: event.data.map(bufferToHex),\n        transaction_hash: bufferToHex(event.transaction_hash),\n    };\n}\n\nexport function mapEventsResponse(response: RetrieveEventsResponse): any {\n    return {\n        items: response.events.map(mapEvent),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function mapContract(contract: GrpcContract): any {\n    return {\n        contract_address: bufferToHex(contract.contract_address),\n        contract_type: contract.contract_type,\n        head: contract.head ? Number(contract.head) : undefined,\n        tps: contract.tps ? Number(contract.tps) : undefined,\n        last_block_timestamp: contract.last_block_timestamp\n            ? Number(contract.last_block_timestamp)\n            : undefined,\n        last_pending_block_tx: contract.last_pending_block_tx\n            ? bufferToHex(contract.last_pending_block_tx)\n            : undefined,\n        updated_at: Number(contract.updated_at),\n        created_at: Number(contract.created_at),\n    };\n}\n\nexport function mapContractsResponse(response: RetrieveContractsResponse): any {\n    return {\n        items: response.contracts.map(mapContract),\n    };\n}\n\nexport function mapWorldMetadataResponse(response: WorldMetadataResponse): any {\n    if (!response.world) {\n        return null;\n    }\n\n    return {\n        world_address: bufferToHex(response.world.world_address),\n        models: response.world.models.map((model: any) => ({\n            selector: bufferToHex(model.selector),\n            namespace: model.namespace,\n            name: model.name,\n            packed_size: model.packed_size,\n            unpacked_size: model.unpacked_size,\n            class_hash: bufferToHex(model.class_hash),\n            layout: bufferToHex(model.layout),\n            schema: bufferToHex(model.schema),\n            contract_address: bufferToHex(model.contract_address),\n            use_legacy_store: model.use_legacy_store,\n        })),\n    };\n}\n","import { Schema } from \"effect\";\nimport type * as GrpcTypes from \"../../generated/world\";\nimport type * as ToriiTypes from \"@dojoengine/torii-wasm\";\nimport {\n    TransactionSchema,\n    TransactionsResponseSchema,\n    ControllerSchema,\n    ControllersResponseSchema,\n    TokenSchema,\n    TokensResponseSchema,\n    TokenBalanceSchema,\n    TokenBalancesResponseSchema,\n    TokenContractSchema,\n    TokenContractsResponseSchema,\n} from \"./entity-schemas\";\nimport { EntitySchema, EntitiesResponseSchema } from \"./model-schemas\";\nimport { BufferToHex } from \"./base-schemas\";\n\nexport function transformTransaction(\n    tx: GrpcTypes.Transaction\n): ToriiTypes.Transaction {\n    return Schema.decodeSync(TransactionSchema)(tx);\n}\n\nexport function transformTransactionsResponse(\n    response: GrpcTypes.RetrieveTransactionsResponse\n): ToriiTypes.Transactions {\n    return Schema.decodeSync(TransactionsResponseSchema)(response);\n}\n\nexport function transformController(\n    controller: GrpcTypes.Controller\n): ToriiTypes.Controller {\n    return Schema.decodeSync(ControllerSchema)(controller);\n}\n\nexport function transformControllersResponse(\n    response: GrpcTypes.RetrieveControllersResponse\n): ToriiTypes.Controllers {\n    return Schema.decodeSync(ControllersResponseSchema)(response);\n}\n\nexport function transformToken(token: GrpcTypes.Token): ToriiTypes.Token {\n    return Schema.decodeSync(TokenSchema)(token);\n}\n\nexport function transformTokensResponse(\n    response: GrpcTypes.RetrieveTokensResponse\n): ToriiTypes.Tokens {\n    return Schema.decodeSync(TokensResponseSchema)(response);\n}\n\nexport function transformTokenBalance(\n    balance: GrpcTypes.TokenBalance\n): ToriiTypes.TokenBalance {\n    return Schema.decodeSync(TokenBalanceSchema)(balance);\n}\n\nexport function transformTokenBalancesResponse(\n    response: GrpcTypes.RetrieveTokenBalancesResponse\n): ToriiTypes.TokenBalances {\n    return Schema.decodeSync(TokenBalancesResponseSchema)(response);\n}\n\nexport function transformTokenContract(\n    collection: GrpcTypes.TokenContract\n): ToriiTypes.TokenContract {\n    return Schema.decodeSync(TokenContractSchema)(collection);\n}\n\nexport function transformTokenContractsResponse(\n    response: GrpcTypes.RetrieveTokenContractsResponse\n): ToriiTypes.TokenContracts {\n    return Schema.decodeSync(TokenContractsResponseSchema)(response);\n}\n\nexport function transformEntity(entity: GrpcTypes.Entity): ToriiTypes.Entity {\n    return Schema.decodeSync(EntitySchema)(entity);\n}\n\nexport function transformEntitiesResponse(\n    response: GrpcTypes.RetrieveEntitiesResponse\n): ToriiTypes.Entities {\n    return Schema.decodeSync(EntitiesResponseSchema)(response);\n}\n\nexport function transformIndexerUpdate(\n    update: GrpcTypes.SubscribeIndexerResponse\n): ToriiTypes.IndexerUpdate {\n    return {\n        head: Number(update.head),\n        tps: Number(update.tps),\n        last_block_timestamp: Number(update.last_block_timestamp),\n        contract_address: Schema.decodeSync(BufferToHex)(\n            update.contract_address\n        ),\n    };\n}\n\nexport function transformMessage(\n    message: ToriiTypes.Message\n): GrpcTypes.PublishMessageRequest {\n    return {\n        message: message.message,\n        signature: message.signature.map((sig) =>\n            Schema.encodeSync(BufferToHex)(sig)\n        ),\n    };\n}\n\nexport function transformEvent(event: any): any {\n    return {\n        keys: event.keys.map((key: Uint8Array) =>\n            Schema.decodeSync(BufferToHex)(key)\n        ),\n        data: event.data.map((d: Uint8Array) =>\n            Schema.decodeSync(BufferToHex)(d)\n        ),\n        transaction_hash: Schema.decodeSync(BufferToHex)(\n            event.transaction_hash\n        ),\n    };\n}\n\nexport function transformEventsResponse(response: any): any {\n    return {\n        items: response.events.map(transformEvent),\n        next_cursor: response.next_cursor || undefined,\n    };\n}\n\nexport function transformContract(contract: any): any {\n    return {\n        contract_address: Schema.decodeSync(BufferToHex)(\n            contract.contract_address\n        ),\n        contract_type: contract.contract_type,\n        head: contract.head ? Number(contract.head) : undefined,\n        tps: contract.tps ? Number(contract.tps) : undefined,\n        last_block_timestamp: contract.last_block_timestamp\n            ? Number(contract.last_block_timestamp)\n            : undefined,\n        last_pending_block_tx: contract.last_pending_block_tx\n            ? Schema.decodeSync(BufferToHex)(contract.last_pending_block_tx)\n            : undefined,\n        updated_at: Number(contract.updated_at),\n        created_at: Number(contract.created_at),\n    };\n}\n\nexport function transformContractsResponse(response: any): any {\n    return {\n        items: response.contracts.map(transformContract),\n    };\n}\n\nexport function transformWorldMetadataResponse(response: any): any {\n    if (!response.world) {\n        return null;\n    }\n\n    return {\n        world_address: Schema.decodeSync(BufferToHex)(\n            response.world.world_address\n        ),\n        models: response.world.models.map((model: any) => ({\n            selector: Schema.decodeSync(BufferToHex)(model.selector),\n            namespace: model.namespace,\n            name: model.name,\n            packed_size: model.packed_size,\n            unpacked_size: model.unpacked_size,\n            class_hash: Schema.decodeSync(BufferToHex)(model.class_hash),\n            layout: Schema.decodeSync(BufferToHex)(model.layout),\n            schema: Schema.decodeSync(BufferToHex)(model.schema),\n            contract_address: Schema.decodeSync(BufferToHex)(\n                model.contract_address\n            ),\n            use_legacy_store: model.use_legacy_store,\n        })),\n    };\n}\n","import { Schema } from \"effect\";\nimport type * as GrpcTypes from \"../../generated/types\";\nimport type * as ToriiTypes from \"@dojoengine/torii-wasm\";\nimport {\n    BufferToHex,\n    OptionalBufferToHex,\n    BufferArrayToHexArray,\n    BigIntToNumber,\n    OptionalString,\n    JsonMetadata,\n} from \"./base-schemas\";\n\nconst CallTypeSchema = Schema.transform(\n    Schema.Enums({\n        EXECUTE: 0,\n        EXECUTE_FROM_OUTSIDE: 1,\n    }),\n    Schema.Literal(\"Execute\", \"ExecuteFromOutside\"),\n    {\n        decode: (grpcCallType) => {\n            switch (grpcCallType) {\n                case 0:\n                    return \"Execute\";\n                case 1:\n                    return \"ExecuteFromOutside\";\n                default:\n                    return \"Execute\";\n            }\n        },\n        encode: (toriiCallType) => {\n            switch (toriiCallType) {\n                case \"Execute\":\n                    return 0;\n                case \"ExecuteFromOutside\":\n                    return 1;\n                default:\n                    return 0;\n            }\n        },\n    }\n);\n\nexport const TransactionCallSchema = Schema.transform(\n    Schema.Struct({\n        contract_address: Schema.Uint8ArrayFromSelf,\n        entrypoint: Schema.String,\n        calldata: Schema.Array(Schema.Uint8ArrayFromSelf),\n        call_type: Schema.Enums({\n            EXECUTE: 0,\n            EXECUTE_FROM_OUTSIDE: 1,\n        }),\n        caller_address: Schema.Uint8ArrayFromSelf,\n    }),\n    Schema.Struct({\n        contract_address: BufferToHex,\n        entrypoint: Schema.String,\n        calldata: BufferArrayToHexArray,\n        call_type: CallTypeSchema,\n        caller_address: BufferToHex,\n    }),\n    {\n        decode: (grpc) => ({\n            contract_address: grpc.contract_address,\n            entrypoint: grpc.entrypoint,\n            calldata: grpc.calldata,\n            call_type: grpc.call_type,\n            caller_address: grpc.caller_address,\n        }),\n        encode: (torii) => ({\n            contract_address: torii.contract_address,\n            entrypoint: torii.entrypoint,\n            calldata: torii.calldata,\n            call_type: torii.call_type,\n            caller_address: torii.caller_address,\n        }),\n    }\n);\n\nexport const TransactionSchema = Schema.transform(\n    Schema.Struct({\n        transaction_hash: Schema.Uint8ArrayFromSelf,\n        sender_address: Schema.Uint8ArrayFromSelf,\n        calldata: Schema.Array(Schema.Uint8ArrayFromSelf),\n        max_fee: Schema.Uint8ArrayFromSelf,\n        signature: Schema.Array(Schema.Uint8ArrayFromSelf),\n        nonce: Schema.Uint8ArrayFromSelf,\n        block_number: Schema.BigIntFromSelf,\n        block_timestamp: Schema.BigIntFromSelf,\n        transaction_type: Schema.String,\n        calls: Schema.Array(TransactionCallSchema),\n        unique_models: Schema.Array(Schema.Uint8ArrayFromSelf),\n    }),\n    Schema.Struct({\n        transaction_hash: BufferToHex,\n        sender_address: BufferToHex,\n        calldata: BufferArrayToHexArray,\n        max_fee: BufferToHex,\n        signature: BufferArrayToHexArray,\n        nonce: BufferToHex,\n        block_number: BigIntToNumber,\n        block_timestamp: BigIntToNumber,\n        transaction_type: Schema.String,\n        calls: Schema.Array(TransactionCallSchema),\n        unique_models: BufferArrayToHexArray,\n    }),\n    {\n        decode: (grpc) => ({\n            transaction_hash: grpc.transaction_hash,\n            sender_address: grpc.sender_address,\n            calldata: grpc.calldata,\n            max_fee: grpc.max_fee,\n            signature: grpc.signature,\n            nonce: grpc.nonce,\n            block_number: grpc.block_number,\n            block_timestamp: grpc.block_timestamp,\n            transaction_type: grpc.transaction_type,\n            calls: grpc.calls,\n            unique_models: grpc.unique_models,\n        }),\n        encode: (torii) => ({\n            transaction_hash: torii.transaction_hash,\n            sender_address: torii.sender_address,\n            calldata: torii.calldata,\n            max_fee: torii.max_fee,\n            signature: torii.signature,\n            nonce: torii.nonce,\n            block_number: BigInt(torii.block_number),\n            block_timestamp: BigInt(torii.block_timestamp),\n            transaction_type: torii.transaction_type,\n            calls: torii.calls,\n            unique_models: torii.unique_models,\n        }),\n    }\n);\n\nexport const ControllerSchema = Schema.transform(\n    Schema.Struct({\n        address: Schema.Uint8ArrayFromSelf,\n        username: Schema.String,\n        deployed_at_timestamp: Schema.BigIntFromSelf,\n    }),\n    Schema.Struct({\n        address: BufferToHex,\n        username: Schema.String,\n        deployed_at_timestamp: BigIntToNumber,\n    }),\n    {\n        decode: (grpc) => ({\n            address: grpc.address,\n            username: grpc.username,\n            deployed_at_timestamp: grpc.deployed_at_timestamp,\n        }),\n        encode: (torii) => ({\n            address: torii.address,\n            username: torii.username,\n            deployed_at_timestamp: BigInt(torii.deployed_at_timestamp),\n        }),\n    }\n);\n\nexport const TokenSchema = Schema.transform(\n    Schema.Struct({\n        contract_address: Schema.Uint8ArrayFromSelf,\n        token_id: Schema.optional(Schema.Uint8ArrayFromSelf),\n        name: Schema.String,\n        symbol: Schema.String,\n        decimals: Schema.Number,\n        metadata: Schema.Uint8ArrayFromSelf,\n    }),\n    Schema.Struct({\n        contract_address: BufferToHex,\n        token_id: OptionalBufferToHex,\n        name: Schema.String,\n        symbol: Schema.String,\n        decimals: Schema.Number,\n        metadata: JsonMetadata,\n    }),\n    {\n        decode: (grpc) => ({\n            contract_address: grpc.contract_address,\n            token_id: grpc.token_id,\n            name: grpc.name,\n            symbol: grpc.symbol,\n            decimals: grpc.decimals,\n            metadata: grpc.metadata,\n        }),\n        encode: (torii) => ({\n            contract_address: torii.contract_address,\n            token_id: torii.token_id,\n            name: torii.name,\n            symbol: torii.symbol,\n            decimals: torii.decimals,\n            metadata: torii.metadata,\n        }),\n    }\n);\n\nexport const TokenBalanceSchema = Schema.transform(\n    Schema.Struct({\n        balance: Schema.Uint8ArrayFromSelf,\n        account_address: Schema.Uint8ArrayFromSelf,\n        contract_address: Schema.Uint8ArrayFromSelf,\n        token_id: Schema.optional(Schema.Uint8ArrayFromSelf),\n    }),\n    Schema.Struct({\n        balance: BufferToHex,\n        account_address: BufferToHex,\n        contract_address: BufferToHex,\n        token_id: OptionalBufferToHex,\n    }),\n    {\n        decode: (grpc) => ({\n            balance: grpc.balance,\n            account_address: grpc.account_address,\n            contract_address: grpc.contract_address,\n            token_id: grpc.token_id,\n        }),\n        encode: (torii) => ({\n            balance: torii.balance,\n            account_address: torii.account_address,\n            contract_address: torii.contract_address,\n            token_id: torii.token_id,\n        }),\n    }\n);\n\nexport const TokenContractSchema = Schema.transform(\n    Schema.Struct({\n        contract_address: Schema.Uint8ArrayFromSelf,\n        name: Schema.String,\n        symbol: Schema.String,\n        decimals: Schema.Number,\n        count: Schema.BigIntFromSelf,\n        metadata: Schema.Uint8ArrayFromSelf,\n    }),\n    Schema.Struct({\n        contract_address: BufferToHex,\n        name: Schema.String,\n        symbol: Schema.String,\n        decimals: Schema.Number,\n        count: Schema.Number,\n        metadata: JsonMetadata,\n    }),\n    {\n        decode: (grpc) => ({\n            contract_address: grpc.contract_address,\n            name: grpc.name,\n            symbol: grpc.symbol,\n            decimals: grpc.decimals,\n            count: grpc.count,\n            metadata: grpc.metadata,\n        }),\n        encode: (torii) => ({\n            contract_address: torii.contract_address,\n            name: torii.name,\n            symbol: torii.symbol,\n            decimals: torii.decimals,\n            count: BigInt(torii.count),\n            metadata: torii.metadata,\n        }),\n    }\n);\n\nexport const TransactionsResponseSchema = Schema.transform(\n    Schema.Struct({\n        transactions: Schema.Array(TransactionSchema),\n        next_cursor: OptionalString,\n    }),\n    Schema.Struct({\n        items: Schema.Array(TransactionSchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.transactions,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            transactions: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n\nexport const ControllersResponseSchema = Schema.transform(\n    Schema.Struct({\n        controllers: Schema.Array(ControllerSchema),\n        next_cursor: OptionalString,\n    }),\n    Schema.Struct({\n        items: Schema.Array(ControllerSchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.controllers,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            controllers: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n\nexport const TokensResponseSchema = Schema.transform(\n    Schema.Struct({\n        tokens: Schema.Array(TokenSchema),\n        next_cursor: OptionalString,\n    }),\n    Schema.Struct({\n        items: Schema.Array(TokenSchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.tokens,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            tokens: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n\nexport const TokenBalancesResponseSchema = Schema.transform(\n    Schema.Struct({\n        balances: Schema.Array(TokenBalanceSchema),\n        next_cursor: OptionalString,\n    }),\n    Schema.Struct({\n        items: Schema.Array(TokenBalanceSchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.balances,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            balances: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n\nexport const TokenContractsResponseSchema = Schema.transform(\n    Schema.Struct({\n        tokens: Schema.Array(TokenContractSchema),\n        next_cursor: OptionalString,\n    }),\n    Schema.Struct({\n        items: Schema.Array(TokenContractSchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.tokens,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            tokens: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n","import { Schema } from \"effect\";\n\nexport const HexString = Schema.String.pipe(\n    Schema.pattern(/^0x[0-9a-fA-F]*$/, {\n        message: () => \"Invalid hex string format\",\n    })\n);\n\nexport const BufferToHex = Schema.transform(\n    Schema.Uint8ArrayFromSelf,\n    HexString,\n    {\n        decode: (buffer) => {\n            return (\n                \"0x\" +\n                Array.from(buffer)\n                    .map((b) => b.toString(16).padStart(2, \"0\"))\n                    .join(\"\")\n            );\n        },\n        encode: (hex) => {\n            const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n            const bytes = new Uint8Array(cleanHex.length / 2);\n            for (let i = 0; i < cleanHex.length; i += 2) {\n                bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);\n            }\n            return bytes;\n        },\n    }\n);\n\nexport const OptionalBufferToHex = Schema.optional(BufferToHex);\n\nexport const BufferArrayToHexArray = Schema.transform(\n    Schema.Array(Schema.Uint8ArrayFromSelf),\n    Schema.Array(HexString),\n    {\n        decode: (buffers) =>\n            buffers.map(\n                (buffer) =>\n                    \"0x\" +\n                    Array.from(buffer)\n                        .map((b) => b.toString(16).padStart(2, \"0\"))\n                        .join(\"\")\n            ),\n        encode: (hexStrings) =>\n            hexStrings.map((hex) => {\n                const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n                const bytes = new Uint8Array(cleanHex.length / 2);\n                for (let i = 0; i < cleanHex.length; i += 2) {\n                    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);\n                }\n                return bytes;\n            }),\n    }\n);\n\nexport const BigIntToNumber = Schema.transform(\n    Schema.BigIntFromSelf,\n    Schema.Number,\n    {\n        decode: (bigint) => Number(bigint),\n        encode: (number) => BigInt(number),\n    }\n);\n\nexport const OptionalString = Schema.optional(Schema.String);\nexport const OptionalNumber = Schema.optional(Schema.Number);\n\nlet textDecoder: TextDecoder | undefined = undefined;\n\nexport const Uint8ArrayToString = Schema.transform(\n    Schema.Uint8ArrayFromSelf,\n    Schema.String,\n    {\n        decode: (input) => {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(input);\n        },\n        encode: (str) => new TextEncoder().encode(str),\n    }\n);\n\nexport const JsonMetadata = Schema.transform(\n    Schema.Uint8ArrayFromSelf,\n    Schema.Unknown,\n    {\n        decode: (input) => {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            const str = textDecoder.decode(input);\n            try {\n                return JSON.parse(str);\n            } catch (_err) {\n                return str;\n            }\n        },\n        encode: (value) => {\n            const str =\n                typeof value === \"string\" ? value : JSON.stringify(value);\n            return new TextEncoder().encode(str);\n        },\n    }\n);\n","import { Schema } from \"effect\";\nimport type * as GrpcSchema from \"../../generated/schema\";\nimport type * as ToriiTypes from \"@dojoengine/torii-wasm\";\nimport { BufferToHex } from \"./base-schemas\";\n\nconst PrimitiveSchema = Schema.transform(\n    Schema.Struct({\n        primitive_type: Schema.Union(\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"i8\"),\n                i8: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"i16\"),\n                i16: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"i32\"),\n                i32: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"i64\"),\n                i64: Schema.BigIntFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"i128\"),\n                i128: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u8\"),\n                u8: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u16\"),\n                u16: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u32\"),\n                u32: Schema.Number,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u64\"),\n                u64: Schema.BigIntFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u128\"),\n                u128: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"u256\"),\n                u256: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"bool\"),\n                bool: Schema.Boolean,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"felt252\"),\n                felt252: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"class_hash\"),\n                class_hash: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"contract_address\"),\n                contract_address: Schema.Uint8ArrayFromSelf,\n            }),\n            Schema.Struct({\n                oneofKind: Schema.Literal(\"eth_address\"),\n                eth_address: Schema.Uint8ArrayFromSelf,\n            })\n        ).pipe(Schema.optional),\n    }),\n    Schema.Unknown,\n    {\n        decode: (primitive) => {\n            if (!primitive.primitive_type) return null;\n\n            switch (primitive.primitive_type.oneofKind) {\n                case \"i8\":\n                    return primitive.primitive_type.i8;\n                case \"i16\":\n                    return primitive.primitive_type.i16;\n                case \"i32\":\n                    return primitive.primitive_type.i32;\n                case \"i64\":\n                    return Number(primitive.primitive_type.i64);\n                case \"i128\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.i128\n                    );\n                case \"u8\":\n                    return primitive.primitive_type.u8;\n                case \"u16\":\n                    return primitive.primitive_type.u16;\n                case \"u32\":\n                    return primitive.primitive_type.u32;\n                case \"u64\":\n                    return Number(primitive.primitive_type.u64);\n                case \"u128\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.u128\n                    );\n                case \"u256\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.u256\n                    );\n                case \"bool\":\n                    return primitive.primitive_type.bool;\n                case \"felt252\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.felt252\n                    );\n                case \"class_hash\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.class_hash\n                    );\n                case \"contract_address\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.contract_address\n                    );\n                case \"eth_address\":\n                    return BufferToHex.pipe(Schema.decodeSync)(\n                        primitive.primitive_type.eth_address\n                    );\n                default:\n                    return null;\n            }\n        },\n        encode: (value) => {\n            throw new Error(\"Encoding not implemented for PrimitiveSchema\");\n        },\n    }\n);\n\ninterface TySchemaType extends Schema.Schema<ToriiTypes.Ty, GrpcSchema.Ty> {}\ninterface MemberSchemaType\n    extends Schema.Schema<GrpcSchema.Member, GrpcSchema.Member> {}\n\nconst TySchema: TySchemaType = Schema.suspend(() =>\n    Schema.transform(\n        Schema.Struct({\n            ty_type: Schema.Union(\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"primitive\"),\n                    primitive: PrimitiveSchema,\n                }),\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"struct\"),\n                    struct: Schema.Struct({\n                        name: Schema.String,\n                        children: Schema.Array(MemberSchema),\n                    }),\n                }),\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"enum\"),\n                    enum: Schema.Struct({\n                        name: Schema.String,\n                        option: Schema.Number,\n                        options: Schema.Array(MemberSchema),\n                    }),\n                }),\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"array\"),\n                    array: Schema.Struct({\n                        children: Schema.Array(TySchema),\n                    }),\n                }),\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"tuple\"),\n                    tuple: Schema.Struct({\n                        children: Schema.Array(TySchema),\n                    }),\n                }),\n                Schema.Struct({\n                    oneofKind: Schema.Literal(\"bytearray\"),\n                    bytearray: Schema.String,\n                })\n            ).pipe(Schema.optional),\n        }),\n        Schema.Struct({\n            type: Schema.String,\n            type_name: Schema.String,\n            value: Schema.Unknown,\n            key: Schema.Boolean,\n        }),\n        {\n            decode: (ty, isKey = false) => {\n                if (!ty.ty_type) {\n                    return {\n                        type: \"primitive\",\n                        type_name: \"\",\n                        value: null,\n                        key: isKey,\n                    };\n                }\n\n                switch (ty.ty_type.oneofKind) {\n                    case \"primitive\": {\n                        const primitiveValue = PrimitiveSchema.pipe(\n                            Schema.decodeSync\n                        )(ty.ty_type.primitive);\n                        return {\n                            type: \"primitive\",\n                            type_name:\n                                ty.ty_type.primitive.primitive_type\n                                    ?.oneofKind || \"\",\n                            value: primitiveValue,\n                            key: isKey,\n                        };\n                    }\n                    case \"struct\": {\n                        const struct = ty.ty_type.struct;\n                        const structValue: Record<string, ToriiTypes.Ty> = {};\n\n                        for (const member of struct.children) {\n                            if (member.ty) {\n                                structValue[member.name] = TySchema.pipe(\n                                    Schema.decodeSync\n                                )(member.ty);\n                            }\n                        }\n\n                        return {\n                            type: \"struct\",\n                            type_name: struct.name,\n                            value: structValue,\n                            key: isKey,\n                        };\n                    }\n                    case \"enum\": {\n                        const enumType = ty.ty_type.enum;\n                        const selectedOption =\n                            enumType.options[enumType.option];\n\n                        return {\n                            type: \"enum\",\n                            type_name: enumType.name,\n                            value:\n                                selectedOption && selectedOption.ty\n                                    ? {\n                                          option: selectedOption.name,\n                                          value: TySchema.pipe(\n                                              Schema.decodeSync\n                                          )(selectedOption.ty),\n                                      }\n                                    : null,\n                            key: isKey,\n                        };\n                    }\n                    case \"array\": {\n                        const array = ty.ty_type.array;\n                        return {\n                            type: \"array\",\n                            type_name: \"array\",\n                            value: array.children.map((child) =>\n                                TySchema.pipe(Schema.decodeSync)(child)\n                            ),\n                            key: isKey,\n                        };\n                    }\n                    case \"tuple\": {\n                        const tuple = ty.ty_type.tuple;\n                        return {\n                            type: \"tuple\",\n                            type_name: \"tuple\",\n                            value: tuple.children.map((child) =>\n                                TySchema.pipe(Schema.decodeSync)(child)\n                            ),\n                            key: isKey,\n                        };\n                    }\n                    case \"bytearray\": {\n                        return {\n                            type: \"bytearray\",\n                            type_name: \"bytearray\",\n                            value: ty.ty_type.bytearray,\n                            key: isKey,\n                        };\n                    }\n                    default:\n                        return {\n                            type: \"primitive\",\n                            type_name: \"\",\n                            value: null,\n                            key: isKey,\n                        };\n                }\n            },\n            encode: (torii) => {\n                throw new Error(\"Encoding not implemented for TySchema\");\n            },\n        }\n    )\n);\n\nconst MemberSchema: MemberSchemaType = Schema.suspend(() =>\n    Schema.Struct({\n        name: Schema.String,\n        ty: Schema.optional(TySchema),\n        key: Schema.Boolean,\n    })\n);\n\nexport const ModelSchema = Schema.transform(\n    Schema.Array(MemberSchema),\n    Schema.Record({ key: Schema.String, value: TySchema }),\n    {\n        decode: (members) => {\n            const model: ToriiTypes.Model = {};\n            if (members && Array.isArray(members)) {\n                for (const member of members) {\n                    if (member.ty) {\n                        const ty = TySchema.pipe(Schema.decodeSync)(member.ty);\n                        model[member.name] = { ...ty, key: member.key };\n                    }\n                }\n            }\n            return model;\n        },\n        encode: (model) => {\n            throw new Error(\"Encoding not implemented for ModelSchema\");\n        },\n    }\n);\n\nexport const EntitySchema = Schema.transform(\n    Schema.Struct({\n        hashed_keys: Schema.Uint8ArrayFromSelf,\n        models: Schema.Array(\n            Schema.Struct({\n                name: Schema.String,\n                children: Schema.Array(MemberSchema),\n            })\n        ),\n    }),\n    Schema.Struct({\n        hashed_keys: BufferToHex,\n        models: Schema.Record({ key: Schema.String, value: ModelSchema }),\n    }),\n    {\n        decode: (grpc) => {\n            const models: Record<string, ToriiTypes.Model> = {};\n            for (const model of grpc.models) {\n                models[model.name] = ModelSchema.pipe(Schema.decodeSync)(\n                    model.children\n                );\n            }\n            return {\n                hashed_keys: BufferToHex.pipe(Schema.decodeSync)(\n                    grpc.hashed_keys\n                ),\n                models,\n            };\n        },\n        encode: (torii) => {\n            throw new Error(\"Encoding not implemented for EntitySchema\");\n        },\n    }\n);\n\nexport const EntitiesResponseSchema = Schema.transform(\n    Schema.Struct({\n        entities: Schema.Array(EntitySchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    Schema.Struct({\n        items: Schema.Array(EntitySchema),\n        next_cursor: Schema.optional(Schema.String),\n    }),\n    {\n        decode: (grpc) => ({\n            items: grpc.entities,\n            next_cursor: grpc.next_cursor,\n        }),\n        encode: (torii) => ({\n            entities: torii.items,\n            next_cursor: torii.next_cursor,\n        }),\n    }\n);\n","import type {\n    ClientConfig,\n    Entities,\n    Controllers,\n    ControllerQuery,\n    TokenQuery,\n    Tokens,\n    TokenBalanceQuery,\n    TokenBalances,\n    TokenContracts,\n    Query,\n    Clause,\n    Transactions,\n    TransactionQuery,\n    TransactionFilter,\n    KeysClause,\n    Message,\n    WasmU256,\n    Pagination,\n} from \"@dojoengine/torii-wasm\";\n\nimport type { KeysClause as GrpcKeysClause } from \"./generated/types\";\n\nimport {\n    PatternMatching as GrpcPatternMatching,\n    ContractType,\n} from \"./generated/types\";\n\nimport {\n    createRetrieveEntitiesRequest,\n    createRetrieveEventMessagesRequest,\n    createRetrieveTokensRequest,\n    createRetrieveTokenBalancesRequest,\n    createRetrieveTokenContractsRequest,\n    createRetrieveControllersRequest,\n    createRetrieveTransactionsRequest,\n    createRetrieveEventsRequest,\n    createRetrieveContractsRequest,\n    mapTransactionFilter,\n    mapClause,\n} from \"./mappings/query\";\n\nimport {\n    mapEntitiesResponse,\n    mapControllersResponse,\n    mapTokensResponse,\n    mapTokenBalancesResponse,\n    mapTokenContractsResponse,\n    mapTransactionsResponse,\n    mapIndexerUpdate,\n    mapMessage,\n    mapTransaction,\n    mapEntity,\n    mapToken,\n    mapTokenBalance,\n    mapEventsResponse,\n    mapContractsResponse,\n    mapWorldMetadataResponse,\n    mapEvent,\n    mapContract,\n} from \"./mappings/types\";\n\nimport {\n    transformEntitiesResponse,\n    transformControllersResponse,\n    transformTokensResponse,\n    transformTokenBalancesResponse,\n    transformTokenContractsResponse,\n    transformTransactionsResponse,\n    transformIndexerUpdate,\n    transformMessage,\n    transformTransaction,\n    transformEntity,\n    transformToken,\n    transformTokenBalance,\n    transformEventsResponse,\n    transformContractsResponse,\n    transformWorldMetadataResponse,\n    transformEvent,\n    transformContract,\n} from \"./mappings/effect-schema/transformers\";\n\nimport { Schema } from \"effect\";\nimport { BufferToHex } from \"./mappings/effect-schema/base-schemas\";\n\nimport { DojoGrpcClient } from \"./client\";\nimport type { ServerStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport type {\n    SubscribeEntityResponse,\n    SubscribeTransactionsResponse,\n    SubscribeTokensResponse,\n    SubscribeTokenBalancesResponse,\n    SubscribeEventsResponse,\n    SubscribeContractsResponse,\n    PublishMessageBatchRequest,\n} from \"./generated/world\";\n\nfunction hexToBuffer(hex: string): Uint8Array {\n    const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n    const bytes = new Uint8Array(cleanHex.length / 2);\n    for (let i = 0; i < cleanHex.length; i += 2) {\n        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);\n    }\n    return bytes;\n}\n\nfunction bufferToHex(buffer: Uint8Array): string {\n    return (\n        \"0x\" +\n        Array.from(buffer)\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\")\n    );\n}\n\ninterface ToriiSubscription {\n    id: bigint;\n    stream: ServerStreamingCall<object, object>;\n    cancel: () => void;\n}\n\ntype GrpcSubscription = {\n    id: bigint;\n    cancel: () => void;\n    free: () => void;\n};\n\nexport class Subscription {\n    private _subscription: ToriiSubscription;\n\n    constructor(subscription: ToriiSubscription) {\n        this._subscription = subscription;\n    }\n\n    cancel() {\n        this._subscription.cancel();\n    }\n\n    free() {\n        this._subscription.cancel();\n    }\n\n    get id(): bigint {\n        return this._subscription.id;\n    }\n}\n\ninterface StreamHandlerOptions<TReq extends object, TRes extends object> {\n    createStream: () => ServerStreamingCall<TReq, TRes>;\n    onMessage: (response: TRes) => void;\n    onError?: (error: Error) => void;\n    onComplete?: () => void;\n}\n\nexport interface ToriiGrpcClientConfig extends ClientConfig {\n    useEffectSchema?: boolean;\n}\n\nexport class ToriiGrpcClient {\n    private client: DojoGrpcClient;\n    private nextSubscriptionId = 1n;\n    private subscriptions = new Map<bigint, ToriiSubscription>();\n    private useEffectSchema: boolean;\n    private mappers: {\n        entitiesResponse: (response: any) => any;\n        controllersResponse: (response: any) => any;\n        tokensResponse: (response: any) => any;\n        tokenBalancesResponse: (response: any) => any;\n        tokenContractsResponse: (response: any) => any;\n        transactionsResponse: (response: any) => any;\n        indexerUpdate: (response: any) => any;\n        message: (message: any) => any;\n        transaction: (tx: any) => any;\n        entity: (entity: any) => any;\n        token: (token: any) => any;\n        tokenBalance: (balance: any) => any;\n        eventsResponse: (response: any) => any;\n        contractsResponse: (response: any) => any;\n        worldMetadataResponse: (response: any) => any;\n        event: (event: any) => any;\n        contract: (contract: any) => any;\n    };\n\n    constructor(config: ToriiGrpcClientConfig) {\n        this.client = new DojoGrpcClient({\n            url: config.toriiUrl,\n        });\n        this.useEffectSchema = config.useEffectSchema ?? false;\n\n        // Initialize mappers based on schema preference\n        this.mappers = this.useEffectSchema\n            ? {\n                  entitiesResponse: transformEntitiesResponse,\n                  controllersResponse: transformControllersResponse,\n                  tokensResponse: transformTokensResponse,\n                  tokenBalancesResponse: transformTokenBalancesResponse,\n                  tokenContractsResponse: transformTokenContractsResponse,\n                  transactionsResponse: transformTransactionsResponse,\n                  indexerUpdate: transformIndexerUpdate,\n                  message: transformMessage,\n                  transaction: transformTransaction,\n                  entity: transformEntity,\n                  token: transformToken,\n                  tokenBalance: transformTokenBalance,\n                  eventsResponse: transformEventsResponse,\n                  contractsResponse: transformContractsResponse,\n                  worldMetadataResponse: transformWorldMetadataResponse,\n                  event: transformEvent,\n                  contract: transformContract,\n              }\n            : {\n                  entitiesResponse: mapEntitiesResponse,\n                  controllersResponse: mapControllersResponse,\n                  tokensResponse: mapTokensResponse,\n                  tokenBalancesResponse: mapTokenBalancesResponse,\n                  tokenContractsResponse: mapTokenContractsResponse,\n                  transactionsResponse: mapTransactionsResponse,\n                  indexerUpdate: mapIndexerUpdate,\n                  message: mapMessage,\n                  transaction: mapTransaction,\n                  entity: mapEntity,\n                  token: mapToken,\n                  tokenBalance: mapTokenBalance,\n                  eventsResponse: mapEventsResponse,\n                  contractsResponse: mapContractsResponse,\n                  worldMetadataResponse: mapWorldMetadataResponse,\n                  event: mapEvent,\n                  contract: mapContract,\n              };\n    }\n\n    private createStreamSubscription<TReq extends object, TRes extends object>(\n        options: StreamHandlerOptions<TReq, TRes>\n    ): Subscription {\n        const subscriptionId = this.nextSubscriptionId++;\n        const stream = options.createStream();\n\n        const subscription: ToriiSubscription = {\n            id: subscriptionId,\n            stream: stream as ServerStreamingCall<object, object>,\n            cancel: () => {\n                // ServerStreamingCall doesn't have a cancel method, so we just clean up\n                this.subscriptions.delete(subscriptionId);\n            },\n        };\n\n        this.subscriptions.set(subscriptionId, subscription);\n\n        // Set up stream event handlers\n        stream.responses.onMessage(options.onMessage);\n\n        if (options.onError) {\n            stream.responses.onError(options.onError);\n        } else {\n            stream.responses.onError((error) => {\n                console.error(\n                    `Stream error (subscription ${subscriptionId}):`,\n                    error\n                );\n            });\n        }\n\n        if (options.onComplete) {\n            stream.responses.onComplete(options.onComplete);\n        } else {\n            stream.responses.onComplete(() => {\n                this.subscriptions.delete(subscriptionId);\n            });\n        }\n\n        return new Subscription(subscription);\n    }\n\n    async getControllers(query: ControllerQuery): Promise<Controllers> {\n        const request = createRetrieveControllersRequest(query);\n        const response =\n            await this.client.worldClient.retrieveControllers(request).response;\n        return this.mappers.controllersResponse(response);\n    }\n\n    async getTransactions(query: TransactionQuery): Promise<Transactions> {\n        const request = createRetrieveTransactionsRequest(query);\n        const response =\n            await this.client.worldClient.retrieveTransactions(request)\n                .response;\n        return this.mappers.transactionsResponse(response);\n    }\n\n    async getTokens(query: TokenQuery): Promise<Tokens> {\n        const request = createRetrieveTokensRequest(query);\n        const response =\n            await this.client.worldClient.retrieveTokens(request).response;\n        return this.mappers.tokensResponse(response);\n    }\n\n    async getTokenBalances(query: TokenBalanceQuery): Promise<TokenBalances> {\n        const request = createRetrieveTokenBalancesRequest(query);\n        const response =\n            await this.client.worldClient.retrieveTokenBalances(request)\n                .response;\n        return this.mappers.tokenBalancesResponse(response);\n    }\n\n    async getTokenContracts(query: TokenBalanceQuery): Promise<TokenContracts> {\n        const request = createRetrieveTokenContractsRequest(query);\n        const response =\n            await this.client.worldClient.retrieveTokenContracts(request)\n                .response;\n        return this.mappers.tokenContractsResponse(response);\n    }\n\n    async getEntities(query: Query): Promise<Entities> {\n        const request = createRetrieveEntitiesRequest(query);\n        const response =\n            await this.client.worldClient.retrieveEntities(request).response;\n        return this.mappers.entitiesResponse(response);\n    }\n\n    async getAllEntities(\n        limit: number,\n        cursor?: string | null\n    ): Promise<Entities> {\n        const query: Query = {\n            pagination: {\n                limit,\n                cursor: cursor || undefined,\n                direction: \"Forward\",\n                order_by: [],\n            },\n            clause: undefined,\n            no_hashed_keys: true,\n            models: [],\n            historical: false,\n        };\n        return this.getEntities(query);\n    }\n\n    async getEventMessages(query: Query): Promise<Entities> {\n        const request = createRetrieveEventMessagesRequest(query);\n        const response =\n            await this.client.worldClient.retrieveEventMessages(request)\n                .response;\n        return this.mappers.entitiesResponse(response);\n    }\n\n    async onTransaction(\n        filter: TransactionFilter | null | undefined,\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeTransactions({\n                    filter: filter ? mapTransactionFilter(filter) : undefined,\n                }),\n            onMessage: (response: SubscribeTransactionsResponse) => {\n                if (response.transaction) {\n                    callback(this.mappers.transaction(response.transaction));\n                }\n            },\n        });\n    }\n\n    async onTokenUpdated(\n        contract_addresses: string[] | null | undefined,\n        token_ids: WasmU256[] | null | undefined,\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeTokens({\n                    contract_addresses:\n                        contract_addresses?.map(hexToBuffer) || [],\n                    token_ids: token_ids?.map(hexToBuffer) || [],\n                }),\n            onMessage: (response: SubscribeTokensResponse) => {\n                if (response.token) {\n                    callback(this.mappers.token(response.token));\n                }\n            },\n        });\n    }\n\n    async onEntityUpdated(\n        clause: Clause | null | undefined,\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeEntities({\n                    clause: clause ? mapClause(clause) : undefined,\n                }),\n            onMessage: (response: SubscribeEntityResponse) => {\n                if (response.entity) {\n                    callback(\n                        this.mappers.entity(response.entity),\n                        response.subscription_id\n                    );\n                }\n            },\n        });\n    }\n\n    async updateEntitySubscription(\n        subscription: Subscription,\n        clause?: Clause | null\n    ): Promise<void> {\n        const grpcSubscription = this.findSubscription(subscription);\n        if (!grpcSubscription) {\n            throw new Error(\"Subscription not found\");\n        }\n\n        await this.client.worldClient.updateEntitiesSubscription({\n            subscription_id: BigInt(grpcSubscription.id),\n            clause: clause ? mapClause(clause) : undefined,\n        }).response;\n    }\n\n    async onEventMessageUpdated(\n        clause: Clause | null | undefined,\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeEventMessages({\n                    clause: clause ? mapClause(clause) : undefined,\n                }),\n            onMessage: (response: SubscribeEntityResponse) => {\n                if (response.entity) {\n                    callback(\n                        this.mappers.entity(response.entity),\n                        response.subscription_id\n                    );\n                }\n            },\n        });\n    }\n\n    async updateEventMessageSubscription(\n        subscription: GrpcSubscription,\n        clause?: Clause | null\n    ): Promise<void> {\n        const grpcSubscription = this.findSubscription(subscription);\n        if (!grpcSubscription) {\n            throw new Error(\"Subscription not found\");\n        }\n\n        await this.client.worldClient.updateEventMessagesSubscription({\n            subscription_id: BigInt(grpcSubscription.id),\n            clause: clause ? mapClause(clause) : undefined,\n        }).response;\n    }\n\n    async onStarknetEvent(\n        clauses: KeysClause[],\n        callback: Function\n    ): Promise<Subscription> {\n        // Map KeysClause[] to a single clause\n        const grpcClauses: GrpcKeysClause[] = clauses.map((clause) => ({\n            keys: clause.keys.map((k) =>\n                k ? hexToBuffer(k) : new Uint8Array()\n            ),\n            pattern_matching:\n                clause.pattern_matching === \"FixedLen\"\n                    ? GrpcPatternMatching.FixedLen\n                    : GrpcPatternMatching.VariableLen,\n            models: clause.models,\n        }));\n\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeEvents({\n                    keys: grpcClauses,\n                }),\n            onMessage: (response: SubscribeEventsResponse) => {\n                if (response.event) {\n                    const hexConverter = this.useEffectSchema\n                        ? (buffer: Uint8Array) =>\n                              Schema.decodeSync(BufferToHex)(buffer)\n                        : bufferToHex;\n\n                    callback({\n                        keys: response.event.keys.map(hexConverter),\n                        data: response.event.data.map(hexConverter),\n                        transaction_hash: hexConverter(\n                            response.event.transaction_hash\n                        ),\n                    });\n                }\n            },\n        });\n    }\n\n    async onTokenBalanceUpdated(\n        contract_addresses: string[] | null | undefined,\n        account_addresses: string[] | null | undefined,\n        token_ids: WasmU256[] | null | undefined,\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeTokenBalances({\n                    contract_addresses:\n                        contract_addresses?.map(hexToBuffer) || [],\n                    account_addresses:\n                        account_addresses?.map(hexToBuffer) || [],\n                    token_ids: token_ids?.map(hexToBuffer) || [],\n                }),\n            onMessage: (response: SubscribeTokenBalancesResponse) => {\n                if (response.balance) {\n                    callback(\n                        this.mappers.tokenBalance(response.balance),\n                        response.subscription_id\n                    );\n                }\n            },\n        });\n    }\n\n    async updateTokenBalanceSubscription(\n        subscription: Subscription,\n        contract_addresses: string[],\n        account_addresses: string[],\n        token_ids: WasmU256[]\n    ): Promise<void> {\n        const grpcSubscription = this.findSubscription(subscription);\n        if (!grpcSubscription) {\n            throw new Error(\"Subscription not found\");\n        }\n\n        await this.client.worldClient.updateTokenBalancesSubscription({\n            subscription_id: BigInt(grpcSubscription.id),\n            contract_addresses: contract_addresses.map(hexToBuffer),\n            account_addresses: account_addresses.map(hexToBuffer),\n            token_ids: token_ids.map(hexToBuffer),\n        }).response;\n    }\n\n    async publishMessage(message: Message): Promise<string> {\n        const request = this.mappers.message(message);\n        const response =\n            await this.client.worldClient.publishMessage(request).response;\n        return this.useEffectSchema\n            ? Schema.decodeSync(BufferToHex)(response.entity_id)\n            : bufferToHex(response.entity_id);\n    }\n\n    async publishMessageBatch(messages: Message[]): Promise<string[]> {\n        const request: PublishMessageBatchRequest = {\n            messages: messages.map(this.mappers.message),\n        };\n        const response =\n            await this.client.worldClient.publishMessageBatch(request).response;\n        const hexConverter = this.useEffectSchema\n            ? (buffer: Uint8Array) => Schema.decodeSync(BufferToHex)(buffer)\n            : bufferToHex;\n        return response.responses.map((r) => hexConverter(r.entity_id));\n    }\n\n    async getWorldMetadata(): Promise<any> {\n        const response = await this.client.worldClient.worldMetadata({})\n            .response;\n        return this.mappers.worldMetadataResponse(response);\n    }\n\n    async getEvents(query: {\n        keys?: KeysClause;\n        pagination?: Pagination;\n    }): Promise<any> {\n        const request = createRetrieveEventsRequest(query);\n        const response =\n            await this.client.worldClient.retrieveEvents(request).response;\n        return this.mappers.eventsResponse(response);\n    }\n\n    async getContracts(query?: {\n        contract_addresses?: string[];\n        contract_types?: ContractType[];\n    }): Promise<any> {\n        const request = createRetrieveContractsRequest(query || {});\n        const response =\n            await this.client.worldClient.retrieveContracts(request).response;\n        return this.mappers.contractsResponse(response);\n    }\n\n    async updateTokensSubscription(\n        subscription: Subscription,\n        contractAddresses?: string[],\n        tokenIds?: WasmU256[]\n    ): Promise<void> {\n        const grpcSubscription = this.findSubscription(subscription);\n        if (!grpcSubscription) {\n            throw new Error(\"Subscription not found\");\n        }\n\n        await this.client.worldClient.updateTokensSubscription({\n            subscription_id: BigInt(grpcSubscription.id),\n            contract_addresses: contractAddresses?.map(hexToBuffer) || [],\n            token_ids: tokenIds?.map(hexToBuffer) || [],\n        }).response;\n    }\n\n    async onContractsUpdated(\n        query: {\n            contract_addresses?: string[];\n            contract_types?: ContractType[];\n        },\n        callback: Function\n    ): Promise<Subscription> {\n        return this.createStreamSubscription({\n            createStream: () =>\n                this.client.worldClient.subscribeContracts({\n                    query: {\n                        contract_addresses:\n                            query.contract_addresses?.map(hexToBuffer) || [],\n                        contract_types: query.contract_types || [],\n                    },\n                }),\n            onMessage: (response: SubscribeContractsResponse) => {\n                if (response.contract) {\n                    callback(this.mappers.contract(response.contract));\n                }\n            },\n        });\n    }\n\n    private findSubscription(\n        subscription: GrpcSubscription\n    ): ToriiSubscription | undefined {\n        return this.subscriptions.get(subscription.id);\n    }\n\n    destroy() {\n        // Cancel all active subscriptions\n        for (const [_, subscription] of this.subscriptions) {\n            subscription.cancel();\n        }\n        this.subscriptions.clear();\n\n        // Destroy the underlying client\n        this.client.destroy();\n    }\n}\n"],"mappings":"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","names":["WireType","UnknownFieldHandler","reflectionMergePartial","MessageType","WireType","UnknownFieldHandler","reflectionMergePartial","MessageType","UnknownFieldHandler","reflectionMergePartial","MessageType","PatternMatching","LogicalOperator","ComparisonOperator","OrderDirection","PaginationDirection","CallType","ContractType","MessageType","reflectionMergePartial","UnknownFieldHandler","WireType","MessageType","reflectionMergePartial","UnknownFieldHandler","WireType","World","World","hexToBuffer","Schema","Schema","textDecoder","Schema","Schema","Schema","Schema","Schema","Schema","Schema","hexToBuffer","bufferToHex","Schema"]}