import * as _protobuf_ts_runtime from '@protobuf-ts/runtime';
import { MessageType, PartialMessage, IBinaryReader, BinaryReadOptions, IBinaryWriter, BinaryWriteOptions } from '@protobuf-ts/runtime';
import * as _protobuf_ts_runtime_rpc from '@protobuf-ts/runtime-rpc';
import { ServiceType, RpcOptions, ServerStreamingCall, UnaryCall, ServiceInfo, RpcTransport } from '@protobuf-ts/runtime-rpc';

declare class EnumOption$Type extends MessageType<EnumOption> {
    constructor();
    create(value?: PartialMessage<EnumOption>): EnumOption;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumOption): EnumOption;
    internalBinaryWrite(message: EnumOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.EnumOption
 */
interface EnumOption {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: types.Ty ty = 2
     */
    ty?: Ty$1;
}
/**
 * @generated MessageType for protobuf message types.EnumOption
 */
declare const EnumOption: EnumOption$Type;
declare class Enum$Type extends MessageType<Enum> {
    constructor();
    create(value?: PartialMessage<Enum>): Enum;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enum): Enum;
    internalBinaryWrite(message: Enum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Enum
 */
interface Enum {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 option = 2
     */
    option: number;
    /**
     * @generated from protobuf field: repeated types.EnumOption options = 3
     */
    options: EnumOption[];
}
/**
 * @generated MessageType for protobuf message types.Enum
 */
declare const Enum: Enum$Type;
declare class Primitive$Type extends MessageType<Primitive$1> {
    constructor();
    create(value?: PartialMessage<Primitive$1>): Primitive$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Primitive$1): Primitive$1;
    internalBinaryWrite(message: Primitive$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Primitive
 */
interface Primitive$1 {
    /**
     * @generated from protobuf oneof: primitive_type
     */
    primitive_type: {
        oneofKind: "i8";
        /**
         * @generated from protobuf field: int32 i8 = 1
         */
        i8: number;
    } | {
        oneofKind: "i16";
        /**
         * @generated from protobuf field: int32 i16 = 2
         */
        i16: number;
    } | {
        oneofKind: "i32";
        /**
         * @generated from protobuf field: int32 i32 = 3
         */
        i32: number;
    } | {
        oneofKind: "i64";
        /**
         * @generated from protobuf field: int64 i64 = 4
         */
        i64: bigint;
    } | {
        oneofKind: "i128";
        /**
         * @generated from protobuf field: bytes i128 = 5
         */
        i128: Uint8Array;
    } | {
        oneofKind: "u8";
        /**
         * @generated from protobuf field: uint32 u8 = 6
         */
        u8: number;
    } | {
        oneofKind: "u16";
        /**
         * @generated from protobuf field: uint32 u16 = 7
         */
        u16: number;
    } | {
        oneofKind: "u32";
        /**
         * @generated from protobuf field: uint32 u32 = 8
         */
        u32: number;
    } | {
        oneofKind: "u64";
        /**
         * @generated from protobuf field: uint64 u64 = 9
         */
        u64: bigint;
    } | {
        oneofKind: "u128";
        /**
         * @generated from protobuf field: bytes u128 = 10
         */
        u128: Uint8Array;
    } | {
        oneofKind: "u256";
        /**
         * @generated from protobuf field: bytes u256 = 11
         */
        u256: Uint8Array;
    } | {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: bool bool = 12
         */
        bool: boolean;
    } | {
        oneofKind: "felt252";
        /**
         * @generated from protobuf field: bytes felt252 = 13
         */
        felt252: Uint8Array;
    } | {
        oneofKind: "class_hash";
        /**
         * @generated from protobuf field: bytes class_hash = 14
         */
        class_hash: Uint8Array;
    } | {
        oneofKind: "contract_address";
        /**
         * @generated from protobuf field: bytes contract_address = 15
         */
        contract_address: Uint8Array;
    } | {
        oneofKind: "eth_address";
        /**
         * @generated from protobuf field: bytes eth_address = 16
         */
        eth_address: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Primitive
 */
declare const Primitive$1: Primitive$Type;
declare class Struct$Type extends MessageType<Struct> {
    constructor();
    create(value?: PartialMessage<Struct>): Struct;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Struct): Struct;
    internalBinaryWrite(message: Struct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Struct
 */
interface Struct {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: repeated types.Member children = 2
     */
    children: Member[];
}
/**
 * @generated MessageType for protobuf message types.Struct
 */
declare const Struct: Struct$Type;
declare class Array$$Type extends MessageType<Array$> {
    constructor();
    create(value?: PartialMessage<Array$>): Array$;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Array$): Array$;
    internalBinaryWrite(message: Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Array
 */
interface Array$ {
    /**
     * @generated from protobuf field: repeated types.Ty children = 1
     */
    children: Ty$1[];
}
/**
 * @generated MessageType for protobuf message types.Array
 */
declare const Array$: Array$$Type;
declare class FixedSizeArray$Type extends MessageType<FixedSizeArray$1> {
    constructor();
    create(value?: PartialMessage<FixedSizeArray$1>): FixedSizeArray$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedSizeArray$1): FixedSizeArray$1;
    internalBinaryWrite(message: FixedSizeArray$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.FixedSizeArray
 */
interface FixedSizeArray$1 {
    /**
     * @generated from protobuf field: repeated types.Ty children = 1
     */
    children: Ty$1[];
    /**
     * @generated from protobuf field: uint32 size = 2
     */
    size: number;
}
/**
 * @generated MessageType for protobuf message types.FixedSizeArray
 */
declare const FixedSizeArray$1: FixedSizeArray$Type;
declare class Ty$Type extends MessageType<Ty$1> {
    constructor();
    create(value?: PartialMessage<Ty$1>): Ty$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ty$1): Ty$1;
    internalBinaryWrite(message: Ty$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Ty
 */
interface Ty$1 {
    /**
     * @generated from protobuf oneof: ty_type
     */
    ty_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 2
         */
        primitive: Primitive$1;
    } | {
        oneofKind: "enum";
        /**
         * @generated from protobuf field: types.Enum enum = 3
         */
        enum: Enum;
    } | {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: types.Struct struct = 4
         */
        struct: Struct;
    } | {
        oneofKind: "tuple";
        /**
         * @generated from protobuf field: types.Array tuple = 5
         */
        tuple: Array$;
    } | {
        oneofKind: "array";
        /**
         * @generated from protobuf field: types.Array array = 6
         */
        array: Array$;
    } | {
        oneofKind: "bytearray";
        /**
         * @generated from protobuf field: string bytearray = 7
         */
        bytearray: string;
    } | {
        oneofKind: "fixed_size_array";
        /**
         * @generated from protobuf field: types.FixedSizeArray fixed_size_array = 8
         */
        fixed_size_array: FixedSizeArray$1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Ty
 */
declare const Ty$1: Ty$Type;
declare class Member$Type extends MessageType<Member> {
    constructor();
    create(value?: PartialMessage<Member>): Member;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Member): Member;
    internalBinaryWrite(message: Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Member
 */
interface Member {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: types.Ty ty = 2
     */
    ty?: Ty$1;
    /**
     * @generated from protobuf field: bool key = 3
     */
    key: boolean;
}
/**
 * @generated MessageType for protobuf message types.Member
 */
declare const Member: Member$Type;

/**
 * @generated from protobuf enum types.PatternMatching
 */
declare enum PatternMatching$1 {
    /**
     * @generated from protobuf enum value: FixedLen = 0;
     */
    FixedLen = 0,
    /**
     * @generated from protobuf enum value: VariableLen = 1;
     */
    VariableLen = 1
}
/**
 * @generated from protobuf enum types.LogicalOperator
 */
declare enum LogicalOperator$1 {
    /**
     * @generated from protobuf enum value: AND = 0;
     */
    AND = 0,
    /**
     * @generated from protobuf enum value: OR = 1;
     */
    OR = 1
}
/**
 * @generated from protobuf enum types.ComparisonOperator
 */
declare enum ComparisonOperator$1 {
    /**
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * @generated from protobuf enum value: NEQ = 1;
     */
    NEQ = 1,
    /**
     * @generated from protobuf enum value: GT = 2;
     */
    GT = 2,
    /**
     * @generated from protobuf enum value: GTE = 3;
     */
    GTE = 3,
    /**
     * @generated from protobuf enum value: LT = 4;
     */
    LT = 4,
    /**
     * @generated from protobuf enum value: LTE = 5;
     */
    LTE = 5,
    /**
     * @generated from protobuf enum value: IN = 6;
     */
    IN = 6,
    /**
     * @generated from protobuf enum value: NOT_IN = 7;
     */
    NOT_IN = 7,
    /**
     * Array-specific operators
     *
     * Array contains value
     *
     * @generated from protobuf enum value: CONTAINS = 8;
     */
    CONTAINS = 8,
    /**
     * Array contains all values
     *
     * @generated from protobuf enum value: CONTAINS_ALL = 9;
     */
    CONTAINS_ALL = 9,
    /**
     * Array contains any of the values
     *
     * @generated from protobuf enum value: CONTAINS_ANY = 10;
     */
    CONTAINS_ANY = 10,
    /**
     * Array length equals
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_EQ = 11;
     */
    ARRAY_LENGTH_EQ = 11,
    /**
     * Array length greater than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_GT = 12;
     */
    ARRAY_LENGTH_GT = 12,
    /**
     * Array length less than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_LT = 13;
     */
    ARRAY_LENGTH_LT = 13
}
/**
 * @generated from protobuf enum types.OrderDirection
 */
declare enum OrderDirection$1 {
    /**
     * @generated from protobuf enum value: ASC = 0;
     */
    ASC = 0,
    /**
     * @generated from protobuf enum value: DESC = 1;
     */
    DESC = 1
}
/**
 * @generated from protobuf enum types.PaginationDirection
 */
declare enum PaginationDirection$1 {
    /**
     * @generated from protobuf enum value: FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: BACKWARD = 1;
     */
    BACKWARD = 1
}
/**
 * @generated from protobuf enum types.CallType
 */
declare enum CallType$1 {
    /**
     * @generated from protobuf enum value: EXECUTE = 0;
     */
    EXECUTE = 0,
    /**
     * @generated from protobuf enum value: EXECUTE_FROM_OUTSIDE = 1;
     */
    EXECUTE_FROM_OUTSIDE = 1
}
/**
 * @generated from protobuf enum types.ContractType
 */
declare enum ContractType {
    /**
     * @generated from protobuf enum value: WORLD = 0;
     */
    WORLD = 0,
    /**
     * @generated from protobuf enum value: ERC20 = 1;
     */
    ERC20 = 1,
    /**
     * @generated from protobuf enum value: ERC721 = 2;
     */
    ERC721 = 2,
    /**
     * @generated from protobuf enum value: ERC1155 = 3;
     */
    ERC1155 = 3,
    /**
     * @generated from protobuf enum value: UDC = 4;
     */
    UDC = 4,
    /**
     * @generated from protobuf enum value: OTHER = 5;
     */
    OTHER = 5
}
declare class World$Type extends MessageType<World$1> {
    constructor();
    create(value?: PartialMessage<World$1>): World$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: World$1): World$1;
    internalBinaryWrite(message: World$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.World
 */
interface World$1 {
    /**
     * The hex-encoded address of the world.
     *
     * @generated from protobuf field: string world_address = 1
     */
    world_address: string;
    /**
     * A list of metadata for all registered components in the world.
     *
     * @generated from protobuf field: repeated types.Model models = 2
     */
    models: Model$1[];
}
/**
 * @generated MessageType for protobuf message types.World
 */
declare const World$1: World$Type;
declare class Model$Type extends MessageType<Model$1> {
    constructor();
    create(value?: PartialMessage<Model$1>): Model$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model$1): Model$1;
    internalBinaryWrite(message: Model$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Model
 */
interface Model$1 {
    /**
     * Model selector
     *
     * @generated from protobuf field: bytes selector = 1
     */
    selector: Uint8Array;
    /**
     * Model namespace
     *
     * @generated from protobuf field: string namespace = 2
     */
    namespace: string;
    /**
     * Model name
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * Model size when it is packed for storage
     *
     * @generated from protobuf field: uint32 packed_size = 4
     */
    packed_size: number;
    /**
     * Model size when it is unpacked
     *
     * @generated from protobuf field: uint32 unpacked_size = 5
     */
    unpacked_size: number;
    /**
     * felt bytes of the class hash of the component
     *
     * @generated from protobuf field: bytes class_hash = 6
     */
    class_hash: Uint8Array;
    /**
     * The layout of the component in bytes
     *
     * @generated from protobuf field: bytes layout = 7
     */
    layout: Uint8Array;
    /**
     * The schema of the component serialized in bytes (for simplicity sake)
     *
     * @generated from protobuf field: bytes schema = 8
     */
    schema: Uint8Array;
    /**
     * felt bytes of the contract address of the component
     *
     * @generated from protobuf field: bytes contract_address = 9
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: bool use_legacy_store = 10
     */
    use_legacy_store: boolean;
}
/**
 * @generated MessageType for protobuf message types.Model
 */
declare const Model$1: Model$Type;
declare class Entity$Type extends MessageType<Entity$1> {
    constructor();
    create(value?: PartialMessage<Entity$1>): Entity$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity$1): Entity$1;
    internalBinaryWrite(message: Entity$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Entity
 */
interface Entity$1 {
    /**
     * The entity's hashed keys
     *
     * @generated from protobuf field: bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array;
    /**
     * Models of the entity
     *
     * @generated from protobuf field: repeated types.Struct models = 2
     */
    models: Struct[];
    /**
     * Created at timestamp
     *
     * @generated from protobuf field: uint64 created_at = 3
     */
    created_at: bigint;
    /**
     * Updated at timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 4
     */
    updated_at: bigint;
    /**
     * Block timestamp when the entity was updated
     *
     * @generated from protobuf field: uint64 executed_at = 5
     */
    executed_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.Entity
 */
declare const Entity$1: Entity$Type;
declare class Event$Type extends MessageType<Event> {
    constructor();
    create(value?: PartialMessage<Event>): Event;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event;
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Event
 */
interface Event {
    /**
     * The event's keys
     *
     * @generated from protobuf field: repeated bytes keys = 1
     */
    keys: Uint8Array[];
    /**
     * Data of the event
     *
     * @generated from protobuf field: repeated bytes data = 2
     */
    data: Uint8Array[];
    /**
     * event's transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 3
     */
    transaction_hash: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Event
 */
declare const Event: Event$Type;
declare class Query$Type extends MessageType<Query$1> {
    constructor();
    create(value?: PartialMessage<Query$1>): Query$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query$1): Query$1;
    internalBinaryWrite(message: Query$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Query
 */
interface Query$1 {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause$1;
    /**
     * @generated from protobuf field: bool no_hashed_keys = 2
     */
    no_hashed_keys: boolean;
    /**
     * @generated from protobuf field: repeated string models = 3
     */
    models: string[];
    /**
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
    /**
     * @generated from protobuf field: bool historical = 5
     */
    historical: boolean;
}
/**
 * @generated MessageType for protobuf message types.Query
 */
declare const Query$1: Query$Type;
declare class EventQuery$Type extends MessageType<EventQuery> {
    constructor();
    create(value?: PartialMessage<EventQuery>): EventQuery;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQuery): EventQuery;
    internalBinaryWrite(message: EventQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.EventQuery
 */
interface EventQuery {
    /**
     * @generated from protobuf field: types.KeysClause keys = 1
     */
    keys?: KeysClause$1;
    /**
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.EventQuery
 */
declare const EventQuery: EventQuery$Type;
declare class Clause$Type extends MessageType<Clause$1> {
    constructor();
    create(value?: PartialMessage<Clause$1>): Clause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clause$1): Clause$1;
    internalBinaryWrite(message: Clause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Clause
 */
interface Clause$1 {
    /**
     * @generated from protobuf oneof: clause_type
     */
    clause_type: {
        oneofKind: "hashed_keys";
        /**
         * @generated from protobuf field: types.HashedKeysClause hashed_keys = 1
         */
        hashed_keys: HashedKeysClause;
    } | {
        oneofKind: "keys";
        /**
         * @generated from protobuf field: types.KeysClause keys = 2
         */
        keys: KeysClause$1;
    } | {
        oneofKind: "member";
        /**
         * @generated from protobuf field: types.MemberClause member = 3
         */
        member: MemberClause$1;
    } | {
        oneofKind: "composite";
        /**
         * @generated from protobuf field: types.CompositeClause composite = 4
         */
        composite: CompositeClause$1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Clause
 */
declare const Clause$1: Clause$Type;
declare class KeysClause$Type extends MessageType<KeysClause$1> {
    constructor();
    create(value?: PartialMessage<KeysClause$1>): KeysClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeysClause$1): KeysClause$1;
    internalBinaryWrite(message: KeysClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.KeysClause
 */
interface KeysClause$1 {
    /**
     * @generated from protobuf field: repeated bytes keys = 2
     */
    keys: Uint8Array[];
    /**
     * @generated from protobuf field: types.PatternMatching pattern_matching = 3
     */
    pattern_matching: PatternMatching$1;
    /**
     * @generated from protobuf field: repeated string models = 4
     */
    models: string[];
}
/**
 * @generated MessageType for protobuf message types.KeysClause
 */
declare const KeysClause$1: KeysClause$Type;
declare class HashedKeysClause$Type extends MessageType<HashedKeysClause> {
    constructor();
    create(value?: PartialMessage<HashedKeysClause>): HashedKeysClause;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HashedKeysClause): HashedKeysClause;
    internalBinaryWrite(message: HashedKeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.HashedKeysClause
 */
interface HashedKeysClause {
    /**
     * @generated from protobuf field: repeated bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message types.HashedKeysClause
 */
declare const HashedKeysClause: HashedKeysClause$Type;
declare class MemberValue$Type extends MessageType<MemberValue$1> {
    constructor();
    create(value?: PartialMessage<MemberValue$1>): MemberValue$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValue$1): MemberValue$1;
    internalBinaryWrite(message: MemberValue$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberValue
 */
interface MemberValue$1 {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 1
         */
        primitive: Primitive$1;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 2
         */
        string: string;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: types.MemberValueList list = 3
         */
        list: MemberValueList;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.MemberValue
 */
declare const MemberValue$1: MemberValue$Type;
declare class MemberValueList$Type extends MessageType<MemberValueList> {
    constructor();
    create(value?: PartialMessage<MemberValueList>): MemberValueList;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValueList): MemberValueList;
    internalBinaryWrite(message: MemberValueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberValueList
 */
interface MemberValueList {
    /**
     * @generated from protobuf field: repeated types.MemberValue values = 1
     */
    values: MemberValue$1[];
}
/**
 * @generated MessageType for protobuf message types.MemberValueList
 */
declare const MemberValueList: MemberValueList$Type;
declare class MemberClause$Type extends MessageType<MemberClause$1> {
    constructor();
    create(value?: PartialMessage<MemberClause$1>): MemberClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberClause$1): MemberClause$1;
    internalBinaryWrite(message: MemberClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberClause
 */
interface MemberClause$1 {
    /**
     * @generated from protobuf field: string model = 2
     */
    model: string;
    /**
     * @generated from protobuf field: string member = 3
     */
    member: string;
    /**
     * @generated from protobuf field: types.ComparisonOperator operator = 4
     */
    operator: ComparisonOperator$1;
    /**
     * @generated from protobuf field: types.MemberValue value = 5
     */
    value?: MemberValue$1;
}
/**
 * @generated MessageType for protobuf message types.MemberClause
 */
declare const MemberClause$1: MemberClause$Type;
declare class CompositeClause$Type extends MessageType<CompositeClause$1> {
    constructor();
    create(value?: PartialMessage<CompositeClause$1>): CompositeClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompositeClause$1): CompositeClause$1;
    internalBinaryWrite(message: CompositeClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.CompositeClause
 */
interface CompositeClause$1 {
    /**
     * @generated from protobuf field: types.LogicalOperator operator = 3
     */
    operator: LogicalOperator$1;
    /**
     * @generated from protobuf field: repeated types.Clause clauses = 4
     */
    clauses: Clause$1[];
}
/**
 * @generated MessageType for protobuf message types.CompositeClause
 */
declare const CompositeClause$1: CompositeClause$Type;
declare class Token$Type extends MessageType<Token$1> {
    constructor();
    create(value?: PartialMessage<Token$1>): Token$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token$1): Token$1;
    internalBinaryWrite(message: Token$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Token
 */
interface Token$1 {
    /**
     * @generated from protobuf field: optional bytes token_id = 1
     */
    token_id?: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Token
 */
declare const Token$1: Token$Type;
declare class TokenContract$Type extends MessageType<TokenContract$1> {
    constructor();
    create(value?: PartialMessage<TokenContract$1>): TokenContract$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContract$1): TokenContract$1;
    internalBinaryWrite(message: TokenContract$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TokenContract
 */
interface TokenContract$1 {
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: uint32 count = 6
     */
    count: number;
    /**
     * @generated from protobuf field: bytes metadata = 7
     */
    metadata: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TokenContract
 */
declare const TokenContract$1: TokenContract$Type;
declare class TokenBalance$Type extends MessageType<TokenBalance$1> {
    constructor();
    create(value?: PartialMessage<TokenBalance$1>): TokenBalance$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalance$1): TokenBalance$1;
    internalBinaryWrite(message: TokenBalance$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TokenBalance
 */
interface TokenBalance$1 {
    /**
     * @generated from protobuf field: bytes balance = 1
     */
    balance: Uint8Array;
    /**
     * @generated from protobuf field: bytes account_address = 2
     */
    account_address: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 3
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes token_id = 4
     */
    token_id?: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TokenBalance
 */
declare const TokenBalance$1: TokenBalance$Type;
declare class OrderBy$Type extends MessageType<OrderBy$1> {
    constructor();
    create(value?: PartialMessage<OrderBy$1>): OrderBy$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBy$1): OrderBy$1;
    internalBinaryWrite(message: OrderBy$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.OrderBy
 */
interface OrderBy$1 {
    /**
     * @generated from protobuf field: string field = 1
     */
    field: string;
    /**
     * @generated from protobuf field: types.OrderDirection direction = 2
     */
    direction: OrderDirection$1;
}
/**
 * @generated MessageType for protobuf message types.OrderBy
 */
declare const OrderBy$1: OrderBy$Type;
declare class Controller$Type extends MessageType<Controller$1> {
    constructor();
    create(value?: PartialMessage<Controller$1>): Controller$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Controller$1): Controller$1;
    internalBinaryWrite(message: Controller$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Controller
 */
interface Controller$1 {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: uint64 deployed_at_timestamp = 3
     */
    deployed_at_timestamp: bigint;
}
/**
 * @generated MessageType for protobuf message types.Controller
 */
declare const Controller$1: Controller$Type;
declare class Pagination$Type extends MessageType<Pagination$1> {
    constructor();
    create(value?: PartialMessage<Pagination$1>): Pagination$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination$1): Pagination$1;
    internalBinaryWrite(message: Pagination$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Pagination
 */
interface Pagination$1 {
    /**
     * @generated from protobuf field: string cursor = 1
     */
    cursor: string;
    /**
     * @generated from protobuf field: uint32 limit = 2
     */
    limit: number;
    /**
     * @generated from protobuf field: types.PaginationDirection direction = 3
     */
    direction: PaginationDirection$1;
    /**
     * @generated from protobuf field: repeated types.OrderBy order_by = 4
     */
    order_by: OrderBy$1[];
}
/**
 * @generated MessageType for protobuf message types.Pagination
 */
declare const Pagination$1: Pagination$Type;
declare class ControllerQuery$Type extends MessageType<ControllerQuery$1> {
    constructor();
    create(value?: PartialMessage<ControllerQuery$1>): ControllerQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerQuery$1): ControllerQuery$1;
    internalBinaryWrite(message: ControllerQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.ControllerQuery
 */
interface ControllerQuery$1 {
    /**
     * The list of contract addresses to retrieve controllers for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of usernames to retrieve controllers for
     *
     * @generated from protobuf field: repeated string usernames = 2
     */
    usernames: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.ControllerQuery
 */
declare const ControllerQuery$1: ControllerQuery$Type;
declare class TokenQuery$Type extends MessageType<TokenQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenQuery$1>): TokenQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenQuery$1): TokenQuery$1;
    internalBinaryWrite(message: TokenQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message types.TokenQuery
 */
interface TokenQuery$1 {
    /**
     * The list of contract addresses to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenQuery
 */
declare const TokenQuery$1: TokenQuery$Type;
declare class TokenBalanceQuery$Type extends MessageType<TokenBalanceQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenBalanceQuery$1>): TokenBalanceQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalanceQuery$1): TokenBalanceQuery$1;
    internalBinaryWrite(message: TokenBalanceQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message types.TokenBalanceQuery
 */
interface TokenBalanceQuery$1 {
    /**
     * The account addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenBalanceQuery
 */
declare const TokenBalanceQuery$1: TokenBalanceQuery$Type;
declare class TransactionCall$Type extends MessageType<TransactionCall$1> {
    constructor();
    create(value?: PartialMessage<TransactionCall$1>): TransactionCall$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionCall$1): TransactionCall$1;
    internalBinaryWrite(message: TransactionCall$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionCall
 */
interface TransactionCall$1 {
    /**
     * The contract address being called
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The function name being called
     *
     * @generated from protobuf field: string entrypoint = 2
     */
    entrypoint: string;
    /**
     * The calldata for the function call
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)
     *
     * @generated from protobuf field: types.CallType call_type = 4
     */
    call_type: CallType$1;
    /**
     * The address making the call
     *
     * @generated from protobuf field: bytes caller_address = 5
     */
    caller_address: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TransactionCall
 */
declare const TransactionCall$1: TransactionCall$Type;
declare class Transaction$Type extends MessageType<Transaction$1> {
    constructor();
    create(value?: PartialMessage<Transaction$1>): Transaction$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction$1): Transaction$1;
    internalBinaryWrite(message: Transaction$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Transaction
 */
interface Transaction$1 {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 1
     */
    transaction_hash: Uint8Array;
    /**
     * The sender address
     *
     * @generated from protobuf field: bytes sender_address = 2
     */
    sender_address: Uint8Array;
    /**
     * The transaction calldata
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The maximum fee for the transaction
     *
     * @generated from protobuf field: bytes max_fee = 4
     */
    max_fee: Uint8Array;
    /**
     * The transaction signature
     *
     * @generated from protobuf field: repeated bytes signature = 5
     */
    signature: Uint8Array[];
    /**
     * The transaction nonce
     *
     * @generated from protobuf field: bytes nonce = 6
     */
    nonce: Uint8Array;
    /**
     * The block number the transaction was included in
     *
     * @generated from protobuf field: uint64 block_number = 7
     */
    block_number: bigint;
    /**
     * The transaction type (INVOKE, L1_HANDLER, etc.)
     *
     * @generated from protobuf field: string transaction_type = 8
     */
    transaction_type: string;
    /**
     * The timestamp when the transaction was executed
     *
     * @generated from protobuf field: uint64 block_timestamp = 9
     */
    block_timestamp: bigint;
    /**
     * The parsed calls within the transaction
     *
     * @generated from protobuf field: repeated types.TransactionCall calls = 10
     */
    calls: TransactionCall$1[];
    /**
     * The unique models associated with this transaction
     *
     * @generated from protobuf field: repeated bytes unique_models = 11
     */
    unique_models: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message types.Transaction
 */
declare const Transaction$1: Transaction$Type;
declare class TransactionFilter$Type extends MessageType<TransactionFilter$1> {
    constructor();
    create(value?: PartialMessage<TransactionFilter$1>): TransactionFilter$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionFilter$1): TransactionFilter$1;
    internalBinaryWrite(message: TransactionFilter$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionFilter
 */
interface TransactionFilter$1 {
    /**
     * The list of transaction hashes to retrieve
     *
     * @generated from protobuf field: repeated bytes transaction_hashes = 1
     */
    transaction_hashes: Uint8Array[];
    /**
     * The list of caller addresses to filter by
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 2
     */
    caller_addresses: Uint8Array[];
    /**
     * The list of contract addresses to filter by (calls made to these contracts)
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 3
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of entrypoints to filter by
     *
     * @generated from protobuf field: repeated string entrypoints = 4
     */
    entrypoints: string[];
    /**
     * The list of model selectors to filter by
     *
     * @generated from protobuf field: repeated bytes model_selectors = 5
     */
    model_selectors: Uint8Array[];
    /**
     * The block number range to filter by
     *
     * @generated from protobuf field: optional uint64 from_block = 6
     */
    from_block?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_block = 7
     */
    to_block?: bigint;
}
/**
 * @generated MessageType for protobuf message types.TransactionFilter
 */
declare const TransactionFilter$1: TransactionFilter$Type;
declare class TransactionQuery$Type extends MessageType<TransactionQuery$1> {
    constructor();
    create(value?: PartialMessage<TransactionQuery$1>): TransactionQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionQuery$1): TransactionQuery$1;
    internalBinaryWrite(message: TransactionQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionQuery
 */
interface TransactionQuery$1 {
    /**
     * The filter to apply to the query
     *
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter$1;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TransactionQuery
 */
declare const TransactionQuery$1: TransactionQuery$Type;
declare class Contract$Type extends MessageType<Contract> {
    constructor();
    create(value?: PartialMessage<Contract>): Contract;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract;
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Contract
 */
interface Contract {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType;
    /**
     * Current block height
     *
     * @generated from protobuf field: optional uint64 head = 3
     */
    head?: bigint;
    /**
     * Transactions per second
     *
     * @generated from protobuf field: optional uint64 tps = 4
     */
    tps?: bigint;
    /**
     * Last block timestamp
     *
     * @generated from protobuf field: optional uint64 last_block_timestamp = 5
     */
    last_block_timestamp?: bigint;
    /**
     * Last pending block transaction
     *
     * @generated from protobuf field: optional bytes last_pending_block_tx = 6
     */
    last_pending_block_tx?: Uint8Array;
    /**
     * When the contract was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
    /**
     * When the contract was first tracked
     *
     * @generated from protobuf field: uint64 created_at = 8
     */
    created_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.Contract
 */
declare const Contract: Contract$Type;
declare class ContractQuery$Type extends MessageType<ContractQuery> {
    constructor();
    create(value?: PartialMessage<ContractQuery>): ContractQuery;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractQuery): ContractQuery;
    internalBinaryWrite(message: ContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve contracts
 *
 * @generated from protobuf message types.ContractQuery
 */
interface ContractQuery {
    /**
     * The list of contract addresses to retrieve
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType[];
}
/**
 * @generated MessageType for protobuf message types.ContractQuery
 */
declare const ContractQuery: ContractQuery$Type;

declare class SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTransactionsRequest>): SubscribeTransactionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsRequest): SubscribeTransactionsRequest;
    internalBinaryWrite(message: SubscribeTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsRequest
 */
interface SubscribeTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsRequest
 */
declare const SubscribeTransactionsRequest: SubscribeTransactionsRequest$Type;
declare class SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTransactionsResponse>): SubscribeTransactionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsResponse): SubscribeTransactionsResponse;
    internalBinaryWrite(message: SubscribeTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsResponse
 */
interface SubscribeTransactionsResponse {
    /**
     * @generated from protobuf field: types.Transaction transaction = 1
     */
    transaction?: Transaction$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsResponse
 */
declare const SubscribeTransactionsResponse: SubscribeTransactionsResponse$Type;
declare class RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveControllersRequest>): RetrieveControllersRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersRequest): RetrieveControllersRequest;
    internalBinaryWrite(message: RetrieveControllersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveControllersRequest
 */
interface RetrieveControllersRequest {
    /**
     * @generated from protobuf field: types.ControllerQuery query = 1
     */
    query?: ControllerQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersRequest
 */
declare const RetrieveControllersRequest: RetrieveControllersRequest$Type;
declare class RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveControllersResponse>): RetrieveControllersResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersResponse): RetrieveControllersResponse;
    internalBinaryWrite(message: RetrieveControllersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveControllersResponse
 */
interface RetrieveControllersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Controller controllers = 2
     */
    controllers: Controller$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersResponse
 */
declare const RetrieveControllersResponse: RetrieveControllersResponse$Type;
declare class RetrieveContractsRequest$Type extends MessageType<RetrieveContractsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveContractsRequest>): RetrieveContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsRequest): RetrieveContractsRequest;
    internalBinaryWrite(message: RetrieveContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveContractsRequest
 */
interface RetrieveContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsRequest
 */
declare const RetrieveContractsRequest: RetrieveContractsRequest$Type;
declare class RetrieveContractsResponse$Type extends MessageType<RetrieveContractsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveContractsResponse>): RetrieveContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsResponse): RetrieveContractsResponse;
    internalBinaryWrite(message: RetrieveContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveContractsResponse
 */
interface RetrieveContractsResponse {
    /**
     * @generated from protobuf field: repeated types.Contract contracts = 1
     */
    contracts: Contract[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsResponse
 */
declare const RetrieveContractsResponse: RetrieveContractsResponse$Type;
declare class UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>): UpdateTokenBalancesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenBalancesSubscriptionRequest): UpdateTokenBalancesSubscriptionRequest;
    internalBinaryWrite(message: UpdateTokenBalancesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update a token balance subscription
 *
 * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
interface UpdateTokenBalancesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
declare const UpdateTokenBalancesSubscriptionRequest: UpdateTokenBalancesSubscriptionRequest$Type;
declare class SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenBalancesResponse>): SubscribeTokenBalancesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesResponse): SubscribeTokenBalancesResponse;
    internalBinaryWrite(message: SubscribeTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.SubscribeTokenBalancesResponse
 */
interface SubscribeTokenBalancesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token balance
     *
     * @generated from protobuf field: types.TokenBalance balance = 2
     */
    balance?: TokenBalance$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse
 */
declare const SubscribeTokenBalancesResponse: SubscribeTokenBalancesResponse$Type;
declare class RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokensRequest>): RetrieveTokensRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensRequest): RetrieveTokensRequest;
    internalBinaryWrite(message: RetrieveTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message world.RetrieveTokensRequest
 */
interface RetrieveTokensRequest {
    /**
     * @generated from protobuf field: types.TokenQuery query = 1
     */
    query?: TokenQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensRequest
 */
declare const RetrieveTokensRequest: RetrieveTokensRequest$Type;
declare class SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTokensRequest>): SubscribeTokensRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensRequest): SubscribeTokensRequest;
    internalBinaryWrite(message: SubscribeTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to token updates
 *
 * @generated from protobuf message world.SubscribeTokensRequest
 */
interface SubscribeTokensRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensRequest
 */
declare const SubscribeTokensRequest: SubscribeTokensRequest$Type;
declare class RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokensResponse>): RetrieveTokensResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensResponse): RetrieveTokensResponse;
    internalBinaryWrite(message: RetrieveTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing tokens
 *
 * @generated from protobuf message world.RetrieveTokensResponse
 */
interface RetrieveTokensResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Token tokens = 2
     */
    tokens: Token$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensResponse
 */
declare const RetrieveTokensResponse: RetrieveTokensResponse$Type;
declare class SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTokensResponse>): SubscribeTokensResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensResponse): SubscribeTokensResponse;
    internalBinaryWrite(message: SubscribeTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token updates
 *
 * @generated from protobuf message world.SubscribeTokensResponse
 */
interface SubscribeTokensResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token
     *
     * @generated from protobuf field: types.Token token = 2
     */
    token?: Token$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensResponse
 */
declare const SubscribeTokensResponse: SubscribeTokensResponse$Type;
declare class UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateTokenSubscriptionRequest>): UpdateTokenSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenSubscriptionRequest): UpdateTokenSubscriptionRequest;
    internalBinaryWrite(message: UpdateTokenSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update a token subscription
 *
 * @generated from protobuf message world.UpdateTokenSubscriptionRequest
 */
interface UpdateTokenSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest
 */
declare const UpdateTokenSubscriptionRequest: UpdateTokenSubscriptionRequest$Type;
declare class RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenBalancesRequest>): RetrieveTokenBalancesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesRequest): RetrieveTokenBalancesRequest;
    internalBinaryWrite(message: RetrieveTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesRequest
 */
interface RetrieveTokenBalancesRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest
 */
declare const RetrieveTokenBalancesRequest: RetrieveTokenBalancesRequest$Type;
declare class SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenBalancesRequest>): SubscribeTokenBalancesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesRequest): SubscribeTokenBalancesRequest;
    internalBinaryWrite(message: SubscribeTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to token balance updates
 *
 * @generated from protobuf message world.SubscribeTokenBalancesRequest
 */
interface SubscribeTokenBalancesRequest {
    /**
     * The account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest
 */
declare const SubscribeTokenBalancesRequest: SubscribeTokenBalancesRequest$Type;
declare class RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenBalancesResponse>): RetrieveTokenBalancesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesResponse): RetrieveTokenBalancesResponse;
    internalBinaryWrite(message: RetrieveTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesResponse
 */
interface RetrieveTokenBalancesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenBalance balances = 2
     */
    balances: TokenBalance$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse
 */
declare const RetrieveTokenBalancesResponse: RetrieveTokenBalancesResponse$Type;
declare class RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTransactionsRequest>): RetrieveTransactionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsRequest): RetrieveTransactionsRequest;
    internalBinaryWrite(message: RetrieveTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsRequest
 */
interface RetrieveTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionQuery query = 1
     */
    query?: TransactionQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsRequest
 */
declare const RetrieveTransactionsRequest: RetrieveTransactionsRequest$Type;
declare class RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTransactionsResponse>): RetrieveTransactionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsResponse): RetrieveTransactionsResponse;
    internalBinaryWrite(message: RetrieveTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsResponse
 */
interface RetrieveTransactionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Transaction transactions = 2
     */
    transactions: Transaction$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsResponse
 */
declare const RetrieveTransactionsResponse: RetrieveTransactionsResponse$Type;
declare class RetrieveTokenContractsRequest$Type extends MessageType<RetrieveTokenContractsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenContractsRequest>): RetrieveTokenContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsRequest): RetrieveTokenContractsRequest;
    internalBinaryWrite(message: RetrieveTokenContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsRequest
 */
interface RetrieveTokenContractsRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsRequest
 */
declare const RetrieveTokenContractsRequest: RetrieveTokenContractsRequest$Type;
declare class RetrieveTokenContractsResponse$Type extends MessageType<RetrieveTokenContractsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenContractsResponse>): RetrieveTokenContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsResponse): RetrieveTokenContractsResponse;
    internalBinaryWrite(message: RetrieveTokenContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenContractsResponse
 */
interface RetrieveTokenContractsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenContract tokens = 2
     */
    tokens: TokenContract$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsResponse
 */
declare const RetrieveTokenContractsResponse: RetrieveTokenContractsResponse$Type;
declare class SubscribeContractsRequest$Type extends MessageType<SubscribeContractsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeContractsRequest>): SubscribeContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsRequest): SubscribeContractsRequest;
    internalBinaryWrite(message: SubscribeContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsRequest
 */
interface SubscribeContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsRequest
 */
declare const SubscribeContractsRequest: SubscribeContractsRequest$Type;
declare class SubscribeContractsResponse$Type extends MessageType<SubscribeContractsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeContractsResponse>): SubscribeContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsResponse): SubscribeContractsResponse;
    internalBinaryWrite(message: SubscribeContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsResponse
 */
interface SubscribeContractsResponse {
    /**
     * @generated from protobuf field: types.Contract contract = 1
     */
    contract?: Contract;
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsResponse
 */
declare const SubscribeContractsResponse: SubscribeContractsResponse$Type;
declare class WorldMetadataRequest$Type extends MessageType<WorldMetadataRequest> {
    constructor();
    create(value?: PartialMessage<WorldMetadataRequest>): WorldMetadataRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataRequest): WorldMetadataRequest;
    internalBinaryWrite(message: WorldMetadataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve metadata for a specific world ID.
 *
 * @generated from protobuf message world.WorldMetadataRequest
 */
interface WorldMetadataRequest {
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataRequest
 */
declare const WorldMetadataRequest: WorldMetadataRequest$Type;
declare class WorldMetadataResponse$Type extends MessageType<WorldMetadataResponse> {
    constructor();
    create(value?: PartialMessage<WorldMetadataResponse>): WorldMetadataResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataResponse): WorldMetadataResponse;
    internalBinaryWrite(message: WorldMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * The metadata response contains addresses and class hashes for the world.
 *
 * @generated from protobuf message world.WorldMetadataResponse
 */
interface WorldMetadataResponse {
    /**
     * @generated from protobuf field: types.World world = 1
     */
    world?: World$1;
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataResponse
 */
declare const WorldMetadataResponse: WorldMetadataResponse$Type;
declare class SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeEntitiesRequest>): SubscribeEntitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntitiesRequest): SubscribeEntitiesRequest;
    internalBinaryWrite(message: SubscribeEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEntitiesRequest
 */
interface SubscribeEntitiesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntitiesRequest
 */
declare const SubscribeEntitiesRequest: SubscribeEntitiesRequest$Type;
declare class SubscribeEventMessagesRequest$Type extends MessageType<SubscribeEventMessagesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeEventMessagesRequest>): SubscribeEventMessagesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventMessagesRequest): SubscribeEventMessagesRequest;
    internalBinaryWrite(message: SubscribeEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEventMessagesRequest
 */
interface SubscribeEventMessagesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventMessagesRequest
 */
declare const SubscribeEventMessagesRequest: SubscribeEventMessagesRequest$Type;
declare class UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateEntitiesSubscriptionRequest>): UpdateEntitiesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEntitiesSubscriptionRequest): UpdateEntitiesSubscriptionRequest;
    internalBinaryWrite(message: UpdateEntitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest
 */
interface UpdateEntitiesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause$1;
}
/**
 * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest
 */
declare const UpdateEntitiesSubscriptionRequest: UpdateEntitiesSubscriptionRequest$Type;
declare class UpdateEventMessagesSubscriptionRequest$Type extends MessageType<UpdateEventMessagesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateEventMessagesSubscriptionRequest>): UpdateEventMessagesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEventMessagesSubscriptionRequest): UpdateEventMessagesSubscriptionRequest;
    internalBinaryWrite(message: UpdateEventMessagesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
interface UpdateEventMessagesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause$1;
}
/**
 * @generated MessageType for protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
declare const UpdateEventMessagesSubscriptionRequest: UpdateEventMessagesSubscriptionRequest$Type;
declare class SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeEntityResponse>): SubscribeEntityResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntityResponse): SubscribeEntityResponse;
    internalBinaryWrite(message: SubscribeEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEntityResponse
 */
interface SubscribeEntityResponse {
    /**
     * @generated from protobuf field: types.Entity entity = 1
     */
    entity?: Entity$1;
    /**
     * @generated from protobuf field: uint64 subscription_id = 2
     */
    subscription_id: bigint;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntityResponse
 */
declare const SubscribeEntityResponse: SubscribeEntityResponse$Type;
declare class RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveEntitiesRequest>): RetrieveEntitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesRequest): RetrieveEntitiesRequest;
    internalBinaryWrite(message: RetrieveEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesRequest
 */
interface RetrieveEntitiesRequest {
    /**
     * The entities to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesRequest
 */
declare const RetrieveEntitiesRequest: RetrieveEntitiesRequest$Type;
declare class RetrieveEventMessagesRequest$Type extends MessageType<RetrieveEventMessagesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveEventMessagesRequest>): RetrieveEventMessagesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventMessagesRequest): RetrieveEventMessagesRequest;
    internalBinaryWrite(message: RetrieveEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEventMessagesRequest
 */
interface RetrieveEventMessagesRequest {
    /**
     * The event messages to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventMessagesRequest
 */
declare const RetrieveEventMessagesRequest: RetrieveEventMessagesRequest$Type;
declare class RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveEntitiesResponse>): RetrieveEntitiesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesResponse): RetrieveEntitiesResponse;
    internalBinaryWrite(message: RetrieveEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesResponse
 */
interface RetrieveEntitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Entity entities = 2
     */
    entities: Entity$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesResponse
 */
declare const RetrieveEntitiesResponse: RetrieveEntitiesResponse$Type;
declare class RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveEventsRequest>): RetrieveEventsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsRequest): RetrieveEventsRequest;
    internalBinaryWrite(message: RetrieveEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEventsRequest
 */
interface RetrieveEventsRequest {
    /**
     * The events to retrieve
     *
     * @generated from protobuf field: types.EventQuery query = 1
     */
    query?: EventQuery;
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsRequest
 */
declare const RetrieveEventsRequest: RetrieveEventsRequest$Type;
declare class RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveEventsResponse>): RetrieveEventsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsResponse): RetrieveEventsResponse;
    internalBinaryWrite(message: RetrieveEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEventsResponse
 */
interface RetrieveEventsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Event events = 2
     */
    events: Event[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsResponse
 */
declare const RetrieveEventsResponse: RetrieveEventsResponse$Type;
declare class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest;
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEventsRequest
 */
interface SubscribeEventsRequest {
    /**
     * @generated from protobuf field: repeated types.KeysClause keys = 1
     */
    keys: KeysClause$1[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsRequest
 */
declare const SubscribeEventsRequest: SubscribeEventsRequest$Type;
declare class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse;
    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEventsResponse
 */
interface SubscribeEventsResponse {
    /**
     * @generated from protobuf field: types.Event event = 1
     */
    event?: Event;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsResponse
 */
declare const SubscribeEventsResponse: SubscribeEventsResponse$Type;
declare class PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {
    constructor();
    create(value?: PartialMessage<PublishMessageRequest>): PublishMessageRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageRequest): PublishMessageRequest;
    internalBinaryWrite(message: PublishMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageRequest
 */
interface PublishMessageRequest {
    /**
     * @generated from protobuf field: repeated bytes signature = 1
     */
    signature: Uint8Array[];
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated MessageType for protobuf message world.PublishMessageRequest
 */
declare const PublishMessageRequest: PublishMessageRequest$Type;
declare class PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {
    constructor();
    create(value?: PartialMessage<PublishMessageResponse>): PublishMessageResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageResponse): PublishMessageResponse;
    internalBinaryWrite(message: PublishMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageResponse
 */
interface PublishMessageResponse {
    /**
     * @generated from protobuf field: bytes entity_id = 1
     */
    entity_id: Uint8Array;
}
/**
 * @generated MessageType for protobuf message world.PublishMessageResponse
 */
declare const PublishMessageResponse: PublishMessageResponse$Type;
declare class PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {
    constructor();
    create(value?: PartialMessage<PublishMessageBatchRequest>): PublishMessageBatchRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchRequest): PublishMessageBatchRequest;
    internalBinaryWrite(message: PublishMessageBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageBatchRequest
 */
interface PublishMessageBatchRequest {
    /**
     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1
     */
    messages: PublishMessageRequest[];
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchRequest
 */
declare const PublishMessageBatchRequest: PublishMessageBatchRequest$Type;
declare class PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {
    constructor();
    create(value?: PartialMessage<PublishMessageBatchResponse>): PublishMessageBatchResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchResponse): PublishMessageBatchResponse;
    internalBinaryWrite(message: PublishMessageBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageBatchResponse
 */
interface PublishMessageBatchResponse {
    /**
     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1
     */
    responses: PublishMessageResponse[];
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchResponse
 */
declare const PublishMessageBatchResponse: PublishMessageBatchResponse$Type;
/**
 * @generated ServiceType for protobuf service world.World
 */
declare const World: ServiceType;

declare class Empty$Type extends MessageType<Empty> {
    constructor();
    create(value?: PartialMessage<Empty>): Empty;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty;
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 *
 * @generated from protobuf message google.protobuf.Empty
 */
interface Empty {
}
/**
 * @generated MessageType for protobuf message google.protobuf.Empty
 */
declare const Empty: Empty$Type;

/**
 * The World service provides information about the world.
 *
 * @generated from protobuf service world.World
 */
interface IWorldClient {
    /**
     * Subscribes to updates about contracts. Like the head block number, tps, etc.
     *
     * @generated from protobuf rpc: SubscribeContracts
     */
    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse>;
    /**
     * Retrieves metadata about the World including all the registered components and systems.
     *
     * @generated from protobuf rpc: WorldMetadata
     */
    worldMetadata(input: WorldMetadataRequest, options?: RpcOptions): UnaryCall<WorldMetadataRequest, WorldMetadataResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEntities
     */
    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEntitiesSubscription
     */
    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEntities
     */
    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEventMessages
     */
    subscribeEventMessages(input: SubscribeEventMessagesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventMessagesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEventMessagesSubscription
     */
    updateEventMessagesSubscription(input: UpdateEventMessagesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEventMessagesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token balance updates.
     *
     * @generated from protobuf rpc: SubscribeTokenBalances
     */
    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>;
    /**
     * Update token balance subscription
     *
     * @generated from protobuf rpc: UpdateTokenBalancesSubscription
     */
    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token updates.
     *
     * @generated from protobuf rpc: SubscribeTokens
     */
    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse>;
    /**
     * Update token subscription
     *
     * @generated from protobuf rpc: UpdateTokensSubscription
     */
    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEventMessages
     */
    retrieveEventMessages(input: RetrieveEventMessagesRequest, options?: RpcOptions): UnaryCall<RetrieveEventMessagesRequest, RetrieveEntitiesResponse>;
    /**
     * Retrieve events
     *
     * @generated from protobuf rpc: RetrieveEvents
     */
    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse>;
    /**
     * Subscribe to events
     *
     * @generated from protobuf rpc: SubscribeEvents
     */
    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse>;
    /**
     * Retrieve tokens
     *
     * @generated from protobuf rpc: RetrieveTokens
     */
    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse>;
    /**
     * Retrieve token balances
     *
     * @generated from protobuf rpc: RetrieveTokenBalances
     */
    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>;
    /**
     * Retrieve transactions
     *
     * @generated from protobuf rpc: RetrieveTransactions
     */
    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse>;
    /**
     * Subscribe to transactions
     *
     * @generated from protobuf rpc: SubscribeTransactions
     */
    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse>;
    /**
     * Retrieve controllers
     *
     * @generated from protobuf rpc: RetrieveControllers
     */
    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse>;
    /**
     * Retrieve contracts
     *
     * @generated from protobuf rpc: RetrieveContracts
     */
    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse>;
    /**
     * Retrieve tokens contracts
     *
     * @generated from protobuf rpc: RetrieveTokenContracts
     */
    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>;
    /**
     * Publish a torii offchain message
     *
     * @generated from protobuf rpc: PublishMessage
     */
    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse>;
    /**
     * Publish a set of torii offchain messages
     *
     * @generated from protobuf rpc: PublishMessageBatch
     */
    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse>;
}
/**
 * The World service provides information about the world.
 *
 * @generated from protobuf service world.World
 */
declare class WorldClient implements IWorldClient, ServiceInfo {
    private readonly _transport;
    typeName: string;
    methods: _protobuf_ts_runtime_rpc.MethodInfo<any, any>[];
    options: {
        [extensionName: string]: _protobuf_ts_runtime.JsonValue;
    };
    constructor(_transport: RpcTransport);
    /**
     * Subscribes to updates about contracts. Like the head block number, tps, etc.
     *
     * @generated from protobuf rpc: SubscribeContracts
     */
    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse>;
    /**
     * Retrieves metadata about the World including all the registered components and systems.
     *
     * @generated from protobuf rpc: WorldMetadata
     */
    worldMetadata(input: WorldMetadataRequest, options?: RpcOptions): UnaryCall<WorldMetadataRequest, WorldMetadataResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEntities
     */
    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEntitiesSubscription
     */
    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEntities
     */
    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEventMessages
     */
    subscribeEventMessages(input: SubscribeEventMessagesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventMessagesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEventMessagesSubscription
     */
    updateEventMessagesSubscription(input: UpdateEventMessagesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEventMessagesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token balance updates.
     *
     * @generated from protobuf rpc: SubscribeTokenBalances
     */
    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>;
    /**
     * Update token balance subscription
     *
     * @generated from protobuf rpc: UpdateTokenBalancesSubscription
     */
    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token updates.
     *
     * @generated from protobuf rpc: SubscribeTokens
     */
    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse>;
    /**
     * Update token subscription
     *
     * @generated from protobuf rpc: UpdateTokensSubscription
     */
    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEventMessages
     */
    retrieveEventMessages(input: RetrieveEventMessagesRequest, options?: RpcOptions): UnaryCall<RetrieveEventMessagesRequest, RetrieveEntitiesResponse>;
    /**
     * Retrieve events
     *
     * @generated from protobuf rpc: RetrieveEvents
     */
    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse>;
    /**
     * Subscribe to events
     *
     * @generated from protobuf rpc: SubscribeEvents
     */
    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse>;
    /**
     * Retrieve tokens
     *
     * @generated from protobuf rpc: RetrieveTokens
     */
    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse>;
    /**
     * Retrieve token balances
     *
     * @generated from protobuf rpc: RetrieveTokenBalances
     */
    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>;
    /**
     * Retrieve transactions
     *
     * @generated from protobuf rpc: RetrieveTransactions
     */
    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse>;
    /**
     * Subscribe to transactions
     *
     * @generated from protobuf rpc: SubscribeTransactions
     */
    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse>;
    /**
     * Retrieve controllers
     *
     * @generated from protobuf rpc: RetrieveControllers
     */
    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse>;
    /**
     * Retrieve contracts
     *
     * @generated from protobuf rpc: RetrieveContracts
     */
    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse>;
    /**
     * Retrieve tokens contracts
     *
     * @generated from protobuf rpc: RetrieveTokenContracts
     */
    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>;
    /**
     * Publish a torii offchain message
     *
     * @generated from protobuf rpc: PublishMessage
     */
    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse>;
    /**
     * Publish a set of torii offchain messages
     *
     * @generated from protobuf rpc: PublishMessageBatch
     */
    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse>;
}

interface DojoGrpcClientConfig {
    url: string;
    options?: RpcOptions;
}
declare class DojoGrpcClient {
    private transport;
    worldClient: WorldClient;
    constructor(config: DojoGrpcClientConfig);
    destroy(): void;
}
declare function createDojoGrpcClient(config: DojoGrpcClientConfig): DojoGrpcClient;

interface Page<T> {
    items: T[];
    next_cursor: string | undefined;
}

type WasmU256 = string;

type Controllers = Page<Controller>;

interface Controller {
    address: string;
    username: string;
    deployed_at_timestamp: number;
}

type Tokens = Page<Token>;

type TokenBalances = Page<TokenBalance>;

type TokenContracts = Page<TokenContract>;

interface Token {
    contract_address: string;
    token_id: string | undefined;
    name: string;
    symbol: string;
    decimals: number;
    metadata: string;
    total_supply: string | undefined;
}

interface TokenContract {
    contract_address: string;
    name: string;
    symbol: string;
    decimals: number;
    metadata: string;
    total_supply: string | undefined;
}

interface TokenBalance {
    balance: string;
    account_address: string;
    contract_address: string;
    token_id: string | undefined;
}

interface TransactionFilter {
    transaction_hashes: string[];
    caller_addresses: string[];
    contract_addresses: string[];
    entrypoints: string[];
    model_selectors: string[];
    from_block: number | undefined;
    to_block: number | undefined;
}

interface TransactionQuery {
    filter: TransactionFilter | undefined;
    pagination: Pagination;
}

type Transactions = Page<Transaction>;

interface Transaction {
    transaction_hash: string;
    sender_address: string;
    calldata: string[];
    max_fee: string;
    signature: string[];
    nonce: string;
    block_number: number;
    transaction_type: string;
    block_timestamp: number;
    calls: TransactionCall[];
    unique_models: string[];
}

type CallType = "Execute" | "ExecuteFromOutside";

interface TransactionCall {
    contract_address: string;
    entrypoint: string;
    calldata: string[];
    call_type: CallType;
    caller_address: string;
}

interface ControllerQuery {
    contract_addresses: string[];
    usernames: string[];
    pagination: Pagination;
}

interface AttributeFilter {
    trait_name: string;
    trait_value: string;
}

interface TokenQuery {
    contract_addresses: string[];
    token_ids: string[];
    attribute_filters: AttributeFilter[];
    pagination: Pagination;
}

interface TokenBalanceQuery {
    contract_addresses: string[];
    account_addresses: string[];
    token_ids: string[];
    pagination: Pagination;
}

interface ClientConfig {
    toriiUrl: string;
    worldAddress: string;
}

interface Ty {
    type: "primitive" | "struct" | "enum" | "array" | "tuple" | "bytearray" | "fixed_size_array";
    type_name: string;
    value: boolean | number | string | Ty | Record<string, Ty> | Array<Ty> | EnumValue | FixedSizeArray | null;
    key: boolean;
}

interface FixedSizeArray {
    array: Ty[];
    size: number;
}

interface EnumValue {
    option: string;
    value: Ty;
}

type Model = Record<string, Ty>;

interface Entity {
    hashed_keys: string;
    models: Record<string, Model>;
    created_at: number;
    updated_at: number;
    executed_at: number;
}

type Entities = Page<Entity>;

interface Query {
    pagination: Pagination;
    clause: Clause | undefined;
    no_hashed_keys: boolean;
    models: string[];
    historical: boolean;
}

interface Pagination {
    limit: number | undefined;
    cursor: string | undefined;
    direction: PaginationDirection;
    order_by: OrderBy[];
}

type PaginationDirection = "Forward" | "Backward";

interface OrderBy {
    field: string;
    direction: OrderDirection;
}

type OrderDirection = "Asc" | "Desc";

type Clause = { HashedKeys: string[] } | { Keys: KeysClause } | { Member: MemberClause } | { Composite: CompositeClause };

type PatternMatching = "FixedLen" | "VariableLen";

interface KeysClause {
    keys: (string | undefined)[];
    pattern_matching: PatternMatching;
    models: string[];
}

type MemberValue = { Primitive: Primitive } | { String: string } | { List: MemberValue[] };

interface MemberClause {
    model: string;
    member: string;
    operator: ComparisonOperator;
    value: MemberValue;
}

interface CompositeClause {
    operator: LogicalOperator;
    clauses: Clause[];
}

type LogicalOperator = "And" | "Or";

type ComparisonOperator = "Eq" | "Neq" | "Gt" | "Gte" | "Lt" | "Lte" | "In" | "NotIn";

type Primitive = { I8: number | undefined } | { I16: number | undefined } | { I32: number | undefined } | { I64: number | undefined } | { I128: string | undefined } | { U8: number | undefined } | { U16: number | undefined } | { U32: number | undefined } | { U64: number | undefined } | { U128: string | undefined } | { U256: string | undefined } | { Bool: boolean | undefined } | { Felt252: string | undefined } | { ClassHash: string | undefined } | { ContractAddress: string | undefined } | { EthAddress: string | undefined };

interface Message {
    message: string;
    signature: string[];
}

interface ToriiSubscription {
    id: bigint;
    stream: ServerStreamingCall<object, object>;
    cancel: () => void;
}
type GrpcSubscription = {
    id: bigint;
    cancel: () => void;
    free: () => void;
};
declare class Subscription {
    private _subscription;
    constructor(subscription: ToriiSubscription);
    cancel(): void;
    free(): void;
    get id(): bigint;
}
interface ToriiGrpcClientConfig extends ClientConfig {
    useEffectSchema?: boolean;
}
declare class ToriiGrpcClient {
    private client;
    private nextSubscriptionId;
    private subscriptions;
    private useEffectSchema;
    private mappers;
    constructor(config: ToriiGrpcClientConfig);
    private createStreamSubscription;
    getControllers(query: ControllerQuery): Promise<Controllers>;
    getTransactions(query: TransactionQuery): Promise<Transactions>;
    getTokens(query: TokenQuery): Promise<Tokens>;
    getTokenBalances(query: TokenBalanceQuery): Promise<TokenBalances>;
    getTokenContracts(query: TokenBalanceQuery): Promise<TokenContracts>;
    getEntities(query: Query): Promise<Entities>;
    getAllEntities(limit: number, cursor?: string | null): Promise<Entities>;
    getEventMessages(query: Query): Promise<Entities>;
    onTransaction(filter: TransactionFilter | null | undefined, callback: Function): Promise<Subscription>;
    onTokenUpdated(contract_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function): Promise<Subscription>;
    onEntityUpdated(clause: Clause | null | undefined, callback: Function): Promise<Subscription>;
    updateEntitySubscription(subscription: Subscription, clause?: Clause | null): Promise<void>;
    onEventMessageUpdated(clause: Clause | null | undefined, callback: Function): Promise<Subscription>;
    updateEventMessageSubscription(subscription: GrpcSubscription, clause?: Clause | null): Promise<void>;
    onStarknetEvent(clauses: KeysClause[], callback: Function): Promise<Subscription>;
    onTokenBalanceUpdated(contract_addresses: string[] | null | undefined, account_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function): Promise<Subscription>;
    updateTokenBalanceSubscription(subscription: Subscription, contract_addresses: string[], account_addresses: string[], token_ids: WasmU256[]): Promise<void>;
    publishMessage(message: Message): Promise<string>;
    publishMessageBatch(messages: Message[]): Promise<string[]>;
    getWorldMetadata(): Promise<any>;
    getEvents(query: {
        keys?: KeysClause;
        pagination?: Pagination;
    }): Promise<any>;
    getContracts(query?: {
        contract_addresses?: string[];
        contract_types?: ContractType[];
    }): Promise<any>;
    updateTokensSubscription(subscription: Subscription, contractAddresses?: string[], tokenIds?: WasmU256[]): Promise<void>;
    onContractsUpdated(query: {
        contract_addresses?: string[];
        contract_types?: ContractType[];
    }, callback: Function): Promise<Subscription>;
    private findSubscription;
    destroy(): void;
}

export { Array$, CallType$1 as CallType, Clause$1 as Clause, ComparisonOperator$1 as ComparisonOperator, CompositeClause$1 as CompositeClause, Contract, ContractQuery, ContractType, Controller$1 as Controller, ControllerQuery$1 as ControllerQuery, DojoGrpcClient, type DojoGrpcClientConfig, Entity$1 as Entity, Enum, EnumOption, Event, EventQuery, FixedSizeArray$1 as FixedSizeArray, HashedKeysClause, KeysClause$1 as KeysClause, LogicalOperator$1 as LogicalOperator, Member, MemberClause$1 as MemberClause, MemberValue$1 as MemberValue, MemberValueList, Model$1 as Model, OrderBy$1 as OrderBy, OrderDirection$1 as OrderDirection, Pagination$1 as Pagination, PaginationDirection$1 as PaginationDirection, PatternMatching$1 as PatternMatching, Primitive$1 as Primitive, PublishMessageBatchRequest, PublishMessageBatchResponse, PublishMessageRequest, PublishMessageResponse, Query$1 as Query, RetrieveContractsRequest, RetrieveContractsResponse, RetrieveControllersRequest, RetrieveControllersResponse, RetrieveEntitiesRequest, RetrieveEntitiesResponse, RetrieveEventMessagesRequest, RetrieveEventsRequest, RetrieveEventsResponse, RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse, RetrieveTokenContractsRequest, RetrieveTokenContractsResponse, RetrieveTokensRequest, RetrieveTokensResponse, RetrieveTransactionsRequest, RetrieveTransactionsResponse, Struct, SubscribeContractsRequest, SubscribeContractsResponse, SubscribeEntitiesRequest, SubscribeEntityResponse, SubscribeEventMessagesRequest, SubscribeEventsRequest, SubscribeEventsResponse, SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse, SubscribeTokensRequest, SubscribeTokensResponse, SubscribeTransactionsRequest, SubscribeTransactionsResponse, Subscription, Token$1 as Token, TokenBalance$1 as TokenBalance, TokenBalanceQuery$1 as TokenBalanceQuery, TokenContract$1 as TokenContract, TokenQuery$1 as TokenQuery, ToriiGrpcClient, type ToriiGrpcClientConfig, Transaction$1 as Transaction, TransactionCall$1 as TransactionCall, TransactionFilter$1 as TransactionFilter, TransactionQuery$1 as TransactionQuery, Ty$1 as Ty, UpdateEntitiesSubscriptionRequest, UpdateEventMessagesSubscriptionRequest, UpdateTokenBalancesSubscriptionRequest, UpdateTokenSubscriptionRequest, WorldClient, World$1 as WorldMessage, WorldMetadataRequest, WorldMetadataResponse, World as WorldService, createDojoGrpcClient };
