// src/client.ts
import { GrpcWebFetchTransport } from "@protobuf-ts/grpcweb-transport";

// src/generated/google/protobuf/empty.ts
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var Empty$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Empty", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Empty = new Empty$Type();

// src/generated/world.ts
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType as WireType3 } from "@protobuf-ts/runtime";
import { UnknownFieldHandler as UnknownFieldHandler4 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial4 } from "@protobuf-ts/runtime";
import { MessageType as MessageType4 } from "@protobuf-ts/runtime";

// src/generated/types.ts
import { WireType as WireType2 } from "@protobuf-ts/runtime";
import { UnknownFieldHandler as UnknownFieldHandler3 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial3 } from "@protobuf-ts/runtime";
import { MessageType as MessageType3 } from "@protobuf-ts/runtime";

// src/generated/schema.ts
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler as UnknownFieldHandler2 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial2 } from "@protobuf-ts/runtime";
import { MessageType as MessageType2 } from "@protobuf-ts/runtime";
var EnumOption$Type = class extends MessageType2 {
  constructor() {
    super("types.EnumOption", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EnumOption = new EnumOption$Type();
var Enum$Type = class extends MessageType2 {
  constructor() {
    super("types.Enum", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "option",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "options", kind: "message", repeat: 2, T: () => EnumOption }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.option = 0;
    message.options = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* uint32 option */
        2:
          message.option = reader.uint32();
          break;
        case /* repeated types.EnumOption options */
        3:
          message.options.push(EnumOption.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.option !== 0)
      writer.tag(2, WireType.Varint).uint32(message.option);
    for (let i = 0; i < message.options.length; i++)
      EnumOption.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Enum = new Enum$Type();
var Primitive$Type = class extends MessageType2 {
  constructor() {
    super("types.Primitive", [
      {
        no: 1,
        name: "i8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "i16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "i32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "i64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "i128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "u8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "u16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "u32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 9,
        name: "u64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "u128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 11,
        name: "u256",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 12,
        name: "bool",
        kind: "scalar",
        oneof: "primitive_type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "felt252",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 14,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 15,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 16,
        name: "eth_address",
        kind: "scalar",
        localName: "eth_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.primitive_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 i8 */
        1:
          message.primitive_type = {
            oneofKind: "i8",
            i8: reader.int32()
          };
          break;
        case /* int32 i16 */
        2:
          message.primitive_type = {
            oneofKind: "i16",
            i16: reader.int32()
          };
          break;
        case /* int32 i32 */
        3:
          message.primitive_type = {
            oneofKind: "i32",
            i32: reader.int32()
          };
          break;
        case /* int64 i64 */
        4:
          message.primitive_type = {
            oneofKind: "i64",
            i64: reader.int64().toBigInt()
          };
          break;
        case /* bytes i128 */
        5:
          message.primitive_type = {
            oneofKind: "i128",
            i128: reader.bytes()
          };
          break;
        case /* uint32 u8 */
        6:
          message.primitive_type = {
            oneofKind: "u8",
            u8: reader.uint32()
          };
          break;
        case /* uint32 u16 */
        7:
          message.primitive_type = {
            oneofKind: "u16",
            u16: reader.uint32()
          };
          break;
        case /* uint32 u32 */
        8:
          message.primitive_type = {
            oneofKind: "u32",
            u32: reader.uint32()
          };
          break;
        case /* uint64 u64 */
        9:
          message.primitive_type = {
            oneofKind: "u64",
            u64: reader.uint64().toBigInt()
          };
          break;
        case /* bytes u128 */
        10:
          message.primitive_type = {
            oneofKind: "u128",
            u128: reader.bytes()
          };
          break;
        case /* bytes u256 */
        11:
          message.primitive_type = {
            oneofKind: "u256",
            u256: reader.bytes()
          };
          break;
        case /* bool bool */
        12:
          message.primitive_type = {
            oneofKind: "bool",
            bool: reader.bool()
          };
          break;
        case /* bytes felt252 */
        13:
          message.primitive_type = {
            oneofKind: "felt252",
            felt252: reader.bytes()
          };
          break;
        case /* bytes class_hash */
        14:
          message.primitive_type = {
            oneofKind: "class_hash",
            class_hash: reader.bytes()
          };
          break;
        case /* bytes contract_address */
        15:
          message.primitive_type = {
            oneofKind: "contract_address",
            contract_address: reader.bytes()
          };
          break;
        case /* bytes eth_address */
        16:
          message.primitive_type = {
            oneofKind: "eth_address",
            eth_address: reader.bytes()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.primitive_type.oneofKind === "i8")
      writer.tag(1, WireType.Varint).int32(message.primitive_type.i8);
    if (message.primitive_type.oneofKind === "i16")
      writer.tag(2, WireType.Varint).int32(message.primitive_type.i16);
    if (message.primitive_type.oneofKind === "i32")
      writer.tag(3, WireType.Varint).int32(message.primitive_type.i32);
    if (message.primitive_type.oneofKind === "i64")
      writer.tag(4, WireType.Varint).int64(message.primitive_type.i64);
    if (message.primitive_type.oneofKind === "i128")
      writer.tag(5, WireType.LengthDelimited).bytes(message.primitive_type.i128);
    if (message.primitive_type.oneofKind === "u8")
      writer.tag(6, WireType.Varint).uint32(message.primitive_type.u8);
    if (message.primitive_type.oneofKind === "u16")
      writer.tag(7, WireType.Varint).uint32(message.primitive_type.u16);
    if (message.primitive_type.oneofKind === "u32")
      writer.tag(8, WireType.Varint).uint32(message.primitive_type.u32);
    if (message.primitive_type.oneofKind === "u64")
      writer.tag(9, WireType.Varint).uint64(message.primitive_type.u64);
    if (message.primitive_type.oneofKind === "u128")
      writer.tag(10, WireType.LengthDelimited).bytes(message.primitive_type.u128);
    if (message.primitive_type.oneofKind === "u256")
      writer.tag(11, WireType.LengthDelimited).bytes(message.primitive_type.u256);
    if (message.primitive_type.oneofKind === "bool")
      writer.tag(12, WireType.Varint).bool(message.primitive_type.bool);
    if (message.primitive_type.oneofKind === "felt252")
      writer.tag(13, WireType.LengthDelimited).bytes(message.primitive_type.felt252);
    if (message.primitive_type.oneofKind === "class_hash")
      writer.tag(14, WireType.LengthDelimited).bytes(message.primitive_type.class_hash);
    if (message.primitive_type.oneofKind === "contract_address")
      writer.tag(15, WireType.LengthDelimited).bytes(message.primitive_type.contract_address);
    if (message.primitive_type.oneofKind === "eth_address")
      writer.tag(16, WireType.LengthDelimited).bytes(message.primitive_type.eth_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Primitive = new Primitive$Type();
var Struct$Type = class extends MessageType2 {
  constructor() {
    super("types.Struct", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "children", kind: "message", repeat: 2, T: () => Member }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.children = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* repeated types.Member children */
        2:
          message.children.push(Member.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    for (let i = 0; i < message.children.length; i++)
      Member.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Struct = new Struct$Type();
var Array$$Type = class extends MessageType2 {
  constructor() {
    super("types.Array", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Array$ = new Array$$Type();
var FixedSizeArray$Type = class extends MessageType2 {
  constructor() {
    super("types.FixedSizeArray", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    message.size = 0;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint32 size */
        2:
          message.size = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.size !== 0)
      writer.tag(2, WireType.Varint).uint32(message.size);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var FixedSizeArray = new FixedSizeArray$Type();
var Ty$Type = class extends MessageType2 {
  constructor() {
    super("types.Ty", [
      { no: 2, name: "primitive", kind: "message", oneof: "ty_type", T: () => Primitive },
      { no: 3, name: "enum", kind: "message", oneof: "ty_type", T: () => Enum },
      { no: 4, name: "struct", kind: "message", oneof: "ty_type", T: () => Struct },
      { no: 5, name: "tuple", kind: "message", oneof: "ty_type", T: () => Array$ },
      { no: 6, name: "array", kind: "message", oneof: "ty_type", T: () => Array$ },
      {
        no: 7,
        name: "bytearray",
        kind: "scalar",
        oneof: "ty_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "fixed_size_array", kind: "message", localName: "fixed_size_array", oneof: "ty_type", T: () => FixedSizeArray }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ty_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        2:
          message.ty_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.primitive)
          };
          break;
        case /* types.Enum enum */
        3:
          message.ty_type = {
            oneofKind: "enum",
            enum: Enum.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.enum)
          };
          break;
        case /* types.Struct struct */
        4:
          message.ty_type = {
            oneofKind: "struct",
            struct: Struct.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.struct)
          };
          break;
        case /* types.Array tuple */
        5:
          message.ty_type = {
            oneofKind: "tuple",
            tuple: Array$.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.tuple)
          };
          break;
        case /* types.Array array */
        6:
          message.ty_type = {
            oneofKind: "array",
            array: Array$.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.array)
          };
          break;
        case /* string bytearray */
        7:
          message.ty_type = {
            oneofKind: "bytearray",
            bytearray: reader.string()
          };
          break;
        case /* types.FixedSizeArray fixed_size_array */
        8:
          message.ty_type = {
            oneofKind: "fixed_size_array",
            fixed_size_array: FixedSizeArray.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.fixed_size_array)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ty_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.ty_type.primitive, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "enum")
      Enum.internalBinaryWrite(message.ty_type.enum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "struct")
      Struct.internalBinaryWrite(message.ty_type.struct, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "tuple")
      Array$.internalBinaryWrite(message.ty_type.tuple, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "array")
      Array$.internalBinaryWrite(message.ty_type.array, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "bytearray")
      writer.tag(7, WireType.LengthDelimited).string(message.ty_type.bytearray);
    if (message.ty_type.oneofKind === "fixed_size_array")
      FixedSizeArray.internalBinaryWrite(message.ty_type.fixed_size_array, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Ty = new Ty$Type();
var Member$Type = class extends MessageType2 {
  constructor() {
    super("types.Member", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty },
      {
        no: 3,
        name: "key",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.key = false;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        case /* bool key */
        3:
          message.key = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.key !== false)
      writer.tag(3, WireType.Varint).bool(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Member = new Member$Type();

// src/generated/types.ts
var PatternMatching = /* @__PURE__ */ ((PatternMatching2) => {
  PatternMatching2[PatternMatching2["FixedLen"] = 0] = "FixedLen";
  PatternMatching2[PatternMatching2["VariableLen"] = 1] = "VariableLen";
  return PatternMatching2;
})(PatternMatching || {});
var LogicalOperator = /* @__PURE__ */ ((LogicalOperator2) => {
  LogicalOperator2[LogicalOperator2["AND"] = 0] = "AND";
  LogicalOperator2[LogicalOperator2["OR"] = 1] = "OR";
  return LogicalOperator2;
})(LogicalOperator || {});
var ComparisonOperator = /* @__PURE__ */ ((ComparisonOperator2) => {
  ComparisonOperator2[ComparisonOperator2["EQ"] = 0] = "EQ";
  ComparisonOperator2[ComparisonOperator2["NEQ"] = 1] = "NEQ";
  ComparisonOperator2[ComparisonOperator2["GT"] = 2] = "GT";
  ComparisonOperator2[ComparisonOperator2["GTE"] = 3] = "GTE";
  ComparisonOperator2[ComparisonOperator2["LT"] = 4] = "LT";
  ComparisonOperator2[ComparisonOperator2["LTE"] = 5] = "LTE";
  ComparisonOperator2[ComparisonOperator2["IN"] = 6] = "IN";
  ComparisonOperator2[ComparisonOperator2["NOT_IN"] = 7] = "NOT_IN";
  ComparisonOperator2[ComparisonOperator2["CONTAINS"] = 8] = "CONTAINS";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ALL"] = 9] = "CONTAINS_ALL";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ANY"] = 10] = "CONTAINS_ANY";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_EQ"] = 11] = "ARRAY_LENGTH_EQ";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_GT"] = 12] = "ARRAY_LENGTH_GT";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_LT"] = 13] = "ARRAY_LENGTH_LT";
  return ComparisonOperator2;
})(ComparisonOperator || {});
var OrderDirection = /* @__PURE__ */ ((OrderDirection2) => {
  OrderDirection2[OrderDirection2["ASC"] = 0] = "ASC";
  OrderDirection2[OrderDirection2["DESC"] = 1] = "DESC";
  return OrderDirection2;
})(OrderDirection || {});
var PaginationDirection = /* @__PURE__ */ ((PaginationDirection2) => {
  PaginationDirection2[PaginationDirection2["FORWARD"] = 0] = "FORWARD";
  PaginationDirection2[PaginationDirection2["BACKWARD"] = 1] = "BACKWARD";
  return PaginationDirection2;
})(PaginationDirection || {});
var CallType = /* @__PURE__ */ ((CallType2) => {
  CallType2[CallType2["EXECUTE"] = 0] = "EXECUTE";
  CallType2[CallType2["EXECUTE_FROM_OUTSIDE"] = 1] = "EXECUTE_FROM_OUTSIDE";
  return CallType2;
})(CallType || {});
var ContractType = /* @__PURE__ */ ((ContractType3) => {
  ContractType3[ContractType3["WORLD"] = 0] = "WORLD";
  ContractType3[ContractType3["ERC20"] = 1] = "ERC20";
  ContractType3[ContractType3["ERC721"] = 2] = "ERC721";
  ContractType3[ContractType3["ERC1155"] = 3] = "ERC1155";
  ContractType3[ContractType3["UDC"] = 4] = "UDC";
  ContractType3[ContractType3["OTHER"] = 5] = "OTHER";
  return ContractType3;
})(ContractType || {});
var World$Type = class extends MessageType3 {
  constructor() {
    super("types.World", [
      {
        no: 1,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Model }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_address = "";
    message.models = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string world_address */
        1:
          message.world_address = reader.string();
          break;
        case /* repeated types.Model models */
        2:
          message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.world_address !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.world_address);
    for (let i = 0; i < message.models.length; i++)
      Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var World = new World$Type();
var Model$Type = class extends MessageType3 {
  constructor() {
    super("types.Model", [
      {
        no: 1,
        name: "selector",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "packed_size",
        kind: "scalar",
        localName: "packed_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "unpacked_size",
        kind: "scalar",
        localName: "unpacked_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "layout",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "schema",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 9,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 10,
        name: "use_legacy_store",
        kind: "scalar",
        localName: "use_legacy_store",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.selector = new Uint8Array(0);
    message.namespace = "";
    message.name = "";
    message.packed_size = 0;
    message.unpacked_size = 0;
    message.class_hash = new Uint8Array(0);
    message.layout = new Uint8Array(0);
    message.schema = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    message.use_legacy_store = false;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes selector */
        1:
          message.selector = reader.bytes();
          break;
        case /* string namespace */
        2:
          message.namespace = reader.string();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* uint32 packed_size */
        4:
          message.packed_size = reader.uint32();
          break;
        case /* uint32 unpacked_size */
        5:
          message.unpacked_size = reader.uint32();
          break;
        case /* bytes class_hash */
        6:
          message.class_hash = reader.bytes();
          break;
        case /* bytes layout */
        7:
          message.layout = reader.bytes();
          break;
        case /* bytes schema */
        8:
          message.schema = reader.bytes();
          break;
        case /* bytes contract_address */
        9:
          message.contract_address = reader.bytes();
          break;
        case /* bool use_legacy_store */
        10:
          message.use_legacy_store = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.selector.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.selector);
    if (message.namespace !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.namespace);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.packed_size !== 0)
      writer.tag(4, WireType2.Varint).uint32(message.packed_size);
    if (message.unpacked_size !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.unpacked_size);
    if (message.class_hash.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.class_hash);
    if (message.layout.length)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.layout);
    if (message.schema.length)
      writer.tag(8, WireType2.LengthDelimited).bytes(message.schema);
    if (message.contract_address.length)
      writer.tag(9, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.use_legacy_store !== false)
      writer.tag(10, WireType2.Varint).bool(message.use_legacy_store);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Model = new Model$Type();
var Entity$Type = class extends MessageType3 {
  constructor() {
    super("types.Entity", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Struct },
      {
        no: 3,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "executed_at",
        kind: "scalar",
        localName: "executed_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = new Uint8Array(0);
    message.models = [];
    message.created_at = 0n;
    message.updated_at = 0n;
    message.executed_at = 0n;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hashed_keys */
        1:
          message.hashed_keys = reader.bytes();
          break;
        case /* repeated types.Struct models */
        2:
          message.models.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 created_at */
        3:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        4:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 executed_at */
        5:
          message.executed_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hashed_keys.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      Struct.internalBinaryWrite(message.models[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    if (message.created_at !== 0n)
      writer.tag(3, WireType2.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(4, WireType2.Varint).uint64(message.updated_at);
    if (message.executed_at !== 0n)
      writer.tag(5, WireType2.Varint).uint64(message.executed_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Entity = new Entity$Type();
var Event$Type = class extends MessageType3 {
  constructor() {
    super("types.Event", [
      {
        no: 1,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.data = [];
    message.transaction_hash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        1:
          message.keys.push(reader.bytes());
          break;
        case /* repeated bytes data */
        2:
          message.data.push(reader.bytes());
          break;
        case /* bytes transaction_hash */
        3:
          message.transaction_hash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.keys[i]);
    for (let i = 0; i < message.data.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.data[i]);
    if (message.transaction_hash.length)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.transaction_hash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Event = new Event$Type();
var Query$Type = class extends MessageType3 {
  constructor() {
    super("types.Query", [
      { no: 1, name: "clause", kind: "message", T: () => Clause },
      {
        no: 2,
        name: "no_hashed_keys",
        kind: "scalar",
        localName: "no_hashed_keys",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination },
      {
        no: 5,
        name: "historical",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.no_hashed_keys = false;
    message.models = [];
    message.historical = false;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        case /* bool no_hashed_keys */
        2:
          message.no_hashed_keys = reader.bool();
          break;
        case /* repeated string models */
        3:
          message.models.push(reader.string());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        case /* bool historical */
        5:
          message.historical = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.no_hashed_keys !== false)
      writer.tag(2, WireType2.Varint).bool(message.no_hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(3, WireType2.LengthDelimited).string(message.models[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    if (message.historical !== false)
      writer.tag(5, WireType2.Varint).bool(message.historical);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Query = new Query$Type();
var EventQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.EventQuery", [
      { no: 1, name: "keys", kind: "message", T: () => KeysClause },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.KeysClause keys */
        1:
          message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.keys)
      KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EventQuery = new EventQuery$Type();
var Clause$Type = class extends MessageType3 {
  constructor() {
    super("types.Clause", [
      { no: 1, name: "hashed_keys", kind: "message", localName: "hashed_keys", oneof: "clause_type", T: () => HashedKeysClause },
      { no: 2, name: "keys", kind: "message", oneof: "clause_type", T: () => KeysClause },
      { no: 3, name: "member", kind: "message", oneof: "clause_type", T: () => MemberClause },
      { no: 4, name: "composite", kind: "message", oneof: "clause_type", T: () => CompositeClause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.clause_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.HashedKeysClause hashed_keys */
        1:
          message.clause_type = {
            oneofKind: "hashed_keys",
            hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.hashed_keys)
          };
          break;
        case /* types.KeysClause keys */
        2:
          message.clause_type = {
            oneofKind: "keys",
            keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.keys)
          };
          break;
        case /* types.MemberClause member */
        3:
          message.clause_type = {
            oneofKind: "member",
            member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.member)
          };
          break;
        case /* types.CompositeClause composite */
        4:
          message.clause_type = {
            oneofKind: "composite",
            composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.composite)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause_type.oneofKind === "hashed_keys")
      HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "keys")
      KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "member")
      MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "composite")
      CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Clause = new Clause$Type();
var KeysClause$Type = class extends MessageType3 {
  constructor() {
    super("types.KeysClause", [
      {
        no: 2,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "pattern_matching", kind: "enum", localName: "pattern_matching", T: () => ["types.PatternMatching", PatternMatching] },
      {
        no: 4,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.pattern_matching = 0;
    message.models = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        2:
          message.keys.push(reader.bytes());
          break;
        case /* types.PatternMatching pattern_matching */
        3:
          message.pattern_matching = reader.int32();
          break;
        case /* repeated string models */
        4:
          message.models.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.keys[i]);
    if (message.pattern_matching !== 0)
      writer.tag(3, WireType2.Varint).int32(message.pattern_matching);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(4, WireType2.LengthDelimited).string(message.models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var KeysClause = new KeysClause$Type();
var HashedKeysClause$Type = class extends MessageType3 {
  constructor() {
    super("types.HashedKeysClause", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes hashed_keys */
        1:
          message.hashed_keys.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.hashed_keys.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.hashed_keys[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var HashedKeysClause = new HashedKeysClause$Type();
var MemberValue$Type = class extends MessageType3 {
  constructor() {
    super("types.MemberValue", [
      { no: 1, name: "primitive", kind: "message", oneof: "value_type", T: () => Primitive },
      {
        no: 2,
        name: "string",
        kind: "scalar",
        oneof: "value_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "list", kind: "message", oneof: "value_type", T: () => MemberValueList }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        1:
          message.value_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.value_type.primitive)
          };
          break;
        case /* string string */
        2:
          message.value_type = {
            oneofKind: "string",
            string: reader.string()
          };
          break;
        case /* types.MemberValueList list */
        3:
          message.value_type = {
            oneofKind: "list",
            list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, message.value_type.list)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.value_type.oneofKind === "string")
      writer.tag(2, WireType2.LengthDelimited).string(message.value_type.string);
    if (message.value_type.oneofKind === "list")
      MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValue = new MemberValue$Type();
var MemberValueList$Type = class extends MessageType3 {
  constructor() {
    super("types.MemberValueList", [
      { no: 1, name: "values", kind: "message", repeat: 2, T: () => MemberValue }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.values = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.MemberValue values */
        1:
          message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.values.length; i++)
      MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValueList = new MemberValueList$Type();
var MemberClause$Type = class extends MessageType3 {
  constructor() {
    super("types.MemberClause", [
      {
        no: 2,
        name: "model",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "member",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "operator", kind: "enum", T: () => ["types.ComparisonOperator", ComparisonOperator] },
      { no: 5, name: "value", kind: "message", T: () => MemberValue }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.model = "";
    message.member = "";
    message.operator = 0;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string model */
        2:
          message.model = reader.string();
          break;
        case /* string member */
        3:
          message.member = reader.string();
          break;
        case /* types.ComparisonOperator operator */
        4:
          message.operator = reader.int32();
          break;
        case /* types.MemberValue value */
        5:
          message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.model !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.model);
    if (message.member !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.member);
    if (message.operator !== 0)
      writer.tag(4, WireType2.Varint).int32(message.operator);
    if (message.value)
      MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberClause = new MemberClause$Type();
var CompositeClause$Type = class extends MessageType3 {
  constructor() {
    super("types.CompositeClause", [
      { no: 3, name: "operator", kind: "enum", T: () => ["types.LogicalOperator", LogicalOperator] },
      { no: 4, name: "clauses", kind: "message", repeat: 2, T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operator = 0;
    message.clauses = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.LogicalOperator operator */
        3:
          message.operator = reader.int32();
          break;
        case /* repeated types.Clause clauses */
        4:
          message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.operator !== 0)
      writer.tag(3, WireType2.Varint).int32(message.operator);
    for (let i = 0; i < message.clauses.length; i++)
      Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var CompositeClause = new CompositeClause$Type();
var Token$Type = class extends MessageType3 {
  constructor() {
    super("types.Token", [
      {
        no: 1,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "total_supply",
        kind: "scalar",
        localName: "total_supply",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes token_id */
        1:
          message.token_id = reader.bytes();
          break;
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* bytes metadata */
        6:
          message.metadata = reader.bytes();
          break;
        case /* optional bytes total_supply */
        7:
          message.total_supply = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.token_id !== void 0)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.token_id);
    if (message.contract_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType2.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.decimals);
    if (message.metadata.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.metadata);
    if (message.total_supply !== void 0)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.total_supply);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Token = new Token$Type();
var TokenContract$Type = class extends MessageType3 {
  constructor() {
    super("types.TokenContract", [
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.count = 0;
    message.metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* uint32 count */
        6:
          message.count = reader.uint32();
          break;
        case /* bytes metadata */
        7:
          message.metadata = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType2.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.decimals);
    if (message.count !== 0)
      writer.tag(6, WireType2.Varint).uint32(message.count);
    if (message.metadata.length)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.metadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenContract = new TokenContract$Type();
var TokenBalance$Type = class extends MessageType3 {
  constructor() {
    super("types.TokenBalance", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        localName: "account_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balance = new Uint8Array(0);
    message.account_address = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes balance */
        1:
          message.balance = reader.bytes();
          break;
        case /* bytes account_address */
        2:
          message.account_address = reader.bytes();
          break;
        case /* bytes contract_address */
        3:
          message.contract_address = reader.bytes();
          break;
        case /* optional bytes token_id */
        4:
          message.token_id = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.balance);
    if (message.account_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.account_address);
    if (message.contract_address.length)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.token_id !== void 0)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.token_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalance = new TokenBalance$Type();
var OrderBy$Type = class extends MessageType3 {
  constructor() {
    super("types.OrderBy", [
      {
        no: 1,
        name: "field",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "direction", kind: "enum", T: () => ["types.OrderDirection", OrderDirection] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = "";
    message.direction = 0;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string field */
        1:
          message.field = reader.string();
          break;
        case /* types.OrderDirection direction */
        2:
          message.direction = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.field !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.field);
    if (message.direction !== 0)
      writer.tag(2, WireType2.Varint).int32(message.direction);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var OrderBy = new OrderBy$Type();
var Controller$Type = class extends MessageType3 {
  constructor() {
    super("types.Controller", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "deployed_at_timestamp",
        kind: "scalar",
        localName: "deployed_at_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = new Uint8Array(0);
    message.username = "";
    message.deployed_at_timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address */
        1:
          message.address = reader.bytes();
          break;
        case /* string username */
        2:
          message.username = reader.string();
          break;
        case /* uint64 deployed_at_timestamp */
        3:
          message.deployed_at_timestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.address);
    if (message.username !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.username);
    if (message.deployed_at_timestamp !== 0n)
      writer.tag(3, WireType2.Varint).uint64(message.deployed_at_timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Controller = new Controller$Type();
var Pagination$Type = class extends MessageType3 {
  constructor() {
    super("types.Pagination", [
      {
        no: 1,
        name: "cursor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "direction", kind: "enum", T: () => ["types.PaginationDirection", PaginationDirection] },
      { no: 4, name: "order_by", kind: "message", localName: "order_by", repeat: 2, T: () => OrderBy }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cursor = "";
    message.limit = 0;
    message.direction = 0;
    message.order_by = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cursor */
        1:
          message.cursor = reader.string();
          break;
        case /* uint32 limit */
        2:
          message.limit = reader.uint32();
          break;
        case /* types.PaginationDirection direction */
        3:
          message.direction = reader.int32();
          break;
        case /* repeated types.OrderBy order_by */
        4:
          message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cursor !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.cursor);
    if (message.limit !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.limit);
    if (message.direction !== 0)
      writer.tag(3, WireType2.Varint).int32(message.direction);
    for (let i = 0; i < message.order_by.length; i++)
      OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Pagination = new Pagination$Type();
var ControllerQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.ControllerQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "usernames",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.usernames = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string usernames */
        2:
          message.usernames.push(reader.string());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.usernames.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.usernames[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ControllerQuery = new ControllerQuery$Type();
var TokenQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.TokenQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenQuery = new TokenQuery$Type();
var TokenBalanceQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.TokenBalanceQuery", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalanceQuery = new TokenBalanceQuery$Type();
var TransactionCall$Type = class extends MessageType3 {
  constructor() {
    super("types.TransactionCall", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "entrypoint",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "call_type", kind: "enum", localName: "call_type", T: () => ["types.CallType", CallType] },
      {
        no: 5,
        name: "caller_address",
        kind: "scalar",
        localName: "caller_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.entrypoint = "";
    message.calldata = [];
    message.call_type = 0;
    message.caller_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* string entrypoint */
        2:
          message.entrypoint = reader.string();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* types.CallType call_type */
        4:
          message.call_type = reader.int32();
          break;
        case /* bytes caller_address */
        5:
          message.caller_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.entrypoint !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.entrypoint);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.calldata[i]);
    if (message.call_type !== 0)
      writer.tag(4, WireType2.Varint).int32(message.call_type);
    if (message.caller_address.length)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.caller_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionCall = new TransactionCall$Type();
var Transaction$Type = class extends MessageType3 {
  constructor() {
    super("types.Transaction", [
      {
        no: 1,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "sender_address",
        kind: "scalar",
        localName: "sender_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "max_fee",
        kind: "scalar",
        localName: "max_fee",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "nonce",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "block_number",
        kind: "scalar",
        localName: "block_number",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "transaction_type",
        kind: "scalar",
        localName: "transaction_type",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "block_timestamp",
        kind: "scalar",
        localName: "block_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 10, name: "calls", kind: "message", repeat: 2, T: () => TransactionCall },
      {
        no: 11,
        name: "unique_models",
        kind: "scalar",
        localName: "unique_models",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hash = new Uint8Array(0);
    message.sender_address = new Uint8Array(0);
    message.calldata = [];
    message.max_fee = new Uint8Array(0);
    message.signature = [];
    message.nonce = new Uint8Array(0);
    message.block_number = 0n;
    message.transaction_type = "";
    message.block_timestamp = 0n;
    message.calls = [];
    message.unique_models = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes transaction_hash */
        1:
          message.transaction_hash = reader.bytes();
          break;
        case /* bytes sender_address */
        2:
          message.sender_address = reader.bytes();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* bytes max_fee */
        4:
          message.max_fee = reader.bytes();
          break;
        case /* repeated bytes signature */
        5:
          message.signature.push(reader.bytes());
          break;
        case /* bytes nonce */
        6:
          message.nonce = reader.bytes();
          break;
        case /* uint64 block_number */
        7:
          message.block_number = reader.uint64().toBigInt();
          break;
        case /* string transaction_type */
        8:
          message.transaction_type = reader.string();
          break;
        case /* uint64 block_timestamp */
        9:
          message.block_timestamp = reader.uint64().toBigInt();
          break;
        case /* repeated types.TransactionCall calls */
        10:
          message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated bytes unique_models */
        11:
          message.unique_models.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction_hash.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.transaction_hash);
    if (message.sender_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.sender_address);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.calldata[i]);
    if (message.max_fee.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.max_fee);
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.signature[i]);
    if (message.nonce.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.nonce);
    if (message.block_number !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.block_number);
    if (message.transaction_type !== "")
      writer.tag(8, WireType2.LengthDelimited).string(message.transaction_type);
    if (message.block_timestamp !== 0n)
      writer.tag(9, WireType2.Varint).uint64(message.block_timestamp);
    for (let i = 0; i < message.calls.length; i++)
      TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType2.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.unique_models.length; i++)
      writer.tag(11, WireType2.LengthDelimited).bytes(message.unique_models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Transaction = new Transaction$Type();
var TransactionFilter$Type = class extends MessageType3 {
  constructor() {
    super("types.TransactionFilter", [
      {
        no: 1,
        name: "transaction_hashes",
        kind: "scalar",
        localName: "transaction_hashes",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "entrypoints",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "model_selectors",
        kind: "scalar",
        localName: "model_selectors",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "from_block",
        kind: "scalar",
        localName: "from_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "to_block",
        kind: "scalar",
        localName: "to_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hashes = [];
    message.caller_addresses = [];
    message.contract_addresses = [];
    message.entrypoints = [];
    message.model_selectors = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes transaction_hashes */
        1:
          message.transaction_hashes.push(reader.bytes());
          break;
        case /* repeated bytes caller_addresses */
        2:
          message.caller_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        3:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string entrypoints */
        4:
          message.entrypoints.push(reader.string());
          break;
        case /* repeated bytes model_selectors */
        5:
          message.model_selectors.push(reader.bytes());
          break;
        case /* optional uint64 from_block */
        6:
          message.from_block = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_block */
        7:
          message.to_block = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transaction_hashes.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.transaction_hashes[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.caller_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.entrypoints.length; i++)
      writer.tag(4, WireType2.LengthDelimited).string(message.entrypoints[i]);
    for (let i = 0; i < message.model_selectors.length; i++)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.model_selectors[i]);
    if (message.from_block !== void 0)
      writer.tag(6, WireType2.Varint).uint64(message.from_block);
    if (message.to_block !== void 0)
      writer.tag(7, WireType2.Varint).uint64(message.to_block);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionFilter = new TransactionFilter$Type();
var TransactionQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.TransactionQuery", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionQuery = new TransactionQuery$Type();
var Contract$Type = class extends MessageType3 {
  constructor() {
    super("types.Contract", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
      {
        no: 3,
        name: "head",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "tps",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_block_timestamp",
        kind: "scalar",
        localName: "last_block_timestamp",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "last_pending_block_tx",
        kind: "scalar",
        localName: "last_pending_block_tx",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.contract_type = 0;
    message.updated_at = 0n;
    message.created_at = 0n;
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* types.ContractType contract_type */
        2:
          message.contract_type = reader.int32();
          break;
        case /* optional uint64 head */
        3:
          message.head = reader.uint64().toBigInt();
          break;
        case /* optional uint64 tps */
        4:
          message.tps = reader.uint64().toBigInt();
          break;
        case /* optional uint64 last_block_timestamp */
        5:
          message.last_block_timestamp = reader.uint64().toBigInt();
          break;
        case /* optional bytes last_pending_block_tx */
        6:
          message.last_pending_block_tx = reader.bytes();
          break;
        case /* uint64 updated_at */
        7:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 created_at */
        8:
          message.created_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.contract_type !== 0)
      writer.tag(2, WireType2.Varint).int32(message.contract_type);
    if (message.head !== void 0)
      writer.tag(3, WireType2.Varint).uint64(message.head);
    if (message.tps !== void 0)
      writer.tag(4, WireType2.Varint).uint64(message.tps);
    if (message.last_block_timestamp !== void 0)
      writer.tag(5, WireType2.Varint).uint64(message.last_block_timestamp);
    if (message.last_pending_block_tx !== void 0)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.last_pending_block_tx);
    if (message.updated_at !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.updated_at);
    if (message.created_at !== 0n)
      writer.tag(8, WireType2.Varint).uint64(message.created_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Contract = new Contract$Type();
var ContractQuery$Type = class extends MessageType3 {
  constructor() {
    super("types.ContractQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1, T: () => ["types.ContractType", ContractType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.contract_types = [];
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated types.ContractType contract_types */
        2:
          if (wireType === WireType2.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contract_types.push(reader.int32());
          else
            message.contract_types.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    if (message.contract_types.length) {
      writer.tag(2, WireType2.LengthDelimited).fork();
      for (let i = 0; i < message.contract_types.length; i++)
        writer.int32(message.contract_types[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ContractQuery = new ContractQuery$Type();

// src/generated/world.ts
var SubscribeTransactionsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTransactionsRequest", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();
var SubscribeTransactionsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTransactionsResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => Transaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Transaction transaction */
        1:
          message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();
var RetrieveControllersRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveControllersRequest", [
      { no: 1, name: "query", kind: "message", T: () => ControllerQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ControllerQuery query */
        1:
          message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersRequest = new RetrieveControllersRequest$Type();
var RetrieveControllersResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveControllersResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "controllers", kind: "message", repeat: 2, T: () => Controller }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.controllers = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Controller controllers */
        2:
          message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.controllers.length; i++)
      Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersResponse = new RetrieveControllersResponse$Type();
var RetrieveContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsRequest = new RetrieveContractsRequest$Type();
var RetrieveContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveContractsResponse", [
      { no: 1, name: "contracts", kind: "message", repeat: 2, T: () => Contract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contracts = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Contract contracts */
        1:
          message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contracts.length; i++)
      Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsResponse = new RetrieveContractsResponse$Type();
var UpdateTokenBalancesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateTokenBalancesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.account_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes account_addresses */
        3:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        4:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(4, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();
var SubscribeTokenBalancesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenBalancesResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "balance", kind: "message", T: () => TokenBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.TokenBalance balance */
        2:
          message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.balance)
      TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();
var RetrieveTokensRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokensRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenQuery query */
        1:
          message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensRequest = new RetrieveTokensRequest$Type();
var SubscribeTokensRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokensRequest", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensRequest = new SubscribeTokensRequest$Type();
var RetrieveTokensResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokensResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tokens", kind: "message", repeat: 2, T: () => Token }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.tokens = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Token tokens */
        2:
          message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.tokens.length; i++)
      Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensResponse = new RetrieveTokensResponse$Type();
var SubscribeTokensResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokensResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "token", kind: "message", T: () => Token }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Token token */
        2:
          message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.token)
      Token.internalBinaryWrite(message.token, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensResponse = new SubscribeTokensResponse$Type();
var UpdateTokenSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateTokenSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();
var RetrieveTokenBalancesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenBalancesRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenBalanceQuery query */
        1:
          message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();
var SubscribeTokenBalancesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenBalancesRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();
var RetrieveTokenBalancesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenBalancesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balances", kind: "message", repeat: 2, T: () => TokenBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenBalance balances */
        2:
          message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.balances.length; i++)
      TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();
var RetrieveTransactionsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTransactionsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TransactionQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionQuery query */
        1:
          message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();
var RetrieveTransactionsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTransactionsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transactions", kind: "message", repeat: 2, T: () => Transaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.transactions = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Transaction transactions */
        2:
          message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.transactions.length; i++)
      Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();
var RetrieveTokenContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenBalanceQuery query */
        1:
          message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();
var RetrieveTokenContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenContractsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tokens", kind: "message", repeat: 2, T: () => TokenContract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.tokens = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenContract tokens */
        2:
          message.tokens.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.tokens.length; i++)
      TokenContract.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();
var SubscribeContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsRequest = new SubscribeContractsRequest$Type();
var SubscribeContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeContractsResponse", [
      { no: 1, name: "contract", kind: "message", T: () => Contract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Contract contract */
        1:
          message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract)
      Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsResponse = new SubscribeContractsResponse$Type();
var WorldMetadataRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.WorldMetadataRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldMetadataRequest = new WorldMetadataRequest$Type();
var WorldMetadataResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.WorldMetadataResponse", [
      { no: 1, name: "world", kind: "message", T: () => World }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.World world */
        1:
          message.world = World.internalBinaryRead(reader, reader.uint32(), options, message.world);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.world)
      World.internalBinaryWrite(message.world, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldMetadataResponse = new WorldMetadataResponse$Type();
var SubscribeEntitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEntitiesRequest", [
      { no: 1, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
var SubscribeEventMessagesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEventMessagesRequest", [
      { no: 1, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventMessagesRequest = new SubscribeEventMessagesRequest$Type();
var UpdateEntitiesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateEntitiesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Clause clause */
        2:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();
var UpdateEventMessagesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateEventMessagesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "clause", kind: "message", T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Clause clause */
        2:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateEventMessagesSubscriptionRequest = new UpdateEventMessagesSubscriptionRequest$Type();
var SubscribeEntityResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEntityResponse", [
      { no: 1, name: "entity", kind: "message", T: () => Entity },
      {
        no: 2,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Entity entity */
        1:
          message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
          break;
        case /* uint64 subscription_id */
        2:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.entity)
      Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    if (message.subscription_id !== 0n)
      writer.tag(2, WireType3.Varint).uint64(message.subscription_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntityResponse = new SubscribeEntityResponse$Type();
var RetrieveEntitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEntitiesRequest", [
      { no: 1, name: "query", kind: "message", T: () => Query }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Query query */
        1:
          message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      Query.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
var RetrieveEventMessagesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEventMessagesRequest", [
      { no: 1, name: "query", kind: "message", T: () => Query }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Query query */
        1:
          message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      Query.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventMessagesRequest = new RetrieveEventMessagesRequest$Type();
var RetrieveEntitiesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEntitiesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "entities", kind: "message", repeat: 2, T: () => Entity }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.entities = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Entity entities */
        2:
          message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.entities.length; i++)
      Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
var RetrieveEventsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEventsRequest", [
      { no: 1, name: "query", kind: "message", T: () => EventQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.EventQuery query */
        1:
          message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsRequest = new RetrieveEventsRequest$Type();
var RetrieveEventsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEventsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "events", kind: "message", repeat: 2, T: () => Event }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.events = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Event events */
        2:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsResponse = new RetrieveEventsResponse$Type();
var SubscribeEventsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEventsRequest", [
      { no: 1, name: "keys", kind: "message", repeat: 2, T: () => KeysClause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.KeysClause keys */
        1:
          message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsRequest = new SubscribeEventsRequest$Type();
var SubscribeEventsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEventsResponse", [
      { no: 1, name: "event", kind: "message", T: () => Event }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Event event */
        1:
          message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.event)
      Event.internalBinaryWrite(message.event, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsResponse = new SubscribeEventsResponse$Type();
var PublishMessageRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageRequest", [
      {
        no: 1,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signature = [];
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes signature */
        1:
          message.signature.push(reader.bytes());
          break;
        case /* string message */
        2:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.signature[i]);
    if (message.message !== "")
      writer.tag(2, WireType3.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageRequest = new PublishMessageRequest$Type();
var PublishMessageResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageResponse", [
      {
        no: 1,
        name: "entity_id",
        kind: "scalar",
        localName: "entity_id",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.entity_id = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes entity_id */
        1:
          message.entity_id = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.entity_id.length)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.entity_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageResponse = new PublishMessageResponse$Type();
var PublishMessageBatchRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageBatchRequest", [
      { no: 1, name: "messages", kind: "message", repeat: 2, T: () => PublishMessageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messages = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageRequest messages */
        1:
          message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.messages.length; i++)
      PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
var PublishMessageBatchResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageBatchResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 2, T: () => PublishMessageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.responses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageResponse responses */
        1:
          message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.responses.length; i++)
      PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();
var World2 = new ServiceType("world.World", [
  { name: "SubscribeContracts", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },
  { name: "WorldMetadata", options: {}, I: WorldMetadataRequest, O: WorldMetadataResponse },
  { name: "SubscribeEntities", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEntitiesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
  { name: "RetrieveEntities", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
  { name: "SubscribeEventMessages", serverStreaming: true, options: {}, I: SubscribeEventMessagesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEventMessagesSubscription", options: {}, I: UpdateEventMessagesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokenBalances", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },
  { name: "UpdateTokenBalancesSubscription", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokens", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },
  { name: "UpdateTokensSubscription", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },
  { name: "RetrieveEventMessages", options: {}, I: RetrieveEventMessagesRequest, O: RetrieveEntitiesResponse },
  { name: "RetrieveEvents", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },
  { name: "SubscribeEvents", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },
  { name: "RetrieveTokens", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },
  { name: "RetrieveTokenBalances", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },
  { name: "RetrieveTransactions", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },
  { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },
  { name: "RetrieveControllers", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },
  { name: "RetrieveContracts", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },
  { name: "RetrieveTokenContracts", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },
  { name: "PublishMessage", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },
  { name: "PublishMessageBatch", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse }
]);

// src/generated/world.client.ts
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
var WorldClient = class {
  constructor(_transport) {
    this._transport = _transport;
  }
  typeName = World2.typeName;
  methods = World2.methods;
  options = World2.options;
  /**
   * Subscribes to updates about contracts. Like the head block number, tps, etc.
   *
   * @generated from protobuf rpc: SubscribeContracts
   */
  subscribeContracts(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieves metadata about the World including all the registered components and systems.
   *
   * @generated from protobuf rpc: WorldMetadata
   */
  worldMetadata(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEntities
   */
  subscribeEntities(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEntitiesSubscription
   */
  updateEntitiesSubscription(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEntities
   */
  retrieveEntities(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEventMessages
   */
  subscribeEventMessages(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEventMessagesSubscription
   */
  updateEventMessagesSubscription(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token balance updates.
   *
   * @generated from protobuf rpc: SubscribeTokenBalances
   */
  subscribeTokenBalances(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token balance subscription
   *
   * @generated from protobuf rpc: UpdateTokenBalancesSubscription
   */
  updateTokenBalancesSubscription(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token updates.
   *
   * @generated from protobuf rpc: SubscribeTokens
   */
  subscribeTokens(input, options) {
    const method = this.methods[9], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token subscription
   *
   * @generated from protobuf rpc: UpdateTokensSubscription
   */
  updateTokensSubscription(input, options) {
    const method = this.methods[10], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEventMessages
   */
  retrieveEventMessages(input, options) {
    const method = this.methods[11], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve events
   *
   * @generated from protobuf rpc: RetrieveEvents
   */
  retrieveEvents(input, options) {
    const method = this.methods[12], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to events
   *
   * @generated from protobuf rpc: SubscribeEvents
   */
  subscribeEvents(input, options) {
    const method = this.methods[13], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve tokens
   *
   * @generated from protobuf rpc: RetrieveTokens
   */
  retrieveTokens(input, options) {
    const method = this.methods[14], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve token balances
   *
   * @generated from protobuf rpc: RetrieveTokenBalances
   */
  retrieveTokenBalances(input, options) {
    const method = this.methods[15], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve transactions
   *
   * @generated from protobuf rpc: RetrieveTransactions
   */
  retrieveTransactions(input, options) {
    const method = this.methods[16], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to transactions
   *
   * @generated from protobuf rpc: SubscribeTransactions
   */
  subscribeTransactions(input, options) {
    const method = this.methods[17], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve controllers
   *
   * @generated from protobuf rpc: RetrieveControllers
   */
  retrieveControllers(input, options) {
    const method = this.methods[18], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve contracts
   *
   * @generated from protobuf rpc: RetrieveContracts
   */
  retrieveContracts(input, options) {
    const method = this.methods[19], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve tokens contracts
   *
   * @generated from protobuf rpc: RetrieveTokenContracts
   */
  retrieveTokenContracts(input, options) {
    const method = this.methods[20], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a torii offchain message
   *
   * @generated from protobuf rpc: PublishMessage
   */
  publishMessage(input, options) {
    const method = this.methods[21], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a set of torii offchain messages
   *
   * @generated from protobuf rpc: PublishMessageBatch
   */
  publishMessageBatch(input, options) {
    const method = this.methods[22], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
};

// src/client.ts
var DojoGrpcClient = class {
  transport;
  worldClient;
  constructor(config) {
    this.transport = new GrpcWebFetchTransport({
      baseUrl: config.url,
      format: "binary"
    });
    this.worldClient = new WorldClient(this.transport);
  }
  destroy() {
  }
};
function createDojoGrpcClient(config) {
  return new DojoGrpcClient(config);
}

// src/mappings/query.ts
function hexToBuffer(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function mapOrderDirection(direction) {
  switch (direction) {
    case "Asc":
      return 0 /* ASC */;
    case "Desc":
      return 1 /* DESC */;
    default:
      return 0 /* ASC */;
  }
}
function mapPaginationDirection(direction) {
  switch (direction) {
    case "Forward":
      return 0 /* FORWARD */;
    case "Backward":
      return 1 /* BACKWARD */;
    default:
      return 0 /* FORWARD */;
  }
}
function mapOrderBy(orderBy) {
  return {
    field: orderBy.field,
    direction: mapOrderDirection(orderBy.direction)
  };
}
function mapPagination(pagination) {
  return {
    limit: pagination.limit || 0,
    cursor: pagination.cursor || "",
    direction: mapPaginationDirection(pagination.direction),
    order_by: pagination.order_by.map(mapOrderBy)
  };
}
function mapPatternMatching(pattern) {
  switch (pattern) {
    case "FixedLen":
      return 0 /* FixedLen */;
    case "VariableLen":
      return 1 /* VariableLen */;
    default:
      return 0 /* FixedLen */;
  }
}
function mapComparisonOperator(op) {
  switch (op) {
    case "Eq":
      return 0 /* EQ */;
    case "Neq":
      return 1 /* NEQ */;
    case "Gt":
      return 2 /* GT */;
    case "Gte":
      return 3 /* GTE */;
    case "Lt":
      return 4 /* LT */;
    case "Lte":
      return 5 /* LTE */;
    case "In":
      return 6 /* IN */;
    case "NotIn":
      return 7 /* NOT_IN */;
    default:
      return 0 /* EQ */;
  }
}
function mapLogicalOperator(op) {
  switch (op) {
    case "And":
      return 0 /* AND */;
    case "Or":
      return 1 /* OR */;
    default:
      return 0 /* AND */;
  }
}
function mapMemberValue(value) {
  if (typeof value === "string") {
    return { value_type: { oneofKind: "string", string: value } };
  } else if (Array.isArray(value)) {
    return {
      value_type: {
        oneofKind: "list",
        list: { values: value.map(mapMemberValue) }
      }
    };
  } else if (value && typeof value === "object" && "Primitive" in value) {
    return {
      value_type: {
        oneofKind: "primitive",
        primitive: value.Primitive
      }
    };
  }
  return {
    value_type: { oneofKind: "string", string: String(value) }
  };
}
function mapClause(clause) {
  if ("HashedKeys" in clause) {
    const hashedKeysClause = {
      hashed_keys: clause.HashedKeys.map(hexToBuffer)
    };
    return {
      clause_type: {
        oneofKind: "hashed_keys",
        hashed_keys: hashedKeysClause
      }
    };
  } else if ("Keys" in clause) {
    const keysClause = {
      keys: clause.Keys.keys.map(
        (k) => k ? hexToBuffer(k) : new Uint8Array()
      ),
      pattern_matching: mapPatternMatching(clause.Keys.pattern_matching),
      models: clause.Keys.models
    };
    return {
      clause_type: { oneofKind: "keys", keys: keysClause }
    };
  } else if ("Member" in clause) {
    const memberClause = {
      model: clause.Member.model,
      member: clause.Member.member,
      operator: mapComparisonOperator(clause.Member.operator),
      value: mapMemberValue(clause.Member.value)
    };
    return {
      clause_type: { oneofKind: "member", member: memberClause }
    };
  } else if ("Composite" in clause) {
    const compositeClause = {
      operator: mapLogicalOperator(clause.Composite.operator),
      clauses: clause.Composite.clauses.map(mapClause)
    };
    return {
      clause_type: {
        oneofKind: "composite",
        composite: compositeClause
      }
    };
  }
  throw new Error("Unknown clause type");
}
function mapQuery(query) {
  return {
    pagination: mapPagination(query.pagination),
    clause: query.clause ? mapClause(query.clause) : void 0,
    no_hashed_keys: query.no_hashed_keys,
    models: query.models,
    historical: query.historical
  };
}
function mapControllerQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    usernames: query.usernames,
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenBalanceQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    account_addresses: query.account_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTransactionFilter(filter) {
  return {
    transaction_hashes: filter.transaction_hashes.map(hexToBuffer),
    caller_addresses: filter.caller_addresses.map(hexToBuffer),
    contract_addresses: filter.contract_addresses.map(hexToBuffer),
    entrypoints: filter.entrypoints,
    model_selectors: filter.model_selectors.map(hexToBuffer),
    from_block: filter.from_block ? BigInt(filter.from_block) : void 0,
    to_block: filter.to_block ? BigInt(filter.to_block) : void 0
  };
}
function mapTransactionQuery(query) {
  return {
    filter: query.filter ? mapTransactionFilter(query.filter) : void 0,
    pagination: mapPagination(query.pagination)
  };
}
function createRetrieveEntitiesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveEventMessagesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveTokensRequest(query) {
  return {
    query: mapTokenQuery(query)
  };
}
function createRetrieveTokenBalancesRequest(query) {
  return {
    query: mapTokenBalanceQuery(query)
  };
}
function createRetrieveTokenContractsRequest(query) {
  return {
    query: mapTokenBalanceQuery(query)
  };
}
function createRetrieveControllersRequest(query) {
  return {
    query: mapControllerQuery(query)
  };
}
function createRetrieveTransactionsRequest(query) {
  return {
    query: mapTransactionQuery(query)
  };
}
function createRetrieveEventsRequest(query) {
  return {
    query: {
      keys: query.keys ? {
        keys: query.keys.keys.map(
          (k) => k ? hexToBuffer(k) : new Uint8Array()
        ),
        pattern_matching: query.keys.pattern_matching === "FixedLen" ? 0 /* FixedLen */ : 1 /* VariableLen */,
        models: query.keys.models || []
      } : void 0,
      pagination: query.pagination ? mapPagination(query.pagination) : void 0
    }
  };
}
function createRetrieveContractsRequest(query) {
  return {
    query: {
      contract_addresses: query.contract_addresses?.map(hexToBuffer) || [],
      contract_types: query.contract_types || []
    }
  };
}

// src/mappings/types.ts
var textDecoder = void 0;
function bufferToHex(buffer) {
  return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function hexToBuffer2(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function mapCallType(callType) {
  switch (callType) {
    case 0 /* EXECUTE */:
      return "Execute";
    case 1 /* EXECUTE_FROM_OUTSIDE */:
      return "ExecuteFromOutside";
    default:
      return "Execute";
  }
}
function mapTransactionCall(call) {
  return {
    contract_address: bufferToHex(call.contract_address),
    entrypoint: call.entrypoint,
    calldata: call.calldata.map(bufferToHex),
    call_type: mapCallType(call.call_type),
    caller_address: bufferToHex(call.caller_address)
  };
}
function mapTransaction(tx) {
  return {
    transaction_hash: bufferToHex(tx.transaction_hash),
    sender_address: bufferToHex(tx.sender_address),
    calldata: tx.calldata.map(bufferToHex),
    max_fee: bufferToHex(tx.max_fee),
    signature: tx.signature.map(bufferToHex),
    nonce: bufferToHex(tx.nonce),
    block_number: Number(tx.block_number),
    transaction_type: tx.transaction_type,
    block_timestamp: Number(tx.block_timestamp),
    calls: tx.calls.map(mapTransactionCall),
    unique_models: tx.unique_models.map(bufferToHex)
  };
}
function mapTransactionsResponse(response) {
  return {
    items: response.transactions.map(mapTransaction),
    next_cursor: response.next_cursor || void 0
  };
}
function mapController(controller) {
  return {
    address: bufferToHex(controller.address),
    username: controller.username,
    deployed_at_timestamp: Number(controller.deployed_at_timestamp)
  };
}
function mapControllersResponse(response) {
  return {
    items: response.controllers.map(mapController),
    next_cursor: response.next_cursor || void 0
  };
}
function uint8ArrayToString(input) {
  if (textDecoder) {
    return textDecoder.decode(input);
  }
  textDecoder = new TextDecoder();
  return textDecoder.decode(input);
}
function parseJsonMetadata(input) {
  try {
    return JSON.parse(uint8ArrayToString(input));
  } catch (_err) {
    return uint8ArrayToString(input);
  }
}
function mapToken(token) {
  return {
    contract_address: bufferToHex(token.contract_address),
    token_id: token.token_id ? bufferToHex(token.token_id) : void 0,
    name: token.name,
    symbol: token.symbol,
    decimals: token.decimals,
    metadata: parseJsonMetadata(token.metadata)
  };
}
function mapTokensResponse(response) {
  return {
    items: response.tokens.map(mapToken),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenBalance(balance) {
  return {
    balance: bufferToHex(balance.balance),
    account_address: bufferToHex(balance.account_address),
    contract_address: bufferToHex(balance.contract_address),
    token_id: balance.token_id ? bufferToHex(balance.token_id) : void 0
  };
}
function mapTokenBalancesResponse(response) {
  return {
    items: response.balances.map(mapTokenBalance),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenContract(collection) {
  return {
    contract_address: bufferToHex(collection.contract_address),
    name: collection.name,
    symbol: collection.symbol,
    decimals: collection.decimals,
    count: collection.count,
    metadata: parseJsonMetadata(collection.metadata)
  };
}
function mapTokenContractsResponse(response) {
  return {
    items: response.tokens.map(mapTokenContract),
    next_cursor: response.next_cursor || void 0
  };
}
function mapPrimitive(primitive) {
  if (!primitive.primitive_type) return null;
  switch (primitive.primitive_type.oneofKind) {
    case "i8":
      return primitive.primitive_type.i8;
    case "i16":
      return primitive.primitive_type.i16;
    case "i32":
      return primitive.primitive_type.i32;
    case "i64":
      return Number(primitive.primitive_type.i64);
    case "i128":
      return bufferToHex(primitive.primitive_type.i128);
    case "u8":
      return primitive.primitive_type.u8;
    case "u16":
      return primitive.primitive_type.u16;
    case "u32":
      return primitive.primitive_type.u32;
    case "u64":
      return Number(primitive.primitive_type.u64);
    case "u128":
      return bufferToHex(primitive.primitive_type.u128);
    case "u256":
      return bufferToHex(primitive.primitive_type.u256);
    case "bool":
      return primitive.primitive_type.bool;
    case "felt252":
      return bufferToHex(primitive.primitive_type.felt252);
    case "class_hash":
      return bufferToHex(primitive.primitive_type.class_hash);
    case "contract_address":
      return bufferToHex(primitive.primitive_type.contract_address);
    case "eth_address":
      return bufferToHex(primitive.primitive_type.eth_address);
    default:
      return null;
  }
}
function getPrimitiveTypeName(primitive) {
  if (!primitive.primitive_type) return "";
  return primitive.primitive_type.oneofKind || "";
}
function mapTy(ty, isKey = false) {
  if (!ty.ty_type) {
    return {
      type: "primitive",
      type_name: "",
      value: null,
      key: isKey
    };
  }
  switch (ty.ty_type.oneofKind) {
    case "primitive": {
      return {
        type: "primitive",
        type_name: getPrimitiveTypeName(ty.ty_type.primitive),
        value: mapPrimitive(ty.ty_type.primitive),
        key: isKey
      };
    }
    case "struct": {
      const struct = ty.ty_type.struct;
      const structValue = {};
      for (const member of struct.children) {
        if (member.ty) {
          structValue[member.name] = mapTy(member.ty, member.key);
        }
      }
      return {
        type: "struct",
        type_name: struct.name,
        value: structValue,
        key: isKey
      };
    }
    case "enum": {
      const enumType = ty.ty_type.enum;
      const selectedOption = enumType.options[enumType.option];
      return {
        type: "enum",
        type_name: enumType.name,
        value: selectedOption && selectedOption.ty ? {
          option: selectedOption.name,
          value: mapTy(selectedOption.ty)
        } : null,
        key: isKey
      };
    }
    case "array": {
      const array = ty.ty_type.array;
      return {
        type: "array",
        type_name: "array",
        value: array.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "tuple": {
      const tuple = ty.ty_type.tuple;
      return {
        type: "tuple",
        type_name: "tuple",
        value: tuple.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "bytearray": {
      return {
        type: "bytearray",
        type_name: "bytearray",
        value: ty.ty_type.bytearray,
        key: isKey
      };
    }
    default:
      return {
        type: "primitive",
        type_name: "",
        value: null,
        key: isKey
      };
  }
}
function mapModel(model) {
  const mappedModel = {};
  if (model && Array.isArray(model)) {
    for (const member of model) {
      if (member.ty) {
        mappedModel[member.name] = mapTy(member.ty, member.key);
      }
    }
  }
  return mappedModel;
}
function mapEntity(entity) {
  const models = {};
  for (const model of entity.models) {
    models[model.name] = mapModel(model.children);
  }
  return {
    hashed_keys: bufferToHex(entity.hashed_keys),
    models
  };
}
function mapEntitiesResponse(response) {
  return {
    items: response.entities.map(mapEntity),
    next_cursor: response.next_cursor || void 0
  };
}
function mapIndexerUpdate(update) {
  return {
    head: Number(update.head),
    tps: Number(update.tps),
    last_block_timestamp: Number(update.last_block_timestamp),
    contract_address: bufferToHex(update.contract_address)
  };
}
function mapMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(hexToBuffer2)
  };
}
function mapEvent(event) {
  return {
    keys: event.keys.map(bufferToHex),
    data: event.data.map(bufferToHex),
    transaction_hash: bufferToHex(event.transaction_hash)
  };
}
function mapEventsResponse(response) {
  return {
    items: response.events.map(mapEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function mapContract(contract) {
  return {
    contract_address: bufferToHex(contract.contract_address),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? bufferToHex(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function mapContractsResponse(response) {
  return {
    items: response.contracts.map(mapContract)
  };
}
function mapWorldMetadataResponse(response) {
  if (!response.world) {
    return null;
  }
  return {
    world_address: bufferToHex(response.world.world_address),
    models: response.world.models.map((model) => ({
      selector: bufferToHex(model.selector),
      namespace: model.namespace,
      name: model.name,
      packed_size: model.packed_size,
      unpacked_size: model.unpacked_size,
      class_hash: bufferToHex(model.class_hash),
      layout: bufferToHex(model.layout),
      schema: bufferToHex(model.schema),
      contract_address: bufferToHex(model.contract_address),
      use_legacy_store: model.use_legacy_store
    }))
  };
}

// src/mappings/effect-schema/transformers.ts
import { Schema as Schema4 } from "effect";

// src/mappings/effect-schema/entity-schemas.ts
import { Schema as Schema2 } from "effect";

// src/mappings/effect-schema/base-schemas.ts
import { Schema } from "effect";
var HexString = Schema.String.pipe(
  Schema.pattern(/^0x[0-9a-fA-F]*$/, {
    message: () => "Invalid hex string format"
  })
);
var BufferToHex = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  HexString,
  {
    decode: (buffer) => {
      return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
    },
    encode: (hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    }
  }
);
var OptionalBufferToHex = Schema.optional(BufferToHex);
var BufferArrayToHexArray = Schema.transform(
  Schema.Array(Schema.Uint8ArrayFromSelf),
  Schema.Array(HexString),
  {
    decode: (buffers) => buffers.map(
      (buffer) => "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("")
    ),
    encode: (hexStrings) => hexStrings.map((hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    })
  }
);
var BigIntToNumber = Schema.transform(
  Schema.BigIntFromSelf,
  Schema.Number,
  {
    decode: (bigint) => Number(bigint),
    encode: (number) => BigInt(number)
  }
);
var OptionalString = Schema.optional(Schema.String);
var OptionalNumber = Schema.optional(Schema.Number);
var textDecoder2 = void 0;
var Uint8ArrayToString = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  Schema.String,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      return textDecoder2.decode(input);
    },
    encode: (str) => new TextEncoder().encode(str)
  }
);
var JsonMetadata = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  Schema.Unknown,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      const str = textDecoder2.decode(input);
      try {
        return JSON.parse(str);
      } catch (_err) {
        return str;
      }
    },
    encode: (value) => {
      const str = typeof value === "string" ? value : JSON.stringify(value);
      return new TextEncoder().encode(str);
    }
  }
);

// src/mappings/effect-schema/entity-schemas.ts
var CallTypeSchema = Schema2.transform(
  Schema2.Enums({
    EXECUTE: 0,
    EXECUTE_FROM_OUTSIDE: 1
  }),
  Schema2.Literal("Execute", "ExecuteFromOutside"),
  {
    decode: (grpcCallType) => {
      switch (grpcCallType) {
        case 0:
          return "Execute";
        case 1:
          return "ExecuteFromOutside";
        default:
          return "Execute";
      }
    },
    encode: (toriiCallType) => {
      switch (toriiCallType) {
        case "Execute":
          return 0;
        case "ExecuteFromOutside":
          return 1;
        default:
          return 0;
      }
    }
  }
);
var TransactionCallSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    entrypoint: Schema2.String,
    calldata: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    call_type: Schema2.Enums({
      EXECUTE: 0,
      EXECUTE_FROM_OUTSIDE: 1
    }),
    caller_address: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    entrypoint: Schema2.String,
    calldata: BufferArrayToHexArray,
    call_type: CallTypeSchema,
    caller_address: BufferToHex
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      entrypoint: grpc.entrypoint,
      calldata: grpc.calldata,
      call_type: grpc.call_type,
      caller_address: grpc.caller_address
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      entrypoint: torii.entrypoint,
      calldata: torii.calldata,
      call_type: torii.call_type,
      caller_address: torii.caller_address
    })
  }
);
var TransactionSchema = Schema2.transform(
  Schema2.Struct({
    transaction_hash: Schema2.Uint8ArrayFromSelf,
    sender_address: Schema2.Uint8ArrayFromSelf,
    calldata: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    max_fee: Schema2.Uint8ArrayFromSelf,
    signature: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    nonce: Schema2.Uint8ArrayFromSelf,
    block_number: Schema2.BigIntFromSelf,
    block_timestamp: Schema2.BigIntFromSelf,
    transaction_type: Schema2.String,
    calls: Schema2.Array(TransactionCallSchema),
    unique_models: Schema2.Array(Schema2.Uint8ArrayFromSelf)
  }),
  Schema2.Struct({
    transaction_hash: BufferToHex,
    sender_address: BufferToHex,
    calldata: BufferArrayToHexArray,
    max_fee: BufferToHex,
    signature: BufferArrayToHexArray,
    nonce: BufferToHex,
    block_number: BigIntToNumber,
    block_timestamp: BigIntToNumber,
    transaction_type: Schema2.String,
    calls: Schema2.Array(TransactionCallSchema),
    unique_models: BufferArrayToHexArray
  }),
  {
    decode: (grpc) => ({
      transaction_hash: grpc.transaction_hash,
      sender_address: grpc.sender_address,
      calldata: grpc.calldata,
      max_fee: grpc.max_fee,
      signature: grpc.signature,
      nonce: grpc.nonce,
      block_number: grpc.block_number,
      block_timestamp: grpc.block_timestamp,
      transaction_type: grpc.transaction_type,
      calls: grpc.calls,
      unique_models: grpc.unique_models
    }),
    encode: (torii) => ({
      transaction_hash: torii.transaction_hash,
      sender_address: torii.sender_address,
      calldata: torii.calldata,
      max_fee: torii.max_fee,
      signature: torii.signature,
      nonce: torii.nonce,
      block_number: BigInt(torii.block_number),
      block_timestamp: BigInt(torii.block_timestamp),
      transaction_type: torii.transaction_type,
      calls: torii.calls,
      unique_models: torii.unique_models
    })
  }
);
var ControllerSchema = Schema2.transform(
  Schema2.Struct({
    address: Schema2.Uint8ArrayFromSelf,
    username: Schema2.String,
    deployed_at_timestamp: Schema2.BigIntFromSelf
  }),
  Schema2.Struct({
    address: BufferToHex,
    username: Schema2.String,
    deployed_at_timestamp: BigIntToNumber
  }),
  {
    decode: (grpc) => ({
      address: grpc.address,
      username: grpc.username,
      deployed_at_timestamp: grpc.deployed_at_timestamp
    }),
    encode: (torii) => ({
      address: torii.address,
      username: torii.username,
      deployed_at_timestamp: BigInt(torii.deployed_at_timestamp)
    })
  }
);
var TokenSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    token_id: Schema2.optional(Schema2.Uint8ArrayFromSelf),
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    metadata: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      token_id: grpc.token_id,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      token_id: torii.token_id,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      metadata: torii.metadata
    })
  }
);
var TokenBalanceSchema = Schema2.transform(
  Schema2.Struct({
    balance: Schema2.Uint8ArrayFromSelf,
    account_address: Schema2.Uint8ArrayFromSelf,
    contract_address: Schema2.Uint8ArrayFromSelf,
    token_id: Schema2.optional(Schema2.Uint8ArrayFromSelf)
  }),
  Schema2.Struct({
    balance: BufferToHex,
    account_address: BufferToHex,
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex
  }),
  {
    decode: (grpc) => ({
      balance: grpc.balance,
      account_address: grpc.account_address,
      contract_address: grpc.contract_address,
      token_id: grpc.token_id
    }),
    encode: (torii) => ({
      balance: torii.balance,
      account_address: torii.account_address,
      contract_address: torii.contract_address,
      token_id: torii.token_id
    })
  }
);
var TokenContractSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    count: Schema2.BigIntFromSelf,
    metadata: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    count: Schema2.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      count: grpc.count,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      count: BigInt(torii.count),
      metadata: torii.metadata
    })
  }
);
var TransactionsResponseSchema = Schema2.transform(
  Schema2.Struct({
    transactions: Schema2.Array(TransactionSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TransactionSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.transactions,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      transactions: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var ControllersResponseSchema = Schema2.transform(
  Schema2.Struct({
    controllers: Schema2.Array(ControllerSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(ControllerSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.controllers,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      controllers: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokensResponseSchema = Schema2.transform(
  Schema2.Struct({
    tokens: Schema2.Array(TokenSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenBalancesResponseSchema = Schema2.transform(
  Schema2.Struct({
    balances: Schema2.Array(TokenBalanceSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenBalanceSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.balances,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      balances: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenContractsResponseSchema = Schema2.transform(
  Schema2.Struct({
    tokens: Schema2.Array(TokenContractSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenContractSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);

// src/mappings/effect-schema/model-schemas.ts
import { Schema as Schema3 } from "effect";
var PrimitiveSchema = Schema3.transform(
  Schema3.Struct({
    primitive_type: Schema3.Union(
      Schema3.Struct({
        oneofKind: Schema3.Literal("i8"),
        i8: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i16"),
        i16: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i32"),
        i32: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i64"),
        i64: Schema3.BigIntFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i128"),
        i128: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u8"),
        u8: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u16"),
        u16: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u32"),
        u32: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u64"),
        u64: Schema3.BigIntFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u128"),
        u128: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u256"),
        u256: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("bool"),
        bool: Schema3.Boolean
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("felt252"),
        felt252: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("class_hash"),
        class_hash: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("contract_address"),
        contract_address: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("eth_address"),
        eth_address: Schema3.Uint8ArrayFromSelf
      })
    ).pipe(Schema3.optional)
  }),
  Schema3.Unknown,
  {
    decode: (primitive) => {
      if (!primitive.primitive_type) return null;
      switch (primitive.primitive_type.oneofKind) {
        case "i8":
          return primitive.primitive_type.i8;
        case "i16":
          return primitive.primitive_type.i16;
        case "i32":
          return primitive.primitive_type.i32;
        case "i64":
          return Number(primitive.primitive_type.i64);
        case "i128":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.i128
          );
        case "u8":
          return primitive.primitive_type.u8;
        case "u16":
          return primitive.primitive_type.u16;
        case "u32":
          return primitive.primitive_type.u32;
        case "u64":
          return Number(primitive.primitive_type.u64);
        case "u128":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.u128
          );
        case "u256":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.u256
          );
        case "bool":
          return primitive.primitive_type.bool;
        case "felt252":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.felt252
          );
        case "class_hash":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.class_hash
          );
        case "contract_address":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.contract_address
          );
        case "eth_address":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.eth_address
          );
        default:
          return null;
      }
    },
    encode: (value) => {
      throw new Error("Encoding not implemented for PrimitiveSchema");
    }
  }
);
var TySchema = Schema3.suspend(
  () => Schema3.transform(
    Schema3.Struct({
      ty_type: Schema3.Union(
        Schema3.Struct({
          oneofKind: Schema3.Literal("primitive"),
          primitive: PrimitiveSchema
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("struct"),
          struct: Schema3.Struct({
            name: Schema3.String,
            children: Schema3.Array(MemberSchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("enum"),
          enum: Schema3.Struct({
            name: Schema3.String,
            option: Schema3.Number,
            options: Schema3.Array(MemberSchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("array"),
          array: Schema3.Struct({
            children: Schema3.Array(TySchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("tuple"),
          tuple: Schema3.Struct({
            children: Schema3.Array(TySchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("bytearray"),
          bytearray: Schema3.String
        })
      ).pipe(Schema3.optional)
    }),
    Schema3.Struct({
      type: Schema3.String,
      type_name: Schema3.String,
      value: Schema3.Unknown,
      key: Schema3.Boolean
    }),
    {
      decode: (ty, isKey = false) => {
        if (!ty.ty_type) {
          return {
            type: "primitive",
            type_name: "",
            value: null,
            key: isKey
          };
        }
        switch (ty.ty_type.oneofKind) {
          case "primitive": {
            const primitiveValue = PrimitiveSchema.pipe(
              Schema3.decodeSync
            )(ty.ty_type.primitive);
            return {
              type: "primitive",
              type_name: ty.ty_type.primitive.primitive_type?.oneofKind || "",
              value: primitiveValue,
              key: isKey
            };
          }
          case "struct": {
            const struct = ty.ty_type.struct;
            const structValue = {};
            for (const member of struct.children) {
              if (member.ty) {
                structValue[member.name] = TySchema.pipe(
                  Schema3.decodeSync
                )(member.ty);
              }
            }
            return {
              type: "struct",
              type_name: struct.name,
              value: structValue,
              key: isKey
            };
          }
          case "enum": {
            const enumType = ty.ty_type.enum;
            const selectedOption = enumType.options[enumType.option];
            return {
              type: "enum",
              type_name: enumType.name,
              value: selectedOption && selectedOption.ty ? {
                option: selectedOption.name,
                value: TySchema.pipe(
                  Schema3.decodeSync
                )(selectedOption.ty)
              } : null,
              key: isKey
            };
          }
          case "array": {
            const array = ty.ty_type.array;
            return {
              type: "array",
              type_name: "array",
              value: array.children.map(
                (child) => TySchema.pipe(Schema3.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "tuple": {
            const tuple = ty.ty_type.tuple;
            return {
              type: "tuple",
              type_name: "tuple",
              value: tuple.children.map(
                (child) => TySchema.pipe(Schema3.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "bytearray": {
            return {
              type: "bytearray",
              type_name: "bytearray",
              value: ty.ty_type.bytearray,
              key: isKey
            };
          }
          default:
            return {
              type: "primitive",
              type_name: "",
              value: null,
              key: isKey
            };
        }
      },
      encode: (torii) => {
        throw new Error("Encoding not implemented for TySchema");
      }
    }
  )
);
var MemberSchema = Schema3.suspend(
  () => Schema3.Struct({
    name: Schema3.String,
    ty: Schema3.optional(TySchema),
    key: Schema3.Boolean
  })
);
var ModelSchema = Schema3.transform(
  Schema3.Array(MemberSchema),
  Schema3.Record({ key: Schema3.String, value: TySchema }),
  {
    decode: (members) => {
      const model = {};
      if (members && Array.isArray(members)) {
        for (const member of members) {
          if (member.ty) {
            const ty = TySchema.pipe(Schema3.decodeSync)(member.ty);
            model[member.name] = { ...ty, key: member.key };
          }
        }
      }
      return model;
    },
    encode: (model) => {
      throw new Error("Encoding not implemented for ModelSchema");
    }
  }
);
var EntitySchema = Schema3.transform(
  Schema3.Struct({
    hashed_keys: Schema3.Uint8ArrayFromSelf,
    models: Schema3.Array(
      Schema3.Struct({
        name: Schema3.String,
        children: Schema3.Array(MemberSchema)
      })
    )
  }),
  Schema3.Struct({
    hashed_keys: BufferToHex,
    models: Schema3.Record({ key: Schema3.String, value: ModelSchema })
  }),
  {
    decode: (grpc) => {
      const models = {};
      for (const model of grpc.models) {
        models[model.name] = ModelSchema.pipe(Schema3.decodeSync)(
          model.children
        );
      }
      return {
        hashed_keys: BufferToHex.pipe(Schema3.decodeSync)(
          grpc.hashed_keys
        ),
        models
      };
    },
    encode: (torii) => {
      throw new Error("Encoding not implemented for EntitySchema");
    }
  }
);
var EntitiesResponseSchema = Schema3.transform(
  Schema3.Struct({
    entities: Schema3.Array(EntitySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  Schema3.Struct({
    items: Schema3.Array(EntitySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.entities,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      entities: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);

// src/mappings/effect-schema/transformers.ts
function transformTransaction(tx) {
  return Schema4.decodeSync(TransactionSchema)(tx);
}
function transformTransactionsResponse(response) {
  return Schema4.decodeSync(TransactionsResponseSchema)(response);
}
function transformControllersResponse(response) {
  return Schema4.decodeSync(ControllersResponseSchema)(response);
}
function transformToken(token) {
  return Schema4.decodeSync(TokenSchema)(token);
}
function transformTokensResponse(response) {
  return Schema4.decodeSync(TokensResponseSchema)(response);
}
function transformTokenBalance(balance) {
  return Schema4.decodeSync(TokenBalanceSchema)(balance);
}
function transformTokenBalancesResponse(response) {
  return Schema4.decodeSync(TokenBalancesResponseSchema)(response);
}
function transformTokenContractsResponse(response) {
  return Schema4.decodeSync(TokenContractsResponseSchema)(response);
}
function transformEntity(entity) {
  return Schema4.decodeSync(EntitySchema)(entity);
}
function transformEntitiesResponse(response) {
  return Schema4.decodeSync(EntitiesResponseSchema)(response);
}
function transformIndexerUpdate(update) {
  return {
    head: Number(update.head),
    tps: Number(update.tps),
    last_block_timestamp: Number(update.last_block_timestamp),
    contract_address: Schema4.decodeSync(BufferToHex)(
      update.contract_address
    )
  };
}
function transformMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(
      (sig) => Schema4.encodeSync(BufferToHex)(sig)
    )
  };
}
function transformEvent(event) {
  return {
    keys: event.keys.map(
      (key) => Schema4.decodeSync(BufferToHex)(key)
    ),
    data: event.data.map(
      (d) => Schema4.decodeSync(BufferToHex)(d)
    ),
    transaction_hash: Schema4.decodeSync(BufferToHex)(
      event.transaction_hash
    )
  };
}
function transformEventsResponse(response) {
  return {
    items: response.events.map(transformEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function transformContract(contract) {
  return {
    contract_address: Schema4.decodeSync(BufferToHex)(
      contract.contract_address
    ),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? Schema4.decodeSync(BufferToHex)(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function transformContractsResponse(response) {
  return {
    items: response.contracts.map(transformContract)
  };
}
function transformWorldMetadataResponse(response) {
  if (!response.world) {
    return null;
  }
  return {
    world_address: Schema4.decodeSync(BufferToHex)(
      response.world.world_address
    ),
    models: response.world.models.map((model) => ({
      selector: Schema4.decodeSync(BufferToHex)(model.selector),
      namespace: model.namespace,
      name: model.name,
      packed_size: model.packed_size,
      unpacked_size: model.unpacked_size,
      class_hash: Schema4.decodeSync(BufferToHex)(model.class_hash),
      layout: Schema4.decodeSync(BufferToHex)(model.layout),
      schema: Schema4.decodeSync(BufferToHex)(model.schema),
      contract_address: Schema4.decodeSync(BufferToHex)(
        model.contract_address
      ),
      use_legacy_store: model.use_legacy_store
    }))
  };
}

// src/torii-client.ts
import { Schema as Schema5 } from "effect";
function hexToBuffer3(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function bufferToHex2(buffer) {
  return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Subscription = class {
  _subscription;
  constructor(subscription) {
    this._subscription = subscription;
  }
  cancel() {
    this._subscription.cancel();
  }
  free() {
    this._subscription.cancel();
  }
  get id() {
    return this._subscription.id;
  }
};
var ToriiGrpcClient = class {
  client;
  nextSubscriptionId = 1n;
  subscriptions = /* @__PURE__ */ new Map();
  useEffectSchema;
  mappers;
  constructor(config) {
    this.client = new DojoGrpcClient({
      url: config.toriiUrl
    });
    this.useEffectSchema = config.useEffectSchema ?? false;
    this.mappers = this.useEffectSchema ? {
      entitiesResponse: transformEntitiesResponse,
      controllersResponse: transformControllersResponse,
      tokensResponse: transformTokensResponse,
      tokenBalancesResponse: transformTokenBalancesResponse,
      tokenContractsResponse: transformTokenContractsResponse,
      transactionsResponse: transformTransactionsResponse,
      indexerUpdate: transformIndexerUpdate,
      message: transformMessage,
      transaction: transformTransaction,
      entity: transformEntity,
      token: transformToken,
      tokenBalance: transformTokenBalance,
      eventsResponse: transformEventsResponse,
      contractsResponse: transformContractsResponse,
      worldMetadataResponse: transformWorldMetadataResponse,
      event: transformEvent,
      contract: transformContract
    } : {
      entitiesResponse: mapEntitiesResponse,
      controllersResponse: mapControllersResponse,
      tokensResponse: mapTokensResponse,
      tokenBalancesResponse: mapTokenBalancesResponse,
      tokenContractsResponse: mapTokenContractsResponse,
      transactionsResponse: mapTransactionsResponse,
      indexerUpdate: mapIndexerUpdate,
      message: mapMessage,
      transaction: mapTransaction,
      entity: mapEntity,
      token: mapToken,
      tokenBalance: mapTokenBalance,
      eventsResponse: mapEventsResponse,
      contractsResponse: mapContractsResponse,
      worldMetadataResponse: mapWorldMetadataResponse,
      event: mapEvent,
      contract: mapContract
    };
  }
  createStreamSubscription(options) {
    const subscriptionId = this.nextSubscriptionId++;
    const stream = options.createStream();
    const subscription = {
      id: subscriptionId,
      stream,
      cancel: () => {
        this.subscriptions.delete(subscriptionId);
      }
    };
    this.subscriptions.set(subscriptionId, subscription);
    stream.responses.onMessage(options.onMessage);
    if (options.onError) {
      stream.responses.onError(options.onError);
    } else {
      stream.responses.onError((error) => {
        console.error(
          `Stream error (subscription ${subscriptionId}):`,
          error
        );
      });
    }
    if (options.onComplete) {
      stream.responses.onComplete(options.onComplete);
    } else {
      stream.responses.onComplete(() => {
        this.subscriptions.delete(subscriptionId);
      });
    }
    return new Subscription(subscription);
  }
  async getControllers(query) {
    const request = createRetrieveControllersRequest(query);
    const response = await this.client.worldClient.retrieveControllers(request).response;
    return this.mappers.controllersResponse(response);
  }
  async getTransactions(query) {
    const request = createRetrieveTransactionsRequest(query);
    const response = await this.client.worldClient.retrieveTransactions(request).response;
    return this.mappers.transactionsResponse(response);
  }
  async getTokens(query) {
    const request = createRetrieveTokensRequest(query);
    const response = await this.client.worldClient.retrieveTokens(request).response;
    return this.mappers.tokensResponse(response);
  }
  async getTokenBalances(query) {
    const request = createRetrieveTokenBalancesRequest(query);
    const response = await this.client.worldClient.retrieveTokenBalances(request).response;
    return this.mappers.tokenBalancesResponse(response);
  }
  async getTokenContracts(query) {
    const request = createRetrieveTokenContractsRequest(query);
    const response = await this.client.worldClient.retrieveTokenContracts(request).response;
    return this.mappers.tokenContractsResponse(response);
  }
  async getEntities(query) {
    const request = createRetrieveEntitiesRequest(query);
    const response = await this.client.worldClient.retrieveEntities(request).response;
    return this.mappers.entitiesResponse(response);
  }
  async getAllEntities(limit, cursor) {
    const query = {
      pagination: {
        limit,
        cursor: cursor || void 0,
        direction: "Forward",
        order_by: []
      },
      clause: void 0,
      no_hashed_keys: true,
      models: [],
      historical: false
    };
    return this.getEntities(query);
  }
  async getEventMessages(query) {
    const request = createRetrieveEventMessagesRequest(query);
    const response = await this.client.worldClient.retrieveEventMessages(request).response;
    return this.mappers.entitiesResponse(response);
  }
  async onTransaction(filter, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTransactions({
        filter: filter ? mapTransactionFilter(filter) : void 0
      }),
      onMessage: (response) => {
        if (response.transaction) {
          callback(this.mappers.transaction(response.transaction));
        }
      }
    });
  }
  async onTokenUpdated(contract_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokens({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.token) {
          callback(this.mappers.token(response.token));
        }
      }
    });
  }
  async onEntityUpdated(clause, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEntities({
        clause: clause ? mapClause(clause) : void 0
      }),
      onMessage: (response) => {
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateEntitySubscription(subscription, clause) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEntitiesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0
    }).response;
  }
  async onEventMessageUpdated(clause, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEventMessages({
        clause: clause ? mapClause(clause) : void 0
      }),
      onMessage: (response) => {
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateEventMessageSubscription(subscription, clause) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEventMessagesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0
    }).response;
  }
  async onStarknetEvent(clauses, callback) {
    const grpcClauses = clauses.map((clause) => ({
      keys: clause.keys.map(
        (k) => k ? hexToBuffer3(k) : new Uint8Array()
      ),
      pattern_matching: clause.pattern_matching === "FixedLen" ? 0 /* FixedLen */ : 1 /* VariableLen */,
      models: clause.models
    }));
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEvents({
        keys: grpcClauses
      }),
      onMessage: (response) => {
        if (response.event) {
          const hexConverter = this.useEffectSchema ? (buffer) => Schema5.decodeSync(BufferToHex)(buffer) : bufferToHex2;
          callback({
            keys: response.event.keys.map(hexConverter),
            data: response.event.data.map(hexConverter),
            transaction_hash: hexConverter(
              response.event.transaction_hash
            )
          });
        }
      }
    });
  }
  async onTokenBalanceUpdated(contract_addresses, account_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokenBalances({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        account_addresses: account_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.balance) {
          callback(
            this.mappers.tokenBalance(response.balance),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateTokenBalanceSubscription(subscription, contract_addresses, account_addresses, token_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokenBalancesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contract_addresses.map(hexToBuffer3),
      account_addresses: account_addresses.map(hexToBuffer3),
      token_ids: token_ids.map(hexToBuffer3)
    }).response;
  }
  async publishMessage(message) {
    const request = this.mappers.message(message);
    const response = await this.client.worldClient.publishMessage(request).response;
    return this.useEffectSchema ? Schema5.decodeSync(BufferToHex)(response.entity_id) : bufferToHex2(response.entity_id);
  }
  async publishMessageBatch(messages) {
    const request = {
      messages: messages.map(this.mappers.message)
    };
    const response = await this.client.worldClient.publishMessageBatch(request).response;
    const hexConverter = this.useEffectSchema ? (buffer) => Schema5.decodeSync(BufferToHex)(buffer) : bufferToHex2;
    return response.responses.map((r) => hexConverter(r.entity_id));
  }
  async getWorldMetadata() {
    const response = await this.client.worldClient.worldMetadata({}).response;
    return this.mappers.worldMetadataResponse(response);
  }
  async getEvents(query) {
    const request = createRetrieveEventsRequest(query);
    const response = await this.client.worldClient.retrieveEvents(request).response;
    return this.mappers.eventsResponse(response);
  }
  async getContracts(query) {
    const request = createRetrieveContractsRequest(query || {});
    const response = await this.client.worldClient.retrieveContracts(request).response;
    return this.mappers.contractsResponse(response);
  }
  async updateTokensSubscription(subscription, contractAddresses, tokenIds) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokensSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contractAddresses?.map(hexToBuffer3) || [],
      token_ids: tokenIds?.map(hexToBuffer3) || []
    }).response;
  }
  async onContractsUpdated(query, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeContracts({
        query: {
          contract_addresses: query.contract_addresses?.map(hexToBuffer3) || [],
          contract_types: query.contract_types || []
        }
      }),
      onMessage: (response) => {
        if (response.contract) {
          callback(this.mappers.contract(response.contract));
        }
      }
    });
  }
  findSubscription(subscription) {
    return this.subscriptions.get(subscription.id);
  }
  destroy() {
    for (const [_, subscription] of this.subscriptions) {
      subscription.cancel();
    }
    this.subscriptions.clear();
    this.client.destroy();
  }
};
export {
  Array$,
  CallType,
  ComparisonOperator,
  ContractType,
  DojoGrpcClient,
  Enum,
  EnumOption,
  FixedSizeArray,
  LogicalOperator,
  Member,
  OrderDirection,
  PaginationDirection,
  PatternMatching,
  Primitive,
  Struct,
  Subscription,
  ToriiGrpcClient,
  Ty,
  WorldClient,
  World as WorldMessage,
  World2 as WorldService,
  createDojoGrpcClient
};
//# sourceMappingURL=index.js.map