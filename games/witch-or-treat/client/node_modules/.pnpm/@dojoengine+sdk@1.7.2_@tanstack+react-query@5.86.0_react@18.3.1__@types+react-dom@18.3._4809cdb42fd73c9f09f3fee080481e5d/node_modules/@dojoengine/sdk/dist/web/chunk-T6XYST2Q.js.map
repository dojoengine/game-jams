{"version":3,"sources":["../../src/web/index.ts","../../../internal/src/clauseBuilder.ts","../../../internal/src/convertToMemberValue.ts","../../../internal/src/errors.ts","../../../internal/src/generateTypedData.ts","../../../internal/src/merge.ts","../../../internal/src/models.ts","../../../internal/src/pagination.ts","../../../internal/src/parseEntities.ts","../../../internal/src/subscribeQueryModel.ts","../../../internal/src/token.ts","../../../internal/src/toriiQueryBuilder.ts","../../src/createSDK.ts","../../src/initGrpc.ts"],"sourcesContent":["import * as torii from \"@dojoengine/torii-wasm\";\nimport { err, ok, type Result } from \"neverthrow\";\nimport type { Account, Signature, TypedData } from \"starknet\";\nimport {\n    NO_ACCOUNT,\n    type SchemaType,\n    type SDK,\n    type SDKConfig,\n} from \"@dojoengine/internal\";\nimport { createSDK, type GrpcClientInterface } from \"../createSDK.js\";\n\nexport * from \"@dojoengine/internal\";\nexport { initGrpc, type InitGrpcOptions } from \"../initGrpc.js\";\nexport type { GrpcClientInterface } from \"../createSDK.js\";\n\n/**\n * Creates a new Torii client instance.\n *\n * @param {torii.ClientConfig} config - The configuration object for the Torii client.\n * @returns {Promise<torii.ToriiClient>} - A promise that resolves to the Torii client instance.\n */\nexport async function createClient(\n    config: torii.ClientConfig\n): Promise<torii.ToriiClient> {\n    return await new torii.ToriiClient(config);\n}\n\nexport const defaultClientConfig: Partial<torii.ClientConfig> = {\n    toriiUrl: \"http://localhost:8080\",\n};\n\n/**\n * Initializes the SDK for web environment with the provided configuration and schema.\n *\n * @template T - The schema type.\n * @param {SDKConfig} options - The configuration object for the SDK.\n * @returns {Promise<SDK<T>>} - A promise that resolves to the initialized SDK instance.\n *\n * @example\n * ```typescript\n * import { init } from \"@dojoengine/sdk\";\n * import { schema } from \"./models.gen\";\n *\n * const sdk = await init<typeof schema>({\n *     client: {\n *         worldAddress: \"0x...\",\n *         toriiUrl: \"http://localhost:8080\",\n *     },\n *     domain: {\n *         name: \"MyApp\",\n *         version: \"1.0.0\",\n *         chainId: \"SN_MAIN\",\n *     },\n * });\n * ```\n */\nexport async function init<T extends SchemaType>(\n    options: SDKConfig & { grpcClient?: GrpcClientInterface }\n): Promise<SDK<T>> {\n    // Only create torii client if grpcClient is not provided\n    let client: torii.ToriiClient | undefined;\n\n    if (!options.grpcClient) {\n        const clientConfig = {\n            ...defaultClientConfig,\n            ...options.client,\n        } as torii.ClientConfig;\n\n        client = await new torii.ToriiClient(clientConfig);\n    }\n\n    // Web-specific message signing implementation\n    const sendMessage = async (\n        data: TypedData,\n        account?: Account\n    ): Promise<Result<string, string>> => {\n        if (!account) {\n            return err(NO_ACCOUNT);\n        }\n\n        try {\n            // Sign the typed data\n            const signature: Signature = await account.signMessage(data);\n\n            // Stringify typed data for publishing\n            const dataString = JSON.stringify(data);\n\n            // Publish the signed message\n            const publishClient = options.grpcClient || client!;\n            return ok(\n                await publishClient.publishMessage({\n                    message: dataString,\n                    signature: Array.isArray(signature)\n                        ? signature\n                        : [signature.r.toString(), signature.s.toString()],\n                })\n            );\n        } catch (error) {\n            console.error(\"Failed to send message:\", error);\n            throw error;\n        }\n    };\n\n    // Web-specific batch message signing implementation\n    const sendMessageBatch = async (\n        data: TypedData[],\n        account?: Account\n    ): Promise<Result<string[], string>> => {\n        if (!account) {\n            return err(NO_ACCOUNT);\n        }\n\n        try {\n            // Sign all messages and prepare batch\n            const messages = [];\n            for (const typedData of data) {\n                const signature: Signature =\n                    await account.signMessage(typedData);\n                const dataString = JSON.stringify(typedData);\n\n                messages.push({\n                    message: dataString,\n                    signature: Array.isArray(signature)\n                        ? signature\n                        : [signature.r.toString(), signature.s.toString()],\n                });\n            }\n\n            // Publish the batch of signed messages\n            const publishClient = options.grpcClient || client!;\n            return ok(await publishClient.publishMessageBatch(messages));\n        } catch (error) {\n            console.error(\"Failed to send message batch:\", error);\n            throw error;\n        }\n    };\n\n    return createSDK<T>({\n        client,\n        config: options,\n        sendMessage,\n        sendMessageBatch,\n        grpcClient: options.grpcClient,\n    });\n}\n","import type {\n    Clause,\n    ComparisonOperator,\n    MemberValue,\n    PatternMatching,\n} from \"@dojoengine/torii-wasm/node\";\nimport { type BigNumberish, shortString } from \"starknet\";\nimport {\n    convertToPrimitive,\n    type MemberValueParam,\n} from \"./convertToMemberValue\";\nimport type { SchemaType } from \"./types\";\n\ntype ClauseBuilderInterface = {\n    build(): Clause;\n};\n\n// Helper types for nested model structure\ntype ModelPath<T, K extends keyof T> = K extends string\n    ? T[K] extends Record<string, any>\n        ? {\n              [SubK in keyof T[K]]: `${K}-${SubK & string}`;\n          }[keyof T[K]]\n        : never\n    : never;\n\ntype GetModelType<\n    T,\n    Path extends string,\n> = Path extends `${infer Namespace}-${infer Model}`\n    ? Namespace extends keyof T\n        ? Model extends keyof T[Namespace]\n            ? T[Namespace][Model]\n            : never\n        : never\n    : never;\n\n/**\n * Saves some keyboard strokes to get a KeysClause.\n *\n * @param models - the models you want to query, has to be in form of ns-Model\n * @param keys - the keys that has the model. You can use `undefined` as a wildcard to match any key\n * @param pattern - either VariableLen or FixedLen - to check exact match of key number\n * @return ClauseBuilder<T>\n */\nexport function KeysClause<T extends SchemaType>(\n    models: ModelPath<T, keyof T>[],\n    keys: (string | undefined)[],\n    pattern: PatternMatching = \"VariableLen\"\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().keys(models, keys, pattern);\n}\n\n/**\n * Saves some keyboard strokes to get a HashedKeysClause.\n *\n * @param keys - the hashed_keys (entityId) that you want to query over\n * @return ClauseBuilder<T>\n */\nexport function HashedKeysClause<T extends SchemaType>(\n    keys: BigNumberish[]\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().hashed_keys(keys);\n}\n\n/**\n * Saves some keyboard strokes to get a MemberClause.\n *\n * @template T - the schema type\n * @param model - the model you want to query, has to be in form of ns-Model\n * @param member - the member of the model on which you want to apply operator\n * @param operator - the operator to apply\n * @param value - the value to operate on.\n * @return ClauseBuilder<T>\n */\nexport function MemberClause<\n    T extends SchemaType,\n    Path extends ModelPath<T, keyof T>,\n    M extends keyof GetModelType<T, ModelPath<T, keyof T>>,\n>(\n    model: Path,\n    member: M & string,\n    operator: ComparisonOperator,\n    value:\n        | GetModelType<T, Path>[M]\n        | GetModelType<T, Path>[M][]\n        | MemberValueParam\n): ClauseBuilder<T> {\n    return new ClauseBuilder<T>().where(model, member, operator, value);\n}\n\n/**\n * Saves some keyboard strokes to get a Composite \"Or\" Clause\n *\n * @template T - the schema type\n * @param clauses - the inner clauses that you want to compose\n * @return CompositeBuilder<T>\n */\nexport function AndComposeClause<T extends SchemaType>(\n    clauses: ClauseBuilderInterface[]\n): CompositeBuilder<T> {\n    return new ClauseBuilder<T>().compose().and(clauses);\n}\n\n/**\n * Saves some keyboard strokes to get a Composite \"And\" Clause\n * @template T - the schema type\n * @param clauses - the inner clauses that you want to compose\n * @return CompositeBuilder<T>\n */\nexport function OrComposeClause<T extends SchemaType>(\n    clauses: ClauseBuilderInterface[]\n): CompositeBuilder<T> {\n    return new ClauseBuilder<T>().compose().or(clauses);\n}\n\nexport class ClauseBuilder<T extends SchemaType> {\n    private clause: Clause;\n\n    constructor() {\n        // @ts-expect-error It's ok if it's not assignable here.\n        this.clause = {};\n    }\n\n    /**\n     * Create a clause based on entity keys\n     */\n    keys(\n        models: ModelPath<T, keyof T>[],\n        keys: (string | undefined)[],\n        pattern: PatternMatching = \"VariableLen\"\n    ): ClauseBuilder<T> {\n        this.clause = {\n            Keys: {\n                keys: keys.length === 0 ? [undefined] : keys,\n                pattern_matching: pattern,\n                models,\n            },\n        };\n        return this;\n    }\n\n    /**\n     * Create a hashed keys clause based on entity keys\n     * keys: an array of your keys array (no need to hash it, just pass raw keys)\n     */\n    hashed_keys(keys: BigNumberish[]): ClauseBuilder<T> {\n        const hexKeys = keys.map((k, index) => {\n            try {\n                // Convert to BigInt for robust handling of different input types\n                const num = typeof k === \"string\" ? BigInt(k) : BigInt(k);\n                // Convert to hex string with 0x prefix\n                return `0x${num.toString(16)}`;\n            } catch (error) {\n                throw new Error(\n                    `Invalid key value at index ${index}: ${k}. Expected a valid BigNumberish value.`\n                );\n            }\n        });\n\n        this.clause = {\n            HashedKeys: hexKeys,\n        };\n        return this;\n    }\n\n    /**\n     * Create a member clause for comparing values\n     */\n    where<\n        Path extends ModelPath<T, keyof T>,\n        M extends keyof GetModelType<T, Path>,\n    >(\n        model: Path,\n        member: M & string,\n        operator: ComparisonOperator,\n        value:\n            | GetModelType<T, Path>[M]\n            | GetModelType<T, Path>[M][]\n            | MemberValueParam\n    ): ClauseBuilder<T> {\n        const memberValue: MemberValue = Array.isArray(value)\n            ? {\n                  List: value.map((i) =>\n                      convertToPrimitive(i, shortString.encodeShortString)\n                  ),\n              }\n            : convertToPrimitive(value, shortString.encodeShortString);\n\n        this.clause = {\n            Member: {\n                model,\n                member,\n                operator,\n                value: memberValue,\n            },\n        };\n        return this;\n    }\n\n    /**\n     * Start a composite clause chain\n     */\n    compose(): CompositeBuilder<T> {\n        return new CompositeBuilder<T>();\n    }\n    /**\n     * Build the final clause\n     */\n    build(): Clause {\n        if (Object.keys(this.clause).length === 0) {\n            throw new Error(\"You cannot build an empty Clause\");\n        }\n\n        return this.clause;\n    }\n}\n\nclass CompositeBuilder<T extends Record<string, Record<string, any>>> {\n    private orClauses: Clause[] = [];\n    private andClauses: Clause[] = [];\n\n    or(clauses: ClauseBuilderInterface[]): CompositeBuilder<T> {\n        this.orClauses = clauses.map((c) => c.build());\n        return this;\n    }\n\n    and(clauses: ClauseBuilderInterface[]): CompositeBuilder<T> {\n        this.andClauses = clauses.map((c) => c.build());\n        return this;\n    }\n\n    build(): Clause {\n        if (this.orClauses.length === 0 && this.andClauses.length === 0) {\n            throw new Error(\n                \"ComposeClause is empty. Add .or([clause]) or .and([clause])\"\n            );\n        }\n\n        // If we only have OR clauses\n        if (this.orClauses && this.andClauses.length === 0) {\n            return {\n                Composite: {\n                    operator: \"Or\",\n                    clauses: this.orClauses,\n                },\n            };\n        }\n\n        // If we only have AND clauses\n        if (this.andClauses && this.orClauses.length === 0) {\n            return {\n                Composite: {\n                    operator: \"And\",\n                    clauses: this.andClauses,\n                },\n            };\n        }\n\n        // If we have both OR and AND clauses\n        if (this.andClauses && this.orClauses) {\n            return {\n                Composite: {\n                    operator: \"And\",\n                    clauses: [\n                        ...this.andClauses,\n                        {\n                            Composite: {\n                                operator: \"Or\",\n                                clauses: this.orClauses,\n                            },\n                        },\n                    ],\n                },\n            };\n        }\n\n        throw new Error(\"CompositeClause is not properly build\");\n    }\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\n\ntype ToUnion<T> = T extends infer U ? U : never;\ntype ExtractPrimitiveKeys<T> = T extends Record<infer K, any> ? K : never;\ntype PrimitiveTypeKeys = ToUnion<ExtractPrimitiveKeys<torii.Primitive>>;\n\nexport type MemberValueParam = { type: PrimitiveTypeKeys; value: any } | any;\n\n/**\n * Converts a value to a Torii primitive type.\n *\n * @param {MemberValue} value - The value to convert.\n * @returns {torii.MemberValue} - The converted primitive value.\n * @throws {Error} - If the value type is unsupported.\n */\nexport function convertToPrimitive(\n    value: MemberValueParam,\n    shortStringToFelt: typeof torii.cairoShortStringToFelt\n): torii.MemberValue {\n    // if you want to have more control over type passed to torii\n    if (Object.hasOwn(value, \"type\") && Object.hasOwn(value, \"value\")) {\n        return { Primitive: { [value.type]: value.value } as torii.Primitive };\n    }\n\n    if (typeof value === \"number\") {\n        return { Primitive: { U32: value } };\n    }\n\n    if (typeof value === \"boolean\") {\n        return { Primitive: { Bool: value } };\n    }\n\n    if (typeof value === \"bigint\") {\n        return {\n            Primitive: {\n                Felt252: shortStringToFelt(value.toString()),\n            },\n        };\n    }\n\n    if (typeof value === \"string\") {\n        return { String: value };\n    }\n\n    if (Array.isArray(value)) {\n        return {\n            List: value.map((item) =>\n                convertToPrimitive(item, shortStringToFelt)\n            ),\n        };\n    }\n\n    // Add more type conversions as needed\n    throw new Error(`Unsupported primitive type: ${typeof value}`);\n}\n","export const NO_SIGNER = \"No signer configured in sdk.init()\";\nexport const NO_IDENTITY = \"No identity configured in sdk.init()\";\nexport const NO_ACCOUNT = \"Account is undefined\";\n\nexport const UNDEFINED_CLAUSE =\n    \"Clause has not been defined yet. Use `.withClause()` to do so\";\n","import type { StarknetDomain, TypedData } from \"starknet\";\nimport type { SchemaType, UnionOfModelData } from \"./types\";\n\n/**\n * Generates typed data for any user-defined message.\n *\n * @template M - The message type defined by the schema models.\n * @param {string} nsModel - Model name prefixed with namespace joined by a hyphen.\n * @param {M} message - The user-defined message content, must be part of the schema models.\n * @param {StarknetDomain} [domain] - The domain object. If not provided, uses the default domain from options.\n * @returns {TypedData} - The generated typed data.\n */\nexport function generateTypedData<\n    T extends SchemaType,\n    M extends UnionOfModelData<T>,\n>(\n    nsModel: string,\n    message: M,\n    domain: StarknetDomain,\n    modelMapping?: Array<{ name: string; type: string }>,\n    additionnalTypes?: Record<string, Array<{ name: string; type: string }>>\n): TypedData {\n    return {\n        types: {\n            StarknetDomain: [\n                { name: \"name\", type: \"shortstring\" },\n                { name: \"version\", type: \"shortstring\" },\n                { name: \"chainId\", type: \"shortstring\" },\n                { name: \"revision\", type: \"shortstring\" },\n            ],\n            ...additionnalTypes,\n            [nsModel]:\n                undefined !== modelMapping\n                    ? modelMapping\n                    : Object.keys(message).map((key) => ({\n                          name: key,\n                          type:\n                              typeof message[key] === \"bigint\" ||\n                              typeof message[key] === \"number\"\n                                  ? \"felt\"\n                                  : \"string\",\n                      })),\n        },\n        primaryType: nsModel,\n        domain,\n        message,\n    };\n}\n","import { CairoCustomEnum, CairoOption, CairoOptionVariant } from \"starknet\";\nimport type { ParsedEntity, SchemaType } from \"./types\";\n\n/**\n * Check if a value is a CairoOption\n * @param value - The value to check\n * @returns True if the value is a CairoOption, false otherwise\n */\nexport function isCairoOption(value: unknown): value is CairoOption<unknown> {\n    return value instanceof CairoOption;\n}\n\n/**\n * Merge two CairoOption instances\n * @param target - The target CairoOption\n * @param source - The source CairoOption\n * @returns A new CairoOption instance with the merged value\n */\nexport function mergeCairoOption<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    // If source is Some, prefer source's value\n    if (source instanceof CairoOption && source.isSome()) {\n        return new CairoOption(\n            CairoOptionVariant.Some,\n            source.unwrap()\n        ) as unknown as MergedModels<T>;\n    }\n\n    // If source is None or undefined, keep target\n    if (target instanceof CairoOption) {\n        if (target.isSome()) {\n            return new CairoOption(\n                CairoOptionVariant.Some,\n                target.unwrap()\n            ) as unknown as MergedModels<T>;\n        }\n        return new CairoOption(\n            CairoOptionVariant.None\n        ) as unknown as MergedModels<T>;\n    }\n\n    // This should not happen if both are CairoOption instances\n    return target as unknown as MergedModels<T>;\n}\n\n/**\n * Check if a value is a CairoCustomEnum\n * @param value - The value to check\n * @returns True if the value is a CairoCustomEnum, false otherwise\n */\nexport function isCairoCustomEnum(value: unknown): value is CairoCustomEnum {\n    return value instanceof CairoCustomEnum;\n}\n\n/**\n * Merge two CairoCustomEnum instances\n * @param target - The target CairoCustomEnum\n * @param source - The source CairoCustomEnum\n * @returns A new CairoCustomEnum instance with the merged value\n */\nexport function mergeCairoCustomEnum<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    if (!isCairoCustomEnum(target) || !isCairoCustomEnum(source)) {\n        return target;\n    }\n    // If source has an active variant, prefer it\n    const sourceActiveVariant = source.activeVariant();\n    const sourceValue = source.unwrap();\n\n    if (sourceActiveVariant && sourceValue !== undefined) {\n        // Create a new enum with source's active variant\n        const newEnumContent: Record<string, any> = {};\n\n        // Initialize all variants from target with undefined\n        for (const key in target.variant) {\n            newEnumContent[key] = undefined;\n        }\n\n        // Set the active variant from source\n        newEnumContent[sourceActiveVariant] = sourceValue;\n\n        return new CairoCustomEnum(\n            newEnumContent\n        ) as unknown as MergedModels<T>;\n    }\n\n    // If source doesn't have an active variant, keep target\n    const targetActiveVariant = target.activeVariant();\n    const targetValue = target.unwrap();\n\n    if (targetActiveVariant && targetValue !== undefined) {\n        const newEnumContent: Record<string, any> = {};\n\n        // Initialize all variants with undefined\n        for (const key in target.variant) {\n            newEnumContent[key] = undefined;\n        }\n\n        // Set the active variant from target\n        newEnumContent[targetActiveVariant] = targetValue;\n\n        return new CairoCustomEnum(\n            newEnumContent\n        ) as unknown as MergedModels<T>;\n    }\n\n    // Fallback if not both CairoCustomEnum\n    return target;\n}\n\n/**\n * Merged models type\n * @template T - The schema type\n * @returns The merged models type\n */\nexport type MergedModels<T extends SchemaType> =\n    ParsedEntity<T>[\"models\"][keyof ParsedEntity<T>[\"models\"]];\n\nexport function deepMerge<T extends SchemaType>(\n    target: MergedModels<T>,\n    source: Partial<MergedModels<T>>\n): MergedModels<T> {\n    if (isCairoOption(target) && isCairoOption(source)) {\n        return mergeCairoOption(target, source);\n    }\n    if (isCairoCustomEnum(target) && isCairoCustomEnum(source)) {\n        return mergeCairoCustomEnum(target, source);\n    }\n    const result = { ...target } as Record<string, any>;\n    for (const key in source) {\n        if (Object.hasOwn(source, key)) {\n            if (\n                source[key] !== null &&\n                typeof source[key] === \"object\" &&\n                !Array.isArray(source[key])\n            ) {\n                // If the property is an object in both source and target, recursively merge\n                if (\n                    key in target &&\n                    typeof target[key] === \"object\" &&\n                    !Array.isArray(target[key])\n                ) {\n                    result[key] = deepMerge(target[key], source[key]);\n                } else {\n                    // If the key doesn't exist in target or isn't an object, just assign\n                    result[key] = source[key];\n                }\n            } else {\n                // For non-objects (primitives, arrays, null), just assign\n                result[key] = source[key];\n            }\n        }\n    }\n\n    return result;\n}\n","import type { BigNumberish } from \"starknet\";\nimport type { SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function getModelByEntityId<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Schema extends SchemaType,\n>(\n    entityId: BigNumberish,\n    model: `${N}-${M}`,\n    value: StandardizedQueryResult<Schema>\n): SchemaType[N][M] | undefined {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    for (const v of value) {\n        if (v.entityId !== entityId) {\n            continue;\n        }\n        return v.models?.[namespace]?.[modelName] as\n            | SchemaType[N][M]\n            | undefined;\n    }\n}\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function getModel<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Schema extends SchemaType,\n>(\n    model: `${N}-${M}`,\n    value: StandardizedQueryResult<Schema>\n): SchemaType[N][M] | undefined {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    for (const v of value) {\n        return v.models?.[namespace]?.[modelName] as\n            | SchemaType[N][M]\n            | undefined;\n    }\n}\n\n// /**\n//  * Custom hook to retrieve all entities that have a specific model.\n//  *\n//  * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n//  * @returns The model structure if found, otherwise undefined.\n//  */\n// export function getModels<\n//     N extends keyof SchemaType,\n//     M extends keyof SchemaType[N] & string,\n//     Client extends (...args: any) => any,\n//     Schema extends SchemaType,\n// >(model: `${N}-${M}`): { [entityId: string]: SchemaType[N][M] | undefined } {\n//     const [namespace, modelName] = model.split(\"-\") as [N, M];\n//     const { useDojoStore } =\n//         useContext<DojoContextType<Client, Schema>>(DojoContext);\n//\n//     const modelData = useDojoStore((state) =>\n//         state.getEntitiesByModel(namespace, modelName).map((entity) => ({\n//             [entity.entityId]: entity.models?.[namespace]?.[modelName],\n//         }))\n//     ) as unknown as { [entityId: string]: SchemaType[N][M] | undefined };\n//\n//     return modelData;\n// }\n","import type {\n    PaginationDirection,\n    Pagination as ToriiPagination,\n} from \"@dojoengine/torii-wasm/types\";\nimport type { SchemaType, ToriiQueryBuilder } from \"./types\";\n\nconst DEFAULT_LIMIT = 1000;\nexport const defaultToriiPagination: ToriiPagination = {\n    limit: DEFAULT_LIMIT,\n    cursor: undefined,\n    direction: \"Forward\",\n    order_by: [],\n};\n\n/**\n * A generic pagination class that handles cursor-based pagination for query results.\n * This class manages the state of paginated items and provides methods to navigate through pages.\n *\n * @template T - The schema type that extends SchemaType\n * @template Inner - The type of items being paginated (must be an array type)\n */\nexport class Pagination<T extends SchemaType, Inner extends any[]> {\n    private items: Inner;\n\n    /**\n     * Creates a new Pagination instance\n     *\n     * @param limit - The maximum number of items to return per page\n     * @param cursor - Optional cursor string for pagination\n     * @param direction - Optional direction of pagination (defaults to \"Forward\")\n     */\n    constructor(\n        public limit: number,\n        public cursor?: string,\n        public direction?: string\n    ) {\n        this.items = [] as unknown as Inner;\n        if (!direction) {\n            this.direction = \"Forward\";\n        }\n    }\n\n    /**\n     * Creates a Pagination instance from a ToriiQueryBuilder\n     *\n     * @param query - The query builder to extract pagination parameters from\n     * @returns A new Pagination instance configured with the query's pagination settings\n     */\n    static fromQuery<T extends SchemaType, Inner extends any[]>(\n        query: ToriiQueryBuilder<T>,\n        nextCursor?: string\n    ): Pagination<T, Inner> {\n        const pagination = query.getPagination();\n        return new Pagination(\n            pagination.limit ?? DEFAULT_LIMIT,\n            nextCursor,\n            pagination.direction\n        );\n    }\n\n    /**\n     * Sets the items for the current page\n     *\n     * @param items - The items to set for the current page\n     * @returns The Pagination instance for method chaining\n     */\n    withItems(items: Inner) {\n        this.items = items;\n        return this;\n    }\n\n    /**\n     * Gets the current page's items\n     *\n     * @returns The array of items for the current page\n     */\n    getItems(): Inner {\n        return this.items;\n    }\n\n    /**\n     * Gets a query builder configured for the next page\n     *\n     * @param query - The base query builder to configure\n     * @returns A new query builder configured for the next page\n     */\n    getNextQuery(query: ToriiQueryBuilder<T>): ToriiQueryBuilder<T> {\n        const q = query.withLimit(this.limit);\n        if (this.cursor) {\n            q.withCursor(this.cursor);\n        }\n        if (q.getPagination().direction !== this.direction) {\n            q.withDirection(this.direction as PaginationDirection);\n        }\n        return q;\n    }\n\n    /**\n     * Gets a query builder configured for the previous page\n     *\n     * @param query - The base query builder to configure\n     * @returns A new query builder configured for the previous page\n     */\n    getPreviousQuery(query: ToriiQueryBuilder<T>): ToriiQueryBuilder<T> {\n        const q = query.withLimit(this.limit);\n        if (this.cursor) {\n            q.withCursor(this.cursor);\n        }\n        if (q.getPagination().direction === this.direction) {\n            q.withDirection(getReversedDirection(this.direction));\n        }\n\n        return q;\n    }\n}\n\n/**\n * Returns the opposite pagination direction.\n *\n * This utility function takes a pagination direction and returns its opposite:\n * - \"Forward\" becomes \"Backward\"\n * - \"Backward\" becomes \"Forward\"\n * - Any other value defaults to \"Forward\" (though this should not occur with proper typing)\n *\n * @param direction - The current pagination direction\n * @returns The reversed pagination direction\n */\nfunction getReversedDirection(\n    direction: PaginationDirection\n): PaginationDirection {\n    if (direction === \"Forward\") return \"Backward\";\n    if (direction === \"Backward\") return \"Forward\";\n    // we should not go down here.\n    return \"Forward\";\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\nimport {\n    CairoCustomEnum,\n    CairoOption,\n    CairoOptionVariant,\n    addAddressPadding,\n} from \"starknet\";\nimport type {\n    ParsedEntity,\n    SchemaType,\n    StandardizedQueryResult,\n} from \"./types\";\n\nexport function parseEntities<T extends SchemaType>(\n    entities: torii.Entity[],\n    options?: { logging?: boolean }\n): StandardizedQueryResult<T> {\n    // @ts-ignore\n    const result: ParsedEntity<T>[] = [];\n\n    for (const entity of entities) {\n        const entityId = addAddressPadding(entity.hashed_keys);\n        const entityData = entity.models;\n        const parsedEntity: ParsedEntity<T> = {\n            entityId,\n            models: {} as ParsedEntity<T>[\"models\"],\n        };\n\n        for (const modelName in entity.models) {\n            const [schemaKey, modelKey] = modelName.split(\"-\") as [\n                keyof T,\n                string,\n            ];\n\n            if (!schemaKey || !modelKey) {\n                if (options?.logging) {\n                    console.warn(`Invalid modelName format: ${modelName}`);\n                }\n                continue;\n            }\n\n            if (!parsedEntity.models[schemaKey]) {\n                parsedEntity.models[schemaKey] = {} as T[typeof schemaKey];\n            }\n\n            (parsedEntity.models[schemaKey] as any)[modelKey] = parseStruct(\n                entityData[modelName]\n            );\n        }\n\n        result.push(parsedEntity);\n\n        if (options?.logging) {\n            console.log(`Parsed entity:`, parsedEntity);\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"Parsed result:\", result);\n    }\n\n    return Object.values(result);\n}\n\n/**\n * Parses a value based on its type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parseValue(value: torii.Ty): any {\n    switch (value.type) {\n        case \"primitive\":\n            return parsePrimitive(value);\n        case \"struct\":\n            return parseStruct(\n                value.value as Record<string, torii.Ty> | Map<string, torii.Ty>\n            );\n        case \"enum\":\n            // Handling Options\n            if (\"Some\" === (value.value as torii.EnumValue).option) {\n                return new CairoOption(\n                    CairoOptionVariant.Some,\n                    parseValue((value.value as torii.EnumValue).value)\n                );\n            }\n            if (\"None\" === (value.value as torii.EnumValue).option) {\n                return new CairoOption(CairoOptionVariant.None);\n            }\n\n            // Handling simple enum as default case\n            // Handling CairoCustomEnum for more complex types\n            return parseCustomEnum(value);\n        case \"tuple\":\n        case \"array\":\n            return (value.value as torii.Ty[]).map(parseValue);\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a value identified as enum either returns a single string matching enum value\n * or CairoCustomEnum matching more complex cairo types\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {CairoCustomEnum | string} - The parsed value.\n */\nfunction parseCustomEnum(value: torii.Ty): CairoCustomEnum | string {\n    // enum is a simple enum\n    if ((value.value as torii.EnumValue).value.type === \"tuple\") {\n        // we keep retrocompatibility\n        return (value.value as torii.EnumValue).option;\n    }\n\n    return new CairoCustomEnum({\n        [(value.value as torii.EnumValue).option]: parseValue(\n            (value.value as torii.EnumValue).value\n        ),\n    });\n}\n\n/**\n * Parses a value based on its primitive type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parsePrimitive(value: torii.Ty): any {\n    switch (value.type_name) {\n        case \"u64\":\n        case \"i64\":\n            return Number(value.value as string);\n        case \"u128\":\n        case \"i128\":\n            return BigInt(value.value as string);\n        case \"u256\":\n            return BigInt(value.value as string);\n        case \"u8\":\n        case \"u16\":\n        case \"u32\":\n        case \"i8\":\n        case \"i16\":\n        case \"i32\":\n        case \"bool\":\n        case \"ContractAddress\":\n        case \"ClassHash\":\n        case \"felt252\":\n        case \"EthAddress\":\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a struct (record or map) into an object with parsed values.\n *\n * @param {Record<string, torii.Ty> | Map<string, torii.Ty>} struct - The struct to parse.\n * @returns {any} - The parsed struct as an object.\n */\nfunction parseStruct(\n    struct: Record<string, torii.Ty> | Map<string, torii.Ty>\n): any {\n    const entries =\n        struct instanceof Map\n            ? Array.from(struct.entries())\n            : Object.entries(struct);\n    return Object.fromEntries(\n        entries.map(([key, value]) => [key, parseValue(value)])\n    );\n}\n","import type { Entity } from \"@dojoengine/torii-wasm/types\";\nimport { parseEntities } from \"./parseEntities\";\nimport type {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionCallback,\n} from \"./types\";\n\n/**\n * Creates a callback function for entity subscription that processes entity data and invokes the provided callback.\n * This function is used to standardize entity data handling in subscription callbacks.\n *\n * @template T - The schema type that defines the structure of the entity data\n * @param {SubscriptionCallback<StandardizedQueryResult<T>>} callback - The callback function to be invoked with parsed entity data or error\n * @returns {Function} A function that accepts a hashed key and entity data, parses the entity data, and invokes the provided callback\n */\nexport function subscribeQueryModelCallback<T extends SchemaType>(\n    callback: SubscriptionCallback<StandardizedQueryResult<T>>\n) {\n    return (entityData: Entity) => {\n        try {\n            if (callback) {\n                const parsedData = parseEntities<T>([entityData]);\n\n                callback({\n                    data: parsedData,\n                    error: undefined,\n                });\n            }\n        } catch (error) {\n            if (callback) {\n                callback({\n                    data: undefined,\n                    error:\n                        error instanceof Error\n                            ? error\n                            : new Error(String(error)),\n                });\n            }\n        }\n    };\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\nimport { addAddressPadding } from \"starknet\";\nimport { defaultToriiPagination } from \"./pagination\";\nimport type {\n    AttributesFilter,\n    GetTokenBalanceRequest,\n    GetTokenContracts,\n    GetTokenRequest,\n    SubscribeTokenBalanceRequest,\n    SubscribeTokenRequest,\n    SubscriptionCallback,\n    UpdateTokenBalanceSubscriptionRequest,\n} from \"./types\";\n\ntype Strict<T> = {\n    [K in keyof T]-?: NonNullable<T[K]>;\n};\n\n/**\n * Creates a safe callback wrapper that handles errors\n * @param callback - The user-provided callback\n * @param defaultValue - Default value to check against\n * @returns Wrapped callback that handles try/catch\n */\nexport function safeCallback<T>(\n    callback: SubscriptionCallback<T>,\n    defaultValue: T\n): (res: T) => void {\n    return (res: T) => {\n        if (res === defaultValue) {\n            return;\n        }\n        try {\n            callback({\n                data: res,\n                error: undefined,\n            });\n        } catch (error) {\n            callback({\n                data: undefined,\n                error: error as Error,\n            });\n        }\n    };\n}\n\nexport const defaultTokenBalance: torii.TokenBalance = {\n    balance:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    account_address: \"0x0\",\n    contract_address: \"0x0\",\n    token_id:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n};\n\nexport function parseTokenRequest<\n    T extends GetTokenRequest & GetTokenBalanceRequest & GetTokenContracts,\n>(req: T): Strict<T> {\n    if (req.contractAddresses) {\n        req.contractAddresses = req.contractAddresses.map((r) =>\n            addAddressPadding(r)\n        );\n    }\n\n    if (req.accountAddresses) {\n        req.accountAddresses = req.accountAddresses.map((r) =>\n            addAddressPadding(r)\n        );\n    }\n\n    return {\n        contractAddresses: req.contractAddresses ?? [],\n        accountAddresses: req.accountAddresses ?? [],\n        attributesFilter: req.attributesFilter ?? [],\n        contractTypes: req.contractTypes ?? [],\n        tokenIds: req.tokenIds ?? [],\n        pagination: req.pagination ?? defaultToriiPagination,\n    } as Strict<T>;\n}\nfunction toAttributesFilter(\n    attributes: AttributesFilter[]\n): torii.AttributeFilter[] {\n    return attributes.map((a) => ({\n        trait_name: a.name,\n        trait_value: a.value,\n    }));\n}\n/**\n * @param {GetTokenRequest} request\n * @returns {Promise<torii.Tokens>}\n */\nexport async function getTokens(\n    client: torii.ToriiClient,\n    request: GetTokenRequest\n): Promise<torii.Tokens> {\n    const { contractAddresses, tokenIds, pagination, attributesFilter } =\n        parseTokenRequest(request);\n    return await client.getTokens({\n        contract_addresses: contractAddresses,\n        token_ids: tokenIds,\n        attribute_filters: toAttributesFilter(attributesFilter),\n        pagination,\n    });\n}\n/**\n * @param {GetTokenContracts} request\n * @returns {Promise<torii.Tokens>}\n */\nexport async function getTokenContracts(\n    client: torii.ToriiClient,\n    request: GetTokenContracts\n): Promise<torii.TokenContracts> {\n    const { contractAddresses, contractTypes, pagination } =\n        parseTokenRequest(request);\n    return await client.getTokenContracts({\n        contract_addresses: contractAddresses,\n        contract_types: contractTypes as torii.ContractType[],\n        pagination,\n    });\n}\n\n/**\n * @param {GetTokenBalanceRequest} request\n * @returns {Promise<torii.TokenBalances>}\n */\nexport async function getTokenBalances(\n    client: torii.ToriiClient,\n    request: GetTokenBalanceRequest\n): Promise<torii.TokenBalances> {\n    const { contractAddresses, accountAddresses, tokenIds, pagination } =\n        parseTokenRequest(request);\n    return await client.getTokenBalances({\n        contract_addresses: contractAddresses,\n        account_addresses: accountAddresses,\n        token_ids: tokenIds,\n        pagination,\n    });\n}\n\n/**\n * Subscribes to token balance updates\n *\n * # Parameters\n * @param {SubscribeTokenBalanceRequest} request\n *\n * # Returns\n * Result containing subscription handle or error\n * @returns torii.Subscription\n */\nexport async function onTokenBalanceUpdated(\n    client: torii.ToriiClient,\n    request: SubscribeTokenBalanceRequest\n): Promise<torii.Subscription> {\n    const { contractAddresses, accountAddresses, tokenIds } =\n        parseTokenRequest(request);\n    return await client.onTokenBalanceUpdated(\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(request.callback, defaultTokenBalance)\n    );\n}\n\n/**\n * Updates an existing token balance subscription\n *\n * # Parameters\n * @param {torii.Subscription} subscription - Existing subscription to update\n * @param {UpdateTokenBalanceSubscriptionRequest} request\n *\n * # Returns\n * Result containing unit or error\n * @returns {Promise<void>}\n */\nexport async function updateTokenBalanceSubscription(\n    client: torii.ToriiClient,\n    request: UpdateTokenBalanceSubscriptionRequest\n): Promise<void> {\n    const { subscription, contractAddresses, accountAddresses, tokenIds } =\n        request;\n    return await client.updateTokenBalanceSubscription(\n        subscription,\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? []\n    );\n}\n/**\n * Subscribes to token balance updates and returns initial data with subscription\n *\n * # Parameters\n * @param {SubscribeTokenBalanceRequest} request - Request parameters\n *\n * # Returns\n * Array containing initial token balances and subscription handle\n * @returns {Promise<[torii.TokenBalances, torii.Subscription]>}\n */\nexport async function subscribeTokenBalance(\n    client: torii.ToriiClient,\n    request: SubscribeTokenBalanceRequest\n): Promise<[torii.TokenBalances, torii.Subscription]> {\n    const { contractAddresses, accountAddresses, tokenIds, callback } = request;\n\n    // Get initial token balances\n    const initialBalances = await getTokenBalances(client, {\n        contractAddresses: contractAddresses ?? [],\n        accountAddresses: accountAddresses ?? [],\n        tokenIds: tokenIds ?? [],\n    });\n\n    // Create subscription for updates\n    const subscription = await client.onTokenBalanceUpdated(\n        contractAddresses ?? [],\n        accountAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultTokenBalance)\n    );\n\n    return [initialBalances, subscription];\n}\n\nexport const defaultToken: torii.Token = {\n    contract_address: \"0x0\",\n    token_id:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    name: \"\",\n    symbol: \"\",\n    decimals: 0,\n    metadata: \"\",\n    total_supply: \"\",\n};\n\n/**\n * Subscribes to token updates\n *\n * # Parameters\n * @param {SubscribeTokenRequest} request\n *\n * # Returns\n * Result containing subscription handle or error\n * @returns torii.Subscription\n */\nexport async function onTokenUpdated(\n    client: torii.ToriiClient,\n    request: SubscribeTokenRequest\n): Promise<torii.Subscription> {\n    const { contractAddresses, tokenIds, callback } =\n        parseTokenRequest(request);\n    return await client.onTokenUpdated(\n        contractAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultToken)\n    );\n}\n\n/**\n * Subscribes to token updates and returns initial data with subscription\n *\n * # Parameters\n * @param {SubscribeTokenRequest} request - Request parameters\n *\n * # Returns\n * Array containing initial tokens and subscription handle\n * @returns {Promise<[torii.Tokens, torii.Subscription]>}\n */\nexport async function subscribeToken(\n    client: torii.ToriiClient,\n    request: SubscribeTokenRequest\n): Promise<[torii.Tokens, torii.Subscription]> {\n    const { contractAddresses, tokenIds, callback } = request;\n\n    // Get initial tokens\n    const initialTokens = await getTokens(client, {\n        contractAddresses: contractAddresses ?? [],\n        tokenIds: tokenIds ?? [],\n    });\n\n    // Create subscription for updates\n    const subscription = await client.onTokenUpdated(\n        contractAddresses ?? [],\n        tokenIds ?? [],\n        safeCallback(callback, defaultToken)\n    );\n\n    return [initialTokens, subscription];\n}\n","import type { Pagination } from \"@dojoengine/torii-wasm\";\nimport type {\n    Clause,\n    OrderBy,\n    PaginationDirection,\n    Query,\n} from \"@dojoengine/torii-wasm/types\";\nimport { err, ok, type Result } from \"neverthrow\";\nimport { UNDEFINED_CLAUSE } from \"./errors\";\nimport type { SchemaType } from \"./types\";\n\nconst defaultToriiOptions = () => ({\n    pagination: {\n        limit: 100,\n        cursor: undefined,\n        direction: \"Forward\",\n        order_by: [],\n    },\n    clause: undefined,\n    no_hashed_keys: true,\n    models: [],\n    historical: false,\n});\n\ntype ToriiQueryBuilderOptions = Omit<Partial<Query>, \"clause\">;\n\nexport class ToriiQueryBuilder<T extends SchemaType> {\n    private query: Query;\n\n    constructor(options?: ToriiQueryBuilderOptions) {\n        this.query = { ...(defaultToriiOptions() as Query), ...options };\n    }\n\n    /**\n     * Set the maximum number of results to return\n     */\n    withLimit(limit: number): ToriiQueryBuilder<T> {\n        this.query.pagination.limit = limit;\n        return this;\n    }\n\n    /**\n     * Set the offset for pagination\n     * @deprecated Use `withCursor` instead\n     */\n    withOffset(): ToriiQueryBuilder<T> {\n        return this;\n    }\n\n    /**\n     * Set the cursor for pagination\n     * undefined is default, fetch from starting point\n     * `next_cursor` is return from queries\n     */\n    withCursor(cursor: string): ToriiQueryBuilder<T> {\n        this.query.pagination.cursor = cursor;\n        return this;\n    }\n\n    /**\n     * Set the maximum number of results to return\n     */\n    withDirection(direction: PaginationDirection): ToriiQueryBuilder<T> {\n        this.query.pagination.direction = direction;\n        return this;\n    }\n\n    /**\n     * Add the clause to filter results\n     */\n    withClause(clause: Clause): ToriiQueryBuilder<T> {\n        this.query.clause = clause;\n        return this;\n    }\n\n    /**\n     * Set whether to include hashed keys in the response\n     * HashedKeys represent internal torii entity id.\n     */\n    includeHashedKeys(): ToriiQueryBuilder<T> {\n        this.query.no_hashed_keys = false;\n        return this;\n    }\n\n    /**\n     * Add a single order by clause\n     */\n    addOrderBy(\n        member: string,\n        direction: \"Asc\" | \"Desc\"\n    ): ToriiQueryBuilder<T> {\n        this.query.pagination.order_by.push({\n            field: member,\n            direction,\n        });\n        return this;\n    }\n\n    /**\n     * Add multiple order by clauses at once\n     */\n    withOrderBy(orderBy: OrderBy[]): ToriiQueryBuilder<T> {\n        this.query.pagination.order_by = orderBy;\n        return this;\n    }\n\n    /**\n     * Add a single entity model to filter\n     */\n    addEntityModel(model: keyof T & string): ToriiQueryBuilder<T> {\n        this.query.models.push(model);\n        return this;\n    }\n\n    /**\n     * Set multiple entity models at once\n     */\n    withEntityModels(models: (keyof T & string)[]): ToriiQueryBuilder<T> {\n        this.query.models = models;\n        return this;\n    }\n\n    /**\n     * Build the final query\n     */\n    build(): Query {\n        return this.query;\n    }\n\n    /**\n     * Create a new builder instance with pagination settings\n     *\n     */\n    static withPagination<T extends Record<string, Record<string, any>>>(\n        cursor: string,\n        limit: number,\n        direction: PaginationDirection\n    ): ToriiQueryBuilder<T> {\n        return new ToriiQueryBuilder<T>()\n            .withLimit(limit)\n            .withCursor(cursor)\n            .withDirection(direction);\n    }\n\n    /**\n     * Returns inner clause inside a Result wrapper.\n     */\n    getClause(): Result<Clause, string> {\n        if (!this.query.clause) {\n            return err(UNDEFINED_CLAUSE);\n        }\n        return ok(this.query.clause);\n    }\n\n    getPagination(): Pagination {\n        return this.query.pagination;\n    }\n\n    /**\n     * Check is query is historical\n     */\n    isHistorical(): boolean {\n        return this.query.historical;\n    }\n}\n\nexport type HistoricalToriiQueryBuilderOptions = Omit<\n    Partial<ToriiQueryBuilderOptions>,\n    \"historical\"\n>;\nexport class HistoricalToriiQueryBuilder<\n    T extends SchemaType,\n> extends ToriiQueryBuilder<T> {\n    constructor(options?: ToriiQueryBuilderOptions) {\n        super({\n            ...(defaultToriiOptions() as Query),\n            ...options,\n            historical: true,\n        });\n    }\n}\n","import type * as torii from \"@dojoengine/torii-wasm/types\";\nimport { ok, type Result } from \"neverthrow\";\nimport type { Account, TypedData } from \"starknet\";\nimport {\n    subscribeQueryModelCallback,\n    generateTypedData,\n    defaultToriiPagination,\n    Pagination,\n    parseEntities,\n    defaultTokenBalance,\n    getTokenBalances,\n    getTokens,\n    parseTokenRequest,\n    safeCallback,\n    subscribeToken,\n    subscribeTokenBalance,\n    updateTokenBalanceSubscription,\n    defaultToken,\n    getTokenContracts,\n} from \"@dojoengine/internal\";\nimport type {\n    GetParams,\n    GetTokenBalanceRequest,\n    GetTokenRequest,\n    GetTokenContracts,\n    SchemaType,\n    SDK,\n    SDKConfig,\n    SubscribeParams,\n    SubscribeResponse,\n    SubscribeTokenBalanceRequest,\n    SubscribeTokenRequest,\n    ToriiResponse,\n    UnionOfModelData,\n    UpdateTokenBalanceSubscriptionRequest,\n} from \"@dojoengine/internal\";\nimport { ToriiGrpcClient } from \"@dojoengine/grpc\";\n\nexport interface GrpcClientInterface {\n    // Entity operations\n    getEntities(query: torii.Query): Promise<torii.Entities>;\n    onEntityUpdated(\n        clause: torii.Clause | undefined,\n        callback: (entityData: torii.Entity) => void\n    ): Promise<torii.Subscription>;\n    updateEntitySubscription(\n        subscription: torii.Subscription,\n        clauses: torii.Clause\n    ): Promise<void>;\n\n    // Event operations\n    getEventMessages(query: torii.Query): Promise<torii.Entities>;\n    onEventMessageUpdated(\n        clause: torii.Clause | undefined,\n        callback: (entityData: torii.Entity) => void\n    ): Promise<torii.Subscription>;\n    updateEventMessageSubscription(\n        subscription: torii.Subscription,\n        clauses: torii.Clause\n    ): Promise<void>;\n\n    // Token operations\n    getTokens(params: {\n        contract_addresses?: string[];\n        token_ids?: any[];\n        pagination?: torii.Pagination;\n    }): Promise<torii.Tokens>;\n    // Token operations\n    getTokenContracts(params: {\n        contract_addresses?: string[];\n        contract_types?: torii.ContractType[];\n        pagination?: torii.Pagination;\n    }): Promise<torii.TokenContracts>;\n    getTokenBalances(params: {\n        contract_addresses?: string[];\n        account_addresses?: string[];\n        token_ids?: any[];\n        pagination?: torii.Pagination;\n    }): Promise<torii.TokenBalances>;\n    onTokenBalanceUpdated(\n        contractAddresses: string[],\n        accountAddresses: string[],\n        tokenIds: any[],\n        callback: (res: torii.TokenBalance) => void\n    ): Promise<torii.Subscription>;\n    onTokenUpdated(\n        contractAddresses: string[],\n        tokenIds: any[],\n        callback: (res: torii.Token) => void\n    ): Promise<torii.Subscription>;\n    updateTokenBalanceSubscription(\n        subscription: torii.Subscription,\n        contract_addresses: string[],\n        account_addresses: string[],\n        token_ids: any[]\n    ): Promise<void>;\n\n    // Message operations\n    publishMessage(message: torii.Message): Promise<string>;\n    publishMessageBatch(messages: torii.Message[]): Promise<string[]>;\n\n    // Controller operations\n    getControllers(params: {\n        contract_addresses?: string[];\n        usernames?: string[];\n        pagination?: torii.Pagination;\n    }): Promise<torii.Controllers>;\n}\n\nexport interface CreateSDKOptions {\n    client?: torii.ToriiClient;\n    config: SDKConfig;\n    sendMessage: (\n        data: TypedData,\n        account?: Account\n    ) => Promise<Result<string, string>>;\n    sendMessageBatch: (\n        data: TypedData[],\n        account?: Account\n    ) => Promise<Result<string[], string>>;\n    grpcClient?: GrpcClientInterface;\n}\n\n/**\n * Creates an SDK instance with the provided client and configuration.\n * This is the shared implementation used by both node and web versions.\n */\nexport function createSDK<T extends SchemaType>({\n    client,\n    config,\n    sendMessage,\n    sendMessageBatch,\n    grpcClient,\n}: CreateSDKOptions): SDK<T> {\n    // Use provided grpcClient or create default setup\n    const sdkClient = grpcClient ?? client;\n    if (!sdkClient) {\n        throw new Error(\"Either client or grpcClient must be provided\");\n    }\n\n    // Only create ToriiGrpcClient if no grpcClient was provided\n    const grpcClientInstance =\n        grpcClient ??\n        new ToriiGrpcClient({\n            toriiUrl: config.client.toriiUrl ?? \"http://localhost:8080\",\n            worldAddress: config.client.worldAddress,\n        });\n    return {\n        client: client!,\n\n        /**\n         * Subscribes to entity queries.\n         *\n         * @param {SubscribeParams<T>} params - Parameters object\n         * @returns {Promise<SubscribeResponse<T>>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEntityQuery: async ({ query, callback }) => {\n            const q = query.build();\n\n            const entities = await sdkClient.getEntities(q);\n\n            const parsedEntities = parseEntities<T>(entities.items);\n            return [\n                Pagination.fromQuery(query, entities.next_cursor).withItems(\n                    parsedEntities\n                ),\n                await sdkClient.onEntityUpdated(\n                    q.clause,\n                    subscribeQueryModelCallback(callback)\n                ),\n            ];\n        },\n\n        /**\n         * Subscribes to event queries.\n         *\n         * @param {SubscribeParams<T>} params - Parameters object\n         * @returns {Promise<SubscribeResponse<T>>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEventQuery: async ({\n            query,\n            callback,\n        }: SubscribeParams<T>): Promise<SubscribeResponse<T>> => {\n            const q = query.build();\n\n            const entities = await grpcClientInstance.getEventMessages(q);\n            const parsedEntities = parseEntities<T>(entities.items);\n            return [\n                Pagination.fromQuery(query, entities.next_cursor).withItems(\n                    parsedEntities\n                ),\n                await grpcClientInstance.onEventMessageUpdated(\n                    q.clause,\n                    subscribeQueryModelCallback(callback)\n                ),\n            ];\n        },\n\n        /**\n         * Subscribes to token balance updates\n         *\n         * @param {SubscribeTokenBalanceRequest} request\n         * @returns {Promise<[torii.TokenBalances, torii.Subscription]>}\n         */\n        subscribeTokenBalance: async (\n            request: SubscribeTokenBalanceRequest\n        ): Promise<[torii.TokenBalances, torii.Subscription]> => {\n            if (grpcClient) {\n                const {\n                    contractAddresses,\n                    accountAddresses,\n                    tokenIds,\n                    pagination,\n                } = parseTokenRequest(request);\n                const balances = await grpcClient.getTokenBalances({\n                    contract_addresses: contractAddresses,\n                    account_addresses: accountAddresses,\n                    token_ids: tokenIds,\n                    pagination,\n                });\n                const subscription = await grpcClient.onTokenBalanceUpdated(\n                    contractAddresses ?? [],\n                    accountAddresses ?? [],\n                    tokenIds ?? [],\n                    safeCallback(request.callback, defaultTokenBalance)\n                );\n                return [balances, subscription];\n            }\n            return await subscribeTokenBalance(client!, request);\n        },\n\n        /**\n         * Fetches entities based on the provided query.\n         *\n         * @param {GetParams<T>} params - Parameters object\n         * @returns {Promise<ToriiResponse<T>>} - A promise that resolves to the standardized query result.\n         */\n        getEntities: async ({ query }) => {\n            const q = query.build();\n\n            const entities = await sdkClient.getEntities(q);\n\n            return Pagination.fromQuery(query, entities.next_cursor).withItems(\n                parseEntities(entities.items)\n            );\n        },\n\n        /**\n         * Fetches event messages based on the provided query.\n         *\n         * @param {GetParams<T>} params - Parameters object\n         * @returns {Promise<ToriiResponse<T>} - A promise that resolves to the standardized query result.\n         */\n        getEventMessages: async ({\n            query,\n        }: GetParams<T>): Promise<ToriiResponse<T>> => {\n            const q = query.build();\n\n            const entities = await sdkClient.getEventMessages(q);\n\n            return Pagination.fromQuery(query, entities.next_cursor).withItems(\n                parseEntities(entities.items)\n            );\n        },\n\n        /**\n         * Generates typed data for any user-defined message.\n         *\n         * @template M - The message type defined by the schema models.\n         * @param {string} nsModel - Model name prefixed with namespace joined by a hyphen.\n         * @param {M} message - The user-defined message content, must be part of the schema models.\n         * @param {Array<{ name: string; type: string }>} modelMapping - Optional model mapping for custom types.\n         * @param {Record<string, Array<{ name: string; type: string }>>} additionalTypes - Optional additional types.\n         * @returns {TypedData} - The generated typed data.\n         */\n        generateTypedData: <M extends UnionOfModelData<T>>(\n            nsModel: string,\n            message: M,\n            modelMapping?: Array<{ name: string; type: string }>,\n            additionalTypes?: Record<\n                string,\n                Array<{ name: string; type: string }>\n            >\n        ): TypedData =>\n            generateTypedData(\n                nsModel,\n                message,\n                config.domain,\n                modelMapping,\n                additionalTypes\n            ),\n\n        /**\n         * Sends a signed message.\n         *\n         * @param {TypedData} data - The typed data to be signed and sent.\n         * @param {Account} account - The account used to sign the message.\n         * @returns {Promise<Result<Uint8Array, string>>} - A promise that resolves when the message is sent successfully.\n         */\n        sendMessage,\n\n        /**\n         * Sends multiple signed messages in a batch.\n         *\n         * @param {TypedData[]} data - Array of typed data to be signed and sent.\n         * @param {Account} account - The account used to sign the messages.\n         * @returns {Promise<Result<string[], string>>} - A promise that resolves when all messages are sent successfully.\n         */\n        sendMessageBatch,\n\n        /**\n         * Sends already signed messages to the Torii server in a batch.\n         * This method allows you to send pre-signed messages directly without signing them again.\n         *\n         * @param {torii.Message[]} data - Array of signed messages with message content and signatures\n         * @returns {Promise<Result<string[], string>>} - A promise that resolves when all messages are sent successfully.\n         */\n        sendSignedMessageBatch: async (\n            data: torii.Message[]\n        ): Promise<Result<string[], string>> => {\n            try {\n                // Publish the batch of already signed messages\n                return ok(await sdkClient.publishMessageBatch(data));\n            } catch (error) {\n                console.error(\"Failed to send signed message batch:\", error);\n                throw error;\n            }\n        },\n\n        /**\n         * Gets tokens based on the provided request.\n         *\n         * @param {GetTokenRequest} request\n         * @returns {Promise<torii.Tokens>}\n         */\n        getTokens: async (request: GetTokenRequest): Promise<torii.Tokens> => {\n            if (grpcClient) {\n                const { contractAddresses, tokenIds, pagination } =\n                    parseTokenRequest(request);\n                return await grpcClient.getTokens({\n                    contract_addresses: contractAddresses,\n                    token_ids: tokenIds,\n                    pagination,\n                });\n            }\n            return await getTokens(client!, request);\n        },\n\n        /**\n         * Gets tokens based on the provided request.\n         *\n         * @param {GetTokenContracts} request\n         * @returns {Promise<torii.Tokens>}\n         */\n        getTokenContracts: async (\n            request: GetTokenContracts\n        ): Promise<torii.TokenContracts> => {\n            if (grpcClient) {\n                const { contractAddresses, contractTypes, pagination } =\n                    parseTokenRequest(request);\n                return await grpcClient.getTokenContracts({\n                    contract_addresses: contractAddresses,\n                    contract_types: contractTypes as torii.ContractType[],\n                    pagination,\n                });\n            }\n            return await getTokenContracts(client!, request);\n        },\n\n        /**\n         * Gets token balances based on the provided request.\n         *\n         * @param {GetTokenBalanceRequest} request\n         * @returns {Promise<torii.TokenBalances>}\n         */\n        getTokenBalances: async (\n            request: GetTokenBalanceRequest\n        ): Promise<torii.TokenBalances> => {\n            if (grpcClient) {\n                const {\n                    contractAddresses,\n                    accountAddresses,\n                    tokenIds,\n                    pagination,\n                } = parseTokenRequest(request);\n                return await grpcClient.getTokenBalances({\n                    contract_addresses: contractAddresses,\n                    account_addresses: accountAddresses,\n                    token_ids: tokenIds,\n                    pagination,\n                });\n            }\n            return await getTokenBalances(client!, request);\n        },\n\n        /**\n         * Subscribes to token balance updates\n         *\n         * @param {SubscribeTokenBalanceRequest} request\n         * @returns {torii.Subscription}\n         */\n        onTokenBalanceUpdated: async (\n            request: SubscribeTokenBalanceRequest\n        ): Promise<torii.Subscription> => {\n            const { contractAddresses, accountAddresses, tokenIds } =\n                parseTokenRequest(request);\n            return await grpcClientInstance.onTokenBalanceUpdated(\n                contractAddresses ?? [],\n                accountAddresses ?? [],\n                tokenIds ?? [],\n                safeCallback(request.callback, defaultTokenBalance)\n            );\n        },\n\n        /**\n         * Subscribes to token updates\n         *\n         * # Parameters\n         * @param {SubscribeTokenRequest} request\n         * @param {Function} callback - JavaScript function to call on updates\n         *\n         * # Returns\n         * Result containing subscription handle or error\n         * @returns torii.Subscription\n         */\n        onTokenUpdated: async (\n            request: SubscribeTokenRequest\n        ): Promise<torii.Subscription> => {\n            const { contractAddresses, tokenIds } = parseTokenRequest(request);\n            return await grpcClientInstance.onTokenUpdated(\n                contractAddresses ?? [],\n                tokenIds ?? [],\n                safeCallback(request.callback, defaultToken)\n            );\n        },\n\n        /**\n         * Updates an existing token balance subscription\n         *\n         * @param {UpdateTokenBalanceSubscriptionRequest} request\n         * @returns {Promise<void>}\n         */\n        updateTokenBalanceSubscription: async (\n            request: UpdateTokenBalanceSubscriptionRequest\n        ): Promise<void> => {\n            if (grpcClient) {\n                const { contractAddresses, accountAddresses, tokenIds } =\n                    parseTokenRequest(request);\n                return await grpcClient.updateTokenBalanceSubscription(\n                    request.subscription,\n                    contractAddresses ?? [],\n                    accountAddresses ?? [],\n                    tokenIds ?? []\n                );\n            }\n            return await updateTokenBalanceSubscription(client!, request);\n        },\n\n        /**\n         * Updates an existing entity subscription\n         *\n         * @param {torii.Subscription} subscription - Existing subscription to update\n         * @param {torii.Clause} clauses - New clauses for filtering\n         * @returns {Promise<void>}\n         */\n        updateEntitySubscription: async (\n            subscription: torii.Subscription,\n            clauses: torii.Clause\n        ): Promise<void> => {\n            return await sdkClient.updateEntitySubscription(\n                subscription,\n                clauses\n            );\n        },\n\n        /**\n         * Updates an existing event message subscription\n         *\n         * @param {torii.Subscription} subscription - Existing subscription to update\n         * @param {torii.Clause} clauses - New clauses for filtering\n         * @returns {Promise<void>}\n         */\n        updateEventMessageSubscription: async (\n            subscription: torii.Subscription,\n            clauses: torii.Clause,\n            _historical: boolean\n        ): Promise<void> => {\n            return await grpcClientInstance.updateEventMessageSubscription(\n                subscription,\n                clauses\n            );\n        },\n\n        /**\n         * Gets controllers along with their usernames for the given contract addresses\n         *\n         * @param {string[]} contract_addresses - Array of contract addresses as hex strings. If empty, all\n         *   controllers will be returned.\n         * @returns {Promise<torii.Controllers>}\n         */\n        getControllers: async (\n            contract_addresses: string[],\n            usernames: string[],\n            pagination: torii.Pagination = defaultToriiPagination\n        ): Promise<torii.Controllers> => {\n            return await sdkClient.getControllers({\n                contract_addresses,\n                usernames,\n                pagination,\n            });\n        },\n\n        /**\n         * Subscribes to token updates\n         *\n         * # Parameters\n         * @param {SubscribeTokenRequest} request\n         * @returns {Promise<[torii.Tokens, torii.Subscription]>}\n         */\n        subscribeToken: async (\n            request: SubscribeTokenRequest\n        ): Promise<[torii.Tokens, torii.Subscription]> => {\n            if (grpcClient) {\n                const { contractAddresses, tokenIds, pagination } =\n                    parseTokenRequest(request);\n                const tokens = await grpcClient.getTokens({\n                    contract_addresses: contractAddresses,\n                    token_ids: tokenIds,\n                    pagination,\n                });\n                const subscription = await grpcClient.onTokenUpdated(\n                    contractAddresses ?? [],\n                    tokenIds ?? [],\n                    safeCallback(request.callback, defaultToken)\n                );\n                return [tokens, subscription];\n            }\n            return await subscribeToken(client!, request);\n        },\n    };\n}\n","import { ToriiGrpcClient } from \"@dojoengine/grpc\";\nimport type { GrpcClientInterface } from \"./createSDK.js\";\n\nexport interface InitGrpcOptions {\n    toriiUrl?: string;\n    worldAddress: string;\n}\n\nexport function initGrpc(options: InitGrpcOptions): GrpcClientInterface {\n    return new ToriiGrpcClient({\n        toriiUrl: options.toriiUrl ?? \"http://localhost:8080\",\n        worldAddress: options.worldAddress,\n    });\n}\n"],"mappings":"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","names":["torii","err","ok","shortString","CairoCustomEnum","CairoOption","CairoOptionVariant","addAddressPadding","err","ok","convertToPrimitive","value","shortStringToFelt","item","KeysClause","models","keys","pattern","ClauseBuilder","HashedKeysClause","MemberClause","model","member","operator","AndComposeClause","clauses","OrComposeClause","hexKeys","k","index","memberValue","i","CompositeBuilder","c","NO_SIGNER","NO_IDENTITY","NO_ACCOUNT","UNDEFINED_CLAUSE","generateTypedData","nsModel","message","domain","modelMapping","additionnalTypes","key","isCairoOption","mergeCairoOption","target","source","isCairoCustomEnum","mergeCairoCustomEnum","sourceActiveVariant","sourceValue","newEnumContent","targetActiveVariant","targetValue","deepMerge","result","getModelByEntityId","entityId","namespace","modelName","v","getModel","defaultToriiPagination","Pagination","_Pagination","limit","cursor","direction","query","nextCursor","pagination","items","q","getReversedDirection","parseEntities","entities","options","entity","entityData","parsedEntity","schemaKey","modelKey","parseStruct","parseValue","parsePrimitive","parseCustomEnum","struct","entries","subscribeQueryModelCallback","callback","parsedData","error","safeCallback","defaultValue","res","defaultTokenBalance","parseTokenRequest","req","r","toAttributesFilter","attributes","a","getTokens","client","request","contractAddresses","tokenIds","attributesFilter","getTokenContracts","contractTypes","getTokenBalances","accountAddresses","onTokenBalanceUpdated","updateTokenBalanceSubscription","subscription","subscribeTokenBalance","initialBalances","defaultToken","onTokenUpdated","subscribeToken","initialTokens","defaultToriiOptions","ToriiQueryBuilder","_ToriiQueryBuilder","clause","orderBy","HistoricalToriiQueryBuilder","ok","ToriiGrpcClient","createSDK","client","config","sendMessage","sendMessageBatch","grpcClient","sdkClient","grpcClientInstance","query","callback","q","entities","parsedEntities","E","S","ge","request","contractAddresses","accountAddresses","tokenIds","pagination","c","balances","subscription","T","v","Se","nsModel","message","modelMapping","additionalTypes","ae","data","ok","error","G","contractTypes","xe","L","O","Me","clauses","_historical","contract_addresses","usernames","P","tokens","Be","ToriiGrpcClient","initGrpc","options","createClient","config","defaultClientConfig","init","options","client","clientConfig","createSDK","data","account","err","oe","signature","dataString","publishClient","ok","error","messages","typedData"]}