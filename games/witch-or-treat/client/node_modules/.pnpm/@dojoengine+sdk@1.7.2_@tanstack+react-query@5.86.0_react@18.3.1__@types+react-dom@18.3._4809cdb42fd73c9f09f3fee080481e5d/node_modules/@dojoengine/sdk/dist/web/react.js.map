{"version":3,"sources":["../../src/web/react/hoc/with-account.tsx","../../src/web/react/hooks/index.ts","../../src/web/react/provider.tsx","../../src/web/react/hooks/state.ts","../../src/web/react/hooks/hooks.ts","../../src/web/react/hooks/utils.ts","../../src/web/react/hooks/entities.ts","../../src/web/react/hooks/events.ts","../../src/web/react/hooks/token.ts"],"sourcesContent":["import { useAccount } from \"@starknet-react/core\";\nimport type { AccountInterface } from \"starknet\";\n\ninterface WithAccountProps {\n    account: AccountInterface;\n    address: `0x${string}`;\n}\n\nexport function WithAccount<P extends object>(\n    Component: React.ComponentType<P>,\n    Fallback: React.ComponentType = () => <div>Please connect your wallet</div>\n): React.FC<Omit<P, keyof WithAccountProps>> {\n    return (props) => {\n        const { account, address } = useAccount();\n        if (!address) {\n            return Fallback ? <Fallback /> : null;\n        }\n        const mergedProps = { ...props, account, address } as P &\n            WithAccountProps;\n        return <Component {...mergedProps} />;\n    };\n}\n","import { getEntityIdFromKeys } from \"@dojoengine/utils\";\nimport { useContext, useMemo } from \"react\";\nimport type { BigNumberish } from \"starknet\";\nimport type { SchemaType } from \"@dojoengine/internal\";\nimport { DojoContext, type DojoContextType } from \"../provider\";\n\nexport * from \"./entities\";\nexport * from \"./events\";\nexport * from \"./state\";\nexport * from \"./token\";\n\n/**\n * Hook that exposes sdk features.\n *\n * @template Client Client function generated with `sozo build --typescript`\n * @template Schema Schema function generated with `sozo build --typescript`\n * @returns DojoContextType<Client, Schema>\n */\nexport function useDojoSDK<\n    Client extends (...args: any) => any,\n    Schema extends SchemaType,\n>(): DojoContextType<Client, Schema> {\n    return useContext<DojoContextType<Client, Schema>>(DojoContext);\n}\n\n/**\n * If you know all distinct keys of your model, here is a way to compose it.\n *\n * @param keys Each keys corresponding to your model keys.\n * @returns Composed entityId\n */\nexport function useEntityId(...keys: BigNumberish[]): BigNumberish {\n    const entityId = useMemo(() => {\n        if (keys.length > 0) {\n            return getEntityIdFromKeys(keys.map((k) => BigInt(k)));\n        }\n        return BigInt(0);\n    }, [keys]);\n\n    return entityId;\n}\n","import { type DojoConfig, DojoProvider } from \"@dojoengine/core\";\nimport { createContext, type ReactNode, useContext } from \"react\";\nimport type { SchemaType, SDK } from \"@dojoengine/internal\";\nimport type { GameState } from \"../state\";\nimport { createDojoStore } from \"./hooks/state\";\n\n// Define the hook type\nexport type DojoStoreHook<T extends SchemaType> = <U>(\n    selector: (state: GameState<T>) => U,\n    equals?: (a: U, b: U) => boolean\n) => U;\n\n/**\n * Interface defining the shape of the Dojo context.\n */\nexport interface DojoContextType<\n    Client extends (...args: any) => any,\n    Schema extends SchemaType,\n> {\n    /** The Dojo client instance */\n    config: DojoConfig;\n    /** The Dojo client instance */\n    client: ReturnType<Client>;\n    /** SDK client instance **/\n    sdk: SDK<Schema>;\n    /** The Dojo provider */\n    provider: DojoProvider;\n    /** The dojo zustand store */\n    useDojoStore: DojoStoreHook<Schema>;\n}\n\n/**\n * React context for sharing Dojo-related data throughout the application.\n */\n// @ts-expect-error Since we c\n// annot dynamically set context at runtime, we will get a type error.\nexport const DojoContext = createContext<DojoContextType>(undefined);\n\n/**\n * Provider component that makes Dojo context available to child components.\n *\n * @param props.children - Child components that will have access to the Dojo context\n * @param props.burnerManager - Instance of BurnerManager for handling burner accounts\n * @throws {Error} If DojoProvider is used more than once in the component tree\n */\nexport function DojoSdkProvider<Schema extends SchemaType>({\n    dojoConfig,\n    sdk,\n    clientFn,\n    children,\n}: {\n    dojoConfig: DojoConfig;\n    sdk: SDK<Schema>;\n    clientFn: Function;\n    children: ReactNode;\n}) {\n    const currentValue = useContext(DojoContext);\n    if (currentValue) {\n        throw new Error(\"DojoProvider can only be used once\");\n    }\n\n    const dojoProvider = new DojoProvider(\n        dojoConfig.manifest,\n        dojoConfig.rpcUrl\n    );\n\n    return (\n        <DojoContext.Provider\n            value={{\n                config: dojoConfig,\n                client: clientFn(dojoProvider),\n                sdk: sdk,\n                provider: dojoProvider,\n                useDojoStore: createDojoStore<Schema>(),\n            }}\n        >\n            {children}\n        </DojoContext.Provider>\n    );\n}\n","import { useContext } from \"react\";\nimport type { BigNumberish } from \"starknet\";\nimport { create, type StoreApi, type UseBoundStore } from \"zustand\";\nimport type { ParsedEntity, SchemaType } from \"@dojoengine/internal\";\nimport {\n    createDojoStoreFactory,\n    type GameState,\n} from \"@dojoengine/state/zustand\";\nimport { DojoContext, type DojoContextType } from \"../provider\";\n\n/**\n * Factory function to create a React Zustand store based on a given SchemaType.\n *\n * @template T - The schema type.\n * @returns A Zustand hook tailored to the provided schema.\n */\nexport function createDojoStore<T extends SchemaType>() {\n    // hacktually until I find a proper type input to createDojoStoreFactory\n    return createDojoStoreFactory<T>(create) as unknown as UseBoundStore<\n        StoreApi<GameState<T>>\n    >;\n}\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function useModel<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Client extends (...args: any) => any,\n    Schema extends SchemaType,\n>(entityId: BigNumberish, model: `${N}-${M}`): SchemaType[N][M] | undefined {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    const { useDojoStore } =\n        useContext<DojoContextType<Client, Schema>>(DojoContext);\n\n    // Select only the specific model data for the given entityId\n    const modelData = useDojoStore(\n        (state) =>\n            state.entities[entityId.toString()]?.models?.[namespace]?.[\n                modelName\n            ] as SchemaType[N][M] | undefined\n    );\n\n    return modelData;\n}\n\n/**\n * Custom hook to retrieve a specific model for a given entityId within a specified namespace.\n *\n * @param entityId - The ID of the entity.\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function useHistoricalModel<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Client extends (...args: any) => any,\n    Schema extends SchemaType,\n>(entityId: BigNumberish, model: `${N}-${M}`): ParsedEntity<Schema>[] {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    const { useDojoStore } =\n        useContext<DojoContextType<Client, Schema>>(DojoContext);\n\n    // Select only the specific model data for the given entityId\n    const modelData = useDojoStore((state) => {\n        const entityModels = state.historical_entities[entityId.toString()];\n        if (!entityModels) return [];\n\n        return entityModels.filter((entity: ParsedEntity<Schema>) => {\n            return entity.models[namespace][modelName] !== undefined;\n        });\n    });\n\n    return modelData;\n}\n\n/**\n * Custom hook to retrieve all entities that have a specific model.\n *\n * @param model - The model to retrieve, specified as a string in the format \"namespace-modelName\".\n * @returns The model structure if found, otherwise undefined.\n */\nexport function useModels<\n    N extends keyof SchemaType,\n    M extends keyof SchemaType[N] & string,\n    Client extends (...args: any) => any,\n    Schema extends SchemaType,\n>(model: `${N}-${M}`): { [entityId: string]: SchemaType[N][M] | undefined } {\n    const [namespace, modelName] = model.split(\"-\") as [N, M];\n    const { useDojoStore } =\n        useContext<DojoContextType<Client, Schema>>(DojoContext);\n\n    const modelData = useDojoStore((state) =>\n        state\n            .getEntitiesByModel(namespace, modelName)\n            .map((entity: ParsedEntity<Schema>) => ({\n                [entity.entityId]: entity.models?.[namespace]?.[modelName],\n            }))\n    ) as unknown as { [entityId: string]: SchemaType[N][M] | undefined };\n\n    return modelData;\n}\n","import type { Subscription } from \"@dojoengine/torii-wasm\";\nimport type { Clause } from \"@dojoengine/torii-wasm/types\";\nimport { useCallback, useEffect, useRef } from \"react\";\nimport type {\n    ToriiQueryBuilder,\n    ParsedEntity,\n    SchemaType,\n    SubscribeParams,\n    SubscribeResponse,\n} from \"@dojoengine/internal\";\nimport { deepEqual, sleep } from \"./utils\";\n\n/**\n * Base hook factory for creating subscription hooks with shared logic\n */\nexport function createSubscriptionHook<\n    Schema extends SchemaType,\n    Historical extends boolean = false,\n>(config: {\n    subscribeMethod: (\n        options: SubscribeParams<Schema>\n    ) => Promise<SubscribeResponse<Schema>>;\n    updateSubscriptionMethod: (\n        subscription: Subscription,\n        clause: any,\n        historical?: boolean\n    ) => Promise<void>;\n    queryToHashedKeysMethod: (\n        query: ToriiQueryBuilder<Schema>,\n        historical?: boolean\n    ) => Clause;\n    processInitialData: (data: ParsedEntity<Schema>[]) => void;\n    processUpdateData: (data: ParsedEntity<Schema>[]) => void;\n    getErrorPrefix: () => string;\n    historical: Historical;\n}) {\n    return function useSubscriptionHook(query: ToriiQueryBuilder<Schema>) {\n        // Subscription handle to update\n        const subscriptionRef = useRef<Subscription | null>(null);\n        // Handle to user input query\n        const fetchingRef = useRef<ToriiQueryBuilder<Schema> | null>(null);\n        // Async lock to sync with event loop\n        const isUpdating = useRef<boolean>(false);\n\n        const fetchData = useCallback(async () => {\n            // Wait until lock is released\n            while (isUpdating.current) {\n                await sleep(50);\n            }\n\n            // Lock function\n            isUpdating.current = true;\n\n            if (subscriptionRef.current) {\n                await config.updateSubscriptionMethod(\n                    subscriptionRef.current,\n                    config.queryToHashedKeysMethod(\n                        fetchingRef.current!,\n                        config.historical\n                    ),\n                    config.historical\n                );\n                return null;\n            }\n\n            const [initialData, subscription] = await config.subscribeMethod({\n                query: fetchingRef.current!,\n                callback: ({ data, error }) => {\n                    if (data) {\n                        config.processUpdateData(\n                            data as unknown as ParsedEntity<Schema>[]\n                        );\n                    }\n                    if (error) {\n                        console.error(\n                            `${config.getErrorPrefix()} - error subscribing with query: `,\n                            query.toString()\n                        );\n                        console.error(error);\n                    }\n                },\n                historical: config.historical,\n            });\n\n            config.processInitialData(initialData.getItems());\n            return subscription;\n        }, [query]);\n\n        useEffect(() => {\n            if (!deepEqual(query, fetchingRef.current)) {\n                fetchingRef.current = query;\n\n                fetchData()\n                    .then((s) => {\n                        if (s !== null) {\n                            subscriptionRef.current = s;\n                        }\n                    })\n                    .catch((err) => {\n                        console.error(\n                            `${config.getErrorPrefix()} - error fetching data for query: `,\n                            JSON.stringify(query)\n                        );\n                        console.error(err);\n                    })\n                    .finally(() => {\n                        // Release lock\n                        isUpdating.current = false;\n                    });\n            }\n\n            return () => {\n                if (subscriptionRef.current) {\n                    // subscriptionRef.current?.free();\n                    // subscriptionRef.current = null;\n                }\n            };\n        }, [query, fetchData]);\n    };\n}\n","/**\n * Performs a deep comparison between two values to determine if they are equivalent.\n * @param a First value to compare\n * @param b Second value to compare\n * @returns True if the values are equivalent, false otherwise\n */\nexport function deepEqual(a: any, b: any): boolean {\n    // If the values are strictly equal, return true\n    if (a === b) return true;\n\n    // If either value is null or not an object, they're not equal\n    if (\n        a === null ||\n        b === null ||\n        typeof a !== \"object\" ||\n        typeof b !== \"object\"\n    ) {\n        return false;\n    }\n\n    // Handle arrays\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) return false;\n\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }\n\n        return true;\n    }\n\n    // Handle Date objects\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n\n    // Handle regular expressions\n    if (a instanceof RegExp && b instanceof RegExp) {\n        return a.toString() === b.toString();\n    }\n\n    // Get all keys from both objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    // If number of keys is different, objects are not equal\n    if (keysA.length !== keysB.length) return false;\n\n    // Check if every key in a exists in b and has the same value\n    return keysA.every(\n        (key) => Object.hasOwn(b, key) && deepEqual(a[key], b[key])\n    );\n}\n\n/**\n * Creates a Promise that resolves after the specified time\n * @param ms The time to sleep in milliseconds\n * @returns A Promise that resolves after the specified time\n */\nexport function sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import type { SchemaType, ToriiQueryBuilder } from \"@dojoengine/internal\";\nimport { useDojoSDK } from \"../hooks\";\nimport { createSubscriptionHook } from \"./hooks\";\n\n/**\n * Subscribe to entity changes. This hook fetches initial data from torii and subscribes to each entity change.\n * Use `useModel` to access your data.\n *\n * @param query ToriiQuery\n */\nexport function useEntityQuery<Schema extends SchemaType>(\n    query: ToriiQueryBuilder<Schema>\n) {\n    const { sdk, useDojoStore } = useDojoSDK<() => any, Schema>();\n    const state = useDojoStore((s) => s);\n\n    const useEntityQueryHook = createSubscriptionHook<Schema>({\n        subscribeMethod: (options) => sdk.subscribeEntityQuery(options),\n        updateSubscriptionMethod: (subscription, clause) =>\n            sdk.updateEntitySubscription(subscription, clause),\n        queryToHashedKeysMethod: (query) => query.getClause()._unsafeUnwrap(),\n        processInitialData: (data) => {\n            state.mergeEntities(data);\n        },\n        processUpdateData: (data) => {\n            if (data) {\n                const entities = data.filter(\n                    (e) => Number.parseInt(e.entityId, 16) !== 0\n                );\n\n                const entity = entities[0];\n                if (entity) {\n                    state.updateEntity(entity);\n                }\n            }\n        },\n        getErrorPrefix: () => \"Dojo.js - useEntityQuery\",\n        historical: false,\n    });\n\n    useEntityQueryHook(query);\n}\n\n/**\n * Subscribe to historical entity changes. This hook fetches initial data from torii and subscribes to each entity change,\n * storing all states in the historical entities store. Use `getHistoricalEntities` to access historical data.\n *\n * @param query ToriiQuery with historical: true\n */\nexport function useHistoricalEntityQuery<Schema extends SchemaType>(\n    query: ToriiQueryBuilder<Schema>\n) {\n    if (!query.isHistorical()) {\n        throw new Error(\"Query must be  HistoricalToriiQueryBuilder\");\n    }\n    const { sdk, useDojoStore } = useDojoSDK<() => any, Schema>();\n    const state = useDojoStore((s) => s);\n\n    const useHistoricalEntityQueryHook = createSubscriptionHook<Schema, true>({\n        subscribeMethod: (options) => sdk.subscribeEntityQuery(options),\n        updateSubscriptionMethod: (subscription, clause) =>\n            sdk.updateEntitySubscription(subscription, clause),\n        queryToHashedKeysMethod: (query) => query.getClause()._unsafeUnwrap(),\n        processInitialData: (data) => {\n            state.setHistoricalEntities(data);\n        },\n        processUpdateData: (data) => {\n            if (data) {\n                const entities = data.filter(\n                    (e) => Number.parseInt(e.entityId, 16) !== 0\n                );\n\n                const entity = entities[0];\n                if (entity) {\n                    state.updateHistoricalEntity(entity);\n                }\n            }\n        },\n        getErrorPrefix: () => \"Dojo.js - useHistoricalEntityQuery\",\n        historical: true,\n    });\n\n    useHistoricalEntityQueryHook(query);\n}\n","import { useState } from \"react\";\nimport type {\n    ParsedEntity,\n    SchemaType,\n    ToriiQueryBuilder,\n} from \"@dojoengine/internal\";\nimport { useDojoSDK } from \"../hooks\";\nimport { createSubscriptionHook } from \"./hooks\";\n\n/**\n * Subscribe to event changes. This hook fetches initial events from torii and subscribes to new events.\n *\n * @param query ToriiQuery\n */\nexport function useEventQuery<Schema extends SchemaType>(\n    query: ToriiQueryBuilder<Schema>\n) {\n    const { sdk, useDojoStore } = useDojoSDK<() => any, Schema>();\n    const state = useDojoStore((s) => s);\n\n    const useEventQueryHook = createSubscriptionHook<Schema>({\n        subscribeMethod: (options) => sdk.subscribeEventQuery(options),\n        updateSubscriptionMethod: (subscription, clause) =>\n            sdk.updateEventMessageSubscription(subscription, clause, false),\n        queryToHashedKeysMethod: (query) => query.getClause()._unsafeUnwrap(),\n        processInitialData: (data) => {\n            state.mergeEntities(data);\n        },\n        processUpdateData: (data) => {\n            if (data) {\n                const evts = data.filter(\n                    (e) => Number.parseInt(e.entityId, 16) !== 0\n                );\n                const event = evts[0];\n                if (event) {\n                    state.updateEntity(event);\n                }\n            }\n        },\n        getErrorPrefix: () => \"Dojo.js - useEventQuery\",\n        historical: false,\n    });\n\n    useEventQueryHook(query);\n}\n\n/**\n * Subscribe to historical events changes. This hook fetches initial data from torii and subscribes to entity changes.\n * You need to specify to torii which events has to be taken in account as historical events.\n *\n * @param query ToriiQuery\n */\nexport function useHistoricalEventsQuery<Schema extends SchemaType>(\n    query: ToriiQueryBuilder<Schema>\n) {\n    const { sdk } = useDojoSDK<() => any, Schema>();\n    const [events, setEvents] = useState<ParsedEntity<Schema>[]>([]);\n\n    const useHistoricalEventsQueryHook = createSubscriptionHook<Schema, true>({\n        subscribeMethod: (options) => sdk.subscribeEventQuery(options),\n        updateSubscriptionMethod: (subscription, clause) =>\n            sdk.updateEventMessageSubscription(subscription, clause, true),\n        queryToHashedKeysMethod: (query) => query.getClause()._unsafeUnwrap(),\n        processInitialData: (data) => {\n            setEvents(data);\n        },\n        processUpdateData: (data) => {\n            if (data) {\n                const evts = data.filter(\n                    (e) => Number.parseInt(e.entityId, 16) !== 0\n                );\n                setEvents((ev) => [...evts, ...ev]);\n            }\n        },\n        getErrorPrefix: () => \"Dojo.js - useHistoricalEventsQuery\",\n        historical: true,\n    });\n\n    useHistoricalEventsQueryHook(query);\n\n    return events;\n}\n","import type { Subscription, Token, TokenBalance } from \"@dojoengine/torii-wasm\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type {\n    GetTokenBalanceRequest,\n    GetTokenRequest,\n    SubscriptionCallbackArgs,\n} from \"@dojoengine/internal\";\nimport { useDojoSDK } from \"../hooks\";\nimport { deepEqual } from \"./utils\";\n\nexport function useTokens(request: GetTokenRequest & GetTokenBalanceRequest) {\n    const { sdk } = useDojoSDK();\n    const [tokens, setTokens] = useState<Token[]>([]);\n    const requestRef = useRef<GetTokenRequest | null>(null);\n    const [tokenBalances, setTokenBalances] = useState<TokenBalance[]>([]);\n    const subscriptionRef = useRef<Subscription | null>(null);\n\n    const fetchTokens = useCallback(async () => {\n        const tokens = await sdk.getTokens({\n            contractAddresses: request.contractAddresses ?? [],\n            tokenIds: request.tokenIds ?? [],\n        });\n        setTokens(tokens.items);\n    }, [sdk, request]);\n\n    const fetchTokenBalances = useCallback(async () => {\n        const [tokenBalances, subscription] = await sdk.subscribeTokenBalance({\n            contractAddresses: request.contractAddresses ?? [],\n            accountAddresses: request.accountAddresses ?? [],\n            tokenIds: request.tokenIds ?? [],\n            callback: ({\n                data,\n                error,\n            }: SubscriptionCallbackArgs<TokenBalance>) => {\n                if (error) {\n                    console.error(error);\n                    return;\n                }\n                setTokenBalances((prev) => updateTokenBalancesList(prev, data));\n            },\n        });\n        subscriptionRef.current = subscription;\n        setTokenBalances(tokenBalances.items);\n    }, [sdk, request]);\n\n    useEffect(() => {\n        if (!deepEqual(request, requestRef.current)) {\n            requestRef.current = request;\n            fetchTokens();\n            fetchTokenBalances();\n        }\n    }, [request]);\n\n    function getBalance(token: Token): TokenBalance | undefined {\n        return tokenBalances.find(\n            (balance) => balance.contract_address === token.contract_address\n        );\n    }\n\n    function toDecimal(\n        token: Token,\n        balance: TokenBalance | undefined\n    ): number {\n        return (\n            Number.parseInt(balance?.balance ?? \"0\", 16) * 10 ** -token.decimals\n        );\n    }\n\n    return { tokens, balances: tokenBalances, getBalance, toDecimal };\n}\n\nfunction updateTokenBalancesList(\n    previousBalances: TokenBalance[],\n    newBalance: TokenBalance\n): TokenBalance[] {\n    if (\n        BigInt(newBalance.account_address) === 0n &&\n        BigInt(newBalance.contract_address) === 0n\n    ) {\n        // torii subscription received, we ignore\n        return previousBalances;\n    }\n\n    const existingBalanceIndex = previousBalances.findIndex(\n        (balance) =>\n            balance.token_id === newBalance.token_id &&\n            balance.contract_address === newBalance.contract_address\n    );\n\n    // If balance doesn't exist, append it to the list\n    if (existingBalanceIndex === -1) {\n        return [...previousBalances, newBalance];\n    }\n\n    // If balance exists, update it while preserving order\n    return previousBalances.map((balance, index) =>\n        index === existingBalanceIndex ? newBalance : balance\n    );\n}\n"],"mappings":"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","names":["useAccount","jsx","WithAccount","Component","Fallback","props","account","address","mergedProps","getEntityIdFromKeys","useContext","useMemo","DojoProvider","createContext","useContext","useContext","create","createDojoStoreFactory","createDojoStore","createDojoStoreFactory","create","useModel","entityId","model","namespace","modelName","useDojoStore","useContext","DojoContext","state","useHistoricalModel","entityModels","entity","useModels","jsx","DojoContext","createContext","DojoSdkProvider","dojoConfig","sdk","clientFn","children","useContext","dojoProvider","DojoProvider","createDojoStore","useCallback","useEffect","useRef","deepEqual","a","b","i","keysA","keysB","key","sleep","ms","resolve","createSubscriptionHook","config","query","subscriptionRef","useRef","fetchingRef","isUpdating","fetchData","useCallback","sleep","initialData","subscription","data","error","useEffect","deepEqual","s","err","useEntityQuery","query","sdk","useDojoStore","useDojoSDK","state","s","createSubscriptionHook","options","subscription","clause","data","entity","e","useHistoricalEntityQuery","useState","useEventQuery","query","sdk","useDojoStore","useDojoSDK","state","s","createSubscriptionHook","options","subscription","clause","data","event","e","useHistoricalEventsQuery","events","setEvents","useState","evts","ev","useCallback","useEffect","useRef","useState","useTokens","request","sdk","useDojoSDK","tokens","setTokens","useState","requestRef","useRef","tokenBalances","setTokenBalances","subscriptionRef","fetchTokens","useCallback","fetchTokenBalances","subscription","data","error","prev","updateTokenBalancesList","useEffect","deepEqual","getBalance","token","balance","toDecimal","previousBalances","newBalance","existingBalanceIndex","index","useDojoSDK","useContext","DojoContext","useEntityId","keys","useMemo","getEntityIdFromKeys","k"]}